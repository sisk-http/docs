{
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.-ctor.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.-ctor.html",
    "title": "Constructor BasicAuthenticateRequestHandler | Sisk",
    "keywords": "Constructor BasicAuthenticateRequestHandler Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll BasicAuthenticateRequestHandler() public BasicAuthenticateRequestHandler()"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.CreateUnauthorizedResponse.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.CreateUnauthorizedResponse.html",
    "title": "Method CreateUnauthorizedResponse | Sisk",
    "keywords": "Method CreateUnauthorizedResponse Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll CreateUnauthorizedResponse(string) Creates an empty HTTP response with the WWW-Authenticate header and an custom realm message. public HttpResponse CreateUnauthorizedResponse(string realm) Parameters realm string Defines the realm message to send back to the client. Returns HttpResponse CreateUnauthorizedResponse() Creates an empty HTTP response with the WWW-Authenticate header and with the realm message defined in this class instance. public HttpResponse CreateUnauthorizedResponse() Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Execute.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Execute.html",
    "title": "Method Execute | Sisk",
    "keywords": "Method Execute Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route callback is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. public HttpResponse? Execute(HttpRequest request, HttpContext context) Parameters request HttpRequest context HttpContext Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll ExecutionMode Gets or sets when this RequestHandler should run. public RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.OnValidating.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.OnValidating.html",
    "title": "Method OnValidating | Sisk",
    "keywords": "Method OnValidating Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll OnValidating(BasicAuthenticationCredentials, HttpContext) Indicates the method that is called to validate a request with client credentials. When returning an HttpResponse, it will be sent immediately to the client and the rest of the stack will not be executed. If the return is null, it is interpretable that the authentication was successful and the execution should continue. public virtual HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) Parameters credentials BasicAuthenticationCredentials Represents the credentials sent by the client, already decoded and ready for use. context HttpContext Represents the Http context. Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Realm.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Realm.html",
    "title": "Property Realm | Sisk",
    "keywords": "Property Realm Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Realm Gets or sets a message to show the client which protection scope it needs to authenticate to. public string Realm { get; set; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.html",
    "title": "Class BasicAuthenticateRequestHandler | Sisk",
    "keywords": "Class BasicAuthenticateRequestHandler Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Gets a IRequestHandler that serves as an authenticator for the Basic Authentication scheme, which can validate a user id and password. public class BasicAuthenticateRequestHandler : IRequestHandler Inheritance object BasicAuthenticateRequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors BasicAuthenticateRequestHandler() Properties ExecutionMode Gets or sets when this RequestHandler should run. Realm Gets or sets a message to show the client which protection scope it needs to authenticate to. Methods CreateUnauthorizedResponse() Creates an empty HTTP response with the WWW-Authenticate header and with the realm message defined in this class instance. CreateUnauthorizedResponse(string) Creates an empty HTTP response with the WWW-Authenticate header and an custom realm message. Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route callback is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. OnValidating(BasicAuthenticationCredentials, HttpContext) Indicates the method that is called to validate a request with client credentials. When returning an HttpResponse, it will be sent immediately to the client and the rest of the stack will not be executed. If the return is null, it is interpretable that the authentication was successful and the execution should continue."
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.Password.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.Password.html",
    "title": "Property Password | Sisk",
    "keywords": "Property Password Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Password Gets the plain password component from this credentials. public string Password { get; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.UserId.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.UserId.html",
    "title": "Property UserId | Sisk",
    "keywords": "Property UserId Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll UserId Gets the user id component from this credentials. public string UserId { get; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.html",
    "title": "Class BasicAuthenticationCredentials | Sisk",
    "keywords": "Class BasicAuthenticationCredentials Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Represents basic authentication credentials for an HTTP request. public class BasicAuthenticationCredentials Inheritance object BasicAuthenticationCredentials Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Password Gets the plain password component from this credentials. UserId Gets the user id component from this credentials."
  },
  "api/Sisk.BasicAuth.html": {
    "href": "api/Sisk.BasicAuth.html",
    "title": "Namespace Sisk.BasicAuth | Sisk",
    "keywords": "Namespace Sisk.BasicAuth Classes BasicAuthenticateRequestHandler Gets a IRequestHandler that serves as an authenticator for the Basic Authentication scheme, which can validate a user id and password. BasicAuthenticationCredentials Represents basic authentication credentials for an HTTP request."
  },
  "api/Sisk.Cadente.HttpEventStreamWriter.WriteDataAsync.html": {
    "href": "api/Sisk.Cadente.HttpEventStreamWriter.WriteDataAsync.html",
    "title": "Method WriteDataAsync | Sisk",
    "keywords": "Method WriteDataAsync Namespace Sisk.Cadente Assembly Sisk.Cadente.dll WriteDataAsync(string) Asynchronously writes a data message to the underlying stream. public Task WriteDataAsync(string data) Parameters data string The data to write. Returns Task A task that represents the asynchronous write operation."
  },
  "api/Sisk.Cadente.HttpEventStreamWriter.WriteEventAsync.html": {
    "href": "api/Sisk.Cadente.HttpEventStreamWriter.WriteEventAsync.html",
    "title": "Method WriteEventAsync | Sisk",
    "keywords": "Method WriteEventAsync Namespace Sisk.Cadente Assembly Sisk.Cadente.dll WriteEventAsync(string) Asynchronously writes an event message to the underlying stream. public Task WriteEventAsync(string eventName) Parameters eventName string The name of the event to write. Returns Task A task that represents the asynchronous write operation."
  },
  "api/Sisk.Cadente.HttpEventStreamWriter.html": {
    "href": "api/Sisk.Cadente.HttpEventStreamWriter.html",
    "title": "Class HttpEventStreamWriter | Sisk",
    "keywords": "Class HttpEventStreamWriter Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Provides methods to write data and events to an underlying stream in the Server-Sent Events (SSE) format. public sealed class HttpEventStreamWriter Inheritance object HttpEventStreamWriter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WriteDataAsync(string) Asynchronously writes a data message to the underlying stream. WriteEventAsync(string) Asynchronously writes an event message to the underlying stream."
  },
  "api/Sisk.Cadente.HttpHeader.-ctor.html": {
    "href": "api/Sisk.Cadente.HttpHeader.-ctor.html",
    "title": "Constructor HttpHeader | Sisk",
    "keywords": "Constructor HttpHeader Namespace Sisk.Cadente Assembly Sisk.Cadente.dll HttpHeader(in ReadOnlyMemory<byte>, in ReadOnlyMemory<byte>) Initializes a new instance of the HttpHeader struct with the specified name and value as byte arrays. public HttpHeader(in ReadOnlyMemory<byte> nameBytes, in ReadOnlyMemory<byte> valueBytes) Parameters nameBytes ReadOnlyMemory<byte> The byte array representing the name of the header. valueBytes ReadOnlyMemory<byte> The byte array representing the value of the header. HttpHeader(string, string) Initializes a new instance of the HttpHeader struct with the specified name and value as strings. public HttpHeader(string name, string value) Parameters name string The name of the header. value string The value of the header."
  },
  "api/Sisk.Cadente.HttpHeader.Equals.html": {
    "href": "api/Sisk.Cadente.HttpHeader.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool Equals(HttpHeader) public bool Equals(HttpHeader other) Parameters other HttpHeader Returns bool"
  },
  "api/Sisk.Cadente.HttpHeader.GetHashCode.html": {
    "href": "api/Sisk.Cadente.HttpHeader.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Cadente Assembly Sisk.Cadente.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.Cadente.HttpHeader.IsEmpty.html": {
    "href": "api/Sisk.Cadente.HttpHeader.IsEmpty.html",
    "title": "Property IsEmpty | Sisk",
    "keywords": "Property IsEmpty Namespace Sisk.Cadente Assembly Sisk.Cadente.dll IsEmpty Gets a value indicating whether this HttpHeader has any empty value or name. public bool IsEmpty { get; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpHeader.Name.html": {
    "href": "api/Sisk.Cadente.HttpHeader.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Name Gets the name of the header as a string. public string Name { get; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHeader.ToString.html": {
    "href": "api/Sisk.Cadente.HttpHeader.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ToString() Gets the string representation of this HttpHeader. public override string ToString() Returns string"
  },
  "api/Sisk.Cadente.HttpHeader.Value.html": {
    "href": "api/Sisk.Cadente.HttpHeader.Value.html",
    "title": "Property Value | Sisk",
    "keywords": "Property Value Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Value Gets the value of the header as a string. public string Value { get; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHeader.html": {
    "href": "api/Sisk.Cadente.HttpHeader.html",
    "title": "Struct HttpHeader | Sisk",
    "keywords": "Struct HttpHeader Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP header, consisting of a name and a value. public readonly struct HttpHeader : IEquatable<HttpHeader> Implements IEquatable<HttpHeader> Inherited Members object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors HttpHeader(in ReadOnlyMemory<byte>, in ReadOnlyMemory<byte>) Initializes a new instance of the HttpHeader struct with the specified name and value as byte arrays. HttpHeader(string, string) Initializes a new instance of the HttpHeader struct with the specified name and value as strings. Properties IsEmpty Gets a value indicating whether this HttpHeader has any empty value or name. Name Gets the name of the header as a string. Value Gets the value of the header as a string. Methods Equals(HttpHeader) Equals(object?) GetHashCode() ToString() Gets the string representation of this HttpHeader."
  },
  "api/Sisk.Cadente.HttpHost.-ctor.html": {
    "href": "api/Sisk.Cadente.HttpHost.-ctor.html",
    "title": "Constructor HttpHost | Sisk",
    "keywords": "Constructor HttpHost Namespace Sisk.Cadente Assembly Sisk.Cadente.dll HttpHost(IPEndPoint) Initializes a new instance of the HttpHost class using the specified IPEndPoint. public HttpHost(IPEndPoint endpoint) Parameters endpoint IPEndPoint The IPEndPoint to listen on. HttpHost(int) Initializes a new instance of the HttpHost class using the specified port on the loopback address. public HttpHost(int port) Parameters port int The port number to listen on."
  },
  "api/Sisk.Cadente.HttpHost.Dispose.html": {
    "href": "api/Sisk.Cadente.HttpHost.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Cadente.HttpHost.Handler.html": {
    "href": "api/Sisk.Cadente.HttpHost.Handler.html",
    "title": "Property Handler | Sisk",
    "keywords": "Property Handler Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Handler Gets or sets an HttpHostHandler instance for this HttpHost. public HttpHostHandler? Handler { get; set; } Property Value HttpHostHandler"
  },
  "api/Sisk.Cadente.HttpHost.HttpsOptions.html": {
    "href": "api/Sisk.Cadente.HttpHost.HttpsOptions.html",
    "title": "Property HttpsOptions | Sisk",
    "keywords": "Property HttpsOptions Namespace Sisk.Cadente Assembly Sisk.Cadente.dll HttpsOptions Gets or sets the HTTPS options for secure connections. Setting an HttpsOptions object in this property, the HttpHost will use HTTPS instead of HTTP. public HttpsOptions? HttpsOptions { get; set; } Property Value HttpsOptions"
  },
  "api/Sisk.Cadente.HttpHost.IsDisposed.html": {
    "href": "api/Sisk.Cadente.HttpHost.IsDisposed.html",
    "title": "Property IsDisposed | Sisk",
    "keywords": "Property IsDisposed Namespace Sisk.Cadente Assembly Sisk.Cadente.dll IsDisposed Gets a value indicating whether this HttpHost has been disposed. public bool IsDisposed { get; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpHost.QueueSize.html": {
    "href": "api/Sisk.Cadente.HttpHost.QueueSize.html",
    "title": "Property QueueSize | Sisk",
    "keywords": "Property QueueSize Namespace Sisk.Cadente Assembly Sisk.Cadente.dll QueueSize Gets or sets the client queue size of all HttpHost instances. This value indicates how many connections the server can maintain simultaneously before queueing other connections attempts. public static int QueueSize { get; set; } Property Value int"
  },
  "api/Sisk.Cadente.HttpHost.ServerNameHeader.html": {
    "href": "api/Sisk.Cadente.HttpHost.ServerNameHeader.html",
    "title": "Property ServerNameHeader | Sisk",
    "keywords": "Property ServerNameHeader Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ServerNameHeader Gets or sets the name of the server in the header name. public static string ServerNameHeader { get; set; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHost.Start.html": {
    "href": "api/Sisk.Cadente.HttpHost.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Start() Starts the HTTP host and begins listening for incoming connections. public void Start()"
  },
  "api/Sisk.Cadente.HttpHost.TimeoutManager.html": {
    "href": "api/Sisk.Cadente.HttpHost.TimeoutManager.html",
    "title": "Property TimeoutManager | Sisk",
    "keywords": "Property TimeoutManager Namespace Sisk.Cadente Assembly Sisk.Cadente.dll TimeoutManager Gets the HttpHostTimeoutManager for this HttpHost. public HttpHostTimeoutManager TimeoutManager { get; } Property Value HttpHostTimeoutManager"
  },
  "api/Sisk.Cadente.HttpHost.html": {
    "href": "api/Sisk.Cadente.HttpHost.html",
    "title": "Class HttpHost | Sisk",
    "keywords": "Class HttpHost Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP host that listens for incoming TCP connections and handles HTTP requests. public sealed class HttpHost : IDisposable Inheritance object HttpHost Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpHost(int) Initializes a new instance of the HttpHost class using the specified port on the loopback address. HttpHost(IPEndPoint) Initializes a new instance of the HttpHost class using the specified IPEndPoint. Properties Handler Gets or sets an HttpHostHandler instance for this HttpHost. HttpsOptions Gets or sets the HTTPS options for secure connections. Setting an HttpsOptions object in this property, the HttpHost will use HTTPS instead of HTTP. IsDisposed Gets a value indicating whether this HttpHost has been disposed. QueueSize Gets or sets the client queue size of all HttpHost instances. This value indicates how many connections the server can maintain simultaneously before queueing other connections attempts. ServerNameHeader Gets or sets the name of the server in the header name. TimeoutManager Gets the HttpHostTimeoutManager for this HttpHost. Methods Dispose() Start() Starts the HTTP host and begins listening for incoming connections."
  },
  "api/Sisk.Cadente.HttpHostClient.ClientCertificate.html": {
    "href": "api/Sisk.Cadente.HttpHostClient.ClientCertificate.html",
    "title": "Property ClientCertificate | Sisk",
    "keywords": "Property ClientCertificate Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ClientCertificate Gets the client certificate, if any. public X509Certificate? ClientCertificate { get; } Property Value X509Certificate"
  },
  "api/Sisk.Cadente.HttpHostClient.ClientEndpoint.html": {
    "href": "api/Sisk.Cadente.HttpHostClient.ClientEndpoint.html",
    "title": "Property ClientEndpoint | Sisk",
    "keywords": "Property ClientEndpoint Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ClientEndpoint Gets the endpoint of the client. public IPEndPoint ClientEndpoint { get; } Property Value IPEndPoint"
  },
  "api/Sisk.Cadente.HttpHostClient.State.html": {
    "href": "api/Sisk.Cadente.HttpHostClient.State.html",
    "title": "Property State | Sisk",
    "keywords": "Property State Namespace Sisk.Cadente Assembly Sisk.Cadente.dll State Gets or sets an optional state object associated with the client. public object? State { get; set; } Property Value object"
  },
  "api/Sisk.Cadente.HttpHostClient.html": {
    "href": "api/Sisk.Cadente.HttpHostClient.html",
    "title": "Class HttpHostClient | Sisk",
    "keywords": "Class HttpHostClient Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP host client with its endpoint and certificate information. public sealed class HttpHostClient Inheritance object HttpHostClient Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ClientCertificate Gets the client certificate, if any. ClientEndpoint Gets the endpoint of the client. State Gets or sets an optional state object associated with the client."
  },
  "api/Sisk.Cadente.HttpHostContext.Client.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.Client.html",
    "title": "Property Client | Sisk",
    "keywords": "Property Client Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Client Gets the associated HttpHostClient with this HTTP context. public HttpHostClient Client { get; } Property Value HttpHostClient"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.ContentLength.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.ContentLength.html",
    "title": "Property ContentLength | Sisk",
    "keywords": "Property ContentLength Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ContentLength Gets the content length of the request. public long ContentLength { get; } Property Value long"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.GetRequestStream.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.GetRequestStream.html",
    "title": "Method GetRequestStream | Sisk",
    "keywords": "Method GetRequestStream Namespace Sisk.Cadente Assembly Sisk.Cadente.dll GetRequestStream() Gets the stream containing the content of the request. public Stream GetRequestStream() Returns Stream"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.Headers.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Headers Gets the headers associated with the request. public HttpHeader[] Headers { get; } Property Value HttpHeader[]"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.Method.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Method Gets the HTTP method (e.g., GET, POST) of the request. public string Method { get; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.Path.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Path Gets the path of the requested resource. public string Path { get; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpRequest.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpRequest.html",
    "title": "Class HttpHostContext.HttpRequest | Sisk",
    "keywords": "Class HttpHostContext.HttpRequest Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP request. public sealed class HttpHostContext.HttpRequest Inheritance object HttpHostContext.HttpRequest Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ContentLength Gets the content length of the request. Headers Gets the headers associated with the request. Method Gets the HTTP method (e.g., GET, POST) of the request. Path Gets the path of the requested resource. Methods GetRequestStream() Gets the stream containing the content of the request."
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.GetEventStream.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.GetEventStream.html",
    "title": "Method GetEventStream | Sisk",
    "keywords": "Method GetEventStream Namespace Sisk.Cadente Assembly Sisk.Cadente.dll GetEventStream() Asynchronously gets an event stream writer with UTF-8 encoding. public HttpEventStreamWriter GetEventStream() Returns HttpEventStreamWriter A task that represents the asynchronous operation, with a HttpEventStreamWriter as the result. GetEventStream(Encoding) Asynchronously gets an event stream writer with the specified encoding. public HttpEventStreamWriter GetEventStream(Encoding encoding) Parameters encoding Encoding The encoding to use for the event stream. Returns HttpEventStreamWriter A task that represents the asynchronous operation, with a HttpEventStreamWriter as the result. Exceptions InvalidOperationException Thrown when unable to obtain an output stream for the response."
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.GetResponseStream.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.GetResponseStream.html",
    "title": "Method GetResponseStream | Sisk",
    "keywords": "Method GetResponseStream Namespace Sisk.Cadente Assembly Sisk.Cadente.dll GetResponseStream() Asynchronously gets the content stream for the response. public Stream GetResponseStream() Returns Stream A task that represents the asynchronous operation, with the response content stream as the result. Exceptions InvalidOperationException Thrown when unable to obtain an output stream for the response."
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.Headers.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Headers Gets or sets the list of headers associated with the response. public List<HttpHeader> Headers { get; set; } Property Value List<HttpHeader>"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.ResponseStream.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.ResponseStream.html",
    "title": "Property ResponseStream | Sisk",
    "keywords": "Property ResponseStream Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ResponseStream Gets or sets the stream for the response content. public Stream? ResponseStream { get; set; } Property Value Stream"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.SendChunked.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.SendChunked.html",
    "title": "Property SendChunked | Sisk",
    "keywords": "Property SendChunked Namespace Sisk.Cadente Assembly Sisk.Cadente.dll SendChunked Gets or sets an boolean indicating if this HttpHostContext.HttpResponse should be send in chunks or not. public bool SendChunked { get; set; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.StatusCode.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.StatusCode.html",
    "title": "Property StatusCode | Sisk",
    "keywords": "Property StatusCode Namespace Sisk.Cadente Assembly Sisk.Cadente.dll StatusCode Gets or sets the HTTP status code of the response. public int StatusCode { get; set; } Property Value int"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.StatusDescription.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.StatusDescription.html",
    "title": "Property StatusDescription | Sisk",
    "keywords": "Property StatusDescription Namespace Sisk.Cadente Assembly Sisk.Cadente.dll StatusDescription Gets or sets the status description of the response. public string StatusDescription { get; set; } Property Value string"
  },
  "api/Sisk.Cadente.HttpHostContext.HttpResponse.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.HttpResponse.html",
    "title": "Class HttpHostContext.HttpResponse | Sisk",
    "keywords": "Class HttpHostContext.HttpResponse Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP response. public sealed class HttpHostContext.HttpResponse Inheritance object HttpHostContext.HttpResponse Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Headers Gets or sets the list of headers associated with the response. ResponseStream Gets or sets the stream for the response content. SendChunked Gets or sets an boolean indicating if this HttpHostContext.HttpResponse should be send in chunks or not. StatusCode Gets or sets the HTTP status code of the response. StatusDescription Gets or sets the status description of the response. Methods GetEventStream() Asynchronously gets an event stream writer with UTF-8 encoding. GetEventStream(Encoding) Asynchronously gets an event stream writer with the specified encoding. GetResponseStream() Asynchronously gets the content stream for the response."
  },
  "api/Sisk.Cadente.HttpHostContext.KeepAlive.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.KeepAlive.html",
    "title": "Property KeepAlive | Sisk",
    "keywords": "Property KeepAlive Namespace Sisk.Cadente Assembly Sisk.Cadente.dll KeepAlive Gets or sets a value indicating whether the connection should be kept alive. public bool KeepAlive { get; set; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpHostContext.Request.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.Request.html",
    "title": "Property Request | Sisk",
    "keywords": "Property Request Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Request Gets the HTTP request associated with this session. public HttpHostContext.HttpRequest Request { get; } Property Value HttpHostContext.HttpRequest"
  },
  "api/Sisk.Cadente.HttpHostContext.Response.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.Response.html",
    "title": "Property Response | Sisk",
    "keywords": "Property Response Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Response Gets the HTTP response associated with this session. public HttpHostContext.HttpResponse Response { get; } Property Value HttpHostContext.HttpResponse"
  },
  "api/Sisk.Cadente.HttpHostContext.html": {
    "href": "api/Sisk.Cadente.HttpHostContext.html",
    "title": "Class HttpHostContext | Sisk",
    "keywords": "Class HttpHostContext Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP session that manages the request and response for a single connection. public sealed class HttpHostContext Inheritance object HttpHostContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Client Gets the associated HttpHostClient with this HTTP context. KeepAlive Gets or sets a value indicating whether the connection should be kept alive. Request Gets the HTTP request associated with this session. Response Gets the HTTP response associated with this session."
  },
  "api/Sisk.Cadente.HttpHostHandler.-ctor.html": {
    "href": "api/Sisk.Cadente.HttpHostHandler.-ctor.html",
    "title": "Constructor HttpHostHandler | Sisk",
    "keywords": "Constructor HttpHostHandler Namespace Sisk.Cadente Assembly Sisk.Cadente.dll HttpHostHandler() protected HttpHostHandler()"
  },
  "api/Sisk.Cadente.HttpHostHandler.OnClientConnectedAsync.html": {
    "href": "api/Sisk.Cadente.HttpHostHandler.OnClientConnectedAsync.html",
    "title": "Method OnClientConnectedAsync | Sisk",
    "keywords": "Method OnClientConnectedAsync Namespace Sisk.Cadente Assembly Sisk.Cadente.dll OnClientConnectedAsync(HttpHost, HttpHostClient) Called when a new client connects to the specified HTTP host. public virtual Task OnClientConnectedAsync(HttpHost host, HttpHostClient client) Parameters host HttpHost The HTTP host that the client connected to. client HttpHostClient The client that connected to the host. Returns Task A task that represents the asynchronous operation."
  },
  "api/Sisk.Cadente.HttpHostHandler.OnClientDisconnectedAsync.html": {
    "href": "api/Sisk.Cadente.HttpHostHandler.OnClientDisconnectedAsync.html",
    "title": "Method OnClientDisconnectedAsync | Sisk",
    "keywords": "Method OnClientDisconnectedAsync Namespace Sisk.Cadente Assembly Sisk.Cadente.dll OnClientDisconnectedAsync(HttpHost, HttpHostClient) Called when a client disconnects from the specified HTTP host. public virtual Task OnClientDisconnectedAsync(HttpHost host, HttpHostClient client) Parameters host HttpHost The HTTP host that the client disconnected from. client HttpHostClient The client that disconnected from the host. Returns Task A task that represents the asynchronous operation."
  },
  "api/Sisk.Cadente.HttpHostHandler.OnContextCreatedAsync.html": {
    "href": "api/Sisk.Cadente.HttpHostHandler.OnContextCreatedAsync.html",
    "title": "Method OnContextCreatedAsync | Sisk",
    "keywords": "Method OnContextCreatedAsync Namespace Sisk.Cadente Assembly Sisk.Cadente.dll OnContextCreatedAsync(HttpHost, HttpHostContext) Called when a new context is created for the specified HTTP host. public virtual Task OnContextCreatedAsync(HttpHost host, HttpHostContext context) Parameters host HttpHost The HTTP host that created the context. context HttpHostContext The newly created context. Returns Task A task that represents the asynchronous operation."
  },
  "api/Sisk.Cadente.HttpHostHandler.html": {
    "href": "api/Sisk.Cadente.HttpHostHandler.html",
    "title": "Class HttpHostHandler | Sisk",
    "keywords": "Class HttpHostHandler Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Provides a base class for handling HTTP host events. public abstract class HttpHostHandler Inheritance object HttpHostHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpHostHandler() Methods OnClientConnectedAsync(HttpHost, HttpHostClient) Called when a new client connects to the specified HTTP host. OnClientDisconnectedAsync(HttpHost, HttpHostClient) Called when a client disconnects from the specified HTTP host. OnContextCreatedAsync(HttpHost, HttpHostContext) Called when a new context is created for the specified HTTP host."
  },
  "api/Sisk.Cadente.HttpHostTimeoutManager.ClientReadTimeout.html": {
    "href": "api/Sisk.Cadente.HttpHostTimeoutManager.ClientReadTimeout.html",
    "title": "Property ClientReadTimeout | Sisk",
    "keywords": "Property ClientReadTimeout Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ClientReadTimeout Gets or sets the timeout for client read operations. public TimeSpan ClientReadTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Cadente.HttpHostTimeoutManager.ClientWriteTimeout.html": {
    "href": "api/Sisk.Cadente.HttpHostTimeoutManager.ClientWriteTimeout.html",
    "title": "Property ClientWriteTimeout | Sisk",
    "keywords": "Property ClientWriteTimeout Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ClientWriteTimeout Gets or sets the timeout for client write operations. public TimeSpan ClientWriteTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Cadente.HttpHostTimeoutManager.html": {
    "href": "api/Sisk.Cadente.HttpHostTimeoutManager.html",
    "title": "Class HttpHostTimeoutManager | Sisk",
    "keywords": "Class HttpHostTimeoutManager Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Manages timeouts for HTTP hosts. public sealed class HttpHostTimeoutManager Inheritance object HttpHostTimeoutManager Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ClientReadTimeout Gets or sets the timeout for client read operations. ClientWriteTimeout Gets or sets the timeout for client write operations."
  },
  "api/Sisk.Cadente.HttpsOptions.-ctor.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.-ctor.html",
    "title": "Constructor HttpsOptions | Sisk",
    "keywords": "Constructor HttpsOptions Namespace Sisk.Cadente Assembly Sisk.Cadente.dll HttpsOptions(X509Certificate) Initializes a new instance of the HttpsOptions class. public HttpsOptions(X509Certificate certificate) Parameters certificate X509Certificate The X509Certificate used to encrypt data between the client and the server."
  },
  "api/Sisk.Cadente.HttpsOptions.AllowedProtocols.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.AllowedProtocols.html",
    "title": "Property AllowedProtocols | Sisk",
    "keywords": "Property AllowedProtocols Namespace Sisk.Cadente Assembly Sisk.Cadente.dll AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. public SslProtocols AllowedProtocols { get; set; } Property Value SslProtocols"
  },
  "api/Sisk.Cadente.HttpsOptions.CheckCertificateRevocation.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.CheckCertificateRevocation.html",
    "title": "Property CheckCertificateRevocation | Sisk",
    "keywords": "Property CheckCertificateRevocation Namespace Sisk.Cadente Assembly Sisk.Cadente.dll CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. public bool CheckCertificateRevocation { get; set; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpsOptions.ClientCertificateRequired.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.ClientCertificateRequired.html",
    "title": "Property ClientCertificateRequired | Sisk",
    "keywords": "Property ClientCertificateRequired Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. public bool ClientCertificateRequired { get; set; } Property Value bool"
  },
  "api/Sisk.Cadente.HttpsOptions.ServerCertificate.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.ServerCertificate.html",
    "title": "Property ServerCertificate | Sisk",
    "keywords": "Property ServerCertificate Namespace Sisk.Cadente Assembly Sisk.Cadente.dll ServerCertificate Gets the SSL certificate used by the proxy server. public X509Certificate ServerCertificate { get; } Property Value X509Certificate"
  },
  "api/Sisk.Cadente.HttpsOptions.html": {
    "href": "api/Sisk.Cadente.HttpsOptions.html",
    "title": "Class HttpsOptions | Sisk",
    "keywords": "Class HttpsOptions Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents the options for configuring an HTTPS server. public sealed class HttpsOptions Inheritance object HttpsOptions Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpsOptions(X509Certificate) Initializes a new instance of the HttpsOptions class. Properties AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. ServerCertificate Gets the SSL certificate used by the proxy server."
  },
  "api/Sisk.Cadente.TransferEncoding.html": {
    "href": "api/Sisk.Cadente.TransferEncoding.html",
    "title": "Enum TransferEncoding | Sisk",
    "keywords": "Enum TransferEncoding Namespace Sisk.Cadente Assembly Sisk.Cadente.dll Represents an HTTP transfer-encoding algorithm. [Flags] public enum TransferEncoding Fields Chunked = 2 Indicates that the response is sent in a series of chunks. Deflate = 8 Indicates that the response is compressed using Deflate encoding. GZip = 4 Indicates that the response is compressed using GZip encoding."
  },
  "api/Sisk.Cadente.html": {
    "href": "api/Sisk.Cadente.html",
    "title": "Namespace Sisk.Cadente | Sisk",
    "keywords": "Namespace Sisk.Cadente Classes HttpEventStreamWriter Provides methods to write data and events to an underlying stream in the Server-Sent Events (SSE) format. HttpHost Represents an HTTP host that listens for incoming TCP connections and handles HTTP requests. HttpHostClient Represents an HTTP host client with its endpoint and certificate information. HttpHostContext Represents an HTTP session that manages the request and response for a single connection. HttpHostContext.HttpRequest Represents an HTTP request. HttpHostContext.HttpResponse Represents an HTTP response. HttpHostHandler Provides a base class for handling HTTP host events. HttpHostTimeoutManager Manages timeouts for HTTP hosts. HttpsOptions Represents the options for configuring an HTTPS server. Structs HttpHeader Represents an HTTP header, consisting of a name and a value. Enums TransferEncoding Represents an HTTP transfer-encoding algorithm."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.-ctor.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.-ctor.html",
    "title": "Constructor CrossOriginResourceSharingHeaders | Sisk",
    "keywords": "Constructor CrossOriginResourceSharingHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CrossOriginResourceSharingHeaders() Creates an empty CrossOriginResourceSharingHeaders instance with no predefined CORS headers. public CrossOriginResourceSharingHeaders() CrossOriginResourceSharingHeaders(string?, string[]?, string[]?, string[]?, string[]?, TimeSpan?) Initializes a new instance of the CrossOriginResourceSharingHeaders class with the specified CORS headers. public CrossOriginResourceSharingHeaders(string? allowOrigin = null, string[]? allowOrigins = null, string[]? allowMethods = null, string[]? allowHeaders = null, string[]? exposeHeaders = null, TimeSpan? maxAge = null) Parameters allowOrigin string The value of the Access-Control-Allow-Origin header. allowOrigins string[] The values of the Access-Control-Allow-Origin header. allowMethods string[] The values of the Access-Control-Allow-Methods header. allowHeaders string[] The values of the Access-Control-Allow-Headers header. exposeHeaders string[] The values of the Access-Control-Expose-Headers header. maxAge TimeSpan? The value of the Access-Control-Max-Age header."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowCredentials.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowCredentials.html",
    "title": "Property AllowCredentials | Sisk",
    "keywords": "Property AllowCredentials Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowCredentials Gets or sets the Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. public bool? AllowCredentials { get; set; } Property Value bool?"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowHeaders.html",
    "title": "Property AllowHeaders | Sisk",
    "keywords": "Property AllowHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowHeaders Gets or sets the Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. public string[] AllowHeaders { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowMethods.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowMethods.html",
    "title": "Property AllowMethods | Sisk",
    "keywords": "Property AllowMethods Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowMethods Gets or sets the Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. public string[] AllowMethods { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigin.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigin.html",
    "title": "Property AllowOrigin | Sisk",
    "keywords": "Property AllowOrigin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowOrigin From MDN: Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the \"*\" wildcard tells browsers to allow any origin to access the resource. public string? AllowOrigin { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigins.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigins.html",
    "title": "Property AllowOrigins | Sisk",
    "keywords": "Property AllowOrigins Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowOrigins Gets or sets domains which will define the source header according to one of the domains present below. public string[] AllowOrigins { get; set; } Property Value string[] Remarks This property makes the server compare the origin of the request and associate the domain that corresponds to it."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AutoAllowOrigin.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AutoAllowOrigin.html",
    "title": "Field AutoAllowOrigin | Sisk",
    "keywords": "Field AutoAllowOrigin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll When applied to the AllowOrigin property, the HTTP server automatically applies the incoming request Origin header value to the Access-Control-Allow-Origin header. public const string AutoAllowOrigin = \"<SISK_AUTO_ALLOW_ORIGIN_NAME>\" Returns string When applied to the property, the HTTP server automatically applies the incoming request Origin header value to the Access-Control-Allow-Origin header."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.CreatePublicContext.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.CreatePublicContext.html",
    "title": "Method CreatePublicContext | Sisk",
    "keywords": "Method CreatePublicContext Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CreatePublicContext() Create an instance of Cross-Origin Resource Sharing that allows any origin, any method and any header in the request. public static CrossOriginResourceSharingHeaders CreatePublicContext() Returns CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.Empty.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.Empty.html",
    "title": "Property Empty | Sisk",
    "keywords": "Property Empty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Empty Gets an instance of an empty CrossOriginResourceSharingHeaders. public static CrossOriginResourceSharingHeaders Empty { get; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.ExposeHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.ExposeHeaders.html",
    "title": "Property ExposeHeaders | Sisk",
    "keywords": "Property ExposeHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ExposeHeaders Gets or sets the Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript in browsers is allowed to access. public string[] ExposeHeaders { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.MaxAge.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.MaxAge.html",
    "title": "Property MaxAge | Sisk",
    "keywords": "Property MaxAge Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaxAge Gets or sets the Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. public TimeSpan MaxAge { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.html",
    "title": "Class CrossOriginResourceSharingHeaders | Sisk",
    "keywords": "Class CrossOriginResourceSharingHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Provides a class to provide Cross Origin response headers for when communicating with a browser. public sealed class CrossOriginResourceSharingHeaders Inheritance object CrossOriginResourceSharingHeaders Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors CrossOriginResourceSharingHeaders() Creates an empty CrossOriginResourceSharingHeaders instance with no predefined CORS headers. CrossOriginResourceSharingHeaders(string?, string[]?, string[]?, string[]?, string[]?, TimeSpan?) Initializes a new instance of the CrossOriginResourceSharingHeaders class with the specified CORS headers. Fields AutoAllowOrigin When applied to the AllowOrigin property, the HTTP server automatically applies the incoming request Origin header value to the Access-Control-Allow-Origin header. Properties AllowCredentials Gets or sets the Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. AllowHeaders Gets or sets the Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. AllowMethods Gets or sets the Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. AllowOrigin From MDN: Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the \"*\" wildcard tells browsers to allow any origin to access the resource. AllowOrigins Gets or sets domains which will define the source header according to one of the domains present below. Empty Gets an instance of an empty CrossOriginResourceSharingHeaders. ExposeHeaders Gets or sets the Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript in browsers is allowed to access. MaxAge Gets or sets the Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. Methods CreatePublicContext() Create an instance of Cross-Origin Resource Sharing that allows any origin, any method and any header in the request."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.-ctor.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.-ctor.html",
    "title": "Constructor HttpHeaderCollection | Sisk",
    "keywords": "Constructor HttpHeaderCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll HttpHeaderCollection() Create an new instance of the HttpHeaderCollection class. public HttpHeaderCollection() HttpHeaderCollection(IDictionary<string, string[]>) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(IDictionary<string, string[]> items) Parameters items IDictionary<string, string[]> The inner collection to add to this collection. HttpHeaderCollection(IDictionary<string, string?>) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(IDictionary<string, string?> items) Parameters items IDictionary<string, string> The inner collection to add to this collection. HttpHeaderCollection(WebHeaderCollection) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(WebHeaderCollection items) Parameters items WebHeaderCollection The inner collection to add to this collection."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Accept.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Accept.html",
    "title": "Property Accept | Sisk",
    "keywords": "Property Accept Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Accept Gets the value of the HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. public string? Accept { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCH.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCH.html",
    "title": "Property AcceptCH | Sisk",
    "keywords": "Property AcceptCH Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptCH Gets or sets the value of the HTTP Accept-CH header. Specifies the client hints that the server supports, allowing clients to provide additional information about their capabilities. public string? AcceptCH { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCharset.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCharset.html",
    "title": "Property AcceptCharset | Sisk",
    "keywords": "Property AcceptCharset Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptCharset Gets the value of the HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. public string? AcceptCharset { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptEncoding.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptEncoding.html",
    "title": "Property AcceptEncoding | Sisk",
    "keywords": "Property AcceptEncoding Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptEncoding Gets the value of the HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. public string? AcceptEncoding { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptLanguage.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptLanguage.html",
    "title": "Property AcceptLanguage | Sisk",
    "keywords": "Property AcceptLanguage Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptLanguage Gets the value of the HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. public string? AcceptLanguage { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPatch.html",
    "title": "Property AcceptPatch | Sisk",
    "keywords": "Property AcceptPatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptPatch Gets the value of the HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. public string? AcceptPatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPost.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPost.html",
    "title": "Property AcceptPost | Sisk",
    "keywords": "Property AcceptPost Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptPost Gets or sets the value of the HTTP Accept-Post header. Specifies the accepted formats for posting data to the server. public string? AcceptPost { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptRanges.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptRanges.html",
    "title": "Property AcceptRanges | Sisk",
    "keywords": "Property AcceptRanges Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptRanges Gets or sets the value of the HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. public string? AcceptRanges { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowCredentials.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowCredentials.html",
    "title": "Property AccessControlAllowCredentials | Sisk",
    "keywords": "Property AccessControlAllowCredentials Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowCredentials Gets or sets the value of the HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. public string? AccessControlAllowCredentials { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowHeaders.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowHeaders.html",
    "title": "Property AccessControlAllowHeaders | Sisk",
    "keywords": "Property AccessControlAllowHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowHeaders Gets or sets the value of the HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. public string? AccessControlAllowHeaders { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowMethods.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowMethods.html",
    "title": "Property AccessControlAllowMethods | Sisk",
    "keywords": "Property AccessControlAllowMethods Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowMethods Gets or sets the value of the HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. public string? AccessControlAllowMethods { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowOrigin.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowOrigin.html",
    "title": "Property AccessControlAllowOrigin | Sisk",
    "keywords": "Property AccessControlAllowOrigin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowOrigin Gets or sets the value of the HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. public string? AccessControlAllowOrigin { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlExposeHeaders.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlExposeHeaders.html",
    "title": "Property AccessControlExposeHeaders | Sisk",
    "keywords": "Property AccessControlExposeHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlExposeHeaders Gets or sets the value of the HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. public string? AccessControlExposeHeaders { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlMaxAge.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlMaxAge.html",
    "title": "Property AccessControlMaxAge | Sisk",
    "keywords": "Property AccessControlMaxAge Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlMaxAge Gets or sets the value of the HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. public string? AccessControlMaxAge { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Age.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Age.html",
    "title": "Property Age | Sisk",
    "keywords": "Property Age Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Age Gets or sets the value of the HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. public string? Age { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Allow.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Allow.html",
    "title": "Property Allow | Sisk",
    "keywords": "Property Allow Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Allow Gets or sets the value of the HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. public string? Allow { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Authorization.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Authorization.html",
    "title": "Property Authorization | Sisk",
    "keywords": "Property Authorization Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Authorization Gets or sets the value of the HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. public string? Authorization { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.CacheControl.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.CacheControl.html",
    "title": "Property CacheControl | Sisk",
    "keywords": "Property CacheControl Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CacheControl Gets or sets the value of the HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. public string? CacheControl { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Connection.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Connection.html",
    "title": "Property Connection | Sisk",
    "keywords": "Property Connection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Connection Gets the value of the HTTP Connection header. To set this header in a HTTP response, use the KeepAlive property. public string? Connection { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentDisposition.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentDisposition.html",
    "title": "Property ContentDisposition | Sisk",
    "keywords": "Property ContentDisposition Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentDisposition Gets or sets the value of the HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. public string? ContentDisposition { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentEncoding.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentEncoding.html",
    "title": "Property ContentEncoding | Sisk",
    "keywords": "Property ContentEncoding Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentEncoding Gets or sets the value of the HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. This header should not be interpreted as the content text charset. public string? ContentEncoding { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLanguage.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLanguage.html",
    "title": "Property ContentLanguage | Sisk",
    "keywords": "Property ContentLanguage Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLanguage Gets or sets the value of the HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. public string? ContentLanguage { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLocation.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLocation.html",
    "title": "Property ContentLocation | Sisk",
    "keywords": "Property ContentLocation Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLocation Gets or sets the value of the HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public string? ContentLocation { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentMD5.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentMD5.html",
    "title": "Property ContentMD5 | Sisk",
    "keywords": "Property ContentMD5 Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentMD5 Gets or sets the value of the HTTP Content-MD5 header. Contains the MD5 hash of the response body in an base-64 format, allowing clients to verify the integrity of the received data. public string? ContentMD5 { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentRange.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentRange.html",
    "title": "Property ContentRange | Sisk",
    "keywords": "Property ContentRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentRange Gets or sets the value of the HTTP Content-Range header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. public string? ContentRange { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentSecurityPolicy.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentSecurityPolicy.html",
    "title": "Property ContentSecurityPolicy | Sisk",
    "keywords": "Property ContentSecurityPolicy Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentSecurityPolicy Gets or sets the value of the HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. public string? ContentSecurityPolicy { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentType.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentType.html",
    "title": "Property ContentType | Sisk",
    "keywords": "Property ContentType Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentType Gets or sets the value of the HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. public string? ContentType { get; set; } Property Value string Remarks Note: setting the value of this header, the value present in the response's HttpContent will be overwritten."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Cookie.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Cookie.html",
    "title": "Property Cookie | Sisk",
    "keywords": "Property Cookie Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Cookie Gets the value of the HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. public string? Cookie { get; } Property Value string Remarks Tip: use Cookies property to getting cookies values from requests and SetCookie(string, string) on HttpResponse to set cookies."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Dnt.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Dnt.html",
    "title": "Property Dnt | Sisk",
    "keywords": "Property Dnt Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Dnt Gets the value of the HTTP DNT header. The HTTP DNT (Do Not Track) request header indicates the user's tracking preference. public string? Dnt { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ETag.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ETag.html",
    "title": "Property ETag | Sisk",
    "keywords": "Property ETag Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ETag Gets or sets the value of the HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. public string? ETag { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Expect.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Expect.html",
    "title": "Property Expect | Sisk",
    "keywords": "Property Expect Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Expect Gets the value of the HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. public string? Expect { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Expires.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Expires.html",
    "title": "Property Expires | Sisk",
    "keywords": "Property Expires Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Expires Gets or sets the value of the HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. public string? Expires { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Host.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Host Gets the value of the HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. public string? Host { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfMatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfMatch.html",
    "title": "Property IfMatch | Sisk",
    "keywords": "Property IfMatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfMatch Gets the value of the HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. public string? IfMatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfModifiedSince.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfModifiedSince.html",
    "title": "Property IfModifiedSince | Sisk",
    "keywords": "Property IfModifiedSince Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfModifiedSince Gets the value of the HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public string? IfModifiedSince { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfNoneMatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfNoneMatch.html",
    "title": "Property IfNoneMatch | Sisk",
    "keywords": "Property IfNoneMatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfNoneMatch Gets the value of the HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public string? IfNoneMatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfRange.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfRange.html",
    "title": "Property IfRange | Sisk",
    "keywords": "Property IfRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfRange Gets the value of the HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. public string? IfRange { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfUnmodifiedSince.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfUnmodifiedSince.html",
    "title": "Property IfUnmodifiedSince | Sisk",
    "keywords": "Property IfUnmodifiedSince Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfUnmodifiedSince Gets the value of the HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. public string? IfUnmodifiedSince { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Location.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Location.html",
    "title": "Property Location | Sisk",
    "keywords": "Property Location Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Location Gets or sets the value of the HTTP Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public string? Location { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.MaxForwards.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.MaxForwards.html",
    "title": "Property MaxForwards | Sisk",
    "keywords": "Property MaxForwards Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaxForwards Gets or sets the value of the HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. public string? MaxForwards { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Origin.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Origin.html",
    "title": "Property Origin | Sisk",
    "keywords": "Property Origin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Origin Gets the value of the HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. public string? Origin { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Pragma.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Pragma.html",
    "title": "Property Pragma | Sisk",
    "keywords": "Property Pragma Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Pragma Gets or sets the value of the HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. public string? Pragma { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthenticate.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthenticate.html",
    "title": "Property ProxyAuthenticate | Sisk",
    "keywords": "Property ProxyAuthenticate Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ProxyAuthenticate Gets or sets the value of the HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. public string? ProxyAuthenticate { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthorization.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthorization.html",
    "title": "Property ProxyAuthorization | Sisk",
    "keywords": "Property ProxyAuthorization Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ProxyAuthorization Gets or sets the value of the HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. public string? ProxyAuthorization { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Range.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Range.html",
    "title": "Property Range | Sisk",
    "keywords": "Property Range Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Range Gets the value of the HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. public string? Range { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Referer.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Referer.html",
    "title": "Property Referer | Sisk",
    "keywords": "Property Referer Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Referer Gets the value of the HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. public string? Referer { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.RetryAfter.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.RetryAfter.html",
    "title": "Property RetryAfter | Sisk",
    "keywords": "Property RetryAfter Namespace Sisk.Core.Entity Assembly Sisk.Core.dll RetryAfter Gets or sets the value of the HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. public string? RetryAfter { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.SecGPC.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.SecGPC.html",
    "title": "Property SecGPC | Sisk",
    "keywords": "Property SecGPC Namespace Sisk.Core.Entity Assembly Sisk.Core.dll SecGPC Gets the value of the HTTP Sec-GPC header. The HTTP Sec-GPC request header is part of the Global Privacy Control (GPC) mechanism to indicate whether the user consents to a website or service selling or sharing their personal information with third parties. public string? SecGPC { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.SetCookie.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.SetCookie.html",
    "title": "Property SetCookie | Sisk",
    "keywords": "Property SetCookie Namespace Sisk.Core.Entity Assembly Sisk.Core.dll SetCookie Gets or sets the value of the HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. public string? SetCookie { get; set; } Property Value string Remarks Note: setting this property, it will override all previous Set-Cookie headers. Use the Add(string, string) method to add more than one Set-Cookie header or use the SetCookie(string, string) method."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.TE.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.TE.html",
    "title": "Property TE | Sisk",
    "keywords": "Property TE Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TE Gets the value of the HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. public string? TE { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.UserAgent.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.UserAgent.html",
    "title": "Property UserAgent | Sisk",
    "keywords": "Property UserAgent Namespace Sisk.Core.Entity Assembly Sisk.Core.dll UserAgent Gets the value of the HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. public string? UserAgent { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Vary.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Vary.html",
    "title": "Property Vary | Sisk",
    "keywords": "Property Vary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Vary Gets or sets the value of the HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. public string? Vary { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Via.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Via.html",
    "title": "Property Via | Sisk",
    "keywords": "Property Via Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Via Gets or sets the value of the HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. public string? Via { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.WWWAuthenticate.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.WWWAuthenticate.html",
    "title": "Property WWWAuthenticate | Sisk",
    "keywords": "Property WWWAuthenticate Namespace Sisk.Core.Entity Assembly Sisk.Core.dll WWWAuthenticate Gets or sets the value of the HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. public string? WWWAuthenticate { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedFor.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedFor.html",
    "title": "Property XForwardedFor | Sisk",
    "keywords": "Property XForwardedFor Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XForwardedFor Gets the value of the HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. public string? XForwardedFor { get; } Property Value string Remarks Tip: use the ForwardingResolver property to obtain the user client proxied IP throught RemoteAddress."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedHost.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedHost.html",
    "title": "Property XForwardedHost | Sisk",
    "keywords": "Property XForwardedHost Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XForwardedHost Gets the value of the HTTP X-Forwarded-Host header Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. public string? XForwardedHost { get; } Property Value string Remarks Tip: use the ForwardingResolver property to obtain the client requested host throught Host."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XFrameOptions.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XFrameOptions.html",
    "title": "Property XFrameOptions | Sisk",
    "keywords": "Property XFrameOptions Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XFrameOptions Gets or sets the value of the HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. public string? XFrameOptions { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XUACompatible.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XUACompatible.html",
    "title": "Property XUACompatible | Sisk",
    "keywords": "Property XUACompatible Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XUACompatible Gets or sets the value of the HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions. public string? XUACompatible { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.html",
    "title": "Class HttpHeaderCollection | Sisk",
    "keywords": "Class HttpHeaderCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an collection of HTTP headers with their name and values. public sealed class HttpHeaderCollection : StringKeyStoreCollection, IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStoreCollection HttpHeaderCollection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members StringKeyStoreCollection.FromQueryString(string) StringKeyStoreCollection.FromCookieString(string) StringKeyStoreCollection.FromNameValueCollection(NameValueCollection) StringKeyStoreCollection.ImportNameValueCollection(NameValueCollection) StringKeyStoreCollection.ImportQueryString(string) StringKeyStoreCollection.ImportCookieString(string) StringKeyStoreCollection.Add(string, string[]) StringKeyStoreCollection.Add(string, IEnumerable<string>) StringKeyStoreCollection.Add(string, string) StringKeyStoreCollection.Add(KeyValuePair<string, string[]>) StringKeyStoreCollection.AddRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStoreCollection.AddRange(IEnumerable<KeyValuePair<string, string>>) StringKeyStoreCollection.SetRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStoreCollection.Set(KeyValuePair<string, string[]>) StringKeyStoreCollection.Set(string, string) StringKeyStoreCollection.Set(string, IEnumerable<string>) StringKeyStoreCollection.GetValue(string) StringKeyStoreCollection.GetValues(string) StringKeyStoreCollection.Clear() StringKeyStoreCollection.Remove(string) StringKeyStoreCollection.MakeReadOnly() StringKeyStoreCollection.ContainsKey(string) StringKeyStoreCollection.GetEnumerator() StringKeyStoreCollection.TryGetValue(string, out string[]) StringKeyStoreCollection.AsDictionary() StringKeyStoreCollection.AsNameValueCollection() StringKeyStoreCollection.AsStringValueCollection() StringKeyStoreCollection.ToString() StringKeyStoreCollection.ToString(IFormatProvider) StringKeyStoreCollection.Comparer StringKeyStoreCollection.this[string] StringKeyStoreCollection.Keys StringKeyStoreCollection.Values StringKeyStoreCollection.Count StringKeyStoreCollection.IsReadOnly object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpHeaderCollection() Create an new instance of the HttpHeaderCollection class. HttpHeaderCollection(IDictionary<string, string[]>) Create an new instance of the HttpHeaderCollection class with values from another collection. HttpHeaderCollection(IDictionary<string, string?>) Create an new instance of the HttpHeaderCollection class with values from another collection. HttpHeaderCollection(WebHeaderCollection) Create an new instance of the HttpHeaderCollection class with values from another collection. Properties Accept Gets the value of the HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. AcceptCH Gets or sets the value of the HTTP Accept-CH header. Specifies the client hints that the server supports, allowing clients to provide additional information about their capabilities. AcceptCharset Gets the value of the HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. AcceptEncoding Gets the value of the HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. AcceptLanguage Gets the value of the HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. AcceptPatch Gets the value of the HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. AcceptPost Gets or sets the value of the HTTP Accept-Post header. Specifies the accepted formats for posting data to the server. AcceptRanges Gets or sets the value of the HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. AccessControlAllowCredentials Gets or sets the value of the HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. AccessControlAllowHeaders Gets or sets the value of the HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. AccessControlAllowMethods Gets or sets the value of the HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. AccessControlAllowOrigin Gets or sets the value of the HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. AccessControlExposeHeaders Gets or sets the value of the HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. AccessControlMaxAge Gets or sets the value of the HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. Age Gets or sets the value of the HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. Allow Gets or sets the value of the HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. Authorization Gets or sets the value of the HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. CacheControl Gets or sets the value of the HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. Connection Gets the value of the HTTP Connection header. To set this header in a HTTP response, use the KeepAlive property. ContentDisposition Gets or sets the value of the HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. ContentEncoding Gets or sets the value of the HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. This header should not be interpreted as the content text charset. ContentLanguage Gets or sets the value of the HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. ContentLocation Gets or sets the value of the HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. ContentMD5 Gets or sets the value of the HTTP Content-MD5 header. Contains the MD5 hash of the response body in an base-64 format, allowing clients to verify the integrity of the received data. ContentRange Gets or sets the value of the HTTP Content-Range header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. ContentSecurityPolicy Gets or sets the value of the HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. ContentType Gets or sets the value of the HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. Cookie Gets the value of the HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. Dnt Gets the value of the HTTP DNT header. The HTTP DNT (Do Not Track) request header indicates the user's tracking preference. ETag Gets or sets the value of the HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. Expect Gets the value of the HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. Expires Gets or sets the value of the HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. Host Gets the value of the HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. IfMatch Gets the value of the HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. IfModifiedSince Gets the value of the HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfNoneMatch Gets the value of the HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfRange Gets the value of the HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. IfUnmodifiedSince Gets the value of the HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. Location Gets or sets the value of the HTTP Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. MaxForwards Gets or sets the value of the HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. Origin Gets the value of the HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. Pragma Gets or sets the value of the HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. ProxyAuthenticate Gets or sets the value of the HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. ProxyAuthorization Gets or sets the value of the HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. Range Gets the value of the HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. Referer Gets the value of the HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. RetryAfter Gets or sets the value of the HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. SecGPC Gets the value of the HTTP Sec-GPC header. The HTTP Sec-GPC request header is part of the Global Privacy Control (GPC) mechanism to indicate whether the user consents to a website or service selling or sharing their personal information with third parties. SetCookie Gets or sets the value of the HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. TE Gets the value of the HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. UserAgent Gets the value of the HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. Vary Gets or sets the value of the HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. Via Gets or sets the value of the HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. WWWAuthenticate Gets or sets the value of the HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. XForwardedFor Gets the value of the HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. XForwardedHost Gets the value of the HTTP X-Forwarded-Host header Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. XFrameOptions Gets or sets the value of the HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. XUACompatible Gets or sets the value of the HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.ContainsKey.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContainsKey(string) public bool ContainsKey(string key) Parameters key string Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Count.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Files.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Files.html",
    "title": "Property Files | Sisk",
    "keywords": "Property Files Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Files Gets a collection of MultipartObject instances that represent files. public IEnumerable<MultipartObject> Files { get; } Property Value IEnumerable<MultipartObject> An IEnumerable<T> of MultipartObject instances."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetEnumerator.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<MultipartObject> GetEnumerator() Returns IEnumerator<MultipartObject>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetFile.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetFile.html",
    "title": "Method GetFile | Sisk",
    "keywords": "Method GetFile Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetFile(string) Retrieves a MultipartObject instance by its file name. public MultipartObject? GetFile(string name) Parameters name string The filename of the MultipartObject to retrieve. Returns MultipartObject The MultipartObject instance with the specified filename, or null if no matching file is found."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetItem.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetItem.html",
    "title": "Method GetItem | Sisk",
    "keywords": "Method GetItem Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItem(string) Gets the last form item by their name. This search is case-insensitive. public MultipartObject? GetItem(string name) Parameters name string The form item name. Returns MultipartObject"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetItems.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetItems.html",
    "title": "Method GetItems | Sisk",
    "keywords": "Method GetItems Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItems(string) Gets all form items that shares the specified name. This search is case-insensitive. public MultipartObject[] GetItems(string name) Parameters name string The form item name. Returns MultipartObject[] An array of MultipartObject with the specified name."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetStringValue.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetStringValue.html",
    "title": "Method GetStringValue | Sisk",
    "keywords": "Method GetStringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetStringValue(string) Gets an StringValue object from the form item content string. This method reads the contents of the last matched last item with the request encoding. public StringValue GetStringValue(string name) Parameters name string The form item name. Returns StringValue"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Keys.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Keys public IEnumerable<string> Keys { get; } Property Value IEnumerable<string>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.ToArray.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.ToArray.html",
    "title": "Method ToArray | Sisk",
    "keywords": "Method ToArray Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ToArray() Creates an array with the MultipartObject in this collection. public MultipartObject[] ToArray() Returns MultipartObject[]"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out MultipartObject) public bool TryGetValue(string key, out MultipartObject value) Parameters key string value MultipartObject Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Values.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Values public IEnumerable<MultipartObject> Values { get; } Property Value IEnumerable<MultipartObject>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.html",
    "title": "Class MultipartFormCollection | Sisk",
    "keywords": "Class MultipartFormCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an class which hosts an multipart form data contents. public sealed class MultipartFormCollection : IReadOnlyList<MultipartObject>, IReadOnlyCollection<MultipartObject>, IEnumerable<MultipartObject>, IReadOnlyDictionary<string, MultipartObject>, IReadOnlyCollection<KeyValuePair<string, MultipartObject>>, IEnumerable<KeyValuePair<string, MultipartObject>>, IEnumerable Inheritance object MultipartFormCollection Implements IReadOnlyList<MultipartObject> IReadOnlyCollection<MultipartObject> IEnumerable<MultipartObject> IReadOnlyDictionary<string, MultipartObject> IReadOnlyCollection<KeyValuePair<string, MultipartObject>> IEnumerable<KeyValuePair<string, MultipartObject>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Count Files Gets a collection of MultipartObject instances that represent files. Keys Values Methods ContainsKey(string) GetEnumerator() GetFile(string) Retrieves a MultipartObject instance by its file name. GetItem(string) Gets the last form item by their name. This search is case-insensitive. GetItems(string) Gets all form items that shares the specified name. This search is case-insensitive. GetStringValue(string) Gets an StringValue object from the form item content string. This method reads the contents of the last matched last item with the request encoding. ToArray() Creates an array with the MultipartObject in this collection. TryGetValue(string, out MultipartObject)"
  },
  "api/Sisk.Core.Entity.MultipartObject.ContentBytes.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ContentBytes.html",
    "title": "Property ContentBytes | Sisk",
    "keywords": "Property ContentBytes Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentBytes Gets this MultipartObject form data content in bytes. public byte[] ContentBytes { get; } Property Value byte[]"
  },
  "api/Sisk.Core.Entity.MultipartObject.ContentLength.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ContentLength.html",
    "title": "Property ContentLength | Sisk",
    "keywords": "Property ContentLength Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLength Gets this MultipartObject form data content length in byte count. public int ContentLength { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.MultipartObject.Equals.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool Equals(MultipartObject?) public bool Equals(MultipartObject? other) Parameters other MultipartObject Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartObject.Filename.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Filename.html",
    "title": "Property Filename | Sisk",
    "keywords": "Property Filename Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Filename Gets this MultipartObject provided file name. If this object ins't disposing a file, nothing is returned. public string? Filename { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.MultipartObject.GetCommonFileFormat.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.GetCommonFileFormat.html",
    "title": "Method GetCommonFileFormat | Sisk",
    "keywords": "Method GetCommonFileFormat Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetCommonFileFormat() Determines the image format based in the file header for each image content type. public MultipartObjectCommonFormat GetCommonFileFormat() Returns MultipartObjectCommonFormat"
  },
  "api/Sisk.Core.Entity.MultipartObject.GetHashCode.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Entity.MultipartObject.HasContents.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.HasContents.html",
    "title": "Property HasContents | Sisk",
    "keywords": "Property HasContents Namespace Sisk.Core.Entity Assembly Sisk.Core.dll HasContents Gets an boolean indicating if this MultipartObject has contents or not. public bool HasContents { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.MultipartObject.Headers.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Headers Gets this MultipartObject headers. public HttpHeaderCollection Headers { get; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Entity.MultipartObject.IsFile.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.IsFile.html",
    "title": "Property IsFile | Sisk",
    "keywords": "Property IsFile Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsFile Gets an boolean indicating if this MultipartObject is a file or not. public bool IsFile { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.MultipartObject.Name.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Name Gets this MultipartObject field name. public string Name { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.MultipartObject.ReadContentAsString.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ReadContentAsString.html",
    "title": "Method ReadContentAsString | Sisk",
    "keywords": "Method ReadContentAsString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ReadContentAsString(Encoding) Reads the content bytes with the given encoder. public string ReadContentAsString(Encoding encoder) Parameters encoder Encoding Returns string ReadContentAsString() Reads the content bytes using the HTTP request content-encoding. public string ReadContentAsString() Returns string"
  },
  "api/Sisk.Core.Entity.MultipartObject.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.html",
    "title": "Class MultipartObject | Sisk",
    "keywords": "Class MultipartObject Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an multipart/form-data object. public sealed class MultipartObject : IEquatable<MultipartObject> Inheritance object MultipartObject Implements IEquatable<MultipartObject> Inherited Members object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Properties ContentBytes Gets this MultipartObject form data content in bytes. ContentLength Gets this MultipartObject form data content length in byte count. Filename Gets this MultipartObject provided file name. If this object ins't disposing a file, nothing is returned. HasContents Gets an boolean indicating if this MultipartObject has contents or not. Headers Gets this MultipartObject headers. IsFile Gets an boolean indicating if this MultipartObject is a file or not. Name Gets this MultipartObject field name. Methods Equals(MultipartObject?) Equals(object?) GetCommonFileFormat() Determines the image format based in the file header for each image content type. GetHashCode() ReadContentAsString() Reads the content bytes using the HTTP request content-encoding. ReadContentAsString(Encoding) Reads the content bytes with the given encoder."
  },
  "api/Sisk.Core.Entity.MultipartObjectCommonFormat.html": {
    "href": "api/Sisk.Core.Entity.MultipartObjectCommonFormat.html",
    "title": "Enum MultipartObjectCommonFormat | Sisk",
    "keywords": "Enum MultipartObjectCommonFormat Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an image format for Multipart objects. public enum MultipartObjectCommonFormat Fields BMP = 104 Represents an bitmap image. GIF = 101 Represents an GIF image. JPEG = 100 Represents an JPEG/JPG image. PDF = 200 Represents an PDF file. PNG = 102 Represents an PNG image. TIFF = 103 Represents an TIFF image. Unknown = 0 Represents that the object is not a recognized image. WEBP = 105 Represents an WebP image."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.-ctor.html",
    "title": "Constructor StringKeyStoreCollection | Sisk",
    "keywords": "Constructor StringKeyStoreCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringKeyStoreCollection() Initializes a new instance of the StringKeyStoreCollection class, public StringKeyStoreCollection() StringKeyStoreCollection(IEqualityComparer<string>) Initializes a new instance of the StringKeyStoreCollection class with a specified comparer. public StringKeyStoreCollection(IEqualityComparer<string> comparer) Parameters comparer IEqualityComparer<string> The comparer used for key equality. StringKeyStoreCollection(IEqualityComparer<string>, IDictionary<string, string[]>?) Initializes a new instance of the StringKeyStoreCollection class, public StringKeyStoreCollection(IEqualityComparer<string> comparer, IDictionary<string, string[]>? items) Parameters comparer IEqualityComparer<string> The comparer used for key equality. items IDictionary<string, string[]> The inner collection to add to this instance."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Add.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Add(string, string[]) Adds an array of values associated with the specified key. public void Add(string key, string[] value) Parameters key string The key to which the values will be added. value string[] The array of values to associate with the key. Add(string, IEnumerable<string>) Adds a collection of values associated with the specified key. public void Add(string key, IEnumerable<string> value) Parameters key string The key to which the values will be added. value IEnumerable<string> The collection of values to associate with the key. Add(string, string) Adds a single value associated with the specified key. public void Add(string key, string value) Parameters key string The key to which the value will be added. value string The value to associate with the key. Add(KeyValuePair<string, string[]>) Adds a key-value pair to the StringKeyStoreCollection. public void Add(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> The key-value pair to add, where the key is associated with an array of values."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.AddRange.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.AddRange.html",
    "title": "Method AddRange | Sisk",
    "keywords": "Method AddRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AddRange(IEnumerable<KeyValuePair<string, string[]>>) Adds the elements of the specified collection to the end of this collection. public void AddRange(IEnumerable<KeyValuePair<string, string[]>> items) Parameters items IEnumerable<KeyValuePair<string, string[]>> The collection whose items should be added to the end of this collection. AddRange(IEnumerable<KeyValuePair<string, string?>>) Adds the elements of the specified collection to the end of this collection. public void AddRange(IEnumerable<KeyValuePair<string, string?>> items) Parameters items IEnumerable<KeyValuePair<string, string>> The collection whose items should be added to the end of this collection."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.AsDictionary.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.AsDictionary.html",
    "title": "Method AsDictionary | Sisk",
    "keywords": "Method AsDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsDictionary() Copies the contents of this StringKeyStoreCollection into an Dictionary<TKey, TValue>. public IDictionary<string, string[]> AsDictionary() Returns IDictionary<string, string[]>"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.AsNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.AsNameValueCollection.html",
    "title": "Method AsNameValueCollection | Sisk",
    "keywords": "Method AsNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsNameValueCollection() Copies the contents of this StringKeyStoreCollection into an NameValueCollection, with values separated with an comma (,). public NameValueCollection AsNameValueCollection() Returns NameValueCollection"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.AsStringValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.AsStringValueCollection.html",
    "title": "Method AsStringValueCollection | Sisk",
    "keywords": "Method AsStringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsStringValueCollection() Copies the contents of this StringKeyStoreCollection into an StringValueCollection. public StringValueCollection AsStringValueCollection() Returns StringValueCollection"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Clear.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Clear() Removes all key-value pairs from the StringKeyStoreCollection. Throws an exception if the store is read-only. public void Clear()"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Comparer.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Comparer.html",
    "title": "Property Comparer | Sisk",
    "keywords": "Property Comparer Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Comparer Gets the IEqualityComparer<T> used to compare keys in this StringKeyStoreCollection. public IEqualityComparer<string> Comparer { get; } Property Value IEqualityComparer<string>"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.ContainsKey.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContainsKey(string) Determines whether the StringKeyStoreCollection contains a specific key. public bool ContainsKey(string key) Parameters key string The key to locate in the StringKeyStoreCollection. Returns bool true if the StringKeyStoreCollection contains an element with the specified key; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Count.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Count Gets the number of key-value pairs in the StringKeyStoreCollection. public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.FromCookieString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.FromCookieString.html",
    "title": "Method FromCookieString | Sisk",
    "keywords": "Method FromCookieString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromCookieString(string) Creates a new instance of the StringKeyStoreCollection from a cookie string. The query string should be in the format of \"key1=value1; key2=value2\". public static StringKeyStoreCollection FromCookieString(string queryString) Parameters queryString string The query string containing the key-value pairs to import. Returns StringKeyStoreCollection A new StringKeyStoreCollection populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.FromNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.FromNameValueCollection.html",
    "title": "Method FromNameValueCollection | Sisk",
    "keywords": "Method FromNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromNameValueCollection(NameValueCollection) Creates a new instance of the StringKeyStoreCollection from a NameValueCollection. public static StringKeyStoreCollection FromNameValueCollection(NameValueCollection collection) Parameters collection NameValueCollection The NameValueCollection containing the key-value pairs to import. Returns StringKeyStoreCollection A new StringKeyStoreCollection populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.FromQueryString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.FromQueryString.html",
    "title": "Method FromQueryString | Sisk",
    "keywords": "Method FromQueryString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromQueryString(string) Creates a new instance of the StringKeyStoreCollection from a query string. The query string should be in the format of \"key1=value1&key2=value2\". public static StringKeyStoreCollection FromQueryString(string queryString) Parameters queryString string The query string containing the key-value pairs to import. Returns StringKeyStoreCollection A new StringKeyStoreCollection populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.GetEnumerator.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<KeyValuePair<string, string[]>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, string[]>>"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.GetValue.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.GetValue.html",
    "title": "Method GetValue | Sisk",
    "keywords": "Method GetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetValue(string) Retrieves the last value associated with the specified key. Returns null if the key does not exist. public string? GetValue(string name) Parameters name string The key for which to retrieve the value. Returns string The last value associated with the specified key, or null if the key is not found."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.GetValues.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.GetValues.html",
    "title": "Method GetValues | Sisk",
    "keywords": "Method GetValues Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetValues(string) Retrieves all values associated with the specified key. Returns an empty array if the key does not exist. public string[] GetValues(string name) Parameters name string The key for which to retrieve the values. Returns string[] An array of values associated with the specified key, or an empty array if the key is not found."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportCookieString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportCookieString.html",
    "title": "Method ImportCookieString | Sisk",
    "keywords": "Method ImportCookieString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportCookieString(string) Imports key-value pairs from a cookie string into the StringKeyStoreCollection. The query string should be in the format of \"key1=value1; key2=value2\". public void ImportCookieString(string queryString) Parameters queryString string The query string containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportNameValueCollection.html",
    "title": "Method ImportNameValueCollection | Sisk",
    "keywords": "Method ImportNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportNameValueCollection(NameValueCollection) Imports key-value pairs from a NameValueCollection into the StringKeyStoreCollection. Each key can have multiple associated values. public void ImportNameValueCollection(NameValueCollection items) Parameters items NameValueCollection The NameValueCollection containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportQueryString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.ImportQueryString.html",
    "title": "Method ImportQueryString | Sisk",
    "keywords": "Method ImportQueryString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportQueryString(string) Imports key-value pairs from a query string into the StringKeyStoreCollection. The query string should be in the format of \"key1=value1&key2=value2\". public void ImportQueryString(string queryString) Parameters queryString string The query string containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.IsReadOnly.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsReadOnly Gets a value indicating whether the StringKeyStoreCollection is read-only. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Item.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Entity Assembly Sisk.Core.dll this[string] Gets or sets the array of values associated with the specified key. Returns null if the key does not exist in the store. public string? this[string key] { get; set; } Parameters key string Property Value string"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Keys.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Keys Gets the collection of keys in the StringKeyStoreCollection. public ICollection<string> Keys { get; } Property Value ICollection<string>"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.MakeReadOnly.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.MakeReadOnly.html",
    "title": "Method MakeReadOnly | Sisk",
    "keywords": "Method MakeReadOnly Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MakeReadOnly() Marks the StringKeyStoreCollection as read-only, preventing further modifications. public void MakeReadOnly()"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Remove.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Remove(string) Removes the value associated with the specified key from the StringKeyStoreCollection. Throws an exception if the store is read-only. public bool Remove(string key) Parameters key string The key of the value to remove. Returns bool true if the key was successfully removed; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Set.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Set.html",
    "title": "Method Set | Sisk",
    "keywords": "Method Set Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Set(KeyValuePair<string, string[]>) Sets the value associated with the specified key, replacing any existing values. public void Set(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> The key-value pair to add, where the key is associated with an array of values. Set(string, string) Sets the value associated with the specified key, replacing any existing values. public void Set(string key, string value) Parameters key string The key for which to set the value. value string The value to associate with the key. Set(string, IEnumerable<string>) Sets the collection of values associated with the specified key, replacing any existing values. public void Set(string key, IEnumerable<string> value) Parameters key string The key for which to set the values. value IEnumerable<string> The collection of values to associate with the key."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.SetRange.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.SetRange.html",
    "title": "Method SetRange | Sisk",
    "keywords": "Method SetRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll SetRange(IEnumerable<KeyValuePair<string, string[]>>) Sets the elements of the specified collection, replacing existing values. public void SetRange(IEnumerable<KeyValuePair<string, string[]>> items) Parameters items IEnumerable<KeyValuePair<string, string[]>> The collection whose items should be replaced or added to this collection."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.ToString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ToString() Returns a string that represents the current object. public override string ToString() Returns string A string that represents the current object. ToString(IFormatProvider?) Returns a string that represents the current object, using the specified format provider. public string ToString(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The format provider to use when formatting the string. If null, the current culture is used. Returns string A string that represents the current object, formatted using the specified format provider."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out string[]) Tries to get the array of values associated with the specified key. public bool TryGetValue(string key, out string[] value) Parameters key string The key for which to retrieve the values. value string[] When this method returns, contains the array of values associated with the specified key, or an empty array if the key is not found. Returns bool true if the key was found and the values were retrieved; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.Values.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Values Gets the collection of values in the StringKeyStoreCollection as arrays. Each key may have multiple associated values. public ICollection<string[]> Values { get; } Property Value ICollection<string[]>"
  },
  "api/Sisk.Core.Entity.StringKeyStoreCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStoreCollection.html",
    "title": "Class StringKeyStoreCollection | Sisk",
    "keywords": "Class StringKeyStoreCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents a collection of string keys associated with multiple string values. public class StringKeyStoreCollection : IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStoreCollection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Derived HttpHeaderCollection StringValueCollection Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors StringKeyStoreCollection() Initializes a new instance of the StringKeyStoreCollection class, StringKeyStoreCollection(IEqualityComparer<string>) Initializes a new instance of the StringKeyStoreCollection class with a specified comparer. StringKeyStoreCollection(IEqualityComparer<string>, IDictionary<string, string[]>?) Initializes a new instance of the StringKeyStoreCollection class, Properties Comparer Gets the IEqualityComparer<T> used to compare keys in this StringKeyStoreCollection. Count Gets the number of key-value pairs in the StringKeyStoreCollection. IsReadOnly Gets a value indicating whether the StringKeyStoreCollection is read-only. this[string] Gets or sets the array of values associated with the specified key. Returns null if the key does not exist in the store. Keys Gets the collection of keys in the StringKeyStoreCollection. Values Gets the collection of values in the StringKeyStoreCollection as arrays. Each key may have multiple associated values. Methods Add(KeyValuePair<string, string[]>) Adds a key-value pair to the StringKeyStoreCollection. Add(string, IEnumerable<string>) Adds a collection of values associated with the specified key. Add(string, string) Adds a single value associated with the specified key. Add(string, string[]) Adds an array of values associated with the specified key. AddRange(IEnumerable<KeyValuePair<string, string[]>>) Adds the elements of the specified collection to the end of this collection. AddRange(IEnumerable<KeyValuePair<string, string?>>) Adds the elements of the specified collection to the end of this collection. AsDictionary() Copies the contents of this StringKeyStoreCollection into an Dictionary<TKey, TValue>. AsNameValueCollection() Copies the contents of this StringKeyStoreCollection into an NameValueCollection, with values separated with an comma (,). AsStringValueCollection() Copies the contents of this StringKeyStoreCollection into an StringValueCollection. Clear() Removes all key-value pairs from the StringKeyStoreCollection. Throws an exception if the store is read-only. ContainsKey(string) Determines whether the StringKeyStoreCollection contains a specific key. FromCookieString(string) Creates a new instance of the StringKeyStoreCollection from a cookie string. The query string should be in the format of \"key1=value1; key2=value2\". FromNameValueCollection(NameValueCollection) Creates a new instance of the StringKeyStoreCollection from a NameValueCollection. FromQueryString(string) Creates a new instance of the StringKeyStoreCollection from a query string. The query string should be in the format of \"key1=value1&key2=value2\". GetEnumerator() GetValue(string) Retrieves the last value associated with the specified key. Returns null if the key does not exist. GetValues(string) Retrieves all values associated with the specified key. Returns an empty array if the key does not exist. ImportCookieString(string) Imports key-value pairs from a cookie string into the StringKeyStoreCollection. The query string should be in the format of \"key1=value1; key2=value2\". ImportNameValueCollection(NameValueCollection) Imports key-value pairs from a NameValueCollection into the StringKeyStoreCollection. Each key can have multiple associated values. ImportQueryString(string) Imports key-value pairs from a query string into the StringKeyStoreCollection. The query string should be in the format of \"key1=value1&key2=value2\". MakeReadOnly() Marks the StringKeyStoreCollection as read-only, preventing further modifications. Remove(string) Removes the value associated with the specified key from the StringKeyStoreCollection. Throws an exception if the store is read-only. Set(KeyValuePair<string, string[]>) Sets the value associated with the specified key, replacing any existing values. Set(string, IEnumerable<string>) Sets the collection of values associated with the specified key, replacing any existing values. Set(string, string) Sets the value associated with the specified key, replacing any existing values. SetRange(IEnumerable<KeyValuePair<string, string[]>>) Sets the elements of the specified collection, replacing existing values. ToString() Returns a string that represents the current object. ToString(IFormatProvider?) Returns a string that represents the current object, using the specified format provider. TryGetValue(string, out string[]) Tries to get the array of values associated with the specified key."
  },
  "api/Sisk.Core.Entity.StringValue.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringValue.-ctor.html",
    "title": "Constructor StringValue | Sisk",
    "keywords": "Constructor StringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringValue(string) Creates an new empty value of the StringValue with no predefined value. public StringValue(string name) Parameters name string The StringValue name. StringValue(string, string?) Creates an new value of the StringValue. public StringValue(string name, string? value) Parameters name string The StringValue name. value string The StringValue value."
  },
  "api/Sisk.Core.Entity.StringValue.Clone.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Clone.html",
    "title": "Method Clone | Sisk",
    "keywords": "Method Clone Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Clone() public object Clone() Returns object"
  },
  "api/Sisk.Core.Entity.StringValue.CompareTo.html": {
    "href": "api/Sisk.Core.Entity.StringValue.CompareTo.html",
    "title": "Method CompareTo | Sisk",
    "keywords": "Method CompareTo Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CompareTo(StringValue, in StringComparison) Compares the current object with another object of the same type, using the specified string comparison. public int CompareTo(StringValue other, in StringComparison stringComparison) Parameters other StringValue The object to compare with the current object. stringComparison StringComparison One of the StringComparison values that specifies the comparison rules to use. Returns int A value that indicates the relative order of the objects being compared. See Also StringComparison"
  },
  "api/Sisk.Core.Entity.StringValue.Create.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Create(string?) Creates an new StringValue from the specified string. public static StringValue Create(string? value) Parameters value string The string value. Returns StringValue"
  },
  "api/Sisk.Core.Entity.StringValue.Get.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Get<T>(IFormatProvider?) Parses the value contained in this StringValue as a type T that implements IParsable<TSelf>. Throws an exception if the value couldn't be parsed to the target type. public T Get<T>(IFormatProvider? formatProvider = null) where T : IParsable<T> Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns T The converted value of type T. Type Parameters T The type to parse the value to. Exceptions FormatException Thrown when the value cannot be parsed to type T."
  },
  "api/Sisk.Core.Entity.StringValue.GetBoolean.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetBoolean.html",
    "title": "Method GetBoolean | Sisk",
    "keywords": "Method GetBoolean Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetBoolean() Parses the value contained in this StringValue as a bool. Throws an exception if the value couldn't be parsed to the target type. public bool GetBoolean() Returns bool The converted bool. Exceptions FormatException Thrown when the value cannot be parsed to a bool."
  },
  "api/Sisk.Core.Entity.StringValue.GetByte.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetByte.html",
    "title": "Method GetByte | Sisk",
    "keywords": "Method GetByte Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetByte(IFormatProvider?) Parses the value contained in this StringValue as a byte. Throws an exception if the value couldn't be parsed to the target type. public int GetByte(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns int The converted byte. Exceptions FormatException Thrown when the value cannot be parsed to a byte."
  },
  "api/Sisk.Core.Entity.StringValue.GetChar.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetChar.html",
    "title": "Method GetChar | Sisk",
    "keywords": "Method GetChar Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetChar() Parses the value contained in this StringValue as a char. Throws an exception if the value couldn't be parsed to the target type. public char GetChar() Returns char The converted char."
  },
  "api/Sisk.Core.Entity.StringValue.GetDateTime.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetDateTime.html",
    "title": "Method GetDateTime | Sisk",
    "keywords": "Method GetDateTime Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetDateTime(IFormatProvider?) Parses the value contained in this StringValue as a DateTime. Throws an exception if the value couldn't be parsed to the target type. public DateTime GetDateTime(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns DateTime The converted DateTime. Exceptions FormatException Thrown when the value cannot be parsed to a DateTime."
  },
  "api/Sisk.Core.Entity.StringValue.GetDecimal.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetDecimal.html",
    "title": "Method GetDecimal | Sisk",
    "keywords": "Method GetDecimal Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetDecimal(IFormatProvider?) Parses the value contained in this StringValue as a decimal. Throws an exception if the value couldn't be parsed to the target type. public decimal GetDecimal(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns decimal The converted decimal. Exceptions FormatException Thrown when the value cannot be parsed to a decimal."
  },
  "api/Sisk.Core.Entity.StringValue.GetDouble.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetDouble.html",
    "title": "Method GetDouble | Sisk",
    "keywords": "Method GetDouble Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetDouble(IFormatProvider?) Parses the value contained in this StringValue as a double. Throws an exception if the value couldn't be parsed to the target type. public double GetDouble(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns double The converted double. Exceptions FormatException Thrown when the value cannot be parsed to a double."
  },
  "api/Sisk.Core.Entity.StringValue.GetEnum.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetEnum.html",
    "title": "Method GetEnum | Sisk",
    "keywords": "Method GetEnum Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnum<TEnum>() Gets an Enum object representation from this StringValue, parsing the current string expression into an value of TEnum. This method will throw an NullReferenceException if the value stored in this instance is null. public TEnum GetEnum<TEnum>() where TEnum : struct, Enum Returns TEnum Type Parameters TEnum The Enum type."
  },
  "api/Sisk.Core.Entity.StringValue.GetGuid.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetGuid.html",
    "title": "Method GetGuid | Sisk",
    "keywords": "Method GetGuid Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetGuid(IFormatProvider?) Parses the value contained in this StringValue as a Guid. Throws an exception if the value couldn't be parsed to the target type. public Guid GetGuid(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns Guid The converted Guid. Exceptions FormatException Thrown when the value cannot be parsed to a Guid."
  },
  "api/Sisk.Core.Entity.StringValue.GetInteger.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetInteger.html",
    "title": "Method GetInteger | Sisk",
    "keywords": "Method GetInteger Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetInteger(IFormatProvider?) Parses the value contained in this StringValue as an int. Throws an exception if the value couldn't be parsed to the target type. public int GetInteger(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns int The converted int. Exceptions FormatException Thrown when the value cannot be parsed to an int."
  },
  "api/Sisk.Core.Entity.StringValue.GetLong.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetLong.html",
    "title": "Method GetLong | Sisk",
    "keywords": "Method GetLong Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetLong(IFormatProvider?) Parses the value contained in this StringValue as a long. Throws an exception if the value couldn't be parsed to the target type. public long GetLong(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns long The converted long. Exceptions FormatException Thrown when the value cannot be parsed to a long."
  },
  "api/Sisk.Core.Entity.StringValue.GetShort.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetShort.html",
    "title": "Method GetShort | Sisk",
    "keywords": "Method GetShort Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetShort(IFormatProvider?) Parses the value contained in this StringValue as a short. Throws an exception if the value couldn't be parsed to the target type. public short GetShort(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns short The converted short. Exceptions FormatException Thrown when the value cannot be parsed to a short."
  },
  "api/Sisk.Core.Entity.StringValue.GetSingle.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetSingle.html",
    "title": "Method GetSingle | Sisk",
    "keywords": "Method GetSingle Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetSingle(IFormatProvider?) Parses the value contained in this StringValue as a float. Throws an exception if the value couldn't be parsed to the target type. public float GetSingle(IFormatProvider? formatProvider = null) Parameters formatProvider IFormatProvider The IFormatProvider to use for parsing. Defaults to null. Returns float The converted float. Exceptions FormatException Thrown when the value cannot be parsed to a float."
  },
  "api/Sisk.Core.Entity.StringValue.GetString.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetString.html",
    "title": "Method GetString | Sisk",
    "keywords": "Method GetString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetString() Gets a non-null string from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. public string GetString() Returns string An non-null string value. Exceptions NullReferenceException Thrown when the value stored in this instance is null."
  },
  "api/Sisk.Core.Entity.StringValue.IsNull.html": {
    "href": "api/Sisk.Core.Entity.StringValue.IsNull.html",
    "title": "Property IsNull | Sisk",
    "keywords": "Property IsNull Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsNull Gets an boolean indicating if this object value is null. public bool IsNull { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringValue.IsNullOrEmpty.html": {
    "href": "api/Sisk.Core.Entity.StringValue.IsNullOrEmpty.html",
    "title": "Property IsNullOrEmpty | Sisk",
    "keywords": "Property IsNullOrEmpty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsNullOrEmpty Gets an boolean indicating if this object value is null or an empty string. public bool IsNullOrEmpty { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringValue.MaybeNull.html": {
    "href": "api/Sisk.Core.Entity.StringValue.MaybeNull.html",
    "title": "Method MaybeNull | Sisk",
    "keywords": "Method MaybeNull Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaybeNull() Returns a self-reference to this object when it's value is not null. public StringValue? MaybeNull() Returns StringValue?"
  },
  "api/Sisk.Core.Entity.StringValue.MaybeNullOrEmpty.html": {
    "href": "api/Sisk.Core.Entity.StringValue.MaybeNullOrEmpty.html",
    "title": "Method MaybeNullOrEmpty | Sisk",
    "keywords": "Method MaybeNullOrEmpty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaybeNullOrEmpty() Returns a self-reference to this object when it's value is not null or an empty string. public StringValue? MaybeNullOrEmpty() Returns StringValue?"
  },
  "api/Sisk.Core.Entity.StringValue.Name.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Name Gets the name of the property that hosts this StringValue. public string Name { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.StringValue.Value.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Value.html",
    "title": "Property Value | Sisk",
    "keywords": "Property Value Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Value Gets the value of the current StringValue string if it has been assigned a valid underlying value. public string? Value { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.StringValue.html": {
    "href": "api/Sisk.Core.Entity.StringValue.html",
    "title": "Struct StringValue | Sisk",
    "keywords": "Struct StringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an option/monad item that wraps an string value and allows conversion to most common types. public readonly struct StringValue : ICloneable, IEquatable<StringValue>, IComparable<StringValue> Implements ICloneable IEquatable<StringValue> IComparable<StringValue> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors StringValue(string) Creates an new empty value of the StringValue with no predefined value. StringValue(string, string?) Creates an new value of the StringValue. Properties IsNull Gets an boolean indicating if this object value is null. IsNullOrEmpty Gets an boolean indicating if this object value is null or an empty string. Name Gets the name of the property that hosts this StringValue. Value Gets the value of the current StringValue string if it has been assigned a valid underlying value. Methods Clone() CompareTo(StringValue, in StringComparison) Compares the current object with another object of the same type, using the specified string comparison. Create(string?) Creates an new StringValue from the specified string. GetBoolean() Parses the value contained in this StringValue as a bool. Throws an exception if the value couldn't be parsed to the target type. GetByte(IFormatProvider?) Parses the value contained in this StringValue as a byte. Throws an exception if the value couldn't be parsed to the target type. GetChar() Parses the value contained in this StringValue as a char. Throws an exception if the value couldn't be parsed to the target type. GetDateTime(IFormatProvider?) Parses the value contained in this StringValue as a DateTime. Throws an exception if the value couldn't be parsed to the target type. GetDecimal(IFormatProvider?) Parses the value contained in this StringValue as a decimal. Throws an exception if the value couldn't be parsed to the target type. GetDouble(IFormatProvider?) Parses the value contained in this StringValue as a double. Throws an exception if the value couldn't be parsed to the target type. GetEnum<TEnum>() Gets an Enum object representation from this StringValue, parsing the current string expression into an value of TEnum. This method will throw an NullReferenceException if the value stored in this instance is null. GetGuid(IFormatProvider?) Parses the value contained in this StringValue as a Guid. Throws an exception if the value couldn't be parsed to the target type. GetInteger(IFormatProvider?) Parses the value contained in this StringValue as an int. Throws an exception if the value couldn't be parsed to the target type. GetLong(IFormatProvider?) Parses the value contained in this StringValue as a long. Throws an exception if the value couldn't be parsed to the target type. GetShort(IFormatProvider?) Parses the value contained in this StringValue as a short. Throws an exception if the value couldn't be parsed to the target type. GetSingle(IFormatProvider?) Parses the value contained in this StringValue as a float. Throws an exception if the value couldn't be parsed to the target type. GetString() Gets a non-null string from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. Get<T>(IFormatProvider?) Parses the value contained in this StringValue as a type T that implements IParsable<TSelf>. Throws an exception if the value couldn't be parsed to the target type. MaybeNull() Returns a self-reference to this object when it's value is not null. MaybeNullOrEmpty() Returns a self-reference to this object when it's value is not null or an empty string."
  },
  "api/Sisk.Core.Entity.StringValueCollection.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.-ctor.html",
    "title": "Constructor StringValueCollection | Sisk",
    "keywords": "Constructor StringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringValueCollection(IDictionary<string, string?>) Creates an new StringValueCollection instance with values from another IDictionary instance. public StringValueCollection(IDictionary<string, string?> values) Parameters values IDictionary<string, string> StringValueCollection(IDictionary<string, string[]>) Creates an new StringValueCollection instance with values from another IDictionary instance. public StringValueCollection(IDictionary<string, string[]> values) Parameters values IDictionary<string, string[]> StringValueCollection() Creates an new empty StringValueCollection. public StringValueCollection()"
  },
  "api/Sisk.Core.Entity.StringValueCollection.GetItem.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.GetItem.html",
    "title": "Method GetItem | Sisk",
    "keywords": "Method GetItem Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItem(string) Gets an StringValue from their key name. If the object was not found by their name, an empty non-null StringValue with no value is returned. public StringValue GetItem(string name) Parameters name string Returns StringValue"
  },
  "api/Sisk.Core.Entity.StringValueCollection.GetItems.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.GetItems.html",
    "title": "Method GetItems | Sisk",
    "keywords": "Method GetItems Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItems(string) Gets an array of StringValue from their key name. If the object was not found by their name, an empty array of StringValue is returned. public StringValue[] GetItems(string name) Parameters name string Returns StringValue[]"
  },
  "api/Sisk.Core.Entity.StringValueCollection.Item.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Entity Assembly Sisk.Core.dll this[string] Gets or sets an StringValue item by their key name. public StringValue this[string name] { get; set; } Parameters name string Property Value StringValue"
  },
  "api/Sisk.Core.Entity.StringValueCollection.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out StringValue) Tries to get the last StringValue associated with the specified key. public bool TryGetValue(string key, out StringValue value) Parameters key string The key for which to retrieve the values. value StringValue When this method returns, the StringValue containing the value, or empty StringValue. Returns bool true if the key was found; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.html",
    "title": "Class StringValueCollection | Sisk",
    "keywords": "Class StringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an collection of StringValue. public sealed class StringValueCollection : StringKeyStoreCollection, IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStoreCollection StringValueCollection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members StringKeyStoreCollection.FromQueryString(string) StringKeyStoreCollection.FromCookieString(string) StringKeyStoreCollection.FromNameValueCollection(NameValueCollection) StringKeyStoreCollection.ImportNameValueCollection(NameValueCollection) StringKeyStoreCollection.ImportQueryString(string) StringKeyStoreCollection.ImportCookieString(string) StringKeyStoreCollection.Add(string, string[]) StringKeyStoreCollection.Add(string, IEnumerable<string>) StringKeyStoreCollection.Add(string, string) StringKeyStoreCollection.Add(KeyValuePair<string, string[]>) StringKeyStoreCollection.AddRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStoreCollection.AddRange(IEnumerable<KeyValuePair<string, string>>) StringKeyStoreCollection.SetRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStoreCollection.Set(KeyValuePair<string, string[]>) StringKeyStoreCollection.Set(string, string) StringKeyStoreCollection.Set(string, IEnumerable<string>) StringKeyStoreCollection.GetValue(string) StringKeyStoreCollection.GetValues(string) StringKeyStoreCollection.Clear() StringKeyStoreCollection.Remove(string) StringKeyStoreCollection.MakeReadOnly() StringKeyStoreCollection.ContainsKey(string) StringKeyStoreCollection.GetEnumerator() StringKeyStoreCollection.TryGetValue(string, out string[]) StringKeyStoreCollection.AsDictionary() StringKeyStoreCollection.AsNameValueCollection() StringKeyStoreCollection.AsStringValueCollection() StringKeyStoreCollection.ToString() StringKeyStoreCollection.ToString(IFormatProvider) StringKeyStoreCollection.Comparer StringKeyStoreCollection.Keys StringKeyStoreCollection.Values StringKeyStoreCollection.Count StringKeyStoreCollection.IsReadOnly object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors StringValueCollection() Creates an new empty StringValueCollection. StringValueCollection(IDictionary<string, string[]>) Creates an new StringValueCollection instance with values from another IDictionary instance. StringValueCollection(IDictionary<string, string?>) Creates an new StringValueCollection instance with values from another IDictionary instance. Properties this[string] Gets or sets an StringValue item by their key name. Methods GetItem(string) Gets an StringValue from their key name. If the object was not found by their name, an empty non-null StringValue with no value is returned. GetItems(string) Gets an array of StringValue from their key name. If the object was not found by their name, an empty array of StringValue is returned. TryGetValue(string, out StringValue) Tries to get the last StringValue associated with the specified key."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.-ctor.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.-ctor.html",
    "title": "Constructor TypedValueDictionary | Sisk",
    "keywords": "Constructor TypedValueDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TypedValueDictionary() Creates an new TypedValueDictionary instance with default parameters. public TypedValueDictionary() TypedValueDictionary(StringComparer) Creates an new TypedValueDictionary instance with default parameters with the specified StringComparer. public TypedValueDictionary(StringComparer keyComparer) Parameters keyComparer StringComparer"
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Get.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Get<T>() Gets a singleton previously defined in this context bag via it's type T. public T Get<T>() where T : notnull Returns T Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAdd.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAdd.html",
    "title": "Method GetOrAdd | Sisk",
    "keywords": "Method GetOrAdd Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrAdd<T>(Func<T>) Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided getter function. public T GetOrAdd<T>(Func<T> getter) where T : notnull Parameters getter Func<T> A function that provides the object to be added if it does not exist. Returns T The object of type T from the context bag. Type Parameters T The type of the object defined in this context bag. GetOrAdd<T>() Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag by creating a new instance of T. public T GetOrAdd<T>() where T : notnull, new() Returns T The object of type T from the context bag. Type Parameters T The type of the object defined in this context bag. It must have a public parameterless constructor."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAddAsync.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAddAsync.html",
    "title": "Method GetOrAddAsync | Sisk",
    "keywords": "Method GetOrAddAsync Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrAddAsync<T>(Func<Task<T>>) Asynchronously gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided asynchronous getter function. public Task<T> GetOrAddAsync<T>(Func<Task<T>> getter) where T : notnull Parameters getter Func<Task<T>> An asynchronous function that provides the object to be added if it does not exist. Returns Task<T> A task that represents the asynchronous operation. The task result contains the object of type T from the context bag. Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrDefault.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrDefault.html",
    "title": "Method GetOrDefault | Sisk",
    "keywords": "Method GetOrDefault Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrDefault<T>() Gets a singleton previously defined in this context bag via its type T. Returns the default value if the object is not defined. public T? GetOrDefault<T>() where T : notnull Returns T The object of type T if it exists; otherwise, null. Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetTypeKeyName.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetTypeKeyName.html",
    "title": "Method GetTypeKeyName | Sisk",
    "keywords": "Method GetTypeKeyName Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetTypeKeyName(Type) Gets the Type full qualified key name. protected string GetTypeKeyName(Type t) Parameters t Type The type to get their qualified key name. Returns string"
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.IsSet.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.IsSet.html",
    "title": "Method IsSet | Sisk",
    "keywords": "Method IsSet Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsSet<T>() Determines whether the specified T singleton is defined in this context. public bool IsSet<T>() where T : notnull Returns bool Type Parameters T The singleton type. IsSet<T>(out T) Determines whether the specified T singleton is defined in this context and tries to output it. public bool IsSet<T>(out T value) where T : notnull Parameters value T When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized. Returns bool True if the object is find with the specified key; otherwise, false. Type Parameters T The singleton type."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Set.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Set.html",
    "title": "Method Set | Sisk",
    "keywords": "Method Set Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Set<T>() Creates and adds an singleton of T in this context bag. public T Set<T>() where T : notnull, new() Returns T Type Parameters T The object that will be defined in this context bag. Set<T>(T) Adds an singleton of T in this context bag. public T Set<T>(T value) where T : notnull Parameters value T The instance of T which will be defined in this context bag. Returns T Type Parameters T The object that will be defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue<TResult>(string, out TResult?) Gets the value associated with the specified key and casts it into TResult. public bool TryGetValue<TResult>(string key, out TResult? value) Parameters key string The key whose to get. value TResult When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized. Returns bool true if the object is find with the specified key; otherwise, false. Type Parameters TResult The type which will be casted into."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Unset.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Unset.html",
    "title": "Method Unset | Sisk",
    "keywords": "Method Unset Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Unset<T>() Removes an singleton object from it's type T. public bool Unset<T>() where T : notnull Returns bool Type Parameters T The singleton type."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.html",
    "title": "Class TypedValueDictionary | Sisk",
    "keywords": "Class TypedValueDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents the base class for storing and retriving data by their type. public class TypedValueDictionary : IDictionary<string, object?>, ICollection<KeyValuePair<string, object?>>, IEnumerable<KeyValuePair<string, object?>>, IEnumerable Inheritance object TypedValueDictionary Implements IDictionary<string, object> ICollection<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors TypedValueDictionary() Creates an new TypedValueDictionary instance with default parameters. TypedValueDictionary(StringComparer) Creates an new TypedValueDictionary instance with default parameters with the specified StringComparer. Methods GetOrAddAsync<T>(Func<Task<T>>) Asynchronously gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided asynchronous getter function. GetOrAdd<T>() Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag by creating a new instance of T. GetOrAdd<T>(Func<T>) Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided getter function. GetOrDefault<T>() Gets a singleton previously defined in this context bag via its type T. Returns the default value if the object is not defined. GetTypeKeyName(Type) Gets the Type full qualified key name. Get<T>() Gets a singleton previously defined in this context bag via it's type T. IsSet<T>() Determines whether the specified T singleton is defined in this context. IsSet<T>(out T) Determines whether the specified T singleton is defined in this context and tries to output it. Set<T>() Creates and adds an singleton of T in this context bag. Set<T>(T) Adds an singleton of T in this context bag. TryGetValue<TResult>(string, out TResult?) Gets the value associated with the specified key and casts it into TResult. Unset<T>() Removes an singleton object from it's type T."
  },
  "api/Sisk.Core.Entity.html": {
    "href": "api/Sisk.Core.Entity.html",
    "title": "Namespace Sisk.Core.Entity | Sisk",
    "keywords": "Namespace Sisk.Core.Entity Classes CrossOriginResourceSharingHeaders Provides a class to provide Cross Origin response headers for when communicating with a browser. HttpHeaderCollection Represents an collection of HTTP headers with their name and values. MultipartFormCollection Represents an class which hosts an multipart form data contents. MultipartObject Represents an multipart/form-data object. StringKeyStoreCollection Represents a collection of string keys associated with multiple string values. StringValueCollection Represents an collection of StringValue. TypedValueDictionary Represents the base class for storing and retriving data by their type. Structs StringValue Represents an option/monad item that wraps an string value and allows conversion to most common types. Enums MultipartObjectCommonFormat Represents an image format for Multipart objects."
  },
  "api/Sisk.Core.Helpers.CookieHelper.BuildCookieHeaderValue.html": {
    "href": "api/Sisk.Core.Helpers.CookieHelper.BuildCookieHeaderValue.html",
    "title": "Method BuildCookieHeaderValue | Sisk",
    "keywords": "Method BuildCookieHeaderValue Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll BuildCookieHeaderValue(Cookie) Builds the cookie header value and returns an string from it. public static string BuildCookieHeaderValue(Cookie cookie) Parameters cookie Cookie The Cookie instance to build the cookie string. Returns string BuildCookieHeaderValue(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Builds the cookie header value and returns an string from it. public static string BuildCookieHeaderValue(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter. Returns string"
  },
  "api/Sisk.Core.Helpers.CookieHelper.html": {
    "href": "api/Sisk.Core.Helpers.CookieHelper.html",
    "title": "Class CookieHelper | Sisk",
    "keywords": "Class CookieHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides a class that contains useful methods for working with cookies in HTTP responses. public static class CookieHelper Inheritance object CookieHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods BuildCookieHeaderValue(Cookie) Builds the cookie header value and returns an string from it. BuildCookieHeaderValue(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Builds the cookie header value and returns an string from it."
  },
  "api/Sisk.Core.Helpers.HeaderHelper.CopyHttpHeaders.html": {
    "href": "api/Sisk.Core.Helpers.HeaderHelper.CopyHttpHeaders.html",
    "title": "Method CopyHttpHeaders | Sisk",
    "keywords": "Method CopyHttpHeaders Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll CopyHttpHeaders(HttpContentHeaders, HttpContentHeaders, bool) Copies HTTP headers from one HttpContentHeaders instance to another. public static void CopyHttpHeaders(HttpContentHeaders from, HttpContentHeaders to, bool safe = true) Parameters from HttpContentHeaders The source HttpContentHeaders instance. to HttpContentHeaders The target HttpContentHeaders instance. safe bool If set to true, headers that are added will be validated (an exception can be throw if an header is invalid). If false, invalid headers could be discarded, but no exception is thrown."
  },
  "api/Sisk.Core.Helpers.HeaderHelper.html": {
    "href": "api/Sisk.Core.Helpers.HeaderHelper.html",
    "title": "Class HeaderHelper | Sisk",
    "keywords": "Class HeaderHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides helper methods for working with HTTP headers. public static class HeaderHelper Inheritance object HeaderHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods CopyHttpHeaders(HttpContentHeaders, HttpContentHeaders, bool) Copies HTTP headers from one HttpContentHeaders instance to another."
  },
  "api/Sisk.Core.Helpers.MimeHelper.DefaultMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.DefaultMimeType.html",
    "title": "Property DefaultMimeType | Sisk",
    "keywords": "Property DefaultMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll DefaultMimeType Gets or sets the MimeHelper default fallback mime-type. public static string DefaultMimeType { get; set; } Property Value string Remarks This property is not used by the HTTP server itself, only this helper class."
  },
  "api/Sisk.Core.Helpers.MimeHelper.GetMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.GetMimeType.html",
    "title": "Method GetMimeType | Sisk",
    "keywords": "Method GetMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll GetMimeType(string, string?) Gets the content mime-type from the specified file extension. public static string GetMimeType(string fileExtension, string? fallback = null) Parameters fileExtension string The file extension, with or without the initial dot. fallback string Optional. The default mime-type when the file best mime-type is not found. If this argument is null, DefaultMimeType is used. Returns string The best matched mime-type, or the default if no mime-type was matched with the specified extension."
  },
  "api/Sisk.Core.Helpers.MimeHelper.IsBrowserKnownInlineMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.IsBrowserKnownInlineMimeType.html",
    "title": "Method IsBrowserKnownInlineMimeType | Sisk",
    "keywords": "Method IsBrowserKnownInlineMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll IsBrowserKnownInlineMimeType(string) Determines whether the specified mime-type is considered an inline content type that can be displayed directly in most browsers. public static bool IsBrowserKnownInlineMimeType(string mimeType) Parameters mimeType string The mime-type to evaluate. Returns bool true if the content type is an inline content type; otherwise, false."
  },
  "api/Sisk.Core.Helpers.MimeHelper.IsPlainTextFile.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.IsPlainTextFile.html",
    "title": "Method IsPlainTextFile | Sisk",
    "keywords": "Method IsPlainTextFile Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll IsPlainTextFile(string) Gets an boolean indicating if the specified file is an well-known plain text file. public static bool IsPlainTextFile(string fileExtension) Parameters fileExtension string The file extension, with or without the initial dot. Returns bool"
  },
  "api/Sisk.Core.Helpers.MimeHelper.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.html",
    "title": "Class MimeHelper | Sisk",
    "keywords": "Class MimeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful helper methods for resolving mime-types from common formats. public static class MimeHelper Inheritance object MimeHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DefaultMimeType Gets or sets the MimeHelper default fallback mime-type. Methods GetMimeType(string, string?) Gets the content mime-type from the specified file extension. IsBrowserKnownInlineMimeType(string) Determines whether the specified mime-type is considered an inline content type that can be displayed directly in most browsers. IsPlainTextFile(string) Gets an boolean indicating if the specified file is an well-known plain text file."
  },
  "api/Sisk.Core.Helpers.PathHelper.-ctor.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.-ctor.html",
    "title": "Constructor PathHelper | Sisk",
    "keywords": "Constructor PathHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll PathHelper() public PathHelper()"
  },
  "api/Sisk.Core.Helpers.PathHelper.CombinePaths.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.CombinePaths.html",
    "title": "Method CombinePaths | Sisk",
    "keywords": "Method CombinePaths Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll CombinePaths(params string[]) Combines the specified URL paths into one. public static string CombinePaths(params string[] paths) Parameters paths string[] The string array which contains parts that will be combined. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.FilesystemCombinePaths.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.FilesystemCombinePaths.html",
    "title": "Method FilesystemCombinePaths | Sisk",
    "keywords": "Method FilesystemCombinePaths Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll FilesystemCombinePaths(bool, char, params string[]) Normalizes and combines the specified file-system paths into one. public static string FilesystemCombinePaths(bool allowRelativeReturn, char separator, params string[] paths) Parameters allowRelativeReturn bool Specifies if relative paths should be merged and \"..\" returns should be respected. separator char Specifies the path separator character. paths string[] Specifies the array of paths to combine. Returns string FilesystemCombinePaths(bool, char, ReadOnlySpan<string>) Normalizes and combines the specified file-system paths into one. public static string FilesystemCombinePaths(bool allowRelativeReturn, char separator, ReadOnlySpan<string> paths) Parameters allowRelativeReturn bool Specifies if relative paths should be merged and \"..\" returns should be respected. separator char Specifies the path separator character. paths ReadOnlySpan<string> Specifies the array of paths to combine. Returns string FilesystemCombinePaths(params string[]) Normalizes and combines the specified file-system paths into one, using the default environment directory separator char. public static string FilesystemCombinePaths(params string[] paths) Parameters paths string[] Specifies the array of paths to combine. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.NormalizePath.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.NormalizePath.html",
    "title": "Method NormalizePath | Sisk",
    "keywords": "Method NormalizePath Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll NormalizePath(string, char) Normalize the given path to use the specified directory separator, trim the last separator and remove empty entries. public static string NormalizePath(string path, char directorySeparator = '/') Parameters path string The path to normalize. directorySeparator char The directory separator. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.html",
    "title": "Class PathHelper | Sisk",
    "keywords": "Class PathHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful path-dedicated helper members. public sealed class PathHelper Inheritance object PathHelper Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors PathHelper() Methods CombinePaths(params string[]) Combines the specified URL paths into one. FilesystemCombinePaths(bool, char, ReadOnlySpan<string>) Normalizes and combines the specified file-system paths into one. FilesystemCombinePaths(bool, char, params string[]) Normalizes and combines the specified file-system paths into one. FilesystemCombinePaths(params string[]) Normalizes and combines the specified file-system paths into one, using the default environment directory separator char. NormalizePath(string, char) Normalize the given path to use the specified directory separator, trim the last separator and remove empty entries."
  },
  "api/Sisk.Core.Helpers.SizeHelper.-ctor.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.-ctor.html",
    "title": "Constructor SizeHelper | Sisk",
    "keywords": "Constructor SizeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll SizeHelper() public SizeHelper()"
  },
  "api/Sisk.Core.Helpers.SizeHelper.HumanReadableSize.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.HumanReadableSize.html",
    "title": "Method HumanReadableSize | Sisk",
    "keywords": "Method HumanReadableSize Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll HumanReadableSize(long) Converts a byte count into a human-readable string representation. public static string HumanReadableSize(long byteCount) Parameters byteCount long The total number of bytes to convert. Returns string A string representing the byte count in a human-readable format. HumanReadableSize(double) Converts a byte count into a human-readable string representation. public static string HumanReadableSize(double byteCount) Parameters byteCount double The total number of bytes to convert. Returns string A string representing the byte count in a human-readable format."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitEb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitEb.html",
    "title": "Field UnitEb | Sisk",
    "keywords": "Field UnitEb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes. public const long UnitEb = 1152921504606846976 Returns long Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitGb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitGb.html",
    "title": "Field UnitGb | Sisk",
    "keywords": "Field UnitGb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes. public const long UnitGb = 1073741824 Returns long Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitKb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitKb.html",
    "title": "Field UnitKb | Sisk",
    "keywords": "Field UnitKb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes. public const long UnitKb = 1024 Returns long Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitMb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitMb.html",
    "title": "Field UnitMb | Sisk",
    "keywords": "Field UnitMb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes. public const long UnitMb = 1048576 Returns long Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitPb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitPb.html",
    "title": "Field UnitPb | Sisk",
    "keywords": "Field UnitPb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes. public const long UnitPb = 1125899906842624 Returns long Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitTb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitTb.html",
    "title": "Field UnitTb | Sisk",
    "keywords": "Field UnitTb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes. public const long UnitTb = 1099511627776 Returns long Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.html",
    "title": "Class SizeHelper | Sisk",
    "keywords": "Class SizeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful size-dedicated helper members. public sealed class SizeHelper Inheritance object SizeHelper Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SizeHelper() Fields UnitEb Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes. UnitGb Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes. UnitKb Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes. UnitMb Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes. UnitPb Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes. UnitTb Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes. Methods HumanReadableSize(double) Converts a byte count into a human-readable string representation. HumanReadableSize(long) Converts a byte count into a human-readable string representation."
  },
  "api/Sisk.Core.Helpers.html": {
    "href": "api/Sisk.Core.Helpers.html",
    "title": "Namespace Sisk.Core.Helpers | Sisk",
    "keywords": "Namespace Sisk.Core.Helpers Classes CookieHelper Provides a class that contains useful methods for working with cookies in HTTP responses. HeaderHelper Provides helper methods for working with HTTP headers. MimeHelper Provides useful helper methods for resolving mime-types from common formats. PathHelper Provides useful path-dedicated helper members. SizeHelper Provides useful size-dedicated helper members."
  },
  "api/Sisk.Core.Http.BrotliContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.-ctor.html",
    "title": "Constructor BrotliContent | Sisk",
    "keywords": "Constructor BrotliContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll BrotliContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public BrotliContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. BrotliContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public BrotliContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. BrotliContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public BrotliContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.BrotliContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.BrotliContent.Setup.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.BrotliContent.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.html",
    "title": "Class BrotliContent | Sisk",
    "keywords": "Class BrotliContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the Brotli algorithm. public sealed class BrotliContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent BrotliContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors BrotliContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. BrotliContent(Stream) Initializes a new instance of compressing stream with the specified stream content. BrotliContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.CompressedContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.-ctor.html",
    "title": "Constructor CompressedContent | Sisk",
    "keywords": "Constructor CompressedContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll CompressedContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public CompressedContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. CompressedContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public CompressedContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. CompressedContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public CompressedContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.CompressedContent.Dispose.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose(bool) protected override void Dispose(bool disposing) Parameters disposing bool"
  },
  "api/Sisk.Core.Http.CompressedContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public abstract Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.CompressedContent.InnerContent.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.InnerContent.html",
    "title": "Property InnerContent | Sisk",
    "keywords": "Property InnerContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll InnerContent Gets the inner HTTP content. public HttpContent InnerContent { get; } Property Value HttpContent"
  },
  "api/Sisk.Core.Http.CompressedContent.SerializeToStream.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.SerializeToStream.html",
    "title": "Method SerializeToStream | Sisk",
    "keywords": "Method SerializeToStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll SerializeToStream(Stream, TransportContext?, CancellationToken) protected override sealed void SerializeToStream(Stream stream, TransportContext? context, CancellationToken cancellationToken) Parameters stream Stream context TransportContext cancellationToken CancellationToken"
  },
  "api/Sisk.Core.Http.CompressedContent.SerializeToStreamAsync.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.SerializeToStreamAsync.html",
    "title": "Method SerializeToStreamAsync | Sisk",
    "keywords": "Method SerializeToStreamAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll SerializeToStreamAsync(Stream, TransportContext?) protected override sealed Task SerializeToStreamAsync(Stream stream, TransportContext? context) Parameters stream Stream context TransportContext Returns Task SerializeToStreamAsync(Stream, TransportContext?, CancellationToken) protected override sealed Task SerializeToStreamAsync(Stream stream, TransportContext? context, CancellationToken cancellationToken) Parameters stream Stream context TransportContext cancellationToken CancellationToken Returns Task"
  },
  "api/Sisk.Core.Http.CompressedContent.Setup.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public abstract void Setup()"
  },
  "api/Sisk.Core.Http.CompressedContent.TryComputeLength.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.TryComputeLength.html",
    "title": "Method TryComputeLength | Sisk",
    "keywords": "Method TryComputeLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll TryComputeLength(out long) protected override sealed bool TryComputeLength(out long length) Parameters length long Returns bool"
  },
  "api/Sisk.Core.Http.CompressedContent.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.html",
    "title": "Class CompressedContent | Sisk",
    "keywords": "Class CompressedContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents a base class for HTTP contents served over an compressing stream. public abstract class CompressedContent : HttpContent, IDisposable Inheritance object HttpContent CompressedContent Implements IDisposable Derived BrotliContent DeflateContent GZipContent Inherited Members HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.CreateContentReadStream(CancellationToken) HttpContent.CreateContentReadStreamAsync() HttpContent.CreateContentReadStreamAsync(CancellationToken) HttpContent.Dispose() HttpContent.Headers object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors CompressedContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. CompressedContent(Stream) Initializes a new instance of compressing stream with the specified stream content. CompressedContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Properties InnerContent Gets the inner HTTP content. Methods Dispose(bool) GetCompressingStream(Stream) Gets a stream that compresses the output stream. SerializeToStream(Stream, TransportContext?, CancellationToken) SerializeToStreamAsync(Stream, TransportContext?) SerializeToStreamAsync(Stream, TransportContext?, CancellationToken) Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. TryComputeLength(out long)"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultPageHtml.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultPageHtml.html",
    "title": "Method CreateDefaultPageHtml | Sisk",
    "keywords": "Method CreateDefaultPageHtml Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateDefaultPageHtml(string, string) Creates an static default page with given header and description. public static string CreateDefaultPageHtml(string firstHeader, string description) Parameters firstHeader string The static page header text. description string The static page description text. Returns string"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultResponse.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultResponse.html",
    "title": "Method CreateDefaultResponse | Sisk",
    "keywords": "Method CreateDefaultResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateDefaultResponse(in HttpStatusInformation, string) Creates an static default page with given status code and description. public static HttpResponse CreateDefaultResponse(in HttpStatusInformation status, string longDescription) Parameters status HttpStatusInformation The static page status code. longDescription string The static page description text. Returns HttpResponse"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.DefaultPageCSS.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.DefaultPageCSS.html",
    "title": "Property DefaultPageCSS | Sisk",
    "keywords": "Property DefaultPageCSS Namespace Sisk.Core.Http Assembly Sisk.Core.dll DefaultPageCSS Gets or sets the page CSS string used by the page code. public static string DefaultPageCSS { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.html",
    "title": "Class DefaultMessagePage | Sisk",
    "keywords": "Class DefaultMessagePage Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides methods for creating informative static pages used by Sisk. public static class DefaultMessagePage Inheritance object DefaultMessagePage Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DefaultPageCSS Gets or sets the page CSS string used by the page code. Methods CreateDefaultPageHtml(string, string) Creates an static default page with given header and description. CreateDefaultResponse(in HttpStatusInformation, string) Creates an static default page with given status code and description."
  },
  "api/Sisk.Core.Http.DeflateContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.-ctor.html",
    "title": "Constructor DeflateContent | Sisk",
    "keywords": "Constructor DeflateContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll DeflateContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public DeflateContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. DeflateContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public DeflateContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. DeflateContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public DeflateContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.DeflateContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.DeflateContent.Setup.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.DeflateContent.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.html",
    "title": "Class DeflateContent | Sisk",
    "keywords": "Class DeflateContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the Deflate algorithm. public sealed class DeflateContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent DeflateContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors DeflateContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. DeflateContent(Stream) Initializes a new instance of compressing stream with the specified stream content. DeflateContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.ForwardingResolver.-ctor.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.-ctor.html",
    "title": "Constructor ForwardingResolver | Sisk",
    "keywords": "Constructor ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForwardingResolver() protected ForwardingResolver()"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveClientAddress.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveClientAddress.html",
    "title": "Method OnResolveClientAddress | Sisk",
    "keywords": "Method OnResolveClientAddress Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveClientAddress(HttpRequest, IPEndPoint) Method that is called when resolving the IP address of the client in the request. public virtual IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. connectingEndpoint IPEndPoint The original connecting endpoint. Returns IPAddress"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveRequestHost.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveRequestHost.html",
    "title": "Method OnResolveRequestHost | Sisk",
    "keywords": "Method OnResolveRequestHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveRequestHost(HttpRequest, string) Method that is called when resolving the client request host. public virtual string OnResolveRequestHost(HttpRequest request, string requestedHost) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. requestedHost string The original requested host. Returns string"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveSecureConnection.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveSecureConnection.html",
    "title": "Method OnResolveSecureConnection | Sisk",
    "keywords": "Method OnResolveSecureConnection Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveSecureConnection(HttpRequest, bool) Method that is called when resolving whether the HTTP request is using HTTPS or HTTP. public virtual bool OnResolveSecureConnection(HttpRequest request, bool isSecure) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. isSecure bool The original security state of the request. Returns bool"
  },
  "api/Sisk.Core.Http.ForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.html",
    "title": "Class ForwardingResolver | Sisk",
    "keywords": "Class ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides HTTP forwarding resolving methods that can be used to resolving the client remote address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. public abstract class ForwardingResolver Inheritance object ForwardingResolver Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors ForwardingResolver() Methods OnResolveClientAddress(HttpRequest, IPEndPoint) Method that is called when resolving the IP address of the client in the request. OnResolveRequestHost(HttpRequest, string) Method that is called when resolving the client request host. OnResolveSecureConnection(HttpRequest, bool) Method that is called when resolving whether the HTTP request is using HTTPS or HTTP."
  },
  "api/Sisk.Core.Http.GZipContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.GZipContent.-ctor.html",
    "title": "Constructor GZipContent | Sisk",
    "keywords": "Constructor GZipContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GZipContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public GZipContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. GZipContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public GZipContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. GZipContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public GZipContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.GZipContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.GZipContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.GZipContent.Setup.html": {
    "href": "api/Sisk.Core.Http.GZipContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.GZipContent.html": {
    "href": "api/Sisk.Core.Http.GZipContent.html",
    "title": "Class GZipContent | Sisk",
    "keywords": "Class GZipContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the GZip algorithm. public sealed class GZipContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent GZipContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors GZipContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. GZipContent(Stream) Initializes a new instance of compressing stream with the specified stream content. GZipContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.-ctor.html",
    "title": "Constructor AsyncHttpServerHandler | Sisk",
    "keywords": "Constructor AsyncHttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll AsyncHttpServerHandler() protected AsyncHttpServerHandler()"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreated.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreated.html",
    "title": "Method OnContextBagCreated | Sisk",
    "keywords": "Method OnContextBagCreated Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. protected override sealed void OnContextBagCreated(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreatedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreatedAsync.html",
    "title": "Method OnContextBagCreatedAsync | Sisk",
    "keywords": "Method OnContextBagCreatedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreatedAsync(TypedValueDictionary) Method that is called when an HTTP context is created within an HttpRequest object. protected virtual Task OnContextBagCreatedAsync(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnException.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnException.html",
    "title": "Method OnException | Sisk",
    "keywords": "Method OnException Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected override sealed void OnException(Exception exception) Parameters exception Exception The exception object."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnExceptionAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnExceptionAsync.html",
    "title": "Method OnExceptionAsync | Sisk",
    "keywords": "Method OnExceptionAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnExceptionAsync(Exception) Method that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected virtual Task OnExceptionAsync(Exception exception) Parameters exception Exception The exception object. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestClose.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestClose.html",
    "title": "Method OnHttpRequestClose | Sisk",
    "keywords": "Method OnHttpRequestClose Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. protected override sealed void OnHttpRequestClose(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestCloseAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestCloseAsync.html",
    "title": "Method OnHttpRequestCloseAsync | Sisk",
    "keywords": "Method OnHttpRequestCloseAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestCloseAsync(HttpServerExecutionResult) Method that is called when an HttpRequest is closed in the HTTP server. protected virtual Task OnHttpRequestCloseAsync(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpen.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpen.html",
    "title": "Method OnHttpRequestOpen | Sisk",
    "keywords": "Method OnHttpRequestOpen Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. protected override sealed void OnHttpRequestOpen(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpenAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpenAsync.html",
    "title": "Method OnHttpRequestOpenAsync | Sisk",
    "keywords": "Method OnHttpRequestOpenAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpenAsync(HttpRequest) Method that is called when an HttpRequest is received in the HTTP server. protected virtual Task OnHttpRequestOpenAsync(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarted.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarted.html",
    "title": "Method OnServerStarted | Sisk",
    "keywords": "Method OnServerStarted Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. protected override sealed void OnServerStarted(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartedAsync.html",
    "title": "Method OnServerStartedAsync | Sisk",
    "keywords": "Method OnServerStartedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStartedAsync(HttpServer) Method that is called immediately after starting the HttpServer, when it's ready and listening. protected virtual Task OnServerStartedAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected override sealed void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartingAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartingAsync.html",
    "title": "Method OnServerStartingAsync | Sisk",
    "keywords": "Method OnServerStartingAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStartingAsync(HttpServer) Method that is called immediately before starting the HttpServer. protected virtual Task OnServerStartingAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopped.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopped.html",
    "title": "Method OnServerStopped | Sisk",
    "keywords": "Method OnServerStopped Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected override sealed void OnServerStopped(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppedAsync.html",
    "title": "Method OnServerStoppedAsync | Sisk",
    "keywords": "Method OnServerStoppedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStoppedAsync(HttpServer) Method that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected virtual Task OnServerStoppedAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopping.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopping.html",
    "title": "Method OnServerStopping | Sisk",
    "keywords": "Method OnServerStopping Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. protected override sealed void OnServerStopping(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppingAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppingAsync.html",
    "title": "Method OnServerStoppingAsync | Sisk",
    "keywords": "Method OnServerStoppingAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStoppingAsync(HttpServer) Method that is called before the HttpServer stop, when it is stopping from listening requests. protected virtual Task OnServerStoppingAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected override sealed void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouterAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouterAsync.html",
    "title": "Method OnSetupRouterAsync | Sisk",
    "keywords": "Method OnSetupRouterAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouterAsync(Router) Method that is called when an Router is binded to the HTTP server. protected virtual Task OnSetupRouterAsync(Router router) Parameters router Router The router entity which is binded. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.html",
    "title": "Class AsyncHttpServerHandler | Sisk",
    "keywords": "Class AsyncHttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll Represents an asynchronous event handler for the HttpServer, router, and related events. public abstract class AsyncHttpServerHandler : HttpServerHandler Inheritance object HttpServerHandler AsyncHttpServerHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors AsyncHttpServerHandler() Methods OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. OnContextBagCreatedAsync(TypedValueDictionary) Method that is called when an HTTP context is created within an HttpRequest object. OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnExceptionAsync(Exception) Method that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestCloseAsync(HttpServerExecutionResult) Method that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. OnHttpRequestOpenAsync(HttpRequest) Method that is called when an HttpRequest is received in the HTTP server. OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStartedAsync(HttpServer) Method that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnServerStartingAsync(HttpServer) Method that is called immediately before starting the HttpServer. OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStoppedAsync(HttpServer) Method that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. OnServerStoppingAsync(HttpServer) Method that is called before the HttpServer stop, when it is stopping from listening requests. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. OnSetupRouterAsync(Router) Method that is called when an Router is binded to the HTTP server."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.-ctor.html",
    "title": "Constructor HttpServerHandler | Sisk",
    "keywords": "Constructor HttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll HttpServerHandler() protected HttpServerHandler()"
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnContextBagCreated.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnContextBagCreated.html",
    "title": "Method OnContextBagCreated | Sisk",
    "keywords": "Method OnContextBagCreated Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. protected virtual void OnContextBagCreated(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnException.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnException.html",
    "title": "Method OnException | Sisk",
    "keywords": "Method OnException Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected virtual void OnException(Exception exception) Parameters exception Exception The exception object."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestClose.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestClose.html",
    "title": "Method OnHttpRequestClose | Sisk",
    "keywords": "Method OnHttpRequestClose Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. protected virtual void OnHttpRequestClose(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestOpen.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestOpen.html",
    "title": "Method OnHttpRequestOpen | Sisk",
    "keywords": "Method OnHttpRequestOpen Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. protected virtual void OnHttpRequestOpen(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarted.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarted.html",
    "title": "Method OnServerStarted | Sisk",
    "keywords": "Method OnServerStarted Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. protected virtual void OnServerStarted(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected virtual void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopped.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopped.html",
    "title": "Method OnServerStopped | Sisk",
    "keywords": "Method OnServerStopped Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected virtual void OnServerStopped(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopping.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopping.html",
    "title": "Method OnServerStopping | Sisk",
    "keywords": "Method OnServerStopping Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. protected virtual void OnServerStopping(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected virtual void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.html",
    "title": "Class HttpServerHandler | Sisk",
    "keywords": "Class HttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll Represents an event handler for the HttpServer, router, and related events. public abstract class HttpServerHandler Inheritance object HttpServerHandler Derived AsyncHttpServerHandler JsonRpcServerHandler SslProxyServerHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServerHandler() Methods OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server."
  },
  "api/Sisk.Core.Http.Handlers.html": {
    "href": "api/Sisk.Core.Http.Handlers.html",
    "title": "Namespace Sisk.Core.Http.Handlers | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Handlers Classes AsyncHttpServerHandler Represents an asynchronous event handler for the HttpServer, router, and related events. HttpServerHandler Represents an event handler for the HttpServer, router, and related events."
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.ConfigurationFile.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.ConfigurationFile.html",
    "title": "Property ConfigurationFile | Sisk",
    "keywords": "Property ConfigurationFile Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ConfigurationFile Gets the absolute path to the configuration file. The file is guaranteed to exist when getting this property value. public string ConfigurationFile { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.Host.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Host Gets the HttpServerHostContext which are configuring this context. public HttpServerHostContext Host { get; } Property Value HttpServerHostContext"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.Parameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Parameters Gets the InitializationParameterCollection collection for defining configuration parameters of the host application. public InitializationParameterCollection Parameters { get; } Property Value InitializationParameterCollection"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.TargetListeningHost.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.TargetListeningHost.html",
    "title": "Property TargetListeningHost | Sisk",
    "keywords": "Property TargetListeningHost Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll TargetListeningHost Gets the target ListeningHost which are configuring this context. public ListeningHost TargetListeningHost { get; } Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.html",
    "title": "Class ConfigurationContext | Sisk",
    "keywords": "Class ConfigurationContext Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents a reading context for a portable configuration file. public sealed class ConfigurationContext Inheritance object ConfigurationContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ConfigurationFile Gets the absolute path to the configuration file. The file is guaranteed to exist when getting this property value. Host Gets the HttpServerHostContext which are configuring this context. Parameters Gets the InitializationParameterCollection collection for defining configuration parameters of the host application. TargetListeningHost Gets the target ListeningHost which are configuring this context."
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationFileLookupDirectory.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationFileLookupDirectory.html",
    "title": "Enum ConfigurationFileLookupDirectory | Sisk",
    "keywords": "Enum ConfigurationFileLookupDirectory Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the base directory where the IConfigurationReader should search for the configuration file. [Flags] public enum ConfigurationFileLookupDirectory Fields AppDirectory = 4 The IConfigurationReader should search in the executable base directory. CurrentDirectory = 2 The IConfigurationReader should search in the process current/base directory."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.AccessLogs.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.AccessLogs.html",
    "title": "Property AccessLogs | Sisk",
    "keywords": "Property AccessLogs Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll AccessLogs Gets the configured access log stream. This property is inherited from ServerConfiguration. public LogStream? AccessLogs { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.CrossOriginResourceSharingPolicy.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.CrossOriginResourceSharingPolicy.html",
    "title": "Property CrossOriginResourceSharingPolicy | Sisk",
    "keywords": "Property CrossOriginResourceSharingPolicy Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll CrossOriginResourceSharingPolicy Gets the host CrossOriginResourceSharingPolicy. public CrossOriginResourceSharingHeaders CrossOriginResourceSharingPolicy { get; set; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Dispose.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. public void Dispose()"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ErrorLogs.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ErrorLogs.html",
    "title": "Property ErrorLogs | Sisk",
    "keywords": "Property ErrorLogs Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ErrorLogs Gets the configured error log stream. This property is inherited from ServerConfiguration. public LogStream? ErrorLogs { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.HttpServer.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.HttpServer.html",
    "title": "Property HttpServer | Sisk",
    "keywords": "Property HttpServer Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll HttpServer Gets the host HTTP server. public HttpServer HttpServer { get; } Property Value HttpServer"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Parameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Parameters Gets the initialization parameters from the portable configuration file. public InitializationParameterCollection Parameters { get; } Property Value InitializationParameterCollection"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Router.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Router Gets the host router. public Router Router { get; set; } Property Value Router"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ServerConfiguration Gets the host server configuration. public HttpServerConfiguration ServerConfiguration { get; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Start.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Start(bool, bool) Starts the HTTP server. public void Start(bool verbose = true, bool preventHault = true) Parameters verbose bool Optional. Specifies if the application should write the listening prefix welcome message. preventHault bool Optional. Specifies if the application should pause the main application loop."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.StartAsync.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.StartAsync.html",
    "title": "Method StartAsync | Sisk",
    "keywords": "Method StartAsync Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll StartAsync(bool, bool) Asynchronously starts the HTTP server. public Task StartAsync(bool verbose = true, bool preventHault = true) Parameters verbose bool Optional. Specifies if the application should write the listening prefix welcome message. preventHault bool Optional. Specifies if the application should pause the main application loop. Returns Task"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.html",
    "title": "Class HttpServerHostContext | Sisk",
    "keywords": "Class HttpServerHostContext Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the class that hosts most of the components needed to run a Sisk application. public sealed class HttpServerHostContext : IDisposable Inheritance object HttpServerHostContext Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties AccessLogs Gets the configured access log stream. This property is inherited from ServerConfiguration. CrossOriginResourceSharingPolicy Gets the host CrossOriginResourceSharingPolicy. ErrorLogs Gets the configured error log stream. This property is inherited from ServerConfiguration. HttpServer Gets the host HTTP server. Parameters Gets the initialization parameters from the portable configuration file. Router Gets the host router. ServerConfiguration Gets the host server configuration. Methods Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. Start(bool, bool) Starts the HTTP server. StartAsync(bool, bool) Asynchronously starts the HTTP server."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.Build.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.Build.html",
    "title": "Method Build | Sisk",
    "keywords": "Method Build Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Build() Builds an HttpServerHostContext with the specified parameters. public HttpServerHostContext Build() Returns HttpServerHostContext"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.CatchConfigurationExceptions.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.CatchConfigurationExceptions.html",
    "title": "Property CatchConfigurationExceptions | Sisk",
    "keywords": "Property CatchConfigurationExceptions Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll CatchConfigurationExceptions Defines how the constructor should capture errors thrown within UsePortableConfiguration(Action<PortableConfigurationBuilder>) and display in the Console. public static HttpServerHostContextBuilderExceptionMode CatchConfigurationExceptions { get; set; } Property Value HttpServerHostContextBuilderExceptionMode"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ServerConfiguration Gets the Server Configuration object. public HttpServerConfiguration ServerConfiguration { get; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseAutoScan.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseAutoScan.html",
    "title": "Method UseAutoScan | Sisk",
    "keywords": "Method UseAutoScan Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseAutoScan<TModule>() This method is an shortcut for calling AutoScanModules<TModule>(). public HttpServerHostContextBuilder UseAutoScan<TModule>() where TModule : RouterModule Returns HttpServerHostContextBuilder Type Parameters TModule An class which implements RouterModule, or the router module itself. UseAutoScan<TModule>(Assembly) This method is an shortcut for calling AutoScanModules<TModule>(). public HttpServerHostContextBuilder UseAutoScan<TModule>(Assembly t) where TModule : RouterModule Parameters t Assembly The assembly where the scanning types are. Returns HttpServerHostContextBuilder Type Parameters TModule An class which implements RouterModule, or the router module itself."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseBootstraper.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseBootstraper.html",
    "title": "Method UseBootstraper | Sisk",
    "keywords": "Method UseBootstraper Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseBootstraper(Action) Adds an function that will be executed immediately before starting the HTTP server. public HttpServerHostContextBuilder UseBootstraper(Action bootstrapAction) Parameters bootstrapAction Action The action which will be executed before the HTTP server start. Returns HttpServerHostContextBuilder UseBootstraper(string, Action) Adds an function that will be executed immediately before starting the HTTP server. public HttpServerHostContextBuilder UseBootstraper(string name, Action bootstrapAction) Parameters name string Defines an custom label for the bootstraping action name. bootstrapAction Action The action which will be executed before the HTTP server start. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseConfiguration.html",
    "title": "Method UseConfiguration | Sisk",
    "keywords": "Method UseConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseConfiguration(Action<HttpServerConfiguration>) Calls an action that has the HTTP server configuration as an argument. public HttpServerHostContextBuilder UseConfiguration(Action<HttpServerConfiguration> handler) Parameters handler Action<HttpServerConfiguration> An action where the first argument is an HttpServerConfiguration. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseCors.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseCors.html",
    "title": "Method UseCors | Sisk",
    "keywords": "Method UseCors Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseCors(Action<CrossOriginResourceSharingHeaders>) Calls an action that has an CrossOriginResourceSharingHeaders instance from the main listening host as an argument. public HttpServerHostContextBuilder UseCors(Action<CrossOriginResourceSharingHeaders> handler) Parameters handler Action<CrossOriginResourceSharingHeaders> An action where the first argument is the main CrossOriginResourceSharingHeaders object. Returns HttpServerHostContextBuilder UseCors(CrossOriginResourceSharingHeaders) Sets an CrossOriginResourceSharingHeaders instance in the current listening host. public HttpServerHostContextBuilder UseCors(CrossOriginResourceSharingHeaders cors) Parameters cors CrossOriginResourceSharingHeaders The CrossOriginResourceSharingHeaders to the current host builder. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseForwardingResolver.html",
    "title": "Method UseForwardingResolver | Sisk",
    "keywords": "Method UseForwardingResolver Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseForwardingResolver(ForwardingResolver) This method is a shortcut for setting ForwardingResolver. public HttpServerHostContextBuilder UseForwardingResolver(ForwardingResolver resolver) Parameters resolver ForwardingResolver The ForwardingResolver object. Returns HttpServerHostContextBuilder UseForwardingResolver<TForwardingResolver>() This method is a shortcut for setting ForwardingResolver. public HttpServerHostContextBuilder UseForwardingResolver<TForwardingResolver>() where TForwardingResolver : ForwardingResolver, new() Returns HttpServerHostContextBuilder Type Parameters TForwardingResolver The type which implements ForwardingResolver."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHandler.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHandler.html",
    "title": "Method UseHandler | Sisk",
    "keywords": "Method UseHandler Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseHandler<THandler>() This method is an shortcut for calling RegisterHandler<T>(). public HttpServerHostContextBuilder UseHandler<THandler>() where THandler : HttpServerHandler, new() Returns HttpServerHostContextBuilder Type Parameters THandler The handler which implements HttpServerHandler. UseHandler(HttpServerHandler) This method is an shortcut for calling RegisterHandler(HttpServerHandler). public HttpServerHostContextBuilder UseHandler(HttpServerHandler handler) Parameters handler HttpServerHandler The instance of the server handler. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHttpServer.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHttpServer.html",
    "title": "Method UseHttpServer | Sisk",
    "keywords": "Method UseHttpServer Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseHttpServer(Action<HttpServer>) Calls an action that has the HTTP server instance as an argument. public HttpServerHostContextBuilder UseHttpServer(Action<HttpServer> handler) Parameters handler Action<HttpServer> An action where the first argument is the main HttpServer object. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseListeningPort.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseListeningPort.html",
    "title": "Method UseListeningPort | Sisk",
    "keywords": "Method UseListeningPort Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseListeningPort(ushort) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(ushort port) Parameters port ushort The port the server will listen on. Returns HttpServerHostContextBuilder UseListeningPort(string) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(string uri) Parameters uri string The URI component that will be parsed to the listening port format. Returns HttpServerHostContextBuilder UseListeningPort(ListeningPort) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(ListeningPort listeningPort) Parameters listeningPort ListeningPort The ListeningPort object which the HTTP server will listen to. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseLocale.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseLocale.html",
    "title": "Method UseLocale | Sisk",
    "keywords": "Method UseLocale Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseLocale(CultureInfo) Changes the default thread current culture through DefaultThreadCurrentCulture. public HttpServerHostContextBuilder UseLocale(CultureInfo locale) Parameters locale CultureInfo The default CultureInfo object which the HTTP server will apply to the request handlers and callbacks thread. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UsePortableConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UsePortableConfiguration.html",
    "title": "Method UsePortableConfiguration | Sisk",
    "keywords": "Method UsePortableConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UsePortableConfiguration(Action<PortableConfigurationBuilder>) Enables the portable configuration for this application, which imports settings, parameters, and other information from a JSON settings file. public HttpServerHostContextBuilder UsePortableConfiguration(Action<PortableConfigurationBuilder> portableConfigHandler) Parameters portableConfigHandler Action<PortableConfigurationBuilder> The handler of PortableConfigurationBuilder. Returns HttpServerHostContextBuilder Remarks This method overrides almost all of your CreateBuilder() configuration. To avoid this, call this method at the beginning of your builder, as the first immediate method."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseRouter.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseRouter.html",
    "title": "Method UseRouter | Sisk",
    "keywords": "Method UseRouter Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseRouter(Action<Router>) Calls an action that has an Router instance from the host HTTP server. public HttpServerHostContextBuilder UseRouter(Action<Router> handler) Parameters handler Action<Router> An action where the first argument is the main Router object. Returns HttpServerHostContextBuilder UseRouter(Router) Sets an Router instance in the current listening host. public HttpServerHostContextBuilder UseRouter(Router r) Parameters r Router The Router to the current host builder. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseStartupMessage.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseStartupMessage.html",
    "title": "Method UseStartupMessage | Sisk",
    "keywords": "Method UseStartupMessage Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseStartupMessage(string) Add an optional message to the HttpServerHostContext output verbose. public HttpServerHostContextBuilder UseStartupMessage(string startupMessage) Parameters startupMessage string The startup message. Returns HttpServerHostContextBuilder UseStartupMessage(Func<string>) Adds a function that returns an optional initialization message to the HttpServerHostContext output verbose. public HttpServerHostContextBuilder UseStartupMessage(Func<string> startupMessage) Parameters startupMessage Func<string> The startup message function. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.html",
    "title": "Class HttpServerHostContextBuilder | Sisk",
    "keywords": "Class HttpServerHostContextBuilder Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents a context constructor for HttpServerHostContext. public sealed class HttpServerHostContextBuilder Inheritance object HttpServerHostContextBuilder Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties CatchConfigurationExceptions Defines how the constructor should capture errors thrown within UsePortableConfiguration(Action<PortableConfigurationBuilder>) and display in the Console. ServerConfiguration Gets the Server Configuration object. Methods Build() Builds an HttpServerHostContext with the specified parameters. UseAutoScan<TModule>() This method is an shortcut for calling AutoScanModules<TModule>(). UseAutoScan<TModule>(Assembly) This method is an shortcut for calling AutoScanModules<TModule>(). UseBootstraper(Action) Adds an function that will be executed immediately before starting the HTTP server. UseBootstraper(string, Action) Adds an function that will be executed immediately before starting the HTTP server. UseConfiguration(Action<HttpServerConfiguration>) Calls an action that has the HTTP server configuration as an argument. UseCors(CrossOriginResourceSharingHeaders) Sets an CrossOriginResourceSharingHeaders instance in the current listening host. UseCors(Action<CrossOriginResourceSharingHeaders>) Calls an action that has an CrossOriginResourceSharingHeaders instance from the main listening host as an argument. UseForwardingResolver(ForwardingResolver) This method is a shortcut for setting ForwardingResolver. UseForwardingResolver<TForwardingResolver>() This method is a shortcut for setting ForwardingResolver. UseHandler(HttpServerHandler) This method is an shortcut for calling RegisterHandler(HttpServerHandler). UseHandler<THandler>() This method is an shortcut for calling RegisterHandler<T>(). UseHttpServer(Action<HttpServer>) Calls an action that has the HTTP server instance as an argument. UseListeningPort(ListeningPort) Sets the main ListeningPort of this host builder. UseListeningPort(string) Sets the main ListeningPort of this host builder. UseListeningPort(ushort) Sets the main ListeningPort of this host builder. UseLocale(CultureInfo) Changes the default thread current culture through DefaultThreadCurrentCulture. UsePortableConfiguration(Action<PortableConfigurationBuilder>) Enables the portable configuration for this application, which imports settings, parameters, and other information from a JSON settings file. UseRouter(Router) Sets an Router instance in the current listening host. UseRouter(Action<Router>) Calls an action that has an Router instance from the host HTTP server. UseStartupMessage(Func<string>) Adds a function that returns an optional initialization message to the HttpServerHostContext output verbose. UseStartupMessage(string) Add an optional message to the HttpServerHostContext output verbose."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilderExceptionMode.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilderExceptionMode.html",
    "title": "Enum HttpServerHostContextBuilderExceptionMode | Sisk",
    "keywords": "Enum HttpServerHostContextBuilderExceptionMode Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents how the builder event error message should be displayed. public enum HttpServerHostContextBuilderExceptionMode Fields Detailed = 2 Detailed messages, including detailed exception trace and information, should be displayed. Normal = 1 Normal messages, including their exception type and message, should be displayed. Silent = 0 No message should be displayed. Throw = 3 No message should be displayed and exceptions should be thrown instead being caughts."
  },
  "api/Sisk.Core.Http.Hosting.IConfigurationReader.ReadConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.IConfigurationReader.ReadConfiguration.html",
    "title": "Method ReadConfiguration | Sisk",
    "keywords": "Method ReadConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file. void ReadConfiguration(ConfigurationContext context) Parameters context ConfigurationContext The configuration context object."
  },
  "api/Sisk.Core.Http.Hosting.IConfigurationReader.html": {
    "href": "api/Sisk.Core.Http.Hosting.IConfigurationReader.html",
    "title": "Interface IConfigurationReader | Sisk",
    "keywords": "Interface IConfigurationReader Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents an interface that reads and applies settings from a settings file. public interface IConfigurationReader Methods ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.-ctor.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.-ctor.html",
    "title": "Constructor InitializationParameterCollection | Sisk",
    "keywords": "Constructor InitializationParameterCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll InitializationParameterCollection() public InitializationParameterCollection()"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.AsNameValueCollection.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.AsNameValueCollection.html",
    "title": "Method AsNameValueCollection | Sisk",
    "keywords": "Method AsNameValueCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll AsNameValueCollection() Gets an instance of NameValueCollection with the values of this class. public NameValueCollection AsNameValueCollection() Returns NameValueCollection"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNull.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNull.html",
    "title": "Method EnsureNotNull | Sisk",
    "keywords": "Method EnsureNotNull Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll EnsureNotNull(string) Ensures that the parameter defined by name parameterName is present in this collection. public void EnsureNotNull(string parameterName) Parameters parameterName string The parameter name which will be evaluated. Remarks If the parameter doens't meet the above requirements, an ArgumentNullException exception is thrown."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNullOrEmpty.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNullOrEmpty.html",
    "title": "Method EnsureNotNullOrEmpty | Sisk",
    "keywords": "Method EnsureNotNullOrEmpty Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll EnsureNotNullOrEmpty(string) Ensures that the parameter defined by name parameterName is present and not empty in this collection. public void EnsureNotNullOrEmpty(string parameterName) Parameters parameterName string The parameter name which will be evaluated. Remarks If the parameter doens't meet the above requirements, an ArgumentNullException exception is thrown."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetStringValue.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetStringValue.html",
    "title": "Method GetStringValue | Sisk",
    "keywords": "Method GetStringValue Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll GetStringValue(string) Retrieves a StringValue instance representing the specified parameter. public StringValue GetStringValue(string parameterName) Parameters parameterName string The name of the parameter to retrieve. Returns StringValue A StringValue instance containing the parameter name and value."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOption.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOption.html",
    "title": "Enum InitializationParameterCollection.GetValueOption | Sisk",
    "keywords": "Enum InitializationParameterCollection.GetValueOption Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the option used in the method GetValueOrThrow(string, GetValueOption). public enum InitializationParameterCollection.GetValueOption Fields NotNull = 0 The method should throw if the value is not present in the collection, but allow empty values. NotNullOrEmpty = 1 The method should throw if the value is not present in the collection or has an empty value. NotNullOrWhiteSpace = 2 The method should throw if the value is not present in the collection, has an empty value or consists of whitespaces (spaces, tabs, etc.)."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOrThrow.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOrThrow.html",
    "title": "Method GetValueOrThrow | Sisk",
    "keywords": "Method GetValueOrThrow Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll GetValueOrThrow(string, GetValueOption) Gets the specified value if present in this parameter collection, or throw an exception if the value is not present. public string GetValueOrThrow(string parameterName, InitializationParameterCollection.GetValueOption option = GetValueOption.NotNullOrEmpty) Parameters parameterName string The parameter name. option InitializationParameterCollection.GetValueOption Specifies the InitializationParameterCollection.GetValueOption used for getting the value. Returns string"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.html",
    "title": "Class InitializationParameterCollection | Sisk",
    "keywords": "Class InitializationParameterCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Provides a collection of HTTP server initialization variables. public sealed class InitializationParameterCollection : IDictionary<string, string?>, ICollection<KeyValuePair<string, string?>>, IEnumerable<KeyValuePair<string, string?>>, IEnumerable Inheritance object InitializationParameterCollection Implements IDictionary<string, string> ICollection<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors InitializationParameterCollection() Methods AsNameValueCollection() Gets an instance of NameValueCollection with the values of this class. EnsureNotNull(string) Ensures that the parameter defined by name parameterName is present in this collection. EnsureNotNullOrEmpty(string) Ensures that the parameter defined by name parameterName is present and not empty in this collection. GetStringValue(string) Retrieves a StringValue instance representing the specified parameter. GetValueOrThrow(string, GetValueOption) Gets the specified value if present in this parameter collection, or throw an exception if the value is not present."
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigFile.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigFile.html",
    "title": "Method WithConfigFile | Sisk",
    "keywords": "Method WithConfigFile Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithConfigFile(string, bool, ConfigurationFileLookupDirectory) Specifies the name of the server configuration file. public PortableConfigurationBuilder WithConfigFile(string filename, bool createIfDontExists = false, ConfigurationFileLookupDirectory lookupDirectories = ConfigurationFileLookupDirectory.CurrentDirectory) Parameters filename string The name of the JSON configuration file. createIfDontExists bool Optional. Determines if the configuration file should be created if it doens't exists. lookupDirectories ConfigurationFileLookupDirectory Optional. Specifies the directories which the IConfigurationReader should search for the configuration file. Returns PortableConfigurationBuilder"
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigReader.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigReader.html",
    "title": "Method WithConfigReader | Sisk",
    "keywords": "Method WithConfigReader Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithConfigReader(IConfigurationReader) Defines an custom IConfigurationReader configuration pipeline to the builder. public PortableConfigurationBuilder WithConfigReader(IConfigurationReader reader) Parameters reader IConfigurationReader The IConfigurationReader object. Returns PortableConfigurationBuilder WithConfigReader<TReader>() Defines an custom IConfigurationReader configuration pipeline to the builder. public PortableConfigurationBuilder WithConfigReader<TReader>() where TReader : IConfigurationReader, new() Returns PortableConfigurationBuilder Type Parameters TReader The IConfigurationReader type."
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithParameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithParameters.html",
    "title": "Method WithParameters | Sisk",
    "keywords": "Method WithParameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithParameters(Action<InitializationParameterCollection>) Invokes a method on the initialization parameter collection. public PortableConfigurationBuilder WithParameters(Action<InitializationParameterCollection> handler) Parameters handler Action<InitializationParameterCollection> The handler of InitializationParameterCollection. Returns PortableConfigurationBuilder"
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.html",
    "title": "Class PortableConfigurationBuilder | Sisk",
    "keywords": "Class PortableConfigurationBuilder Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the portable configuration builder for HttpServerHostContextBuilder. public sealed class PortableConfigurationBuilder Inheritance object PortableConfigurationBuilder Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WithConfigFile(string, bool, ConfigurationFileLookupDirectory) Specifies the name of the server configuration file. WithConfigReader(IConfigurationReader) Defines an custom IConfigurationReader configuration pipeline to the builder. WithConfigReader<TReader>() Defines an custom IConfigurationReader configuration pipeline to the builder. WithParameters(Action<InitializationParameterCollection>) Invokes a method on the initialization parameter collection."
  },
  "api/Sisk.Core.Http.Hosting.html": {
    "href": "api/Sisk.Core.Http.Hosting.html",
    "title": "Namespace Sisk.Core.Http.Hosting | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Hosting Classes ConfigurationContext Represents a reading context for a portable configuration file. HttpServerHostContext Represents the class that hosts most of the components needed to run a Sisk application. HttpServerHostContextBuilder Represents a context constructor for HttpServerHostContext. InitializationParameterCollection Provides a collection of HTTP server initialization variables. PortableConfigurationBuilder Represents the portable configuration builder for HttpServerHostContextBuilder. Interfaces IConfigurationReader Represents an interface that reads and applies settings from a settings file. Enums ConfigurationFileLookupDirectory Represents the base directory where the IConfigurationReader should search for the configuration file. HttpServerHostContextBuilderExceptionMode Represents how the builder event error message should be displayed. InitializationParameterCollection.GetValueOption Represents the option used in the method GetValueOrThrow(string, GetValueOption)."
  },
  "api/Sisk.Core.Http.HtmlContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.HtmlContent.-ctor.html",
    "title": "Constructor HtmlContent | Sisk",
    "keywords": "Constructor HtmlContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll HtmlContent(string, Encoding) Creates an new HtmlContent class with given HTML content and encoding. public HtmlContent(string content, Encoding encoding) Parameters content string The HTML content string. encoding Encoding The encoding which will encode the HTML contents. HtmlContent(string) Creates an new HtmlContent class with given HTML content, using the environment default encoding. public HtmlContent(string content) Parameters content string The HTML content string. HtmlContent(ReadOnlySpan<byte>, Encoding) Creates a new HtmlContent class with given HTML content as a byte span and encoding. public HtmlContent(ReadOnlySpan<byte> contents, Encoding encoding) Parameters contents ReadOnlySpan<byte> The HTML content as a byte span. encoding Encoding The encoding which will decode the HTML contents. HtmlContent(ReadOnlySpan<byte>) Creates a new HtmlContent class with given HTML content as a UTF-8 encoded byte span. public HtmlContent(ReadOnlySpan<byte> utf8Contents) Parameters utf8Contents ReadOnlySpan<byte> The HTML content as a UTF-8 encoded byte span."
  },
  "api/Sisk.Core.Http.HtmlContent.html": {
    "href": "api/Sisk.Core.Http.HtmlContent.html",
    "title": "Class HtmlContent | Sisk",
    "keywords": "Class HtmlContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides HTTP content based on HTML contents. public class HtmlContent : StringContent, IDisposable Inheritance object HttpContent ByteArrayContent StringContent HtmlContent Implements IDisposable Inherited Members StringContent.SerializeToStreamAsync(Stream, TransportContext, CancellationToken) ByteArrayContent.SerializeToStream(Stream, TransportContext, CancellationToken) ByteArrayContent.SerializeToStreamAsync(Stream, TransportContext) ByteArrayContent.TryComputeLength(out long) ByteArrayContent.CreateContentReadStream(CancellationToken) ByteArrayContent.CreateContentReadStreamAsync() HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.CreateContentReadStreamAsync(CancellationToken) HttpContent.Dispose(bool) HttpContent.Dispose() HttpContent.Headers object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HtmlContent(ReadOnlySpan<byte>) Creates a new HtmlContent class with given HTML content as a UTF-8 encoded byte span. HtmlContent(ReadOnlySpan<byte>, Encoding) Creates a new HtmlContent class with given HTML content as a byte span and encoding. HtmlContent(string) Creates an new HtmlContent class with given HTML content, using the environment default encoding. HtmlContent(string, Encoding) Creates an new HtmlContent class with given HTML content and encoding."
  },
  "api/Sisk.Core.Http.HttpContext.Current.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Current.html",
    "title": "Property Current | Sisk",
    "keywords": "Property Current Namespace Sisk.Core.Http Assembly Sisk.Core.dll Current Gets the current running HttpContext. public static HttpContext Current { get; } Property Value HttpContext Remarks This property is only accessible during an HTTP session, within the executing HTTP code."
  },
  "api/Sisk.Core.Http.HttpContext.ExtraHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpContext.ExtraHeaders.html",
    "title": "Property ExtraHeaders | Sisk",
    "keywords": "Property ExtraHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll ExtraHeaders Gets or sets the HttpHeaderCollection indicating HTTP headers which will be added (not overwritten) in the final response. public HttpHeaderCollection ExtraHeaders { get; set; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpContext.HttpServer.html": {
    "href": "api/Sisk.Core.Http.HttpContext.HttpServer.html",
    "title": "Property HttpServer | Sisk",
    "keywords": "Property HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServer Gets the context HttpServer instance. public HttpServer HttpServer { get; } Property Value HttpServer"
  },
  "api/Sisk.Core.Http.HttpContext.IsRequestContext.html": {
    "href": "api/Sisk.Core.Http.HttpContext.IsRequestContext.html",
    "title": "Property IsRequestContext | Sisk",
    "keywords": "Property IsRequestContext Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsRequestContext Gets whether the current thread context is running inside an HTTP context. public static bool IsRequestContext { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpContext.ListeningHost.html": {
    "href": "api/Sisk.Core.Http.HttpContext.ListeningHost.html",
    "title": "Property ListeningHost | Sisk",
    "keywords": "Property ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHost Gets the ListeningHost instance of this HTTP context. public ListeningHost? ListeningHost { get; } Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.HttpContext.MatchedRoute.html": {
    "href": "api/Sisk.Core.Http.HttpContext.MatchedRoute.html",
    "title": "Property MatchedRoute | Sisk",
    "keywords": "Property MatchedRoute Namespace Sisk.Core.Http Assembly Sisk.Core.dll MatchedRoute Gets the matched Route for this context. public Route? MatchedRoute { get; } Property Value Route"
  },
  "api/Sisk.Core.Http.HttpContext.OverrideHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpContext.OverrideHeaders.html",
    "title": "Property OverrideHeaders | Sisk",
    "keywords": "Property OverrideHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll OverrideHeaders Gets or sets an HttpHeaderCollection indicating HTTP headers which will overwrite headers set by CORS, router response or request handlers. public HttpHeaderCollection OverrideHeaders { get; set; } Property Value HttpHeaderCollection Remarks This property replaces existing headers in the final response. Use ExtraHeaders to add headers without replacing existing ones."
  },
  "api/Sisk.Core.Http.HttpContext.Request.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Request.html",
    "title": "Property Request | Sisk",
    "keywords": "Property Request Namespace Sisk.Core.Http Assembly Sisk.Core.dll Request Gets the HttpRequest which is contained in this HTTP context. public HttpRequest Request { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.HttpContext.RequestBag.html": {
    "href": "api/Sisk.Core.Http.HttpContext.RequestBag.html",
    "title": "Property RequestBag | Sisk",
    "keywords": "Property RequestBag Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestBag Gets or sets a managed collection for this HTTP context. public TypedValueDictionary RequestBag { get; set; } Property Value TypedValueDictionary"
  },
  "api/Sisk.Core.Http.HttpContext.Router.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http Assembly Sisk.Core.dll Router Gets the Router where this context was created. public Router? Router { get; } Property Value Router"
  },
  "api/Sisk.Core.Http.HttpContext.RouterResponse.html": {
    "href": "api/Sisk.Core.Http.HttpContext.RouterResponse.html",
    "title": "Property RouterResponse | Sisk",
    "keywords": "Property RouterResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll RouterResponse Gets the HttpResponse for this context. This property acessible when a post-executing IRequestHandler was executed for this router context. public HttpResponse? RouterResponse { get; } Property Value HttpResponse"
  },
  "api/Sisk.Core.Http.HttpContext.html": {
    "href": "api/Sisk.Core.Http.HttpContext.html",
    "title": "Class HttpContext | Sisk",
    "keywords": "Class HttpContext Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an context that is shared in a entire HTTP session. public sealed class HttpContext Inheritance object HttpContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Current Gets the current running HttpContext. ExtraHeaders Gets or sets the HttpHeaderCollection indicating HTTP headers which will be added (not overwritten) in the final response. HttpServer Gets the context HttpServer instance. IsRequestContext Gets whether the current thread context is running inside an HTTP context. ListeningHost Gets the ListeningHost instance of this HTTP context. MatchedRoute Gets the matched Route for this context. OverrideHeaders Gets or sets an HttpHeaderCollection indicating HTTP headers which will overwrite headers set by CORS, router response or request handlers. Request Gets the HttpRequest which is contained in this HTTP context. RequestBag Gets or sets a managed collection for this HTTP context. Router Gets the Router where this context was created. RouterResponse Gets the HttpResponse for this context. This property acessible when a post-executing IRequestHandler was executed for this router context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Accept.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Accept.html",
    "title": "Field Accept | Sisk",
    "keywords": "Field Accept Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. public const string Accept = \"Accept\" Returns string The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCH.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCH.html",
    "title": "Field AcceptCH | Sisk",
    "keywords": "Field AcceptCH Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-CH header. Specifies the client hints that the server supports, allowing clients to provide additional information about their capabilities. public const string AcceptCH = \"Accept-CH\" Returns string The HTTP Accept-CH header. Specifies the client hints that the server supports, allowing clients to provide additional information about their capabilities."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCharset.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCharset.html",
    "title": "Field AcceptCharset | Sisk",
    "keywords": "Field AcceptCharset Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. public const string AcceptCharset = \"Accept-Charset\" Returns string The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptEncoding.html",
    "title": "Field AcceptEncoding | Sisk",
    "keywords": "Field AcceptEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. public const string AcceptEncoding = \"Accept-Encoding\" Returns string The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptLanguage.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptLanguage.html",
    "title": "Field AcceptLanguage | Sisk",
    "keywords": "Field AcceptLanguage Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. public const string AcceptLanguage = \"Accept-Language\" Returns string The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPatch.html",
    "title": "Field AcceptPatch | Sisk",
    "keywords": "Field AcceptPatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. public const string AcceptPatch = \"Accept-Patch\" Returns string The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPost.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPost.html",
    "title": "Field AcceptPost | Sisk",
    "keywords": "Field AcceptPost Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Post header. Specifies which media types are accepted by the server in a POST request. public const string AcceptPost = \"Accept-Post\" Returns string The HTTP Accept-Post header. Specifies which media types are accepted by the server in a POST request."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptRanges.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptRanges.html",
    "title": "Field AcceptRanges | Sisk",
    "keywords": "Field AcceptRanges Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. public const string AcceptRanges = \"Accept-Ranges\" Returns string The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowCredentials.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowCredentials.html",
    "title": "Field AccessControlAllowCredentials | Sisk",
    "keywords": "Field AccessControlAllowCredentials Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. public const string AccessControlAllowCredentials = \"Access-Control-Allow-Credentials\" Returns string The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowHeaders.html",
    "title": "Field AccessControlAllowHeaders | Sisk",
    "keywords": "Field AccessControlAllowHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. public const string AccessControlAllowHeaders = \"Access-Control-Allow-Headers\" Returns string The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowMethods.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowMethods.html",
    "title": "Field AccessControlAllowMethods | Sisk",
    "keywords": "Field AccessControlAllowMethods Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. public const string AccessControlAllowMethods = \"Access-Control-Allow-Methods\" Returns string The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowOrigin.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowOrigin.html",
    "title": "Field AccessControlAllowOrigin | Sisk",
    "keywords": "Field AccessControlAllowOrigin Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. public const string AccessControlAllowOrigin = \"Access-Control-Allow-Origin\" Returns string The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlExposeHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlExposeHeaders.html",
    "title": "Field AccessControlExposeHeaders | Sisk",
    "keywords": "Field AccessControlExposeHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. public const string AccessControlExposeHeaders = \"Access-Control-Expose-Headers\" Returns string The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlMaxAge.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlMaxAge.html",
    "title": "Field AccessControlMaxAge | Sisk",
    "keywords": "Field AccessControlMaxAge Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. public const string AccessControlMaxAge = \"Access-Control-Max-Age\" Returns string The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Age.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Age.html",
    "title": "Field Age | Sisk",
    "keywords": "Field Age Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. public const string Age = \"Age\" Returns string The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Allow.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Allow.html",
    "title": "Field Allow | Sisk",
    "keywords": "Field Allow Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. public const string Allow = \"Allow\" Returns string The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AltSvc.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AltSvc.html",
    "title": "Field AltSvc | Sisk",
    "keywords": "Field AltSvc Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol. public const string AltSvc = \"Alt-Svc\" Returns string The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Authorization.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Authorization.html",
    "title": "Field Authorization | Sisk",
    "keywords": "Field Authorization Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. public const string Authorization = \"Authorization\" Returns string The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.CacheControl.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.CacheControl.html",
    "title": "Field CacheControl | Sisk",
    "keywords": "Field CacheControl Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. public const string CacheControl = \"Cache-Control\" Returns string The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Connection.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Connection.html",
    "title": "Field Connection | Sisk",
    "keywords": "Field Connection Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections. public const string Connection = \"Connection\" Returns string The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentDisposition.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentDisposition.html",
    "title": "Field ContentDisposition | Sisk",
    "keywords": "Field ContentDisposition Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. public const string ContentDisposition = \"Content-Disposition\" Returns string The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentEncoding.html",
    "title": "Field ContentEncoding | Sisk",
    "keywords": "Field ContentEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. public const string ContentEncoding = \"Content-Encoding\" Returns string The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLanguage.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLanguage.html",
    "title": "Field ContentLanguage | Sisk",
    "keywords": "Field ContentLanguage Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. public const string ContentLanguage = \"Content-Language\" Returns string The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLength.html",
    "title": "Field ContentLength | Sisk",
    "keywords": "Field ContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. public const string ContentLength = \"Content-Length\" Returns string The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLocation.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLocation.html",
    "title": "Field ContentLocation | Sisk",
    "keywords": "Field ContentLocation Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public const string ContentLocation = \"Content-Location\" Returns string The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentMD5.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentMD5.html",
    "title": "Field ContentMD5 | Sisk",
    "keywords": "Field ContentMD5 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data. public const string ContentMD5 = \"Content-MD5\" Returns string The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentRange.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentRange.html",
    "title": "Field ContentRange | Sisk",
    "keywords": "Field ContentRange Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges. public const string ContentRange = \"Content-Range\" Returns string The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentSecurityPolicy.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentSecurityPolicy.html",
    "title": "Field ContentSecurityPolicy | Sisk",
    "keywords": "Field ContentSecurityPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. public const string ContentSecurityPolicy = \"Content-Security-Policy\" Returns string The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentType.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentType.html",
    "title": "Field ContentType | Sisk",
    "keywords": "Field ContentType Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. public const string ContentType = \"Content-Type\" Returns string The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie.html",
    "title": "Field Cookie | Sisk",
    "keywords": "Field Cookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. public const string Cookie = \"Cookie\" Returns string The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie2.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie2.html",
    "title": "Field Cookie2 | Sisk",
    "keywords": "Field Cookie2 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. public const string Cookie2 = \"Cookie2\" Returns string The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Date.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Date.html",
    "title": "Field Date | Sisk",
    "keywords": "Field Date Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response. public const string Date = \"Date\" Returns string The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Dnt.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Dnt.html",
    "title": "Field Dnt | Sisk",
    "keywords": "Field Dnt Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP DNT header. The HTTP DNT (Do Not Track) request header indicates the user's tracking preference. public const string Dnt = \"DNT\" Returns string The HTTP DNT header. The HTTP DNT (Do Not Track) request header indicates the user's tracking preference."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ETag.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ETag.html",
    "title": "Field ETag | Sisk",
    "keywords": "Field ETag Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. public const string ETag = \"ETag\" Returns string The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Expect.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Expect.html",
    "title": "Field Expect | Sisk",
    "keywords": "Field Expect Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. public const string Expect = \"Expect\" Returns string The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Expires.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Expires.html",
    "title": "Field Expires | Sisk",
    "keywords": "Field Expires Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. public const string Expires = \"Expires\" Returns string The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Host.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Host.html",
    "title": "Field Host | Sisk",
    "keywords": "Field Host Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. public const string Host = \"Host\" Returns string The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfMatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfMatch.html",
    "title": "Field IfMatch | Sisk",
    "keywords": "Field IfMatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. public const string IfMatch = \"If-Match\" Returns string The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfModifiedSince.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfModifiedSince.html",
    "title": "Field IfModifiedSince | Sisk",
    "keywords": "Field IfModifiedSince Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public const string IfModifiedSince = \"If-Modified-Since\" Returns string The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfNoneMatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfNoneMatch.html",
    "title": "Field IfNoneMatch | Sisk",
    "keywords": "Field IfNoneMatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag. public const string IfNoneMatch = \"If-None-Match\" Returns string The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfRange.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfRange.html",
    "title": "Field IfRange | Sisk",
    "keywords": "Field IfRange Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. public const string IfRange = \"If-Range\" Returns string The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfUnmodifiedSince.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfUnmodifiedSince.html",
    "title": "Field IfUnmodifiedSince | Sisk",
    "keywords": "Field IfUnmodifiedSince Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. public const string IfUnmodifiedSince = \"If-Unmodified-Since\" Returns string The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.KeepAlive.html",
    "title": "Field KeepAlive | Sisk",
    "keywords": "Field KeepAlive Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests. public const string KeepAlive = \"Keep-Alive\" Returns string The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.LastModified.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.LastModified.html",
    "title": "Field LastModified | Sisk",
    "keywords": "Field LastModified Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version. public const string LastModified = \"Last-Modified\" Returns string The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Link.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Link.html",
    "title": "Field Link | Sisk",
    "keywords": "Field Link Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking. public const string Link = \"Link\" Returns string The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Location.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Location.html",
    "title": "Field Location | Sisk",
    "keywords": "Field Location Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect. public const string Location = \"Location\" Returns string The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.MaxForwards.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.MaxForwards.html",
    "title": "Field MaxForwards | Sisk",
    "keywords": "Field MaxForwards Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. public const string MaxForwards = \"Max-Forwards\" Returns string The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Origin.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Origin.html",
    "title": "Field Origin | Sisk",
    "keywords": "Field Origin Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. public const string Origin = \"Origin\" Returns string The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.P3P.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.P3P.html",
    "title": "Field P3P | Sisk",
    "keywords": "Field P3P Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled. public const string P3P = \"P3P\" Returns string The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Pragma.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Pragma.html",
    "title": "Field Pragma | Sisk",
    "keywords": "Field Pragma Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. public const string Pragma = \"Pragma\" Returns string The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthenticate.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthenticate.html",
    "title": "Field ProxyAuthenticate | Sisk",
    "keywords": "Field ProxyAuthenticate Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. public const string ProxyAuthenticate = \"Proxy-Authenticate\" Returns string The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthorization.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthorization.html",
    "title": "Field ProxyAuthorization | Sisk",
    "keywords": "Field ProxyAuthorization Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. public const string ProxyAuthorization = \"Proxy-Authorization\" Returns string The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyConnection.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyConnection.html",
    "title": "Field ProxyConnection | Sisk",
    "keywords": "Field ProxyConnection Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction. public const string ProxyConnection = \"Proxy-Connection\" Returns string The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.PublicKeyPins.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.PublicKeyPins.html",
    "title": "Field PublicKeyPins | Sisk",
    "keywords": "Field PublicKeyPins Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate. public const string PublicKeyPins = \"Public-Key-Pins\" Returns string The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Range.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Range.html",
    "title": "Field Range | Sisk",
    "keywords": "Field Range Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. public const string Range = \"Range\" Returns string The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Referer.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Referer.html",
    "title": "Field Referer | Sisk",
    "keywords": "Field Referer Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. public const string Referer = \"Referer\" Returns string The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.RetryAfter.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.RetryAfter.html",
    "title": "Field RetryAfter | Sisk",
    "keywords": "Field RetryAfter Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. public const string RetryAfter = \"Retry-After\" Returns string The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecGPC.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecGPC.html",
    "title": "Field SecGPC | Sisk",
    "keywords": "Field SecGPC Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-GPC header. The HTTP Sec-GPC request header is part of the Global Privacy Control (GPC) mechanism to indicate whether the user consents to a website or service selling or sharing their personal information with third parties. public const string SecGPC = \"Sec-GPC\" Returns string The HTTP Sec-GPC header. The HTTP Sec-GPC request header is part of the Global Privacy Control (GPC) mechanism to indicate whether the user consents to a website or service selling or sharing their personal information with third parties."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketAccept.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketAccept.html",
    "title": "Field SecWebSocketAccept | Sisk",
    "keywords": "Field SecWebSocketAccept Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request. public const string SecWebSocketAccept = \"Sec-WebSocket-Accept\" Returns string The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketExtensions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketExtensions.html",
    "title": "Field SecWebSocketExtensions | Sisk",
    "keywords": "Field SecWebSocketExtensions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities. public const string SecWebSocketExtensions = \"Sec-WebSocket-Extensions\" Returns string The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketKey.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketKey.html",
    "title": "Field SecWebSocketKey | Sisk",
    "keywords": "Field SecWebSocketKey Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid. public const string SecWebSocketKey = \"Sec-WebSocket-Key\" Returns string The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketProtocol.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketProtocol.html",
    "title": "Field SecWebSocketProtocol | Sisk",
    "keywords": "Field SecWebSocketProtocol Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection. public const string SecWebSocketProtocol = \"Sec-WebSocket-Protocol\" Returns string The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketVersion.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketVersion.html",
    "title": "Field SecWebSocketVersion | Sisk",
    "keywords": "Field SecWebSocketVersion Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use. public const string SecWebSocketVersion = \"Sec-WebSocket-Version\" Returns string The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Server.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Server.html",
    "title": "Field Server | Sisk",
    "keywords": "Field Server Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes. public const string Server = \"Server\" Returns string The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie.html",
    "title": "Field SetCookie | Sisk",
    "keywords": "Field SetCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. public const string SetCookie = \"Set-Cookie\" Returns string The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie2.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie2.html",
    "title": "Field SetCookie2 | Sisk",
    "keywords": "Field SetCookie2 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. public const string SetCookie2 = \"Set-Cookie2\" Returns string The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.StrictTransportSecurity.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.StrictTransportSecurity.html",
    "title": "Field StrictTransportSecurity | Sisk",
    "keywords": "Field StrictTransportSecurity Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks. public const string StrictTransportSecurity = \"Strict-Transport-Security\" Returns string The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TE.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TE.html",
    "title": "Field TE | Sisk",
    "keywords": "Field TE Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. public const string TE = \"TE\" Returns string The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TSV.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TSV.html",
    "title": "Field TSV | Sisk",
    "keywords": "Field TSV Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols. public const string TSV = \"TSV\" Returns string The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Trailer.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Trailer.html",
    "title": "Field Trailer | Sisk",
    "keywords": "Field Trailer Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata. public const string Trailer = \"Trailer\" Returns string The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TransferEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TransferEncoding.html",
    "title": "Field TransferEncoding | Sisk",
    "keywords": "Field TransferEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user. public const string TransferEncoding = \"Transfer-Encoding\" Returns string The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Upgrade.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Upgrade.html",
    "title": "Field Upgrade | Sisk",
    "keywords": "Field Upgrade Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2. public const string Upgrade = \"Upgrade\" Returns string The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.UpgradeInsecureRequests.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.UpgradeInsecureRequests.html",
    "title": "Field UpgradeInsecureRequests | Sisk",
    "keywords": "Field UpgradeInsecureRequests Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP. public const string UpgradeInsecureRequests = \"Upgrade-Insecure-Requests\" Returns string The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.UserAgent.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.UserAgent.html",
    "title": "Field UserAgent | Sisk",
    "keywords": "Field UserAgent Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. public const string UserAgent = \"User-Agent\" Returns string The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Vary.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Vary.html",
    "title": "Field Vary | Sisk",
    "keywords": "Field Vary Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. public const string Vary = \"Vary\" Returns string The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Via.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Via.html",
    "title": "Field Via | Sisk",
    "keywords": "Field Via Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. public const string Via = \"Via\" Returns string The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.WWWAuthenticate.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.WWWAuthenticate.html",
    "title": "Field WWWAuthenticate | Sisk",
    "keywords": "Field WWWAuthenticate Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. public const string WWWAuthenticate = \"WWW-Authenticate\" Returns string The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Warning.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Warning.html",
    "title": "Field Warning | Sisk",
    "keywords": "Field Warning Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation. public const string Warning = \"Warning\" Returns string The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentDuration.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentDuration.html",
    "title": "Field XContentDuration | Sisk",
    "keywords": "Field XContentDuration Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files. public const string XContentDuration = \"X-Content-Duration\" Returns string The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentTypeOptions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentTypeOptions.html",
    "title": "Field XContentTypeOptions | Sisk",
    "keywords": "Field XContentTypeOptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type. public const string XContentTypeOptions = \"X-Content-Type-Options\" Returns string The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedFor.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedFor.html",
    "title": "Field XForwardedFor | Sisk",
    "keywords": "Field XForwardedFor Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. public const string XForwardedFor = \"X-Forwarded-For\" Returns string The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedHost.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedHost.html",
    "title": "Field XForwardedHost | Sisk",
    "keywords": "Field XForwardedHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. public const string XForwardedHost = \"X-Forwarded-Host\" Returns string The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XFrameOptions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XFrameOptions.html",
    "title": "Field XFrameOptions | Sisk",
    "keywords": "Field XFrameOptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. public const string XFrameOptions = \"X-Frame-Options\" Returns string The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XPoweredBy.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XPoweredBy.html",
    "title": "Field XPoweredBy | Sisk",
    "keywords": "Field XPoweredBy Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes. public const string XPoweredBy = \"X-Powered-By\" Returns string The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XRequestID.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XRequestID.html",
    "title": "Field XRequestID | Sisk",
    "keywords": "Field XRequestID Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server. public const string XRequestID = \"X-Request-ID\" Returns string The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XUACompatible.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XUACompatible.html",
    "title": "Field XUACompatible | Sisk",
    "keywords": "Field XUACompatible Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions. public const string XUACompatible = \"X-UA-Compatible\" Returns string The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.html",
    "title": "Class HttpKnownHeaderNames | Sisk",
    "keywords": "Class HttpKnownHeaderNames Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides most of the most commonly known HTTP headers for constants. public static class HttpKnownHeaderNames Inheritance object HttpKnownHeaderNames Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Fields Accept The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. AcceptCH The HTTP Accept-CH header. Specifies the client hints that the server supports, allowing clients to provide additional information about their capabilities. AcceptCharset The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. AcceptEncoding The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. AcceptLanguage The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. AcceptPatch The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. AcceptPost The HTTP Accept-Post header. Specifies which media types are accepted by the server in a POST request. AcceptRanges The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. AccessControlAllowCredentials The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. AccessControlAllowHeaders The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. AccessControlAllowMethods The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. AccessControlAllowOrigin The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. AccessControlExposeHeaders The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. AccessControlMaxAge The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. Age The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. Allow The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. AltSvc The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol. Authorization The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. CacheControl The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. Connection The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections. ContentDisposition The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. ContentEncoding The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. ContentLanguage The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. ContentLength The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. ContentLocation The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. ContentMD5 The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data. ContentRange The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges. ContentSecurityPolicy The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. ContentType The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. Cookie The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. Cookie2 The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. Date The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response. Dnt The HTTP DNT header. The HTTP DNT (Do Not Track) request header indicates the user's tracking preference. ETag The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. Expect The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. Expires The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. Host The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. IfMatch The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. IfModifiedSince The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfNoneMatch The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag. IfRange The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. IfUnmodifiedSince The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. KeepAlive The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests. LastModified The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version. Link The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking. Location The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect. MaxForwards The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. Origin The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. P3P The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled. Pragma The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. ProxyAuthenticate The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. ProxyAuthorization The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. ProxyConnection The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction. PublicKeyPins The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate. Range The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. Referer The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. RetryAfter The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. SecGPC The HTTP Sec-GPC header. The HTTP Sec-GPC request header is part of the Global Privacy Control (GPC) mechanism to indicate whether the user consents to a website or service selling or sharing their personal information with third parties. SecWebSocketAccept The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request. SecWebSocketExtensions The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities. SecWebSocketKey The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid. SecWebSocketProtocol The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection. SecWebSocketVersion The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use. Server The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes. SetCookie The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. SetCookie2 The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. StrictTransportSecurity The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks. TE The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. TSV The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols. Trailer The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata. TransferEncoding The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user. Upgrade The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2. UpgradeInsecureRequests The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP. UserAgent The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. Vary The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. Via The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. WWWAuthenticate The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. Warning The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation. XContentDuration The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files. XContentTypeOptions The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type. XForwardedFor The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. XForwardedHost The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. XFrameOptions The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. XPoweredBy The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes. XRequestID The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server. XUACompatible The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Http.HttpRequest.Abort.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Abort.html",
    "title": "Method Abort | Sisk",
    "keywords": "Method Abort Namespace Sisk.Core.Http Assembly Sisk.Core.dll Abort() Immediately closes the connection with the client and does not send any response. public HttpResponse Abort() Returns HttpResponse Remarks This method returns an HttpResponse indicated to exit outside the scope of the request context. However, when calling this method, the connection is interrupted instantly."
  },
  "api/Sisk.Core.Http.HttpRequest.Authority.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Authority.html",
    "title": "Property Authority | Sisk",
    "keywords": "Property Authority Namespace Sisk.Core.Http Assembly Sisk.Core.dll Authority Get the requested host header with the port from this HTTP request. public string Authority { get; } Property Value string Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.Bag.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Bag.html",
    "title": "Property Bag | Sisk",
    "keywords": "Property Bag Namespace Sisk.Core.Http Assembly Sisk.Core.dll Bag Gets the managed object which holds data for an entire HTTP session. public TypedValueDictionary Bag { get; } Property Value TypedValueDictionary Remarks This property is an shortcut for RequestBag property."
  },
  "api/Sisk.Core.Http.HttpRequest.Body.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Body.html",
    "title": "Property Body | Sisk",
    "keywords": "Property Body Namespace Sisk.Core.Http Assembly Sisk.Core.dll Body Gets the HTTP request body as string, decoded by the request content encoding. public string Body { get; } Property Value string Remarks When calling this property, the entire content of the request is read into memory and stored in RawBody."
  },
  "api/Sisk.Core.Http.HttpRequest.ContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.ContentLength.html",
    "title": "Property ContentLength | Sisk",
    "keywords": "Property ContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll ContentLength Gets the content length in bytes count. public long ContentLength { get; } Property Value long Remarks This value can be negative if the content length is unknown."
  },
  "api/Sisk.Core.Http.HttpRequest.Context.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Context.html",
    "title": "Property Context | Sisk",
    "keywords": "Property Context Namespace Sisk.Core.Http Assembly Sisk.Core.dll Context Gets the HttpContext for this request. public HttpContext Context { get; } Property Value HttpContext"
  },
  "api/Sisk.Core.Http.HttpRequest.Cookies.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Cookies.html",
    "title": "Property Cookies | Sisk",
    "keywords": "Property Cookies Namespace Sisk.Core.Http Assembly Sisk.Core.dll Cookies Gets an StringKeyStoreCollection object with all cookies set in this request. public StringKeyStoreCollection Cookies { get; } Property Value StringKeyStoreCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.DefaultJsonSerializerOptions.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.DefaultJsonSerializerOptions.html",
    "title": "Property DefaultJsonSerializerOptions | Sisk",
    "keywords": "Property DefaultJsonSerializerOptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll DefaultJsonSerializerOptions Gets or sets the default options used for JSON serialization. public static JsonSerializerOptions? DefaultJsonSerializerOptions { get; set; } Property Value JsonSerializerOptions Remarks These options are used by default when serializing or deserializing JSON data through GetJsonContent<T>(), unless custom options are provided. See JsonSerializerOptions for more information on available options."
  },
  "api/Sisk.Core.Http.HttpRequest.FullPath.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.FullPath.html",
    "title": "Property FullPath | Sisk",
    "keywords": "Property FullPath Namespace Sisk.Core.Http Assembly Sisk.Core.dll FullPath Gets the raw, full HTTP request path with the query string. public string FullPath { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.FullUrl.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.FullUrl.html",
    "title": "Property FullUrl | Sisk",
    "keywords": "Property FullUrl Namespace Sisk.Core.Http Assembly Sisk.Core.dll FullUrl Gets the full URL for this request, with scheme, host, port, path and query. public string FullUrl { get; } Property Value string Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.GetBodyContents.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetBodyContents.html",
    "title": "Method GetBodyContents | Sisk",
    "keywords": "Method GetBodyContents Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetBodyContents() Gets the request contents of the body as a byte array. public byte[] GetBodyContents() Returns byte[] A byte array containing the body contents."
  },
  "api/Sisk.Core.Http.HttpRequest.GetBodyContentsAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetBodyContentsAsync.html",
    "title": "Method GetBodyContentsAsync | Sisk",
    "keywords": "Method GetBodyContentsAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetBodyContentsAsync(CancellationToken) Asynchronously reads the request contents as a memory byte array. public Task<Memory<byte>> GetBodyContentsAsync(CancellationToken cancellation = default) Parameters cancellation CancellationToken A CancellationToken to cancel the operation. Returns Task<Memory<byte>> A Task that returns a Memory<T> of bytes containing the body contents."
  },
  "api/Sisk.Core.Http.HttpRequest.GetEventSource.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetEventSource.html",
    "title": "Method GetEventSource | Sisk",
    "keywords": "Method GetEventSource Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetEventSource(string?) Gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in it's event source listening state. public HttpRequestEventSource GetEventSource(string? identifier = null) Parameters identifier string Optional. Defines an label to the EventStream connection, useful for finding this connection's reference later. Returns HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.HttpRequest.GetEventSourceAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetEventSourceAsync.html",
    "title": "Method GetEventSourceAsync | Sisk",
    "keywords": "Method GetEventSourceAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetEventSourceAsync(string?) Asynchronously gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in its event source listening state. public Task<HttpRequestEventSource> GetEventSourceAsync(string? identifier = null) Parameters identifier string Optional. Defines a label to the EventStream connection, useful for finding this connection's reference later. Returns Task<HttpRequestEventSource> A Task that represents the asynchronous operation, containing an HttpRequestEventSource instance representing the event source for this request."
  },
  "api/Sisk.Core.Http.HttpRequest.GetFormContent.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetFormContent.html",
    "title": "Method GetFormContent | Sisk",
    "keywords": "Method GetFormContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetFormContent() Reads the request body and extracts form data parameters from it. public StringKeyStoreCollection GetFormContent() Returns StringKeyStoreCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.GetFormContentAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetFormContentAsync.html",
    "title": "Method GetFormContentAsync | Sisk",
    "keywords": "Method GetFormContentAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetFormContentAsync(CancellationToken) Asynchronously reads the request body and extracts form data parameters from it. public Task<StringKeyStoreCollection> GetFormContentAsync(CancellationToken cancellation = default) Parameters cancellation CancellationToken A CancellationToken to cancel the asynchronous operation. Returns Task<StringKeyStoreCollection>"
  },
  "api/Sisk.Core.Http.HttpRequest.GetJsonContent.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetJsonContent.html",
    "title": "Method GetJsonContent | Sisk",
    "keywords": "Method GetJsonContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetJsonContent<T>(JsonTypeInfo<T>) Deserializes the request body into an object of type T using the provided JsonTypeInfo<T>. public T? GetJsonContent<T>(JsonTypeInfo<T> typeInfo) Parameters typeInfo JsonTypeInfo<T> The JsonTypeInfo<T> to use for deserialization. Returns T The deserialized object, or null if the request body is empty. Type Parameters T The type of the object to deserialize into. GetJsonContent<T>(JsonSerializerOptions?) Deserializes the request body into an object of type T using the provided JsonSerializerOptions. public T? GetJsonContent<T>(JsonSerializerOptions? jsonOptions = null) Parameters jsonOptions JsonSerializerOptions The JsonSerializerOptions to use for deserialization. Returns T The deserialized object, or null if the request body is empty. Type Parameters T The type of the object to deserialize into. GetJsonContent<T>() Deserializes the request body into an object of type T using the default JsonSerializerOptions from DefaultJsonSerializerOptions. public T? GetJsonContent<T>() Returns T The deserialized object, or null if the request body is empty. Type Parameters T The type of the object to deserialize into."
  },
  "api/Sisk.Core.Http.HttpRequest.GetJsonContentAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetJsonContentAsync.html",
    "title": "Method GetJsonContentAsync | Sisk",
    "keywords": "Method GetJsonContentAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetJsonContentAsync<T>(JsonTypeInfo<T>, CancellationToken) Asynchronously deserializes the request body into an object of type T using the provided JsonTypeInfo<T>. public ValueTask<T?> GetJsonContentAsync<T>(JsonTypeInfo<T> typeInfo, CancellationToken cancellation = default) Parameters typeInfo JsonTypeInfo<T> The JsonTypeInfo<T> to use for deserialization. cancellation CancellationToken A CancellationToken to cancel the asynchronous operation. Returns ValueTask<T> A ValueTask<TResult> that represents the asynchronous deserialization operation. Type Parameters T The type of the object to deserialize into. GetJsonContentAsync<T>(JsonSerializerOptions?, CancellationToken) Asynchronously deserializes the request body into an object of type T using the provided JsonSerializerOptions. public ValueTask<T?> GetJsonContentAsync<T>(JsonSerializerOptions? jsonOptions, CancellationToken cancellation = default) Parameters jsonOptions JsonSerializerOptions The JsonSerializerOptions to use for deserialization. cancellation CancellationToken A CancellationToken to cancel the asynchronous operation. Returns ValueTask<T> A ValueTask<TResult> that represents the asynchronous deserialization operation. Type Parameters T The type of the object to deserialize into. GetJsonContentAsync<T>(CancellationToken) Asynchronously deserializes the request body into an object of type T using the default JsonSerializerOptions. public ValueTask<T?> GetJsonContentAsync<T>(CancellationToken cancellation = default) Parameters cancellation CancellationToken A CancellationToken to cancel the asynchronous operation. Returns ValueTask<T> A ValueTask<TResult> that represents the asynchronous deserialization operation. Type Parameters T The type of the object to deserialize into."
  },
  "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContent.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContent.html",
    "title": "Method GetMultipartFormContent | Sisk",
    "keywords": "Method GetMultipartFormContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetMultipartFormContent() Reads the request body and obtains a MultipartFormCollection from it. public MultipartFormCollection GetMultipartFormContent() Returns MultipartFormCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContentAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContentAsync.html",
    "title": "Method GetMultipartFormContentAsync | Sisk",
    "keywords": "Method GetMultipartFormContentAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetMultipartFormContentAsync(CancellationToken) Asynchronously reads the request body and obtains a MultipartFormCollection from it. public Task<MultipartFormCollection> GetMultipartFormContentAsync(CancellationToken cancellation = default) Parameters cancellation CancellationToken A CancellationToken to cancel the asynchronous operation. Returns Task<MultipartFormCollection> A Task that represents the asynchronous operation, containing a MultipartFormCollection instance representing the multipart form content of the request. Exceptions HttpRequestException If an error occurs while parsing the multipart form content."
  },
  "api/Sisk.Core.Http.HttpRequest.GetRawHttpRequest.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetRawHttpRequest.html",
    "title": "Method GetRawHttpRequest | Sisk",
    "keywords": "Method GetRawHttpRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRawHttpRequest(bool, bool) Gets a visual representation of this request. public string GetRawHttpRequest(bool includeBody = true, bool appendExtraInfo = false) Parameters includeBody bool Optional. Defines if the body should be included in the output. appendExtraInfo bool Optional. Appends extra information, such as request id and date into the output. Returns string"
  },
  "api/Sisk.Core.Http.HttpRequest.GetRequestStream.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetRequestStream.html",
    "title": "Method GetRequestStream | Sisk",
    "keywords": "Method GetRequestStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRequestStream() Gets the HTTP request content stream. This property is only available while the content has not been imported by the HTTP server and will invalidate the body content cached in this object. public Stream GetRequestStream() Returns Stream"
  },
  "api/Sisk.Core.Http.HttpRequest.GetResponseStream.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetResponseStream.html",
    "title": "Method GetResponseStream | Sisk",
    "keywords": "Method GetResponseStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetResponseStream() Gets an HTTP response stream for this HTTP request. public HttpResponseStreamManager GetResponseStream() Returns HttpResponseStreamManager"
  },
  "api/Sisk.Core.Http.HttpRequest.GetWebSocket.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetWebSocket.html",
    "title": "Method GetWebSocket | Sisk",
    "keywords": "Method GetWebSocket Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetWebSocket(string?, string?) Accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. public HttpWebSocket GetWebSocket(string? subprotocol = null, string? identifier = null) Parameters subprotocol string Optional. Determines the sub-protocol to plug the websocket in. identifier string Optional. Defines an label to the Web Socket connection, useful for finding this connection's reference later. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.HttpRequest.GetWebSocketAsync.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetWebSocketAsync.html",
    "title": "Method GetWebSocketAsync | Sisk",
    "keywords": "Method GetWebSocketAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetWebSocketAsync(string?, string?) Asynchronously accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. public Task<HttpWebSocket> GetWebSocketAsync(string? subprotocol = null, string? identifier = null) Parameters subprotocol string Optional. Determines the sub-protocol to plug the websocket in. identifier string Optional. Defines an label to the Web Socket connection, useful for finding this connection's reference later. Returns Task<HttpWebSocket> A task that represents the asynchronous operation, returning an instance of HttpWebSocket representing the accepted websocket connection."
  },
  "api/Sisk.Core.Http.HttpRequest.HasContents.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.HasContents.html",
    "title": "Property HasContents | Sisk",
    "keywords": "Property HasContents Namespace Sisk.Core.Http Assembly Sisk.Core.dll HasContents Gets a boolean indicating whether this request has body contents. public bool HasContents { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpRequest.Headers.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Http Assembly Sisk.Core.dll Headers Gets the HTTP request headers. public HttpHeaderCollection Headers { get; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.Host.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Http Assembly Sisk.Core.dll Host Get the requested host (without port) for this HttpRequest. public string? Host { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.IsContentAvailable.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.IsContentAvailable.html",
    "title": "Property IsContentAvailable | Sisk",
    "keywords": "Property IsContentAvailable Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsContentAvailable Gets a boolean indicating whether this request has body contents and whether it has already been read into memory by the server. public bool IsContentAvailable { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpRequest.IsSecure.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.IsSecure.html",
    "title": "Property IsSecure | Sisk",
    "keywords": "Property IsSecure Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSecure Gets a boolean indicating whether this request was locally made by an secure transport context (SSL/TLS) or not. public bool IsSecure { get; } Property Value bool Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.Method.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Http Assembly Sisk.Core.dll Method Gets the HTTP request method. public HttpMethod Method { get; } Property Value HttpMethod"
  },
  "api/Sisk.Core.Http.HttpRequest.Path.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Http Assembly Sisk.Core.dll Path Gets the HTTP request path without the query string. public string Path { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.Query.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Query.html",
    "title": "Property Query | Sisk",
    "keywords": "Property Query Namespace Sisk.Core.Http Assembly Sisk.Core.dll Query Gets the HTTP request query value collection. public StringValueCollection Query { get; } Property Value StringValueCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.QueryString.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.QueryString.html",
    "title": "Property QueryString | Sisk",
    "keywords": "Property QueryString Namespace Sisk.Core.Http Assembly Sisk.Core.dll QueryString Gets the HTTP request URL raw query string, including the '?' char. public string QueryString { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.RawBody.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RawBody.html",
    "title": "Property RawBody | Sisk",
    "keywords": "Property RawBody Namespace Sisk.Core.Http Assembly Sisk.Core.dll RawBody Gets the HTTP request body as a byte array. public byte[] RawBody { get; } Property Value byte[] Remarks When calling this property, the entire content of the request is read into memory."
  },
  "api/Sisk.Core.Http.HttpRequest.RemoteAddress.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RemoteAddress.html",
    "title": "Property RemoteAddress | Sisk",
    "keywords": "Property RemoteAddress Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoteAddress Gets the incoming local IP address from the request. public IPAddress RemoteAddress { get; } Property Value IPAddress"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestEncoding.html",
    "title": "Property RequestEncoding | Sisk",
    "keywords": "Property RequestEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestEncoding Gets an string Encoding that can be used to decode text in this HTTP request. public Encoding RequestEncoding { get; } Property Value Encoding"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestId.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestId.html",
    "title": "Property RequestId | Sisk",
    "keywords": "Property RequestId Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestId Gets a unique random ID for this request. public Guid RequestId { get; } Property Value Guid"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestedAt.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestedAt.html",
    "title": "Property RequestedAt | Sisk",
    "keywords": "Property RequestedAt Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestedAt Gets the moment which the request was received by the server. public DateTime RequestedAt { get; } Property Value DateTime"
  },
  "api/Sisk.Core.Http.HttpRequest.RouteParameters.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RouteParameters.html",
    "title": "Property RouteParameters | Sisk",
    "keywords": "Property RouteParameters Namespace Sisk.Core.Http Assembly Sisk.Core.dll RouteParameters Gets the StringValueCollection object which represents the current route parameters. public StringValueCollection RouteParameters { get; } Property Value StringValueCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.SendTo.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.SendTo.html",
    "title": "Method SendTo | Sisk",
    "keywords": "Method SendTo Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendTo(RouteAction) Calls another handler for this request, preserving the current call-stack frame, and then returns the response from it. This method manages to prevent possible stack overflows. public object SendTo(RouteAction otherCallback) Parameters otherCallback RouteAction Defines the RouteAction method which will handle this request. Returns object"
  },
  "api/Sisk.Core.Http.HttpRequest.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this HttpRequest object. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpRequest.Uri.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Uri.html",
    "title": "Property Uri | Sisk",
    "keywords": "Property Uri Namespace Sisk.Core.Http Assembly Sisk.Core.dll Uri Gets the System.Uri component for this HTTP request requested URL. public Uri Uri { get; } Property Value Uri"
  },
  "api/Sisk.Core.Http.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.html",
    "title": "Class HttpRequest | Sisk",
    "keywords": "Class HttpRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP request received by a Sisk server. public sealed class HttpRequest : IDisposable Inheritance object HttpRequest Implements IDisposable Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Authority Get the requested host header with the port from this HTTP request. Bag Gets the managed object which holds data for an entire HTTP session. Body Gets the HTTP request body as string, decoded by the request content encoding. ContentLength Gets the content length in bytes count. Context Gets the HttpContext for this request. Cookies Gets an StringKeyStoreCollection object with all cookies set in this request. DefaultJsonSerializerOptions Gets or sets the default options used for JSON serialization. FullPath Gets the raw, full HTTP request path with the query string. FullUrl Gets the full URL for this request, with scheme, host, port, path and query. HasContents Gets a boolean indicating whether this request has body contents. Headers Gets the HTTP request headers. Host Get the requested host (without port) for this HttpRequest. IsContentAvailable Gets a boolean indicating whether this request has body contents and whether it has already been read into memory by the server. IsSecure Gets a boolean indicating whether this request was locally made by an secure transport context (SSL/TLS) or not. Method Gets the HTTP request method. Path Gets the HTTP request path without the query string. Query Gets the HTTP request query value collection. QueryString Gets the HTTP request URL raw query string, including the '?' char. RawBody Gets the HTTP request body as a byte array. RemoteAddress Gets the incoming local IP address from the request. RequestEncoding Gets an string Encoding that can be used to decode text in this HTTP request. RequestId Gets a unique random ID for this request. RequestedAt Gets the moment which the request was received by the server. RouteParameters Gets the StringValueCollection object which represents the current route parameters. Uri Gets the System.Uri component for this HTTP request requested URL. Methods Abort() Immediately closes the connection with the client and does not send any response. GetBodyContents() Gets the request contents of the body as a byte array. GetBodyContentsAsync(CancellationToken) Asynchronously reads the request contents as a memory byte array. GetEventSource(string?) Gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in it's event source listening state. GetEventSourceAsync(string?) Asynchronously gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in its event source listening state. GetFormContent() Reads the request body and extracts form data parameters from it. GetFormContentAsync(CancellationToken) Asynchronously reads the request body and extracts form data parameters from it. GetJsonContentAsync<T>(JsonSerializerOptions?, CancellationToken) Asynchronously deserializes the request body into an object of type T using the provided JsonSerializerOptions. GetJsonContentAsync<T>(JsonTypeInfo<T>, CancellationToken) Asynchronously deserializes the request body into an object of type T using the provided JsonTypeInfo<T>. GetJsonContentAsync<T>(CancellationToken) Asynchronously deserializes the request body into an object of type T using the default JsonSerializerOptions. GetJsonContent<T>() Deserializes the request body into an object of type T using the default JsonSerializerOptions from DefaultJsonSerializerOptions. GetJsonContent<T>(JsonSerializerOptions?) Deserializes the request body into an object of type T using the provided JsonSerializerOptions. GetJsonContent<T>(JsonTypeInfo<T>) Deserializes the request body into an object of type T using the provided JsonTypeInfo<T>. GetMultipartFormContent() Reads the request body and obtains a MultipartFormCollection from it. GetMultipartFormContentAsync(CancellationToken) Asynchronously reads the request body and obtains a MultipartFormCollection from it. GetRawHttpRequest(bool, bool) Gets a visual representation of this request. GetRequestStream() Gets the HTTP request content stream. This property is only available while the content has not been imported by the HTTP server and will invalidate the body content cached in this object. GetResponseStream() Gets an HTTP response stream for this HTTP request. GetWebSocket(string?, string?) Accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. GetWebSocketAsync(string?, string?) Asynchronously accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. SendTo(RouteAction) Calls another handler for this request, preserving the current call-stack frame, and then returns the response from it. This method manages to prevent possible stack overflows. ToString() Gets an string representation of this HttpRequest object."
  },
  "api/Sisk.Core.Http.HttpRequestException.html": {
    "href": "api/Sisk.Core.Http.HttpRequestException.html",
    "title": "Class HttpRequestException | Sisk",
    "keywords": "Class HttpRequestException Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an exception that is thrown while a request is being interpreted by the HTTP server. public sealed class HttpRequestException : Exception, ISerializable Inheritance object Exception HttpRequestException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode()"
  },
  "api/Sisk.Core.Http.HttpResponse.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.-ctor.html",
    "title": "Constructor HttpResponse | Sisk",
    "keywords": "Constructor HttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpResponse() Creates an new HttpResponse instance with HTTP OK status code and no content. public HttpResponse() HttpResponse(HttpStatusCode) Creates an new HttpResponse instance with given status code. public HttpResponse(HttpStatusCode status) Parameters status HttpStatusCode The HttpStatusCode of this HTTP response. HttpResponse(int) Creates an new HttpResponse instance with given status code. public HttpResponse(int status) Parameters status int The status code of this HTTP response. HttpResponse(int, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP content. public HttpResponse(int status, HttpContent? content) Parameters status int The status code of this HTTP response. content HttpContent The response content, if any. HttpResponse(HttpContent?) Creates an new HttpResponse instance with given HTTP content, with default status code as 200 OK. public HttpResponse(HttpContent? content) Parameters content HttpContent The response content, if any. HttpResponse(string) Creates an new HttpResponse instanec with given string content and status code as 200 OK. public HttpResponse(string stringContent) Parameters stringContent string The UTF-8 string content. HttpResponse(HttpStatusCode, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP contents. public HttpResponse(HttpStatusCode status, HttpContent? content) Parameters status HttpStatusCode The HttpStatusCode of this HTTP response. content HttpContent The response content, if any. HttpResponse(in HttpStatusInformation) Creates an new HttpResponse instance with given status code. public HttpResponse(in HttpStatusInformation status) Parameters status HttpStatusInformation The HttpStatusInformation of this HTTP response."
  },
  "api/Sisk.Core.Http.HttpResponse.Content.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Content.html",
    "title": "Property Content | Sisk",
    "keywords": "Property Content Namespace Sisk.Core.Http Assembly Sisk.Core.dll Content Gets or sets the HTTP response body contents. public HttpContent? Content { get; set; } Property Value HttpContent"
  },
  "api/Sisk.Core.Http.HttpResponse.Equals.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool"
  },
  "api/Sisk.Core.Http.HttpResponse.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.HttpResponse.GetRawHttpResponse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.GetRawHttpResponse.html",
    "title": "Method GetRawHttpResponse | Sisk",
    "keywords": "Method GetRawHttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRawHttpResponse(bool) Gets a visual representation of this HTTP response. public string GetRawHttpResponse(bool includeBody = true) Parameters includeBody bool Determines whether the message content will also be included in the return from this function. Returns string"
  },
  "api/Sisk.Core.Http.HttpResponse.Headers.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Http Assembly Sisk.Core.dll Headers Gets or sets the HttpHeaderCollection instance of the HTTP response headers. public HttpHeaderCollection Headers { get; set; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpResponse.Refuse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Refuse.html",
    "title": "Method Refuse | Sisk",
    "keywords": "Method Refuse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Refuse() Creates an HttpResponse object which closes the connection with the client immediately (ECONNRESET). public static HttpResponse Refuse() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.HttpResponse.SendChunked.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.SendChunked.html",
    "title": "Property SendChunked | Sisk",
    "keywords": "Property SendChunked Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendChunked Gets or sets whether the HTTP response will be sent chunked. When setting this property to true, the Content-Length header is automatically omitted. public bool SendChunked { get; set; } Property Value bool Remarks The response is always sent as chunked when it is not possible to determine the size of the content to send."
  },
  "api/Sisk.Core.Http.HttpResponse.SetCookie.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.SetCookie.html",
    "title": "Method SetCookie | Sisk",
    "keywords": "Method SetCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(Cookie cookie) Parameters cookie Cookie The cookie object. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value) Parameters name string The cookie name. value string The cookie value. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter."
  },
  "api/Sisk.Core.Http.HttpResponse.Status.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Status.html",
    "title": "Property Status | Sisk",
    "keywords": "Property Status Namespace Sisk.Core.Http Assembly Sisk.Core.dll Status Gets or sets the HTTP status code and description for this HTTP response. public HttpStatusInformation Status { get; set; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpResponse.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpResponse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.html",
    "title": "Class HttpResponse | Sisk",
    "keywords": "Class HttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP Response. public class HttpResponse Inheritance object HttpResponse Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, HttpContent) HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, string) HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) HttpResponseExtensions.WithCookie<THttpResponse>(THttpResponse, Cookie) HttpResponseExtensions.WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, StringKeyStoreCollection) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, NameValueCollection) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, string, string) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, int) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Constructors HttpResponse() Creates an new HttpResponse instance with HTTP OK status code and no content. HttpResponse(in HttpStatusInformation) Creates an new HttpResponse instance with given status code. HttpResponse(int) Creates an new HttpResponse instance with given status code. HttpResponse(int, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP content. HttpResponse(HttpContent?) Creates an new HttpResponse instance with given HTTP content, with default status code as 200 OK. HttpResponse(HttpStatusCode) Creates an new HttpResponse instance with given status code. HttpResponse(HttpStatusCode, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP contents. HttpResponse(string) Creates an new HttpResponse instanec with given string content and status code as 200 OK. Properties Content Gets or sets the HTTP response body contents. Headers Gets or sets the HttpHeaderCollection instance of the HTTP response headers. SendChunked Gets or sets whether the HTTP response will be sent chunked. When setting this property to true, the Content-Length header is automatically omitted. Status Gets or sets the HTTP status code and description for this HTTP response. Methods Equals(object?) GetHashCode() GetRawHttpResponse(bool) Gets a visual representation of this HTTP response. Refuse() Creates an HttpResponse object which closes the connection with the client immediately (ECONNRESET). SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. ToString()"
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithContent.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithContent.html",
    "title": "Method WithContent | Sisk",
    "keywords": "Method WithContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithContent<THttpResponse>(THttpResponse, string) Sets an UTF-8 string as the HTTP response content in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, string content) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content string The UTF-8 string containing the response body. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) Sets an string as the HTTP response content in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, string content, Encoding? encoding, string mimeType) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content string The string containing the response body. encoding Encoding The encoding to encode the string message. mimeType string The mime-type of the response content. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithContent<THttpResponse>(THttpResponse, HttpContent) Sets an HttpContent as the HTTP content body in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, HttpContent content) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content HttpContent The HTTP content object. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithCookie.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithCookie.html",
    "title": "Method WithCookie | Sisk",
    "keywords": "Method WithCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public static THttpResponse WithCookie<THttpResponse>(this THttpResponse response, string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter. Returns THttpResponse Type Parameters THttpResponse The type which implements HttpResponse. WithCookie<THttpResponse>(THttpResponse, Cookie) Sets a cookie and sends it in the response to be set by the client. public static THttpResponse WithCookie<THttpResponse>(this THttpResponse response, Cookie cookie) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. cookie Cookie The cookie object. Returns THttpResponse Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithHeader.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithHeader.html",
    "title": "Method WithHeader | Sisk",
    "keywords": "Method WithHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithHeader<THttpResponse>(THttpResponse, string, string) Sets an HTTP header in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, string headerName, string headerValue) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headerName string The name of the header. headerValue string The header value. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithHeader<THttpResponse>(THttpResponse, NameValueCollection) Sets an list of HTTP headers in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, NameValueCollection headers) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headers NameValueCollection The collection of HTTP headers. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithHeader<THttpResponse>(THttpResponse, StringKeyStoreCollection) Sets an list of HTTP headers in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, StringKeyStoreCollection headers) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headers StringKeyStoreCollection The collection of HTTP headers. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithStatus.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithStatus.html",
    "title": "Method WithStatus | Sisk",
    "keywords": "Method WithStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithStatus<THttpResponse>(THttpResponse, int) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, int httpStatusCode) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. httpStatusCode int The HTTP status code. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, HttpStatusCode httpStatusCode) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. httpStatusCode HttpStatusCode The HTTP status code. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, in HttpStatusInformation statusInformation) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. statusInformation HttpStatusInformation The HTTP status information. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.html",
    "title": "Class HttpResponseExtensions | Sisk",
    "keywords": "Class HttpResponseExtensions Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides useful extensions for HttpResponse objects. public static class HttpResponseExtensions Inheritance object HttpResponseExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WithContent<THttpResponse>(THttpResponse, HttpContent) Sets an HttpContent as the HTTP content body in this HttpResponse. WithContent<THttpResponse>(THttpResponse, string) Sets an UTF-8 string as the HTTP response content in this HttpResponse. WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) Sets an string as the HTTP response content in this HttpResponse. WithCookie<THttpResponse>(THttpResponse, Cookie) Sets a cookie and sends it in the response to be set by the client. WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. WithHeader<THttpResponse>(THttpResponse, StringKeyStoreCollection) Sets an list of HTTP headers in this HttpResponse. WithHeader<THttpResponse>(THttpResponse, NameValueCollection) Sets an list of HTTP headers in this HttpResponse. WithHeader<THttpResponse>(THttpResponse, string, string) Sets an HTTP header in this HttpResponse. WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) Sets the HTTP status code of this HttpResponse. WithStatus<THttpResponse>(THttpResponse, int) Sets the HTTP status code of this HttpResponse. WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Sets the HTTP status code of this HttpResponse."
  },
  "api/Sisk.Core.Http.HttpServer.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpServer.-ctor.html",
    "title": "Constructor HttpServer | Sisk",
    "keywords": "Constructor HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServer() Creates an new HttpServer instance with no predefined configuration. public HttpServer() HttpServer(HttpServerConfiguration) Creates a new default configuration HttpServer instance with the given Route and server configuration. public HttpServer(HttpServerConfiguration configuration) Parameters configuration HttpServerConfiguration The configuration object of the server."
  },
  "api/Sisk.Core.Http.HttpServer.CreateBuilder.html": {
    "href": "api/Sisk.Core.Http.HttpServer.CreateBuilder.html",
    "title": "Method CreateBuilder | Sisk",
    "keywords": "Method CreateBuilder Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateBuilder(Action<HttpServerHostContextBuilder>) Builds an HttpServerHostContext context invoking the handler on it. public static HttpServerHostContextBuilder CreateBuilder(Action<HttpServerHostContextBuilder> handler) Parameters handler Action<HttpServerHostContextBuilder> The action which will configure the host context. Returns HttpServerHostContextBuilder CreateBuilder(ushort) Builds an empty HttpServerHostContext context with predefined listening port. public static HttpServerHostContextBuilder CreateBuilder(ushort port) Parameters port ushort Returns HttpServerHostContextBuilder CreateBuilder(string) Builds an empty HttpServerHostContext context with predefined listening host string. public static HttpServerHostContextBuilder CreateBuilder(string listeningHost) Parameters listeningHost string Returns HttpServerHostContextBuilder CreateBuilder() Builds an empty HttpServerHostContext context. public static HttpServerHostContextBuilder CreateBuilder() Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.HttpServer.CreateListener.html": {
    "href": "api/Sisk.Core.Http.HttpServer.CreateListener.html",
    "title": "Method CreateListener | Sisk",
    "keywords": "Method CreateListener Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateListener() Gets an listening and running HTTP server in an random port. public static HttpServer CreateListener() Returns HttpServer CreateListener(ushort) Gets an listening and running HTTP server in the specified port. public static HttpServer CreateListener(ushort port) Parameters port ushort The listening port of the HTTP server. Returns HttpServer CreateListener(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an listening and running HTTP server in the specified port. public static HttpServer CreateListener(ushort insecureHttpPort, out HttpServerConfiguration configuration, out ListeningHost host, out Router router) Parameters insecureHttpPort ushort The insecure port where the HTTP server will listen. configuration HttpServerConfiguration The HttpServerConfiguration object issued from this method. host ListeningHost The ListeningHost object issued from this method. router Router The Router object issued from this method. Returns HttpServer"
  },
  "api/Sisk.Core.Http.HttpServer.Dispose.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. public void Dispose()"
  },
  "api/Sisk.Core.Http.HttpServer.Emit.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Emit.html",
    "title": "Method Emit | Sisk",
    "keywords": "Method Emit Namespace Sisk.Core.Http Assembly Sisk.Core.dll Emit(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an non-listening HTTP server with configuration, listening host, and router. public static HttpServer Emit(ushort insecureHttpPort, out HttpServerConfiguration configuration, out ListeningHost host, out Router router) Parameters insecureHttpPort ushort The insecure port where the HTTP server will listen. configuration HttpServerConfiguration The HttpServerConfiguration object issued from this method. host ListeningHost The ListeningHost object issued from this method. router Router The Router object issued from this method. Returns HttpServer"
  },
  "api/Sisk.Core.Http.HttpServer.EventSources.html": {
    "href": "api/Sisk.Core.Http.HttpServer.EventSources.html",
    "title": "Property EventSources | Sisk",
    "keywords": "Property EventSources Namespace Sisk.Core.Http Assembly Sisk.Core.dll EventSources Gets an HttpEventSourceCollection with active event source connections in this HTTP server. public HttpEventSourceCollection EventSources { get; } Property Value HttpEventSourceCollection"
  },
  "api/Sisk.Core.Http.HttpServer.IsDynamicCodeSupported.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsDynamicCodeSupported.html",
    "title": "Property IsDynamicCodeSupported | Sisk",
    "keywords": "Property IsDynamicCodeSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsDynamicCodeSupported Gets an bool indicating if the current environment supports dynamic code or it's running in an AOT assembly. public static bool IsDynamicCodeSupported { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.IsListening.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsListening.html",
    "title": "Property IsListening | Sisk",
    "keywords": "Property IsListening Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsListening Gets an boolean indicating if this HTTP server is running and listening. public bool IsListening { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.IsSupported.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsSupported.html",
    "title": "Property IsSupported | Sisk",
    "keywords": "Property IsSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSupported Gets an bool indicating if Sisk can be used with the current environment. public static bool IsSupported { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.ListeningPrefixes.html": {
    "href": "api/Sisk.Core.Http.HttpServer.ListeningPrefixes.html",
    "title": "Property ListeningPrefixes | Sisk",
    "keywords": "Property ListeningPrefixes Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningPrefixes Gets an string array containing all URL prefixes which this HTTP server is listening to. public string[] ListeningPrefixes { get; } Property Value string[]"
  },
  "api/Sisk.Core.Http.HttpServer.PoweredBy.html": {
    "href": "api/Sisk.Core.Http.HttpServer.PoweredBy.html",
    "title": "Property PoweredBy | Sisk",
    "keywords": "Property PoweredBy Namespace Sisk.Core.Http Assembly Sisk.Core.dll PoweredBy Gets the X-Powered-By Sisk header value. public static string PoweredBy { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpServer.RegisterHandler.html": {
    "href": "api/Sisk.Core.Http.HttpServer.RegisterHandler.html",
    "title": "Method RegisterHandler | Sisk",
    "keywords": "Method RegisterHandler Namespace Sisk.Core.Http Assembly Sisk.Core.dll RegisterHandler<T>() Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. public void RegisterHandler<T>() where T : HttpServerHandler, new() Type Parameters T The handler which implements HttpServerHandler. RegisterHandler(HttpServerHandler) Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. public void RegisterHandler(HttpServerHandler obj) Parameters obj HttpServerHandler The instance of the server handler."
  },
  "api/Sisk.Core.Http.HttpServer.Restart.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Restart.html",
    "title": "Method Restart | Sisk",
    "keywords": "Method Restart Namespace Sisk.Core.Http Assembly Sisk.Core.dll Restart() Restarts this HTTP server, sending all processing responses and starting them again, reading the listening ports again. public void Restart()"
  },
  "api/Sisk.Core.Http.HttpServer.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.HttpServer.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServerConfiguration Gets or sets the Server Configuration object. public HttpServerConfiguration ServerConfiguration { get; set; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.HttpServer.SiskVersion.html": {
    "href": "api/Sisk.Core.Http.HttpServer.SiskVersion.html",
    "title": "Property SiskVersion | Sisk",
    "keywords": "Property SiskVersion Namespace Sisk.Core.Http Assembly Sisk.Core.dll SiskVersion Gets the current Sisk version. public static Version SiskVersion { get; } Property Value Version"
  },
  "api/Sisk.Core.Http.HttpServer.Start.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http Assembly Sisk.Core.dll Start() Starts listening to the set port and handling requests on this server. public void Start()"
  },
  "api/Sisk.Core.Http.HttpServer.Stop.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Stop.html",
    "title": "Method Stop | Sisk",
    "keywords": "Method Stop Namespace Sisk.Core.Http Assembly Sisk.Core.dll Stop() Stops the server from listening and stops the request handler. public void Stop()"
  },
  "api/Sisk.Core.Http.HttpServer.WaitNext.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WaitNext.html",
    "title": "Method WaitNext | Sisk",
    "keywords": "Method WaitNext Namespace Sisk.Core.Http Assembly Sisk.Core.dll WaitNext() Waits for the next execution result from the server. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. public HttpServerExecutionResult WaitNext() Returns HttpServerExecutionResult Remarks Calling this method, it starts the HTTP server if it ins't started yet."
  },
  "api/Sisk.Core.Http.HttpServer.WaitNextAsync.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WaitNextAsync.html",
    "title": "Method WaitNextAsync | Sisk",
    "keywords": "Method WaitNextAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WaitNextAsync() Waits for the next execution result from the server asynchronously. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. public Task<HttpServerExecutionResult> WaitNextAsync() Returns Task<HttpServerExecutionResult> Remarks Calling this method, it starts the HTTP server if it ins't started yet."
  },
  "api/Sisk.Core.Http.HttpServer.WebSockets.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WebSockets.html",
    "title": "Property WebSockets | Sisk",
    "keywords": "Property WebSockets Namespace Sisk.Core.Http Assembly Sisk.Core.dll WebSockets Gets an HttpWebSocketConnectionCollection with active Web Sockets connections in this HTTP server. public HttpWebSocketConnectionCollection WebSockets { get; } Property Value HttpWebSocketConnectionCollection"
  },
  "api/Sisk.Core.Http.HttpServer.html": {
    "href": "api/Sisk.Core.Http.HttpServer.html",
    "title": "Class HttpServer | Sisk",
    "keywords": "Class HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides an lightweight HTTP server powered by Sisk. public sealed class HttpServer : IDisposable Inheritance object HttpServer Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServer() Creates an new HttpServer instance with no predefined configuration. HttpServer(HttpServerConfiguration) Creates a new default configuration HttpServer instance with the given Route and server configuration. Properties EventSources Gets an HttpEventSourceCollection with active event source connections in this HTTP server. IsDynamicCodeSupported Gets an bool indicating if the current environment supports dynamic code or it's running in an AOT assembly. IsListening Gets an boolean indicating if this HTTP server is running and listening. IsSupported Gets an bool indicating if Sisk can be used with the current environment. ListeningPrefixes Gets an string array containing all URL prefixes which this HTTP server is listening to. PoweredBy Gets the X-Powered-By Sisk header value. ServerConfiguration Gets or sets the Server Configuration object. SiskVersion Gets the current Sisk version. WebSockets Gets an HttpWebSocketConnectionCollection with active Web Sockets connections in this HTTP server. Methods CreateBuilder() Builds an empty HttpServerHostContext context. CreateBuilder(Action<HttpServerHostContextBuilder>) Builds an HttpServerHostContext context invoking the handler on it. CreateBuilder(string) Builds an empty HttpServerHostContext context with predefined listening host string. CreateBuilder(ushort) Builds an empty HttpServerHostContext context with predefined listening port. CreateListener() Gets an listening and running HTTP server in an random port. CreateListener(ushort) Gets an listening and running HTTP server in the specified port. CreateListener(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an listening and running HTTP server in the specified port. Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. Emit(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an non-listening HTTP server with configuration, listening host, and router. RegisterHandler(HttpServerHandler) Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. RegisterHandler<T>() Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. Restart() Restarts this HTTP server, sending all processing responses and starting them again, reading the listening ports again. Start() Starts listening to the set port and handling requests on this server. Stop() Stops the server from listening and stops the request handler. WaitNext() Waits for the next execution result from the server. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. WaitNextAsync() Waits for the next execution result from the server asynchronously. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.-ctor.html",
    "title": "Constructor HttpServerConfiguration | Sisk",
    "keywords": "Constructor HttpServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServerConfiguration() Creates an new HttpServerConfiguration instance with no parameters. public HttpServerConfiguration()"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsFormat.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsFormat.html",
    "title": "Property AccessLogsFormat | Sisk",
    "keywords": "Property AccessLogsFormat Namespace Sisk.Core.Http Assembly Sisk.Core.dll AccessLogsFormat Gets or sets the access logging format for incoming HTTP requests. public string AccessLogsFormat { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsStream.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsStream.html",
    "title": "Property AccessLogsStream | Sisk",
    "keywords": "Property AccessLogsStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll AccessLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server access messages to. public LogStream? AccessLogsStream { get; set; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AsyncRequestProcessing.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AsyncRequestProcessing.html",
    "title": "Property AsyncRequestProcessing | Sisk",
    "keywords": "Property AsyncRequestProcessing Namespace Sisk.Core.Http Assembly Sisk.Core.dll AsyncRequestProcessing Gets or sets whether the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. public bool AsyncRequestProcessing { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable.html",
    "title": "Property ConvertIAsyncEnumerableIntoEnumerable | Sisk",
    "keywords": "Property ConvertIAsyncEnumerableIntoEnumerable Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConvertIAsyncEnumerableIntoEnumerable Gets or sets whether the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. public bool ConvertIAsyncEnumerableIntoEnumerable { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.Dispose.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() Frees the resources and invalidates this instance. public void Dispose()"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.DisposeDisposableContextValues.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.DisposeDisposableContextValues.html",
    "title": "Property DisposeDisposableContextValues | Sisk",
    "keywords": "Property DisposeDisposableContextValues Namespace Sisk.Core.Http Assembly Sisk.Core.dll DisposeDisposableContextValues Gets or sets whether the HTTP server should dispose all IDisposable values in the HttpContext bag when an HTTP session is closed. public bool DisposeDisposableContextValues { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression.html",
    "title": "Property EnableAutomaticResponseCompression | Sisk",
    "keywords": "Property EnableAutomaticResponseCompression Namespace Sisk.Core.Http Assembly Sisk.Core.dll EnableAutomaticResponseCompression Gets or sets whether the HTTP server should automatically compress response content bodies using request-allowed encoding algorithms when possible. public bool EnableAutomaticResponseCompression { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ErrorsLogsStream.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ErrorsLogsStream.html",
    "title": "Property ErrorsLogsStream | Sisk",
    "keywords": "Property ErrorsLogsStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll ErrorsLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server error transcriptions to. public LogStream? ErrorsLogsStream { get; set; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ForceTrailingSlash.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ForceTrailingSlash.html",
    "title": "Property ForceTrailingSlash | Sisk",
    "keywords": "Property ForceTrailingSlash Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForceTrailingSlash Gets or sets whether the HTTP server should automatically rewrite GET requests to end their path with /. This is applyable only to non-Regex routes. public bool ForceTrailingSlash { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ForwardingResolver.html",
    "title": "Property ForwardingResolver | Sisk",
    "keywords": "Property ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForwardingResolver Gets or sets an object that is responsible for resolving the client address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. public ForwardingResolver? ForwardingResolver { get; set; } Property Value ForwardingResolver"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.IdleConnectionTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.IdleConnectionTimeout.html",
    "title": "Property IdleConnectionTimeout | Sisk",
    "keywords": "Property IdleConnectionTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll IdleConnectionTimeout Gets or sets the maximum time allowed for an idle connection. public TimeSpan IdleConnectionTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.IncludeRequestIdHeader.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.IncludeRequestIdHeader.html",
    "title": "Property IncludeRequestIdHeader | Sisk",
    "keywords": "Property IncludeRequestIdHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll IncludeRequestIdHeader Gets or sets whether the server should include the \"X-Request-Id\" header in response headers. public bool IncludeRequestIdHeader { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.KeepAlive.html",
    "title": "Property KeepAlive | Sisk",
    "keywords": "Property KeepAlive Namespace Sisk.Core.Http Assembly Sisk.Core.dll KeepAlive Gets or sets whether the client should mantain an persistent connection with the HTTP server. public bool KeepAlive { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ListeningHosts.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ListeningHosts.html",
    "title": "Property ListeningHosts | Sisk",
    "keywords": "Property ListeningHosts Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHosts Gets or sets the listening hosts repository that the HttpServer instance will listen to. public ListeningHostRepository ListeningHosts { get; set; } Property Value ListeningHostRepository"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength.html",
    "title": "Property MaximumContentLength | Sisk",
    "keywords": "Property MaximumContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll MaximumContentLength Gets or sets the maximum size of a request body before it is closed by the socket. public long MaximumContentLength { get; set; } Property Value long Remarks Leave it as \"0\" to set the maximum content length to unlimited."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.NormalizeHeadersEncodings.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.NormalizeHeadersEncodings.html",
    "title": "Property NormalizeHeadersEncodings | Sisk",
    "keywords": "Property NormalizeHeadersEncodings Namespace Sisk.Core.Http Assembly Sisk.Core.dll NormalizeHeadersEncodings Gets or sets whether the HTTP server should convert request headers encoding to the content encoding. public bool NormalizeHeadersEncodings { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.OptionsLogMode.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.OptionsLogMode.html",
    "title": "Property OptionsLogMode | Sisk",
    "keywords": "Property OptionsLogMode Namespace Sisk.Core.Http Assembly Sisk.Core.dll OptionsLogMode Gets or sets the log mode that the HTTP server should use to log OPTIONS requests. public LogOutput OptionsLogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.RemoteRequestsAction.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.RemoteRequestsAction.html",
    "title": "Property RemoteRequestsAction | Sisk",
    "keywords": "Property RemoteRequestsAction Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoteRequestsAction Gets or sets the server's action when it receives an HTTP request outside the local host. public RequestListenAction RemoteRequestsAction { get; set; } Property Value RequestListenAction Remarks It is recommended to use Drop in this property when working with a reverse proxy or in environments where the service is not directly exposed to the internet."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.SendSiskHeader.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.SendSiskHeader.html",
    "title": "Property SendSiskHeader | Sisk",
    "keywords": "Property SendSiskHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendSiskHeader Gets or sets whether the HTTP server should send the X-Powered-By header in all responses. public bool SendSiskHeader { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions.html",
    "title": "Property ThrowExceptions | Sisk",
    "keywords": "Property ThrowExceptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll ThrowExceptions Gets or sets whether the server should throw exceptions instead of reporting it on HttpServerExecutionStatus if any is thrown while processing requests. public bool ThrowExceptions { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.html",
    "title": "Class HttpServerConfiguration | Sisk",
    "keywords": "Class HttpServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides execution parameters for an HttpServer. public sealed class HttpServerConfiguration : IDisposable Inheritance object HttpServerConfiguration Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServerConfiguration() Creates an new HttpServerConfiguration instance with no parameters. Properties AccessLogsFormat Gets or sets the access logging format for incoming HTTP requests. AccessLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server access messages to. AsyncRequestProcessing Gets or sets whether the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. ConvertIAsyncEnumerableIntoEnumerable Gets or sets whether the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. DisposeDisposableContextValues Gets or sets whether the HTTP server should dispose all IDisposable values in the HttpContext bag when an HTTP session is closed. EnableAutomaticResponseCompression Gets or sets whether the HTTP server should automatically compress response content bodies using request-allowed encoding algorithms when possible. ErrorsLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server error transcriptions to. ForceTrailingSlash Gets or sets whether the HTTP server should automatically rewrite GET requests to end their path with /. This is applyable only to non-Regex routes. ForwardingResolver Gets or sets an object that is responsible for resolving the client address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. IdleConnectionTimeout Gets or sets the maximum time allowed for an idle connection. IncludeRequestIdHeader Gets or sets whether the server should include the \"X-Request-Id\" header in response headers. KeepAlive Gets or sets whether the client should mantain an persistent connection with the HTTP server. ListeningHosts Gets or sets the listening hosts repository that the HttpServer instance will listen to. MaximumContentLength Gets or sets the maximum size of a request body before it is closed by the socket. NormalizeHeadersEncodings Gets or sets whether the HTTP server should convert request headers encoding to the content encoding. OptionsLogMode Gets or sets the log mode that the HTTP server should use to log OPTIONS requests. RemoteRequestsAction Gets or sets the server's action when it receives an HTTP request outside the local host. SendSiskHeader Gets or sets whether the HTTP server should send the X-Powered-By header in all responses. ThrowExceptions Gets or sets whether the server should throw exceptions instead of reporting it on HttpServerExecutionStatus if any is thrown while processing requests. Methods Dispose() Frees the resources and invalidates this instance."
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Context.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Context.html",
    "title": "Property Context | Sisk",
    "keywords": "Property Context Namespace Sisk.Core.Http Assembly Sisk.Core.dll Context Gets the HttpContext of this execution result. public HttpContext Context { get; } Property Value HttpContext"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Elapsed.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Elapsed.html",
    "title": "Property Elapsed | Sisk",
    "keywords": "Property Elapsed Namespace Sisk.Core.Http Assembly Sisk.Core.dll Elapsed Gets the total processing time of the HTTP session. public TimeSpan Elapsed { get; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.IsSuccessStatus.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.IsSuccessStatus.html",
    "title": "Property IsSuccessStatus | Sisk",
    "keywords": "Property IsSuccessStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSuccessStatus Gets an boolean indicating if this execution status is an success status. public bool IsSuccessStatus { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Request.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Request.html",
    "title": "Property Request | Sisk",
    "keywords": "Property Request Namespace Sisk.Core.Http Assembly Sisk.Core.dll Request Gets the HttpRequest received in this diagnosis. public HttpRequest Request { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.RequestSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.RequestSize.html",
    "title": "Property RequestSize | Sisk",
    "keywords": "Property RequestSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestSize Gets the estimated request size in bytes. public long RequestSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Response.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Response.html",
    "title": "Property Response | Sisk",
    "keywords": "Property Response Namespace Sisk.Core.Http Assembly Sisk.Core.dll Response Gets the resulted HttpResponse send by the router, if any. This object can be null if the server didn't sent any response to the client. public HttpResponse? Response { get; } Property Value HttpResponse"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.ResponseSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.ResponseSize.html",
    "title": "Property ResponseSize | Sisk",
    "keywords": "Property ResponseSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll ResponseSize Gets the estimated response size in bytes, if any. public long ResponseSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.ServerException.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.ServerException.html",
    "title": "Property ServerException | Sisk",
    "keywords": "Property ServerException Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServerException Gets the exception that was thrown when executing the route, if any. public Exception? ServerException { get; } Property Value Exception"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Status.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Status.html",
    "title": "Property Status | Sisk",
    "keywords": "Property Status Namespace Sisk.Core.Http Assembly Sisk.Core.dll Status Gets the status of server operation. public HttpServerExecutionStatus Status { get; } Property Value HttpServerExecutionStatus"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.html",
    "title": "Class HttpServerExecutionResult | Sisk",
    "keywords": "Class HttpServerExecutionResult Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the results of an request execution on the HTTP server. public sealed class HttpServerExecutionResult Inheritance object HttpServerExecutionResult Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Context Gets the HttpContext of this execution result. Elapsed Gets the total processing time of the HTTP session. IsSuccessStatus Gets an boolean indicating if this execution status is an success status. Request Gets the HttpRequest received in this diagnosis. RequestSize Gets the estimated request size in bytes. Response Gets the resulted HttpResponse send by the router, if any. This object can be null if the server didn't sent any response to the client. ResponseSize Gets the estimated response size in bytes, if any. ServerException Gets the exception that was thrown when executing the route, if any. Status Gets the status of server operation."
  },
  "api/Sisk.Core.Http.HttpServerExecutionStatus.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionStatus.html",
    "title": "Enum HttpServerExecutionStatus | Sisk",
    "keywords": "Enum HttpServerExecutionStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the status of an execution of a request on an HttpServer. public enum HttpServerExecutionStatus Fields ConnectionClosed = 3 Represents that the connection stream was closed by the client. ContentServedOnIllegalMethod = 1 Represents that the request has sent an request body with an with a HTTP method that is not indicated for receiving request contents. ContentTooLarge = 2 Represents that the content of the request is too large than what was configured on the server, or it's bigger than the max supported size (2GB). [Obsolete(\"This field is now obsolete and is not used anywhere.\")] DnsFailed = 5 Represents that the client did not correctly specify a host in the request. DnsUnknownHost = 6 Represents that the client requested an host that's not been set up on this server. ExceptionThrown = 7 Indicates that the server encountered an exception while processing the request. Executed = 0 Represents that the request was closed by the HTTP server and executed by a router and its response was succesfully delivered. ListeningHostNotReady = 9 Indicates that the DNS was successful, however the matched ListeningHost does not have an valid initialized router. MalformedRequest = 10 Indicates that the server cannot or will not process the request due to something that is perceived to be a client error. NoResponse = 4 Represents that the router did not deliver a response to the received request. RemoteRequestDropped = 11 Indicates that the HTTP server closed an unwanted remote connection. UncaughtExceptionThrown = 8 Indicates that the router encontered an uncaught exception while calling it's action function."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.-ctor.html",
    "title": "Constructor HttpStatusInformation | Sisk",
    "keywords": "Constructor HttpStatusInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpStatusInformation() Creates an new HttpStatusInformation with default parameters (200 OK) status. public HttpStatusInformation() HttpStatusInformation(int) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(int statusCode) Parameters statusCode int Sets the numeric HTTP status code of the HTTP message. HttpStatusInformation(HttpStatusCode) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode Sets the numeric HTTP status code of the HTTP message. HttpStatusInformation(int, string) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(int statusCode, string description) Parameters statusCode int Sets the numeric HTTP status code of the HTTP message. description string Sets the short description of the HTTP message. Remarks Custom status descriptions is only supported for plain HTTP/1.1 and 1.0 transfers. Exceptions ArgumentNullException"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Accepted.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Accepted.html",
    "title": "Property Accepted | Sisk",
    "keywords": "Property Accepted Namespace Sisk.Core.Http Assembly Sisk.Core.dll Accepted Gets an HttpStatusInformation with an HTTP 202 Accepted status. public static HttpStatusInformation Accepted { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.AlreadyReported.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.AlreadyReported.html",
    "title": "Property AlreadyReported | Sisk",
    "keywords": "Property AlreadyReported Namespace Sisk.Core.Http Assembly Sisk.Core.dll AlreadyReported Gets an HttpStatusInformation with an HTTP 208 Already Reported status. public static HttpStatusInformation AlreadyReported { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.BadGateway.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.BadGateway.html",
    "title": "Property BadGateway | Sisk",
    "keywords": "Property BadGateway Namespace Sisk.Core.Http Assembly Sisk.Core.dll BadGateway Gets an HttpStatusInformation with an HTTP 502 Bad Gateway status. public static HttpStatusInformation BadGateway { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.BadRequest.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.BadRequest.html",
    "title": "Property BadRequest | Sisk",
    "keywords": "Property BadRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll BadRequest Gets an HttpStatusInformation with an HTTP 400 Bad Request status. public static HttpStatusInformation BadRequest { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Conflict.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Conflict.html",
    "title": "Property Conflict | Sisk",
    "keywords": "Property Conflict Namespace Sisk.Core.Http Assembly Sisk.Core.dll Conflict Gets an HttpStatusInformation with an HTTP 409 Conflict status. public static HttpStatusInformation Conflict { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Continue.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Continue.html",
    "title": "Property Continue | Sisk",
    "keywords": "Property Continue Namespace Sisk.Core.Http Assembly Sisk.Core.dll Continue Gets an HttpStatusInformation with an HTTP 100 Continue status. public static HttpStatusInformation Continue { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Created.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Created.html",
    "title": "Property Created | Sisk",
    "keywords": "Property Created Namespace Sisk.Core.Http Assembly Sisk.Core.dll Created Gets an HttpStatusInformation with an HTTP 201 Created status. public static HttpStatusInformation Created { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Description.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Core.Http Assembly Sisk.Core.dll Description Gets the short description of the HTTP message. public string Description { get; } Property Value string Remarks Custom status descriptions is only supported for plain HTTP/1.1 and 1.0 transfers."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.EarlyHints.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.EarlyHints.html",
    "title": "Property EarlyHints | Sisk",
    "keywords": "Property EarlyHints Namespace Sisk.Core.Http Assembly Sisk.Core.dll EarlyHints Gets an HttpStatusInformation with an HTTP 103 Early Hints status. public static HttpStatusInformation EarlyHints { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ExpectationFailed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ExpectationFailed.html",
    "title": "Property ExpectationFailed | Sisk",
    "keywords": "Property ExpectationFailed Namespace Sisk.Core.Http Assembly Sisk.Core.dll ExpectationFailed Gets an HttpStatusInformation with an HTTP 417 Expectation Failed status. public static HttpStatusInformation ExpectationFailed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.FailedDependency.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.FailedDependency.html",
    "title": "Property FailedDependency | Sisk",
    "keywords": "Property FailedDependency Namespace Sisk.Core.Http Assembly Sisk.Core.dll FailedDependency Gets an HttpStatusInformation with an HTTP 424 Failed Dependency status. public static HttpStatusInformation FailedDependency { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Forbidden.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Forbidden.html",
    "title": "Property Forbidden | Sisk",
    "keywords": "Property Forbidden Namespace Sisk.Core.Http Assembly Sisk.Core.dll Forbidden Gets an HttpStatusInformation with an HTTP 403 Forbidden status. public static HttpStatusInformation Forbidden { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Found.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Found.html",
    "title": "Property Found | Sisk",
    "keywords": "Property Found Namespace Sisk.Core.Http Assembly Sisk.Core.dll Found Gets an HttpStatusInformation with an HTTP 302 Found status. public static HttpStatusInformation Found { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GatewayTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GatewayTimeout.html",
    "title": "Property GatewayTimeout | Sisk",
    "keywords": "Property GatewayTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll GatewayTimeout Gets an HttpStatusInformation with an HTTP 504 Gateway Timeout status. public static HttpStatusInformation GatewayTimeout { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GetHttpStatusCode.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GetHttpStatusCode.html",
    "title": "Method GetHttpStatusCode | Sisk",
    "keywords": "Method GetHttpStatusCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHttpStatusCode() Gets an HttpStatusCode corresponding to this instance, or null if the HTTP status does not match any value. public HttpStatusCode? GetHttpStatusCode() Returns HttpStatusCode? An HttpStatusCode or null if the HTTP status matches no entry on it."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GetStatusCodeDescription.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GetStatusCodeDescription.html",
    "title": "Method GetStatusCodeDescription | Sisk",
    "keywords": "Method GetStatusCodeDescription Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetStatusCodeDescription(int) Gets the description of the specified HTTP status code. public static string GetStatusCodeDescription(int statusCode) Parameters statusCode int The HTTP status code. Returns string The description of the HTTP status code. GetStatusCodeDescription(HttpStatusCode) Gets the description of the specified HTTP status code. public static string GetStatusCodeDescription(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode The HttpStatusCode value. Returns string The description of the HTTP status code."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Gone.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Gone.html",
    "title": "Property Gone | Sisk",
    "keywords": "Property Gone Namespace Sisk.Core.Http Assembly Sisk.Core.dll Gone Gets an HttpStatusInformation with an HTTP 410 Gone status. public static HttpStatusInformation Gone { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.HttpVersionNotSupported.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.HttpVersionNotSupported.html",
    "title": "Property HttpVersionNotSupported | Sisk",
    "keywords": "Property HttpVersionNotSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpVersionNotSupported Gets an HttpStatusInformation with an HTTP 505 HTTP Version Not Supported status. public static HttpStatusInformation HttpVersionNotSupported { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ImATeapot.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ImATeapot.html",
    "title": "Property ImATeapot | Sisk",
    "keywords": "Property ImATeapot Namespace Sisk.Core.Http Assembly Sisk.Core.dll ImATeapot Gets an HttpStatusInformation with an HTTP 418 I'm a teapot status. public static HttpStatusInformation ImATeapot { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ImUsed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ImUsed.html",
    "title": "Property ImUsed | Sisk",
    "keywords": "Property ImUsed Namespace Sisk.Core.Http Assembly Sisk.Core.dll ImUsed Gets an HttpStatusInformation with an HTTP 226 IM Used status. public static HttpStatusInformation ImUsed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.InsufficientStorage.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.InsufficientStorage.html",
    "title": "Property InsufficientStorage | Sisk",
    "keywords": "Property InsufficientStorage Namespace Sisk.Core.Http Assembly Sisk.Core.dll InsufficientStorage Gets an HttpStatusInformation with an HTTP 507 Insufficient Storage status. public static HttpStatusInformation InsufficientStorage { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.InternalServerError.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.InternalServerError.html",
    "title": "Property InternalServerError | Sisk",
    "keywords": "Property InternalServerError Namespace Sisk.Core.Http Assembly Sisk.Core.dll InternalServerError Gets an HttpStatusInformation with an HTTP 500 Internal Server Error status. public static HttpStatusInformation InternalServerError { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.LengthRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.LengthRequired.html",
    "title": "Property LengthRequired | Sisk",
    "keywords": "Property LengthRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll LengthRequired Gets an HttpStatusInformation with an HTTP 411 Length Required status. public static HttpStatusInformation LengthRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Locked.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Locked.html",
    "title": "Property Locked | Sisk",
    "keywords": "Property Locked Namespace Sisk.Core.Http Assembly Sisk.Core.dll Locked Gets an HttpStatusInformation with an HTTP 423 Locked status. public static HttpStatusInformation Locked { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.LoopDetected.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.LoopDetected.html",
    "title": "Property LoopDetected | Sisk",
    "keywords": "Property LoopDetected Namespace Sisk.Core.Http Assembly Sisk.Core.dll LoopDetected Gets an HttpStatusInformation with an HTTP 508 Loop Detected status. public static HttpStatusInformation LoopDetected { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MethodNotAllowed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MethodNotAllowed.html",
    "title": "Property MethodNotAllowed | Sisk",
    "keywords": "Property MethodNotAllowed Namespace Sisk.Core.Http Assembly Sisk.Core.dll MethodNotAllowed Gets an HttpStatusInformation with an HTTP 405 Method Not Allowed status. public static HttpStatusInformation MethodNotAllowed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MisdirectedRequest.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MisdirectedRequest.html",
    "title": "Property MisdirectedRequest | Sisk",
    "keywords": "Property MisdirectedRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll MisdirectedRequest Gets an HttpStatusInformation with an HTTP 421 Misdirected Request status. public static HttpStatusInformation MisdirectedRequest { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MovedPermanently.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MovedPermanently.html",
    "title": "Property MovedPermanently | Sisk",
    "keywords": "Property MovedPermanently Namespace Sisk.Core.Http Assembly Sisk.Core.dll MovedPermanently Gets an HttpStatusInformation with an HTTP 301 Moved Permanently status. public static HttpStatusInformation MovedPermanently { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MultiStatus.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MultiStatus.html",
    "title": "Property MultiStatus | Sisk",
    "keywords": "Property MultiStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll MultiStatus Gets an HttpStatusInformation with an HTTP 207 Multi-Status status. public static HttpStatusInformation MultiStatus { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MultipleChoices.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MultipleChoices.html",
    "title": "Property MultipleChoices | Sisk",
    "keywords": "Property MultipleChoices Namespace Sisk.Core.Http Assembly Sisk.Core.dll MultipleChoices Gets an HttpStatusInformation with an HTTP 300 Multiple Choices status. public static HttpStatusInformation MultipleChoices { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NoContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NoContent.html",
    "title": "Property NoContent | Sisk",
    "keywords": "Property NoContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll NoContent Gets an HttpStatusInformation with an HTTP 204 No Content status. public static HttpStatusInformation NoContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NonAuthoritativeInformation.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NonAuthoritativeInformation.html",
    "title": "Property NonAuthoritativeInformation | Sisk",
    "keywords": "Property NonAuthoritativeInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll NonAuthoritativeInformation Gets an HttpStatusInformation with an HTTP 203 Non-Authoritative Information status. public static HttpStatusInformation NonAuthoritativeInformation { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotAcceptable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotAcceptable.html",
    "title": "Property NotAcceptable | Sisk",
    "keywords": "Property NotAcceptable Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotAcceptable Gets an HttpStatusInformation with an HTTP 406 Not Acceptable status. public static HttpStatusInformation NotAcceptable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotExtended.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotExtended.html",
    "title": "Property NotExtended | Sisk",
    "keywords": "Property NotExtended Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotExtended Gets an HttpStatusInformation with an HTTP 510 Not Extended status. public static HttpStatusInformation NotExtended { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotFound.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotFound.html",
    "title": "Property NotFound | Sisk",
    "keywords": "Property NotFound Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotFound Gets an HttpStatusInformation with an HTTP 404 Not Found status. public static HttpStatusInformation NotFound { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotImplemented.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotImplemented.html",
    "title": "Property NotImplemented | Sisk",
    "keywords": "Property NotImplemented Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotImplemented Gets an HttpStatusInformation with an HTTP 501 Not Implemented status. public static HttpStatusInformation NotImplemented { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotModified.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotModified.html",
    "title": "Property NotModified | Sisk",
    "keywords": "Property NotModified Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotModified Gets an HttpStatusInformation with an HTTP 304 Not Modified status. public static HttpStatusInformation NotModified { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Ok.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Ok.html",
    "title": "Property Ok | Sisk",
    "keywords": "Property Ok Namespace Sisk.Core.Http Assembly Sisk.Core.dll Ok Gets an HttpStatusInformation with an HTTP 200 OK status. public static HttpStatusInformation Ok { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PartialContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PartialContent.html",
    "title": "Property PartialContent | Sisk",
    "keywords": "Property PartialContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll PartialContent Gets an HttpStatusInformation with an HTTP 206 Partial Content status. public static HttpStatusInformation PartialContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PayloadTooLarge.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PayloadTooLarge.html",
    "title": "Property PayloadTooLarge | Sisk",
    "keywords": "Property PayloadTooLarge Namespace Sisk.Core.Http Assembly Sisk.Core.dll PayloadTooLarge Gets an HttpStatusInformation with an HTTP 413 Payload Too Large status. public static HttpStatusInformation PayloadTooLarge { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PaymentRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PaymentRequired.html",
    "title": "Property PaymentRequired | Sisk",
    "keywords": "Property PaymentRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll PaymentRequired Gets an HttpStatusInformation with an HTTP 402 Payment Required status. public static HttpStatusInformation PaymentRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PermanentRedirect.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PermanentRedirect.html",
    "title": "Property PermanentRedirect | Sisk",
    "keywords": "Property PermanentRedirect Namespace Sisk.Core.Http Assembly Sisk.Core.dll PermanentRedirect Gets an HttpStatusInformation with an HTTP 308 Permanent Redirect status. public static HttpStatusInformation PermanentRedirect { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PreconditionFailed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PreconditionFailed.html",
    "title": "Property PreconditionFailed | Sisk",
    "keywords": "Property PreconditionFailed Namespace Sisk.Core.Http Assembly Sisk.Core.dll PreconditionFailed Gets an HttpStatusInformation with an HTTP 412 Precondition Failed status. public static HttpStatusInformation PreconditionFailed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PreconditionRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PreconditionRequired.html",
    "title": "Property PreconditionRequired | Sisk",
    "keywords": "Property PreconditionRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll PreconditionRequired Gets an HttpStatusInformation with an HTTP 428 Precondition Required status. public static HttpStatusInformation PreconditionRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Processing.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Processing.html",
    "title": "Property Processing | Sisk",
    "keywords": "Property Processing Namespace Sisk.Core.Http Assembly Sisk.Core.dll Processing Gets an HttpStatusInformation with an HTTP 102 Processing status. public static HttpStatusInformation Processing { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ProxyAuthenticationRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ProxyAuthenticationRequired.html",
    "title": "Property ProxyAuthenticationRequired | Sisk",
    "keywords": "Property ProxyAuthenticationRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll ProxyAuthenticationRequired Gets an HttpStatusInformation with an HTTP 407 Proxy Authentication Required status. public static HttpStatusInformation ProxyAuthenticationRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RangeNotSatisfiable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RangeNotSatisfiable.html",
    "title": "Property RangeNotSatisfiable | Sisk",
    "keywords": "Property RangeNotSatisfiable Namespace Sisk.Core.Http Assembly Sisk.Core.dll RangeNotSatisfiable Gets an HttpStatusInformation with an HTTP 416 Range Not Satisfiable status. public static HttpStatusInformation RangeNotSatisfiable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RequestHeaderFieldsTooLarge.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RequestHeaderFieldsTooLarge.html",
    "title": "Property RequestHeaderFieldsTooLarge | Sisk",
    "keywords": "Property RequestHeaderFieldsTooLarge Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestHeaderFieldsTooLarge Gets an HttpStatusInformation with an HTTP 431 Request Header Fields Too Large status. public static HttpStatusInformation RequestHeaderFieldsTooLarge { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RequestTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RequestTimeout.html",
    "title": "Property RequestTimeout | Sisk",
    "keywords": "Property RequestTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestTimeout Gets an HttpStatusInformation with an HTTP 408 Request Timeout status. public static HttpStatusInformation RequestTimeout { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ResetContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ResetContent.html",
    "title": "Property ResetContent | Sisk",
    "keywords": "Property ResetContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll ResetContent Gets an HttpStatusInformation with an HTTP 205 Reset Content status. public static HttpStatusInformation ResetContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SeeOther.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SeeOther.html",
    "title": "Property SeeOther | Sisk",
    "keywords": "Property SeeOther Namespace Sisk.Core.Http Assembly Sisk.Core.dll SeeOther Gets an HttpStatusInformation with an HTTP 303 See Other status. public static HttpStatusInformation SeeOther { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ServiceUnavailable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ServiceUnavailable.html",
    "title": "Property ServiceUnavailable | Sisk",
    "keywords": "Property ServiceUnavailable Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServiceUnavailable Gets an HttpStatusInformation with an HTTP 503 Service Unavailable status. public static HttpStatusInformation ServiceUnavailable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.StatusCode.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.StatusCode.html",
    "title": "Property StatusCode | Sisk",
    "keywords": "Property StatusCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll StatusCode Gets the numeric HTTP status code of the HTTP message. public int StatusCode { get; } Property Value int"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SwitchProxy.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SwitchProxy.html",
    "title": "Property SwitchProxy | Sisk",
    "keywords": "Property SwitchProxy Namespace Sisk.Core.Http Assembly Sisk.Core.dll SwitchProxy Gets an HttpStatusInformation with an HTTP 306 Switch Proxy status. public static HttpStatusInformation SwitchProxy { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SwitchingProtocols.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SwitchingProtocols.html",
    "title": "Property SwitchingProtocols | Sisk",
    "keywords": "Property SwitchingProtocols Namespace Sisk.Core.Http Assembly Sisk.Core.dll SwitchingProtocols Gets an HttpStatusInformation with an HTTP 101 Switching Protocols status. public static HttpStatusInformation SwitchingProtocols { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.TemporaryRedirect.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.TemporaryRedirect.html",
    "title": "Property TemporaryRedirect | Sisk",
    "keywords": "Property TemporaryRedirect Namespace Sisk.Core.Http Assembly Sisk.Core.dll TemporaryRedirect Gets an HttpStatusInformation with an HTTP 307 Temporary Redirect status. public static HttpStatusInformation TemporaryRedirect { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this HTTP Status Code. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.TooManyRequests.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.TooManyRequests.html",
    "title": "Property TooManyRequests | Sisk",
    "keywords": "Property TooManyRequests Namespace Sisk.Core.Http Assembly Sisk.Core.dll TooManyRequests Gets an HttpStatusInformation with an HTTP 429 Too Many Requests status. public static HttpStatusInformation TooManyRequests { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Unauthorized.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Unauthorized.html",
    "title": "Property Unauthorized | Sisk",
    "keywords": "Property Unauthorized Namespace Sisk.Core.Http Assembly Sisk.Core.dll Unauthorized Gets an HttpStatusInformation with an HTTP 401 Unauthorized status. public static HttpStatusInformation Unauthorized { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnavailableForLegalReasons.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnavailableForLegalReasons.html",
    "title": "Property UnavailableForLegalReasons | Sisk",
    "keywords": "Property UnavailableForLegalReasons Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnavailableForLegalReasons Gets an HttpStatusInformation with an HTTP 451 Unavailable For Legal Reasons status. public static HttpStatusInformation UnavailableForLegalReasons { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnprocessableEntity.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnprocessableEntity.html",
    "title": "Property UnprocessableEntity | Sisk",
    "keywords": "Property UnprocessableEntity Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnprocessableEntity Gets an HttpStatusInformation with an HTTP 422 Unprocessable Entity status. public static HttpStatusInformation UnprocessableEntity { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnsupportedMediaType.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnsupportedMediaType.html",
    "title": "Property UnsupportedMediaType | Sisk",
    "keywords": "Property UnsupportedMediaType Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnsupportedMediaType Gets an HttpStatusInformation with an HTTP 415 Unsupported Media Type status. public static HttpStatusInformation UnsupportedMediaType { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UpgradeRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UpgradeRequired.html",
    "title": "Property UpgradeRequired | Sisk",
    "keywords": "Property UpgradeRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll UpgradeRequired Gets an HttpStatusInformation with an HTTP 426 Upgrade Required status. public static HttpStatusInformation UpgradeRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UriTooLong.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UriTooLong.html",
    "title": "Property UriTooLong | Sisk",
    "keywords": "Property UriTooLong Namespace Sisk.Core.Http Assembly Sisk.Core.dll UriTooLong Gets an HttpStatusInformation with an HTTP 414 URI Too Long status. public static HttpStatusInformation UriTooLong { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UseProxy.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UseProxy.html",
    "title": "Property UseProxy | Sisk",
    "keywords": "Property UseProxy Namespace Sisk.Core.Http Assembly Sisk.Core.dll UseProxy Gets an HttpStatusInformation with an HTTP 305 Use Proxy status. public static HttpStatusInformation UseProxy { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.VariantAlsoNegotiates.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.VariantAlsoNegotiates.html",
    "title": "Property VariantAlsoNegotiates | Sisk",
    "keywords": "Property VariantAlsoNegotiates Namespace Sisk.Core.Http Assembly Sisk.Core.dll VariantAlsoNegotiates Gets an HttpStatusInformation with an HTTP 506 Variant Also Negotiates status. public static HttpStatusInformation VariantAlsoNegotiates { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.html",
    "title": "Struct HttpStatusInformation | Sisk",
    "keywords": "Struct HttpStatusInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents a value that holds an HTTP response status information, with it's status code and description. public readonly struct HttpStatusInformation : IEquatable<HttpStatusInformation>, IEquatable<HttpStatusCode>, IEquatable<int> Implements IEquatable<HttpStatusInformation> IEquatable<HttpStatusCode> IEquatable<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors HttpStatusInformation() Creates an new HttpStatusInformation with default parameters (200 OK) status. HttpStatusInformation(int) Creates an new HttpStatusInformation instance with given parameters. HttpStatusInformation(int, string) Creates an new HttpStatusInformation instance with given parameters. HttpStatusInformation(HttpStatusCode) Creates an new HttpStatusInformation instance with given parameters. Properties Accepted Gets an HttpStatusInformation with an HTTP 202 Accepted status. AlreadyReported Gets an HttpStatusInformation with an HTTP 208 Already Reported status. BadGateway Gets an HttpStatusInformation with an HTTP 502 Bad Gateway status. BadRequest Gets an HttpStatusInformation with an HTTP 400 Bad Request status. Conflict Gets an HttpStatusInformation with an HTTP 409 Conflict status. Continue Gets an HttpStatusInformation with an HTTP 100 Continue status. Created Gets an HttpStatusInformation with an HTTP 201 Created status. Description Gets the short description of the HTTP message. EarlyHints Gets an HttpStatusInformation with an HTTP 103 Early Hints status. ExpectationFailed Gets an HttpStatusInformation with an HTTP 417 Expectation Failed status. FailedDependency Gets an HttpStatusInformation with an HTTP 424 Failed Dependency status. Forbidden Gets an HttpStatusInformation with an HTTP 403 Forbidden status. Found Gets an HttpStatusInformation with an HTTP 302 Found status. GatewayTimeout Gets an HttpStatusInformation with an HTTP 504 Gateway Timeout status. Gone Gets an HttpStatusInformation with an HTTP 410 Gone status. HttpVersionNotSupported Gets an HttpStatusInformation with an HTTP 505 HTTP Version Not Supported status. ImATeapot Gets an HttpStatusInformation with an HTTP 418 I'm a teapot status. ImUsed Gets an HttpStatusInformation with an HTTP 226 IM Used status. InsufficientStorage Gets an HttpStatusInformation with an HTTP 507 Insufficient Storage status. InternalServerError Gets an HttpStatusInformation with an HTTP 500 Internal Server Error status. LengthRequired Gets an HttpStatusInformation with an HTTP 411 Length Required status. Locked Gets an HttpStatusInformation with an HTTP 423 Locked status. LoopDetected Gets an HttpStatusInformation with an HTTP 508 Loop Detected status. MethodNotAllowed Gets an HttpStatusInformation with an HTTP 405 Method Not Allowed status. MisdirectedRequest Gets an HttpStatusInformation with an HTTP 421 Misdirected Request status. MovedPermanently Gets an HttpStatusInformation with an HTTP 301 Moved Permanently status. MultiStatus Gets an HttpStatusInformation with an HTTP 207 Multi-Status status. MultipleChoices Gets an HttpStatusInformation with an HTTP 300 Multiple Choices status. NoContent Gets an HttpStatusInformation with an HTTP 204 No Content status. NonAuthoritativeInformation Gets an HttpStatusInformation with an HTTP 203 Non-Authoritative Information status. NotAcceptable Gets an HttpStatusInformation with an HTTP 406 Not Acceptable status. NotExtended Gets an HttpStatusInformation with an HTTP 510 Not Extended status. NotFound Gets an HttpStatusInformation with an HTTP 404 Not Found status. NotImplemented Gets an HttpStatusInformation with an HTTP 501 Not Implemented status. NotModified Gets an HttpStatusInformation with an HTTP 304 Not Modified status. Ok Gets an HttpStatusInformation with an HTTP 200 OK status. PartialContent Gets an HttpStatusInformation with an HTTP 206 Partial Content status. PayloadTooLarge Gets an HttpStatusInformation with an HTTP 413 Payload Too Large status. PaymentRequired Gets an HttpStatusInformation with an HTTP 402 Payment Required status. PermanentRedirect Gets an HttpStatusInformation with an HTTP 308 Permanent Redirect status. PreconditionFailed Gets an HttpStatusInformation with an HTTP 412 Precondition Failed status. PreconditionRequired Gets an HttpStatusInformation with an HTTP 428 Precondition Required status. Processing Gets an HttpStatusInformation with an HTTP 102 Processing status. ProxyAuthenticationRequired Gets an HttpStatusInformation with an HTTP 407 Proxy Authentication Required status. RangeNotSatisfiable Gets an HttpStatusInformation with an HTTP 416 Range Not Satisfiable status. RequestHeaderFieldsTooLarge Gets an HttpStatusInformation with an HTTP 431 Request Header Fields Too Large status. RequestTimeout Gets an HttpStatusInformation with an HTTP 408 Request Timeout status. ResetContent Gets an HttpStatusInformation with an HTTP 205 Reset Content status. SeeOther Gets an HttpStatusInformation with an HTTP 303 See Other status. ServiceUnavailable Gets an HttpStatusInformation with an HTTP 503 Service Unavailable status. StatusCode Gets the numeric HTTP status code of the HTTP message. SwitchProxy Gets an HttpStatusInformation with an HTTP 306 Switch Proxy status. SwitchingProtocols Gets an HttpStatusInformation with an HTTP 101 Switching Protocols status. TemporaryRedirect Gets an HttpStatusInformation with an HTTP 307 Temporary Redirect status. TooManyRequests Gets an HttpStatusInformation with an HTTP 429 Too Many Requests status. Unauthorized Gets an HttpStatusInformation with an HTTP 401 Unauthorized status. UnavailableForLegalReasons Gets an HttpStatusInformation with an HTTP 451 Unavailable For Legal Reasons status. UnprocessableEntity Gets an HttpStatusInformation with an HTTP 422 Unprocessable Entity status. UnsupportedMediaType Gets an HttpStatusInformation with an HTTP 415 Unsupported Media Type status. UpgradeRequired Gets an HttpStatusInformation with an HTTP 426 Upgrade Required status. UriTooLong Gets an HttpStatusInformation with an HTTP 414 URI Too Long status. UseProxy Gets an HttpStatusInformation with an HTTP 305 Use Proxy status. VariantAlsoNegotiates Gets an HttpStatusInformation with an HTTP 506 Variant Also Negotiates status. Methods GetHttpStatusCode() Gets an HttpStatusCode corresponding to this instance, or null if the HTTP status does not match any value. GetStatusCodeDescription(int) Gets the description of the specified HTTP status code. GetStatusCodeDescription(HttpStatusCode) Gets the description of the specified HTTP status code. ToString() Gets an string representation of this HTTP Status Code. Operators operator ==(HttpStatusInformation, int?)"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.op_Equality.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.op_Equality.html",
    "title": "Operator operator == | Sisk",
    "keywords": "Operator operator == Namespace Sisk.Core.Http Assembly Sisk.Core.dll operator ==(HttpStatusInformation, int?) public static bool operator ==(HttpStatusInformation a, int? b) Parameters a HttpStatusInformation b int? Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHost.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.-ctor.html",
    "title": "Constructor ListeningHost | Sisk",
    "keywords": "Constructor ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHost() Creates an new empty ListeningHost instance. public ListeningHost() ListeningHost(params ListeningPort[]) Creates an new ListeningHost instance with given array of ListeningPort. public ListeningHost(params ListeningPort[] ports) Parameters ports ListeningPort[] The array of ListeningPort to listen in the ListeningHost. ListeningHost(string, Router) Creates an new ListeningHost instance with given URL. public ListeningHost(string uri, Router r) Parameters uri string The well formatted URL with scheme, hostname and port. r Router The router which will handle this listener requests."
  },
  "api/Sisk.Core.Http.ListeningHost.CanListen.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.CanListen.html",
    "title": "Property CanListen | Sisk",
    "keywords": "Property CanListen Namespace Sisk.Core.Http Assembly Sisk.Core.dll CanListen Gets whether this ListeningHost can be listened by it's host HttpServer. public bool CanListen { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningHost.CrossOriginResourceSharingPolicy.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.CrossOriginResourceSharingPolicy.html",
    "title": "Property CrossOriginResourceSharingPolicy | Sisk",
    "keywords": "Property CrossOriginResourceSharingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll CrossOriginResourceSharingPolicy Gets or sets the CORS sharing policy object. public CrossOriginResourceSharingHeaders CrossOriginResourceSharingPolicy { get; set; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Http.ListeningHost.Equals.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) Determines if another object is equals to this class instance. public override bool Equals(object? obj) Parameters obj object The another object which will be used to compare. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHost.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() Gets the hash code for this listening host. public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.ListeningHost.Label.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Label.html",
    "title": "Property Label | Sisk",
    "keywords": "Property Label Namespace Sisk.Core.Http Assembly Sisk.Core.dll Label Gets or sets a label for this Listening Host. public string? Label { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningHost.Ports.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Ports.html",
    "title": "Property Ports | Sisk",
    "keywords": "Property Ports Namespace Sisk.Core.Http Assembly Sisk.Core.dll Ports Gets or sets the list of ListeningPort that this host will listen on. public IList<ListeningPort> Ports { get; set; } Property Value IList<ListeningPort>"
  },
  "api/Sisk.Core.Http.ListeningHost.Router.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http Assembly Sisk.Core.dll Router Gets or sets the Router for this ListeningHost instance. public Router? Router { get; set; } Property Value Router"
  },
  "api/Sisk.Core.Http.ListeningHost.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.html",
    "title": "Class ListeningHost | Sisk",
    "keywords": "Class ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a structure to contain the fields needed by an http server host. public sealed class ListeningHost Inheritance object ListeningHost Inherited Members object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ListeningHost() Creates an new empty ListeningHost instance. ListeningHost(params ListeningPort[]) Creates an new ListeningHost instance with given array of ListeningPort. ListeningHost(string, Router) Creates an new ListeningHost instance with given URL. Properties CanListen Gets whether this ListeningHost can be listened by it's host HttpServer. CrossOriginResourceSharingPolicy Gets or sets the CORS sharing policy object. Label Gets or sets a label for this Listening Host. Ports Gets or sets the list of ListeningPort that this host will listen on. Router Gets or sets the Router for this ListeningHost instance. Methods Equals(object?) Determines if another object is equals to this class instance. GetHashCode() Gets the hash code for this listening host."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.-ctor.html",
    "title": "Constructor ListeningHostRepository | Sisk",
    "keywords": "Constructor ListeningHostRepository Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHostRepository() Creates a new instance of an empty ListeningHostRepository. public ListeningHostRepository() ListeningHostRepository(IEnumerable<ListeningHost>) Creates a new instance of an ListeningHostRepository copying the items from another collection of ListeningHost. public ListeningHostRepository(IEnumerable<ListeningHost> hosts) Parameters hosts IEnumerable<ListeningHost> The collection which stores the ListeningHost which will be copied to this repository."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Add.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.Core.Http Assembly Sisk.Core.dll Add(ListeningHost) Adds a listeninghost to this repository. If this listeninghost already exists in this class, an exception will be thrown. public void Add(ListeningHost item) Parameters item ListeningHost The ListeningHost to add to this collection."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Clear.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.Core.Http Assembly Sisk.Core.dll Clear() Removes all listeninghosts from this repository. public void Clear()"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Contains.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.Core.Http Assembly Sisk.Core.dll Contains(ListeningHost) Determines if an ListeningHost is present in this repository. public bool Contains(ListeningHost item) Parameters item ListeningHost The ListeningHost to check if is present in this repository. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.CopyTo.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.Core.Http Assembly Sisk.Core.dll CopyTo(ListeningHost[], int) Copies all elements from this repository to another compatible repository. public void CopyTo(ListeningHost[] array, int arrayIndex) Parameters array ListeningHost[] The one-dimensional System.Array that is the destination of the elements copied. arrayIndex int The zero-based index in array at which copying begins."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Count.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Http Assembly Sisk.Core.dll Count Gets the number of elements contained in this ListeningHostRepository. public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.GetEnumerator.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetEnumerator() Returns an enumerator that iterates through this ListeningHostRepository. public IEnumerator<ListeningHost> GetEnumerator() Returns IEnumerator<ListeningHost>"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.IndexOf.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.IndexOf.html",
    "title": "Method IndexOf | Sisk",
    "keywords": "Method IndexOf Namespace Sisk.Core.Http Assembly Sisk.Core.dll IndexOf(ListeningHost) public int IndexOf(ListeningHost item) Parameters item ListeningHost Returns int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Insert.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Insert.html",
    "title": "Method Insert | Sisk",
    "keywords": "Method Insert Namespace Sisk.Core.Http Assembly Sisk.Core.dll Insert(int, ListeningHost) public void Insert(int index, ListeningHost item) Parameters index int item ListeningHost"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.IsReadOnly.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsReadOnly Gets an boolean indicating if this ListeningHostRepository is read only. This property always returns false. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Item.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Http Assembly Sisk.Core.dll this[int] public ListeningHost this[int index] { get; set; } Parameters index int Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Remove.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.Core.Http Assembly Sisk.Core.dll Remove(ListeningHost) Try to remove a ListeningHost from this repository. If the item is removed, this methods returns true. public bool Remove(ListeningHost item) Parameters item ListeningHost The ListeningHost to be removed. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.RemoveAt.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.RemoveAt.html",
    "title": "Method RemoveAt | Sisk",
    "keywords": "Method RemoveAt Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.html",
    "title": "Class ListeningHostRepository | Sisk",
    "keywords": "Class ListeningHostRepository Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an fluent repository of ListeningHost that can add, modify, or remove listening hosts while an HttpServer is running. public sealed class ListeningHostRepository : IList<ListeningHost>, ICollection<ListeningHost>, IEnumerable<ListeningHost>, IEnumerable Inheritance object ListeningHostRepository Implements IList<ListeningHost> ICollection<ListeningHost> IEnumerable<ListeningHost> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors ListeningHostRepository() Creates a new instance of an empty ListeningHostRepository. ListeningHostRepository(IEnumerable<ListeningHost>) Creates a new instance of an ListeningHostRepository copying the items from another collection of ListeningHost. Properties Count Gets the number of elements contained in this ListeningHostRepository. IsReadOnly Gets an boolean indicating if this ListeningHostRepository is read only. This property always returns false. this[int] Methods Add(ListeningHost) Adds a listeninghost to this repository. If this listeninghost already exists in this class, an exception will be thrown. Clear() Removes all listeninghosts from this repository. Contains(ListeningHost) Determines if an ListeningHost is present in this repository. CopyTo(ListeningHost[], int) Copies all elements from this repository to another compatible repository. GetEnumerator() Returns an enumerator that iterates through this ListeningHostRepository. IndexOf(ListeningHost) Insert(int, ListeningHost) Remove(ListeningHost) Try to remove a ListeningHost from this repository. If the item is removed, this methods returns true. RemoveAt(int)"
  },
  "api/Sisk.Core.Http.ListeningPort.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.-ctor.html",
    "title": "Constructor ListeningPort | Sisk",
    "keywords": "Constructor ListeningPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningPort() Creates an new ListeningPort instance with default parameters. public ListeningPort() ListeningPort(ushort) Creates an new ListeningPort instance with the specified port at the loopback host. public ListeningPort(ushort port) Parameters port ushort The port the server will listen on. If this port is the default HTTPS port (443), the class will have the property Secure to true. ListeningPort(ushort, bool) Creates an new ListeningPort instance with the specified port and secure context at the loopback host. public ListeningPort(ushort port, bool secure) Parameters port ushort The port the server will listen on. secure bool Indicates whether the server should listen to this port securely (SSL). ListeningPort(bool, string, ushort) Creates an new ListeningPort instance with the specified port, secure context and hostname. public ListeningPort(bool secure, string hostname, ushort port) Parameters secure bool Indicates whether the server should listen to this port securely (SSL). hostname string The hostname DNS pattern the server will listen to. port ushort The port the server will listen on. ListeningPort(bool, string, ushort, string) Creates an new ListeningPort instance with the specified port, secure context, hostname and path. public ListeningPort(bool secure, string hostname, ushort port, string path) Parameters secure bool Indicates whether the server should listen to this port securely (SSL). hostname string The hostname DNS pattern the server will listen to. port ushort The port the server will listen on. path string The prefix path. ListeningPort(string) Creates an new ListeningPort instance with the specified URI. public ListeningPort(string uri) Parameters uri string The URI component that will be parsed to the listening port format."
  },
  "api/Sisk.Core.Http.ListeningPort.Equals.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) Determines if another object is equals to this class instance. public override bool Equals(object? obj) Parameters obj object The another object which will be used to compare. Returns bool Equals(ListeningPort) Determines if this ListeningPort is equals to another ListeningPort. public bool Equals(ListeningPort other) Parameters other ListeningPort The another object which will be used to compare. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() Gets the hash code for this listening port. public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.ListeningPort.GetRandomPort.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.GetRandomPort.html",
    "title": "Method GetRandomPort | Sisk",
    "keywords": "Method GetRandomPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRandomPort() Gets an ListeningPort object with an random insecure port at the default loopback address. public static ListeningPort GetRandomPort() Returns ListeningPort"
  },
  "api/Sisk.Core.Http.ListeningPort.Hostname.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Hostname.html",
    "title": "Property Hostname | Sisk",
    "keywords": "Property Hostname Namespace Sisk.Core.Http Assembly Sisk.Core.dll Hostname Gets the DNS hostname pattern where this listening port will refer. public string Hostname { get; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningPort.IsPathRoot.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.IsPathRoot.html",
    "title": "Property IsPathRoot | Sisk",
    "keywords": "Property IsPathRoot Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsPathRoot Gets an boolean indicating if this listening port has an non-rooted path. public bool IsPathRoot { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningPort.Parse.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Parse.html",
    "title": "Method Parse | Sisk",
    "keywords": "Method Parse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Parse(string) Parses a string into a ListeningPort. public static ListeningPort Parse(string s) Parameters s string The string to parse. Returns ListeningPort Parse(string, IFormatProvider?) Parses a string into a ListeningPort. static ListeningPort Parse(string s, IFormatProvider? provider) Parameters s string The string to parse. provider IFormatProvider An object that provides culture-specific formatting information about s. Returns ListeningPort"
  },
  "api/Sisk.Core.Http.ListeningPort.Path.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Http Assembly Sisk.Core.dll Path Gets where this listening port prefix is listening to. public string Path { get; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningPort.Port.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Port.html",
    "title": "Property Port | Sisk",
    "keywords": "Property Port Namespace Sisk.Core.Http Assembly Sisk.Core.dll Port Gets the port where this listening port will refer. public ushort Port { get; } Property Value ushort"
  },
  "api/Sisk.Core.Http.ListeningPort.Secure.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Secure.html",
    "title": "Property Secure | Sisk",
    "keywords": "Property Secure Namespace Sisk.Core.Http Assembly Sisk.Core.dll Secure Gets whether the server should listen to this port securely (SSL). public bool Secure { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningPort.ToString.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this ListeningPort. public override string ToString() Returns string ToString(bool) Gets an string representation of this ListeningPort. public string ToString(bool includePath = true) Parameters includePath bool Optional. Defines whether the path should be included in the result string. Returns string"
  },
  "api/Sisk.Core.Http.ListeningPort.TryParse.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.TryParse.html",
    "title": "Method TryParse | Sisk",
    "keywords": "Method TryParse Namespace Sisk.Core.Http Assembly Sisk.Core.dll TryParse(string?, IFormatProvider?, out ListeningPort) Tries to parse a string into a ListeningPort. static bool TryParse(string? s, IFormatProvider? provider, out ListeningPort result) Parameters s string The string to parse. provider IFormatProvider An object that provides culture-specific formatting information about s. result ListeningPort When this method returns, contains the result of successfully parsing s or an undefined value on failure. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.html",
    "title": "Struct ListeningPort | Sisk",
    "keywords": "Struct ListeningPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a structure to contain a listener port for an ListeningHost instance. public readonly struct ListeningPort : IEquatable<ListeningPort>, IParsable<ListeningPort> Implements IEquatable<ListeningPort> IParsable<ListeningPort> Inherited Members object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Examples A listener port represents an access point on the HTTP server. It consists of an indicator that it should use a secure connection (HTTPS), its hostname and port. It must start with https:// or http://, and must terminate with an /. It is represented by the syntax: [http|https]://[hostname]:[port]/ Examples: http://localhost:80/ https://subdomain.domain.net:443/ http://182.32.112.223:5251/ Constructors ListeningPort() Creates an new ListeningPort instance with default parameters. ListeningPort(bool, string, ushort) Creates an new ListeningPort instance with the specified port, secure context and hostname. ListeningPort(bool, string, ushort, string) Creates an new ListeningPort instance with the specified port, secure context, hostname and path. ListeningPort(string) Creates an new ListeningPort instance with the specified URI. ListeningPort(ushort) Creates an new ListeningPort instance with the specified port at the loopback host. ListeningPort(ushort, bool) Creates an new ListeningPort instance with the specified port and secure context at the loopback host. Properties Hostname Gets the DNS hostname pattern where this listening port will refer. IsPathRoot Gets an boolean indicating if this listening port has an non-rooted path. Path Gets where this listening port prefix is listening to. Port Gets the port where this listening port will refer. Secure Gets whether the server should listen to this port securely (SSL). Methods Equals(ListeningPort) Determines if this ListeningPort is equals to another ListeningPort. Equals(object?) Determines if another object is equals to this class instance. GetHashCode() Gets the hash code for this listening port. GetRandomPort() Gets an ListeningPort object with an random insecure port at the default loopback address. Parse(string) Parses a string into a ListeningPort. ToString() Gets an string representation of this ListeningPort. ToString(bool) Gets an string representation of this ListeningPort. Operators operator ==(ListeningPort, ListeningPort) operator !=(ListeningPort, ListeningPort) Explicit Interface Implementations Parse(string, IFormatProvider?) Parses a string into a ListeningPort. TryParse(string?, IFormatProvider?, out ListeningPort) Tries to parse a string into a ListeningPort."
  },
  "api/Sisk.Core.Http.ListeningPort.op_Equality.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.op_Equality.html",
    "title": "Operator operator == | Sisk",
    "keywords": "Operator operator == Namespace Sisk.Core.Http Assembly Sisk.Core.dll operator ==(ListeningPort, ListeningPort) public static bool operator ==(ListeningPort left, ListeningPort right) Parameters left ListeningPort right ListeningPort Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.op_Inequality.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.op_Inequality.html",
    "title": "Operator operator != | Sisk",
    "keywords": "Operator operator != Namespace Sisk.Core.Http Assembly Sisk.Core.dll operator !=(ListeningPort, ListeningPort) public static bool operator !=(ListeningPort left, ListeningPort right) Parameters left ListeningPort right ListeningPort Returns bool"
  },
  "api/Sisk.Core.Http.LogStream.-ctor.html": {
    "href": "api/Sisk.Core.Http.LogStream.-ctor.html",
    "title": "Constructor LogStream | Sisk",
    "keywords": "Constructor LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll LogStream() Creates an new LogStream instance with no predefined outputs. public LogStream() LogStream(TextWriter) Creates an new LogStream instance with the given TextWriter object. public LogStream(TextWriter tw) Parameters tw TextWriter The TextWriter instance which this instance will write log to. LogStream(string) Creates an new LogStream instance with the given relative or absolute file path. public LogStream(string filename) Parameters filename string The file path where this instance will write log to. LogStream(string?, TextWriter?) Creates an new LogStream instance which writes text to an file and an TextWriter. public LogStream(string? filename, TextWriter? tw) Parameters filename string The file path where this instance will write log to. tw TextWriter The text writer which this instance will write log to."
  },
  "api/Sisk.Core.Http.LogStream.Close.html": {
    "href": "api/Sisk.Core.Http.LogStream.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http Assembly Sisk.Core.dll Close() Writes all pending logs from the queue and closes all resources used by this object. public virtual void Close()"
  },
  "api/Sisk.Core.Http.LogStream.ConfigureRotatingPolicy.html": {
    "href": "api/Sisk.Core.Http.LogStream.ConfigureRotatingPolicy.html",
    "title": "Method ConfigureRotatingPolicy | Sisk",
    "keywords": "Method ConfigureRotatingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConfigureRotatingPolicy(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. This method is an shortcut for calling Configure(long, TimeSpan) of this defined RotatingPolicy method. public LogStream ConfigureRotatingPolicy(long maximumSize, TimeSpan dueTime) Parameters maximumSize long The non-negative size threshold of the log file size in byte count. dueTime TimeSpan The time interval between checks. Returns LogStream Remarks The first run is performed immediately after calling this method."
  },
  "api/Sisk.Core.Http.LogStream.ConsoleOutput.html": {
    "href": "api/Sisk.Core.Http.LogStream.ConsoleOutput.html",
    "title": "Property ConsoleOutput | Sisk",
    "keywords": "Property ConsoleOutput Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConsoleOutput Gets a LogStream that writes its output to the Out stream. public static LogStream ConsoleOutput { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.LogStream.Dispose.html": {
    "href": "api/Sisk.Core.Http.LogStream.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose(bool) Writes all pending logs from the queue and closes all resources used by this object. protected virtual void Dispose(bool disposing) Parameters disposing bool Dispose() Writes all pending logs from the queue and closes all resources used by this object. public void Dispose()"
  },
  "api/Sisk.Core.Http.LogStream.Disposed.html": {
    "href": "api/Sisk.Core.Http.LogStream.Disposed.html",
    "title": "Property Disposed | Sisk",
    "keywords": "Property Disposed Namespace Sisk.Core.Http Assembly Sisk.Core.dll Disposed Gets an boolean indicating if this LogStream was disposed. public bool Disposed { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.Encoding.html": {
    "href": "api/Sisk.Core.Http.LogStream.Encoding.html",
    "title": "Property Encoding | Sisk",
    "keywords": "Property Encoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll Encoding Gets or sets the encoding used for writting data to the output file. This property is only appliable if this instance is using an file-based output. public Encoding Encoding { get; set; } Property Value Encoding"
  },
  "api/Sisk.Core.Http.LogStream.FilePath.html": {
    "href": "api/Sisk.Core.Http.LogStream.FilePath.html",
    "title": "Property FilePath | Sisk",
    "keywords": "Property FilePath Namespace Sisk.Core.Http Assembly Sisk.Core.dll FilePath Gets or sets the absolute path to the file where the log is being written to. public string? FilePath { get; set; } Property Value string Remarks When setting this method, if the file directory doens't exists, it is created."
  },
  "api/Sisk.Core.Http.LogStream.Finalize.html": {
    "href": "api/Sisk.Core.Http.LogStream.Finalize.html",
    "title": "Method ~LogStream | Sisk",
    "keywords": "Method ~LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll ~LogStream() protected ~LogStream()"
  },
  "api/Sisk.Core.Http.LogStream.Flush.html": {
    "href": "api/Sisk.Core.Http.LogStream.Flush.html",
    "title": "Method Flush | Sisk",
    "keywords": "Method Flush Namespace Sisk.Core.Http Assembly Sisk.Core.dll Flush() Clears the current log queue and blocks the current thread until all content is written to the underlying streams. public void Flush()"
  },
  "api/Sisk.Core.Http.LogStream.IsBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.IsBuffering.html",
    "title": "Property IsBuffering | Sisk",
    "keywords": "Property IsBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsBuffering Gets an boolean indicating if this LogStream is buffering output messages to their internal message buffer. public bool IsBuffering { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.NormalizeEntries.html": {
    "href": "api/Sisk.Core.Http.LogStream.NormalizeEntries.html",
    "title": "Property NormalizeEntries | Sisk",
    "keywords": "Property NormalizeEntries Namespace Sisk.Core.Http Assembly Sisk.Core.dll NormalizeEntries Gets or sets a boolean that indicates that every input must be trimmed and have their line endings normalized before being written to the output stream. public bool NormalizeEntries { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.Peek.html": {
    "href": "api/Sisk.Core.Http.LogStream.Peek.html",
    "title": "Method Peek | Sisk",
    "keywords": "Method Peek Namespace Sisk.Core.Http Assembly Sisk.Core.dll Peek() Reads the output buffer. To use this method, it's required to set this LogStream buffering with StartBuffering(int). public string Peek() Returns string Exceptions InvalidOperationException Thrown when this LogStream is not buffering."
  },
  "api/Sisk.Core.Http.LogStream.RotatingPolicy.html": {
    "href": "api/Sisk.Core.Http.LogStream.RotatingPolicy.html",
    "title": "Property RotatingPolicy | Sisk",
    "keywords": "Property RotatingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll RotatingPolicy Gets the defined RotatingLogPolicy for this LogStream. public RotatingLogPolicy RotatingPolicy { get; } Property Value RotatingLogPolicy"
  },
  "api/Sisk.Core.Http.LogStream.StartBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.StartBuffering.html",
    "title": "Method StartBuffering | Sisk",
    "keywords": "Method StartBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll StartBuffering(int) Start buffering all output to an alternate stream in memory for readability with Peek() later. public void StartBuffering(int lines) Parameters lines int The amount of lines to store in the buffer."
  },
  "api/Sisk.Core.Http.LogStream.StopBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.StopBuffering.html",
    "title": "Method StopBuffering | Sisk",
    "keywords": "Method StopBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll StopBuffering() Stops buffering output. public void StopBuffering()"
  },
  "api/Sisk.Core.Http.LogStream.TextWriter.html": {
    "href": "api/Sisk.Core.Http.LogStream.TextWriter.html",
    "title": "Property TextWriter | Sisk",
    "keywords": "Property TextWriter Namespace Sisk.Core.Http Assembly Sisk.Core.dll TextWriter Gets the TextWriter object where the log is being written to. public TextWriter? TextWriter { get; set; } Property Value TextWriter"
  },
  "api/Sisk.Core.Http.LogStream.WriteException.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteException.html",
    "title": "Method WriteException | Sisk",
    "keywords": "Method WriteException Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteException(Exception) Writes an exception description in the log. public void WriteException(Exception exp) Parameters exp Exception The exception which will be written. WriteException(Exception, string?) Writes an exception description in the log. public void WriteException(Exception exp, string? extraContext = null) Parameters exp Exception The exception which will be written. extraContext string Extra context message to append to the exception message."
  },
  "api/Sisk.Core.Http.LogStream.WriteExceptionAsync.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteExceptionAsync.html",
    "title": "Method WriteExceptionAsync | Sisk",
    "keywords": "Method WriteExceptionAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteExceptionAsync(Exception) Writes an exception description in the log. public Task WriteExceptionAsync(Exception exp) Parameters exp Exception The exception which will be written. Returns Task WriteExceptionAsync(Exception, string?) Writes an exception description in the log. public Task WriteExceptionAsync(Exception exp, string? extraContext = null) Parameters exp Exception The exception which will be written. extraContext string Extra context message to append to the exception message. Returns Task"
  },
  "api/Sisk.Core.Http.LogStream.WriteLine.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLine.html",
    "title": "Method WriteLine | Sisk",
    "keywords": "Method WriteLine Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLine() Writes an line-break at the end of the output. public void WriteLine() WriteLine(object?) Writes the text and concats an line-break at the end into the output. public void WriteLine(object? message) Parameters message object The text that will be written in the output. WriteLine(string) Writes the text and concats an line-break at the end into the output. public void WriteLine(string message) Parameters message string The text that will be written in the output. WriteLine(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. public void WriteLine(string format, params object?[] args) Parameters format string The string format that represents the arguments positions. args object[] An array of objects that represents the string format slots values. WriteLine(IFormatProvider?, string, params object?[]) Writes the text format and arguments and appends a line-break at the end into the output, using the specified format provider. public void WriteLine(IFormatProvider? formatProvider, string format, params object?[] args) Parameters formatProvider IFormatProvider The format provider to use when formatting the string. If null, the current culture is used. format string The string format that represents the arguments positions. args object[] An array of objects that represents the string format slots values."
  },
  "api/Sisk.Core.Http.LogStream.WriteLineAsync.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLineAsync.html",
    "title": "Method WriteLineAsync | Sisk",
    "keywords": "Method WriteLineAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineAsync() Writes an line-break at the end of the output. public Task WriteLineAsync() Returns Task WriteLineAsync(object?) Writes the text and concats an line-break at the end into the output. public Task WriteLineAsync(object? message) Parameters message object The text that will be written in the output. Returns Task WriteLineAsync(string) Writes the text and concats an line-break at the end into the output. public Task WriteLineAsync(string message) Parameters message string The text that will be written in the output. Returns Task WriteLineAsync(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. public Task WriteLineAsync(string format, params object?[] args) Parameters format string The string format that represents the arguments positions. args object[] An array of objects that represents the string format slots values. Returns Task WriteLineAsync(IFormatProvider?, string, params object?[]) Writes the text format and arguments and appends a line-break at the end into the output, using the specified format provider. public Task WriteLineAsync(IFormatProvider? formatProvider, string format, params object?[] args) Parameters formatProvider IFormatProvider The format provider to use when formatting the string. If null, the current culture is used. format string The string format that represents the arguments positions. args object[] An array of objects that represents the string format slots values. Returns Task"
  },
  "api/Sisk.Core.Http.LogStream.WriteLineInternal.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLineInternal.html",
    "title": "Method WriteLineInternal | Sisk",
    "keywords": "Method WriteLineInternal Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing. protected virtual void WriteLineInternal(string line) Parameters line string The line which will be written to the log stream."
  },
  "api/Sisk.Core.Http.LogStream.WriteLineInternalAsync.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLineInternalAsync.html",
    "title": "Method WriteLineInternalAsync | Sisk",
    "keywords": "Method WriteLineInternalAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineInternalAsync(string) Represents the asynchronous method that intercepts the line that will be written to an output log before being queued for writing. protected virtual ValueTask WriteLineInternalAsync(string line) Parameters line string The line which will be written to the log stream. Returns ValueTask A ValueTask that represents the asynchronous operation."
  },
  "api/Sisk.Core.Http.LogStream.html": {
    "href": "api/Sisk.Core.Http.LogStream.html",
    "title": "Class LogStream | Sisk",
    "keywords": "Class LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a managed, asynchronous log writer which supports writing safe data to log files or text streams. public class LogStream : IDisposable Inheritance object LogStream Implements IDisposable Derived PrefixedLogStream Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors LogStream() Creates an new LogStream instance with no predefined outputs. LogStream(TextWriter) Creates an new LogStream instance with the given TextWriter object. LogStream(string) Creates an new LogStream instance with the given relative or absolute file path. LogStream(string?, TextWriter?) Creates an new LogStream instance which writes text to an file and an TextWriter. Properties ConsoleOutput Gets a LogStream that writes its output to the Out stream. Disposed Gets an boolean indicating if this LogStream was disposed. Encoding Gets or sets the encoding used for writting data to the output file. This property is only appliable if this instance is using an file-based output. FilePath Gets or sets the absolute path to the file where the log is being written to. IsBuffering Gets an boolean indicating if this LogStream is buffering output messages to their internal message buffer. NormalizeEntries Gets or sets a boolean that indicates that every input must be trimmed and have their line endings normalized before being written to the output stream. RotatingPolicy Gets the defined RotatingLogPolicy for this LogStream. TextWriter Gets the TextWriter object where the log is being written to. Methods Close() Writes all pending logs from the queue and closes all resources used by this object. ConfigureRotatingPolicy(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. This method is an shortcut for calling Configure(long, TimeSpan) of this defined RotatingPolicy method. Dispose() Writes all pending logs from the queue and closes all resources used by this object. Dispose(bool) Writes all pending logs from the queue and closes all resources used by this object. ~LogStream() Flush() Clears the current log queue and blocks the current thread until all content is written to the underlying streams. Peek() Reads the output buffer. To use this method, it's required to set this LogStream buffering with StartBuffering(int). StartBuffering(int) Start buffering all output to an alternate stream in memory for readability with Peek() later. StopBuffering() Stops buffering output. WriteException(Exception) Writes an exception description in the log. WriteException(Exception, string?) Writes an exception description in the log. WriteExceptionAsync(Exception) Writes an exception description in the log. WriteExceptionAsync(Exception, string?) Writes an exception description in the log. WriteLine() Writes an line-break at the end of the output. WriteLine(IFormatProvider?, string, params object?[]) Writes the text format and arguments and appends a line-break at the end into the output, using the specified format provider. WriteLine(object?) Writes the text and concats an line-break at the end into the output. WriteLine(string) Writes the text and concats an line-break at the end into the output. WriteLine(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. WriteLineAsync() Writes an line-break at the end of the output. WriteLineAsync(IFormatProvider?, string, params object?[]) Writes the text format and arguments and appends a line-break at the end into the output, using the specified format provider. WriteLineAsync(object?) Writes the text and concats an line-break at the end into the output. WriteLineAsync(string) Writes the text and concats an line-break at the end into the output. WriteLineAsync(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing. WriteLineInternalAsync(string) Represents the asynchronous method that intercepts the line that will be written to an output log before being queued for writing."
  },
  "api/Sisk.Core.Http.PrefixedLogStream.-ctor.html": {
    "href": "api/Sisk.Core.Http.PrefixedLogStream.-ctor.html",
    "title": "Constructor PrefixedLogStream | Sisk",
    "keywords": "Constructor PrefixedLogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll PrefixedLogStream(Func<string>) Initializes a new instance of the PrefixedLogStream class with the specified prefix function. public PrefixedLogStream(Func<string> prefixFunction) Parameters prefixFunction Func<string> A function that returns the prefix to be added to log messages. PrefixedLogStream(Func<string>, TextWriter) Initializes a new instance of the PrefixedLogStream class with the specified prefix function and text writer. public PrefixedLogStream(Func<string> prefixFunction, TextWriter tw) Parameters prefixFunction Func<string> A function that returns the prefix to be added to log messages. tw TextWriter The text writer to write log messages to. PrefixedLogStream(Func<string>, string) Initializes a new instance of the PrefixedLogStream class with the specified prefix function and file name. public PrefixedLogStream(Func<string> prefixFunction, string filename) Parameters prefixFunction Func<string> A function that returns the prefix to be added to log messages. filename string The name of the file to write log messages to. PrefixedLogStream(Func<string>, string?, TextWriter?) Initializes a new instance of the PrefixedLogStream class with the specified prefix function, file name, and text writer. public PrefixedLogStream(Func<string> prefixFunction, string? filename, TextWriter? tw) Parameters prefixFunction Func<string> A function that returns the prefix to be added to log messages. filename string The name of the file to write log messages to, or null to write to the text writer. tw TextWriter The text writer to write log messages to, or null to write to the file."
  },
  "api/Sisk.Core.Http.PrefixedLogStream.PrefixFunction.html": {
    "href": "api/Sisk.Core.Http.PrefixedLogStream.PrefixFunction.html",
    "title": "Property PrefixFunction | Sisk",
    "keywords": "Property PrefixFunction Namespace Sisk.Core.Http Assembly Sisk.Core.dll PrefixFunction Gets or sets a function that returns the prefix to be added to log messages. public Func<string> PrefixFunction { get; set; } Property Value Func<string>"
  },
  "api/Sisk.Core.Http.PrefixedLogStream.WriteLineInternal.html": {
    "href": "api/Sisk.Core.Http.PrefixedLogStream.WriteLineInternal.html",
    "title": "Method WriteLineInternal | Sisk",
    "keywords": "Method WriteLineInternal Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing. protected override void WriteLineInternal(string line) Parameters line string The line which will be written to the log stream."
  },
  "api/Sisk.Core.Http.PrefixedLogStream.WriteLineInternalAsync.html": {
    "href": "api/Sisk.Core.Http.PrefixedLogStream.WriteLineInternalAsync.html",
    "title": "Method WriteLineInternalAsync | Sisk",
    "keywords": "Method WriteLineInternalAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineInternalAsync(string) Represents the asynchronous method that intercepts the line that will be written to an output log before being queued for writing. protected override ValueTask WriteLineInternalAsync(string line) Parameters line string The line which will be written to the log stream. Returns ValueTask A ValueTask that represents the asynchronous operation."
  },
  "api/Sisk.Core.Http.PrefixedLogStream.html": {
    "href": "api/Sisk.Core.Http.PrefixedLogStream.html",
    "title": "Class PrefixedLogStream | Sisk",
    "keywords": "Class PrefixedLogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents a log stream that prefixes log messages with a custom string. public sealed class PrefixedLogStream : LogStream, IDisposable Inheritance object LogStream PrefixedLogStream Implements IDisposable Inherited Members LogStream.Flush() LogStream.Peek() LogStream.StartBuffering(int) LogStream.StopBuffering() LogStream.Close() LogStream.ConfigureRotatingPolicy(long, TimeSpan) LogStream.WriteException(Exception) LogStream.WriteException(Exception, string) LogStream.WriteLine() LogStream.WriteLine(object) LogStream.WriteLine(string) LogStream.WriteLine(string, params object[]) LogStream.WriteLine(IFormatProvider, string, params object[]) LogStream.WriteExceptionAsync(Exception) LogStream.WriteExceptionAsync(Exception, string) LogStream.WriteLineAsync() LogStream.WriteLineAsync(object) LogStream.WriteLineAsync(string) LogStream.WriteLineAsync(string, params object[]) LogStream.WriteLineAsync(IFormatProvider, string, params object[]) LogStream.Dispose() LogStream.ConsoleOutput LogStream.RotatingPolicy LogStream.IsBuffering LogStream.Disposed LogStream.NormalizeEntries LogStream.FilePath LogStream.TextWriter LogStream.Encoding object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors PrefixedLogStream(Func<string>) Initializes a new instance of the PrefixedLogStream class with the specified prefix function. PrefixedLogStream(Func<string>, TextWriter) Initializes a new instance of the PrefixedLogStream class with the specified prefix function and text writer. PrefixedLogStream(Func<string>, string) Initializes a new instance of the PrefixedLogStream class with the specified prefix function and file name. PrefixedLogStream(Func<string>, string?, TextWriter?) Initializes a new instance of the PrefixedLogStream class with the specified prefix function, file name, and text writer. Properties PrefixFunction Gets or sets a function that returns the prefix to be added to log messages. Methods WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing. WriteLineInternalAsync(string) Represents the asynchronous method that intercepts the line that will be written to an output log before being queued for writing."
  },
  "api/Sisk.Core.Http.RequestListenAction.html": {
    "href": "api/Sisk.Core.Http.RequestListenAction.html",
    "title": "Enum RequestListenAction | Sisk",
    "keywords": "Enum RequestListenAction Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the HTTP server action when receiving an request. public enum RequestListenAction Fields Accept = 1 The server must accept and route the request. Drop = 2 The server must reject the request and close the connection with the client."
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.-ctor.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.-ctor.html",
    "title": "Constructor RotatingLogPolicy | Sisk",
    "keywords": "Constructor RotatingLogPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll RotatingLogPolicy(LogStream) Creates an new RotatingLogPolicy instance with the given LogStream object to watch. public RotatingLogPolicy(LogStream ls) Parameters ls LogStream"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Configure.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Configure.html",
    "title": "Method Configure | Sisk",
    "keywords": "Method Configure Namespace Sisk.Core.Http Assembly Sisk.Core.dll Configure(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. public void Configure(long maximumSize, TimeSpan due) Parameters maximumSize long The non-negative size threshold of the log file size in byte count. due TimeSpan The time interval between checks. Remarks The first run is performed immediately after calling this method."
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Dispose.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Due.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Due.html",
    "title": "Property Due | Sisk",
    "keywords": "Property Due Namespace Sisk.Core.Http Assembly Sisk.Core.dll Due Gets the time interval between checks. public TimeSpan Due { get; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.MaximumSize.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.MaximumSize.html",
    "title": "Property MaximumSize | Sisk",
    "keywords": "Property MaximumSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll MaximumSize Gets the file size threshold in bytes for when the file will be compressed and then cleared. public long MaximumSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.html",
    "title": "Class RotatingLogPolicy | Sisk",
    "keywords": "Class RotatingLogPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a managed utility for rotating log files by their file size. public sealed class RotatingLogPolicy : IDisposable Inheritance object RotatingLogPolicy Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RotatingLogPolicy(LogStream) Creates an new RotatingLogPolicy instance with the given LogStream object to watch. Properties Due Gets the time interval between checks. MaximumSize Gets the file size threshold in bytes for when the file will be compressed and then cleared. Methods Configure(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. Dispose()"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.-ctor.html",
    "title": "Constructor EventSourceRegistrationHandler | Sisk",
    "keywords": "Constructor EventSourceRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EventSourceRegistrationHandler(object, nint) public EventSourceRegistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpRequestEventSource eventSource, AsyncCallback callback, object @object) Parameters sender object eventSource HttpRequestEventSource callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpRequestEventSource) public virtual void Invoke(object sender, HttpRequestEventSource eventSource) Parameters sender object eventSource HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.html",
    "title": "Delegate EventSourceRegistrationHandler | Sisk",
    "keywords": "Delegate EventSourceRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpEventSourceCollection registers an new event source connection. public delegate void EventSourceRegistrationHandler(object sender, HttpRequestEventSource eventSource) Parameters sender object Represents the caller HttpEventSourceCollection object. eventSource HttpRequestEventSource Represents the registered HttpRequestEventSource event source connection. Constructors EventSourceRegistrationHandler(object, nint) Methods BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpRequestEventSource)"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.-ctor.html",
    "title": "Constructor EventSourceUnregistrationHandler | Sisk",
    "keywords": "Constructor EventSourceUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EventSourceUnregistrationHandler(object, nint) public EventSourceUnregistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpRequestEventSource eventSource, AsyncCallback callback, object @object) Parameters sender object eventSource HttpRequestEventSource callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpRequestEventSource) public virtual void Invoke(object sender, HttpRequestEventSource eventSource) Parameters sender object eventSource HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.html",
    "title": "Delegate EventSourceUnregistrationHandler | Sisk",
    "keywords": "Delegate EventSourceUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpEventSourceCollection is removed and had their connection closed. public delegate void EventSourceUnregistrationHandler(object sender, HttpRequestEventSource eventSource) Parameters sender object Represents the caller HttpEventSourceCollection object. eventSource HttpRequestEventSource Represents the closed HttpRequestEventSource event source connection. Constructors EventSourceUnregistrationHandler(object, nint) Methods BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpRequestEventSource)"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.ActiveConnections.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.ActiveConnections.html",
    "title": "Property ActiveConnections | Sisk",
    "keywords": "Property ActiveConnections Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ActiveConnections Gets an number indicating the amount of active event source connections. public int ActiveConnections { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All.html",
    "title": "Method All | Sisk",
    "keywords": "Method All Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll All() Gets all actives HttpRequestEventSource instances. public HttpRequestEventSource[] All() Returns HttpRequestEventSource[]"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Count.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.DropAll.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.DropAll.html",
    "title": "Method DropAll | Sisk",
    "keywords": "Method DropAll Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DropAll() Closes and disposes all registered and active HttpRequestEventSource in this collections. public void DropAll()"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Find.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Find.html",
    "title": "Method Find | Sisk",
    "keywords": "Method Find Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Find(Func<string, bool>) Gets all actives HttpRequestEventSource instances that matches their identifier predicate. public HttpRequestEventSource[] Find(Func<string, bool> predicate) Parameters predicate Func<string, bool> The expression on the an non-empty event source identifier. Returns HttpRequestEventSource[]"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetByIdentifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetByIdentifier.html",
    "title": "Method GetByIdentifier | Sisk",
    "keywords": "Method GetByIdentifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetByIdentifier(string) Gets the event source connection for the specified identifier. public HttpRequestEventSource? GetByIdentifier(string identifier) Parameters identifier string The event source identifier. Returns HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetEnumerator.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<HttpRequestEventSource> GetEnumerator() Returns IEnumerator<HttpRequestEventSource>"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceRegistered.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceRegistered.html",
    "title": "Event OnEventSourceRegistered | Sisk",
    "keywords": "Event OnEventSourceRegistered Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpRequestEventSource is registered in this collection. public event EventSourceRegistrationHandler? OnEventSourceRegistered Returns EventSourceRegistrationHandler Represents an event that is fired when an is registered in this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceUnregistration.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceUnregistration.html",
    "title": "Event OnEventSourceUnregistration | Sisk",
    "keywords": "Event OnEventSourceUnregistration Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpRequestEventSource is closed and removed from this collection. public event EventSourceUnregistrationHandler? OnEventSourceUnregistration Returns EventSourceUnregistrationHandler Represents an event that is fired when an is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.html",
    "title": "Class HttpEventSourceCollection | Sisk",
    "keywords": "Class HttpEventSourceCollection Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides a managed object to manage HttpRequestEventSource connections. public sealed class HttpEventSourceCollection : IReadOnlyCollection<HttpRequestEventSource>, IEnumerable<HttpRequestEventSource>, IEnumerable Inheritance object HttpEventSourceCollection Implements IReadOnlyCollection<HttpRequestEventSource> IEnumerable<HttpRequestEventSource> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ActiveConnections Gets an number indicating the amount of active event source connections. Count Methods All() Gets all actives HttpRequestEventSource instances. DropAll() Closes and disposes all registered and active HttpRequestEventSource in this collections. Find(Func<string, bool>) Gets all actives HttpRequestEventSource instances that matches their identifier predicate. GetByIdentifier(string) Gets the event source connection for the specified identifier. GetEnumerator() Events OnEventSourceRegistered Represents an event that is fired when an HttpRequestEventSource is registered in this collection. OnEventSourceUnregistration Represents an event that is fired when an HttpRequestEventSource is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader.html",
    "title": "Method AppendHeader | Sisk",
    "keywords": "Method AppendHeader Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll AppendHeader(string, string) Sends an header to the streaming context. public void AppendHeader(string name, string value) Parameters name string The header name. value string The header value."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Cancel.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Cancel.html",
    "title": "Method Cancel | Sisk",
    "keywords": "Method Cancel Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Cancel() Cancels the sending queue from sending pending messages and clears the queue. public void Cancel()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes the event listener and it's connection. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Dispose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Dispose() Flushes and releases the used resources of this class instance. public void Dispose()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.HttpRequest.html",
    "title": "Property HttpRequest | Sisk",
    "keywords": "Property HttpRequest Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll HttpRequest Gets the HttpRequest object which created this Event Source instance. public HttpRequest HttpRequest { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Identifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Identifier.html",
    "title": "Property Identifier | Sisk",
    "keywords": "Property Identifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Identifier Gets an unique identifier label to this EventStream connection, useful for finding this connection's reference later. public string? Identifier { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.IsActive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.IsActive.html",
    "title": "Property IsActive | Sisk",
    "keywords": "Property IsActive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsActive Gets an boolean indicating if this connection is open and this instance can send messages. public bool IsActive { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.KeepAlive.html",
    "title": "Method KeepAlive | Sisk",
    "keywords": "Method KeepAlive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll KeepAlive() Asynchronously waits for the connection to close before continuing execution. This method is released when either the client or the server reaches an sending failure. public void KeepAlive()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.PingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.PingPolicy.html",
    "title": "Property PingPolicy | Sisk",
    "keywords": "Property PingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll PingPolicy Gets the HttpStreamPingPolicy for this HTTP event source connection. public HttpStreamPingPolicy PingPolicy { get; } Property Value HttpStreamPingPolicy"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Send.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Send.html",
    "title": "Method Send | Sisk",
    "keywords": "Method Send Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Send(string?, string) Sends an event to the client over the HTTP connection. public bool Send(string? data, string fieldName = \"data\") Parameters data string The data to be sent as part of the event. fieldName string The field name for the event data. Defaults to \"data\". Returns bool True if the event was sent successfully, false otherwise."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SendAsync.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SendAsync.html",
    "title": "Method SendAsync | Sisk",
    "keywords": "Method SendAsync Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SendAsync(string?, string) Asynchronously sends an event to the client over the HTTP connection. public ValueTask<bool> SendAsync(string? data, string fieldName = \"data\") Parameters data string The data to be sent as part of the event. fieldName string The field name for the event data. Defaults to \"data\". Returns ValueTask<bool> A ValueTask<TResult> that represents the asynchronous operation. The result is true if the event was sent successfully, false otherwise."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SentContentLength.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SentContentLength.html",
    "title": "Property SentContentLength | Sisk",
    "keywords": "Property SentContentLength Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SentContentLength Gets an integer indicating the total bytes sent by this instance to the client. public int SentContentLength { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail.html",
    "title": "Method WaitForFail | Sisk",
    "keywords": "Method WaitForFail Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitForFail(TimeSpan) Asynchronously waits for the connection to close before continuing execution with an maximum keep alive timeout. This method is released when either the client or the server reaches an sending failure. public void WaitForFail(TimeSpan maximumIdleTolerance) Parameters maximumIdleTolerance TimeSpan The maximum timeout interval for an idle connection to automatically release this method."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WithPing.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WithPing.html",
    "title": "Method WithPing | Sisk",
    "keywords": "Method WithPing Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Event Source. public void WithPing(Action<HttpStreamPingPolicy> act) Parameters act Action<HttpStreamPingPolicy> The method that runs on the ping policy for this HTTP Event Source."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.html",
    "title": "Class HttpRequestEventSource | Sisk",
    "keywords": "Class HttpRequestEventSource Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll An HttpRequestEventSource instance opens a persistent connection to the request, which sends events in text/event-stream format. public sealed class HttpRequestEventSource : IDisposable Inheritance object HttpRequestEventSource Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpRequest Gets the HttpRequest object which created this Event Source instance. Identifier Gets an unique identifier label to this EventStream connection, useful for finding this connection's reference later. IsActive Gets an boolean indicating if this connection is open and this instance can send messages. PingPolicy Gets the HttpStreamPingPolicy for this HTTP event source connection. SentContentLength Gets an integer indicating the total bytes sent by this instance to the client. Methods AppendHeader(string, string) Sends an header to the streaming context. Cancel() Cancels the sending queue from sending pending messages and clears the queue. Close() Closes the event listener and it's connection. Dispose() Flushes and releases the used resources of this class instance. KeepAlive() Asynchronously waits for the connection to close before continuing execution. This method is released when either the client or the server reaches an sending failure. Send(string?, string) Sends an event to the client over the HTTP connection. SendAsync(string?, string) Asynchronously sends an event to the client over the HTTP connection. WaitForFail(TimeSpan) Asynchronously waits for the connection to close before continuing execution with an maximum keep alive timeout. This method is released when either the client or the server reaches an sending failure. WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Event Source."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes this HTTP response stream connection between the server and the client and returns an empty HttpResponse to finish the HTTP server context. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.ResponseStream.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.ResponseStream.html",
    "title": "Property ResponseStream | Sisk",
    "keywords": "Property ResponseStream Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ResponseStream Gets the Stream that represents the HTTP response output stream. public Stream ResponseStream { get; } Property Value Stream"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SendChunked.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SendChunked.html",
    "title": "Property SendChunked | Sisk",
    "keywords": "Property SendChunked Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SendChunked Gets or sets whether this HTTP response stream should use chunked transfer encoding. public bool SendChunked { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetContentLength.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetContentLength.html",
    "title": "Method SetContentLength | Sisk",
    "keywords": "Method SetContentLength Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetContentLength(long) Sets the Content-Length header of this response stream. If this response stream is using chunked transfer encoding, this method will do nothing. public void SetContentLength(long contentLength) Parameters contentLength long The length in bytes of the content stream."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetCookie.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetCookie.html",
    "title": "Method SetCookie | Sisk",
    "keywords": "Method SetCookie Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(Cookie cookie) Parameters cookie Cookie The cookie object. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value) Parameters name string The cookie name. value string The cookie value. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetHeader.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetHeader.html",
    "title": "Method SetHeader | Sisk",
    "keywords": "Method SetHeader Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetHeader(string, object?) Sets the specific HTTP header into this response stream. public void SetHeader(string headerName, object? value) Parameters headerName string The HTTP header name. value object The HTTP header value. Remarks Headers are sent immediately, along with the HTTP response code, after starting to send content or closing this stream."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetStatus.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.SetStatus.html",
    "title": "Method SetStatus | Sisk",
    "keywords": "Method SetStatus Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetStatus(int) Sets the HTTP status code for this response stream. public void SetStatus(int httpStatusCode) Parameters httpStatusCode int The HTTP status code. SetStatus(HttpStatusCode) Sets the HTTP status code for this response stream. public void SetStatus(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode The HTTP status code. SetStatus(HttpStatusInformation) Sets the HTTP status code and description for this response stream. public void SetStatus(HttpStatusInformation statusCode) Parameters statusCode HttpStatusInformation The custom HTTP status code information."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.Write.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.Write.html",
    "title": "Method Write | Sisk",
    "keywords": "Method Write Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Write(ReadOnlySpan<byte>) Writes an sequence of bytes to the HTTP response stream. public void Write(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The read only memory that includes the buffer which will be written to the HTTP response. Write(byte[]) Writes an sequence of bytes to the HTTP response stream. public void Write(byte[] buffer) Parameters buffer byte[] The byte array that includes the buffer which will be written to the HTTP response."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStreamManager.html",
    "title": "Class HttpResponseStreamManager | Sisk",
    "keywords": "Class HttpResponseStreamManager Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents a way to manage HTTP requests with their output streams, without relying on synchronous content. public sealed class HttpResponseStreamManager Inheritance object HttpResponseStreamManager Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ResponseStream Gets the Stream that represents the HTTP response output stream. SendChunked Gets or sets whether this HTTP response stream should use chunked transfer encoding. Methods Close() Closes this HTTP response stream connection between the server and the client and returns an empty HttpResponse to finish the HTTP server context. SetContentLength(long) Sets the Content-Length header of this response stream. If this response stream is using chunked transfer encoding, this method will do nothing. SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. SetHeader(string, object?) Sets the specific HTTP header into this response stream. SetStatus(HttpStatusInformation) Sets the HTTP status code and description for this response stream. SetStatus(int) Sets the HTTP status code for this response stream. SetStatus(HttpStatusCode) Sets the HTTP status code for this response stream. Write(byte[]) Writes an sequence of bytes to the HTTP response stream. Write(ReadOnlySpan<byte>) Writes an sequence of bytes to the HTTP response stream."
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.DataMessage.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.DataMessage.html",
    "title": "Property DataMessage | Sisk",
    "keywords": "Property DataMessage Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DataMessage Gets or sets the payload message that is sent to the server as a ping message. public string DataMessage { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Dispose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Interval.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Interval.html",
    "title": "Property Interval | Sisk",
    "keywords": "Property Interval Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Interval Gets or sets the sending interval for each ping message. public TimeSpan Interval { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Start.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Start() Starts sending periodic pings to the client. public void Start() Start(string, TimeSpan) Configures and starts sending periodic pings to the client. public void Start(string dataMessage, TimeSpan interval) Parameters dataMessage string The payload message that is sent to the server as a ping message. interval TimeSpan The sending interval for each ping message."
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.html",
    "title": "Class HttpStreamPingPolicy | Sisk",
    "keywords": "Class HttpStreamPingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides an automatic ping sender for HTTP Event Source connections. public sealed class HttpStreamPingPolicy : IDisposable Inheritance object HttpStreamPingPolicy Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DataMessage Gets or sets the payload message that is sent to the server as a ping message. Interval Gets or sets the sending interval for each ping message. Methods Dispose() Start() Starts sending periodic pings to the client. Start(string, TimeSpan) Configures and starts sending periodic pings to the client."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes the connection between the client and the server and returns an HTTP response indicating that the connection has been terminated. This method will not throw an exception if the connection is already closed. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Dispose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.HttpRequest.html",
    "title": "Property HttpRequest | Sisk",
    "keywords": "Property HttpRequest Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll HttpRequest Gets the HttpRequest object which created this Web Socket instance. public HttpRequest HttpRequest { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Identifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Identifier.html",
    "title": "Property Identifier | Sisk",
    "keywords": "Property Identifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Identifier Gets an unique identifier label to this Web Socket connection, useful for finding this connection's reference later. public string? Identifier { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.IsClosed.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.IsClosed.html",
    "title": "Property IsClosed | Sisk",
    "keywords": "Property IsClosed Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsClosed Gets an boolean indicating if this Web Socket connection is closed. public bool IsClosed { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.MaxAttempts.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.MaxAttempts.html",
    "title": "Property MaxAttempts | Sisk",
    "keywords": "Property MaxAttempts Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll MaxAttempts Gets or sets the maximum number of attempts to send a failed message before the server closes the connection. Set it to -1 to don't close the connection on failed attempts. public int MaxAttempts { get; set; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.OnReceive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.OnReceive.html",
    "title": "Event OnReceive | Sisk",
    "keywords": "Event OnReceive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents the event which is called when this web socket receives an message from remote origin. public event EventHandler<WebSocketMessage>? OnReceive Returns EventHandler<WebSocketMessage> Represents the event which is called when this web socket receives an message from remote origin."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.PingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.PingPolicy.html",
    "title": "Property PingPolicy | Sisk",
    "keywords": "Property PingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll PingPolicy Gets the HttpStreamPingPolicy for this HTTP web socket connection. public HttpStreamPingPolicy PingPolicy { get; } Property Value HttpStreamPingPolicy"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Send.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Send.html",
    "title": "Method Send | Sisk",
    "keywords": "Method Send Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Send(string) Sends an text message to the remote point. public bool Send(string message) Parameters message string The target message which will be as an encoded using the request preferred encoding. Returns bool Send(byte[]) Sends an binary message to the remote point. public bool Send(byte[] buffer) Parameters buffer byte[] The target byte array. Returns bool Send(byte[], int, int) Sends an binary message to the remote point. public bool Send(byte[] buffer, int start, int length) Parameters buffer byte[] The target byte array. start int The index at which to begin the memory. length int The number of items in the memory. Returns bool Send(ReadOnlyMemory<byte>) Sends an binary message to the remote point. public bool Send(ReadOnlyMemory<byte> buffer) Parameters buffer ReadOnlyMemory<byte> The target byte memory. Returns bool"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.SendAsync.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.SendAsync.html",
    "title": "Method SendAsync | Sisk",
    "keywords": "Method SendAsync Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SendAsync(string) Asynchronously sends an text message to the remote point. public ValueTask<bool> SendAsync(string message) Parameters message string The target message which will be as an encoded UTF-8 string. Returns ValueTask<bool> SendAsync(ReadOnlyMemory<byte>) Asynchronously sends an binary message to the remote point. public ValueTask<bool> SendAsync(ReadOnlyMemory<byte> buffer) Parameters buffer ReadOnlyMemory<byte> The target message which will be as an encoded UTF-8 string. Returns ValueTask<bool>"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.State.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.State.html",
    "title": "Property State | Sisk",
    "keywords": "Property State Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll State Gets or sets an object linked with this WebSocket session. public object? State { get; set; } Property Value object"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitForClose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitForClose.html",
    "title": "Method WaitForClose | Sisk",
    "keywords": "Method WaitForClose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitForClose(TimeSpan) Blocks the current call stack until the connection is terminated by the client or the server, limited to the maximum timeout. public void WaitForClose(TimeSpan timeout) Parameters timeout TimeSpan Defines the timeout timer before the connection expires without any message. WaitForClose() Blocks the current call stack until the connection is terminated by either the client or the server. public void WaitForClose()"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitNext.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitNext.html",
    "title": "Method WaitNext | Sisk",
    "keywords": "Method WaitNext Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitNext() Blocks the current thread and waits the next incoming message from this web socket instance. public WebSocketMessage? WaitNext() Returns WebSocketMessage Remarks Null is returned if a connection error is thrown. WaitNext(TimeSpan) Blocks the current thread and waits the next incoming message from this web socket instance within the maximum defined timeout. public WebSocketMessage? WaitNext(TimeSpan timeout) Parameters timeout TimeSpan The maximum time to wait until the next message. Returns WebSocketMessage Remarks Null is returned if a connection error is thrown."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitTimeout.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitTimeout.html",
    "title": "Property WaitTimeout | Sisk",
    "keywords": "Property WaitTimeout Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitTimeout Gets or sets the maximum wait time for synchronous listener methods like WaitNext(). public TimeSpan WaitTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WithPing.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WithPing.html",
    "title": "Method WithPing | Sisk",
    "keywords": "Method WithPing Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Web Socket. public HttpWebSocket WithPing(Action<HttpStreamPingPolicy> act) Parameters act Action<HttpStreamPingPolicy> The method that runs on the ping policy for this HTTP Web Socket. Returns HttpWebSocket WithPing(string, TimeSpan) Configures the ping policy for this instance of HTTP Web Socket. public HttpWebSocket WithPing(string probeMessage, TimeSpan interval) Parameters probeMessage string The payload/probe message that is sent to the client. interval TimeSpan The sending interval for each probe message. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.html",
    "title": "Class HttpWebSocket | Sisk",
    "keywords": "Class HttpWebSocket Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides an persistent bi-directional socket between the client and the HTTP server. public sealed class HttpWebSocket : IDisposable Inheritance object HttpWebSocket Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpRequest Gets the HttpRequest object which created this Web Socket instance. Identifier Gets an unique identifier label to this Web Socket connection, useful for finding this connection's reference later. IsClosed Gets an boolean indicating if this Web Socket connection is closed. MaxAttempts Gets or sets the maximum number of attempts to send a failed message before the server closes the connection. Set it to -1 to don't close the connection on failed attempts. PingPolicy Gets the HttpStreamPingPolicy for this HTTP web socket connection. State Gets or sets an object linked with this WebSocket session. WaitTimeout Gets or sets the maximum wait time for synchronous listener methods like WaitNext(). Methods Close() Closes the connection between the client and the server and returns an HTTP response indicating that the connection has been terminated. This method will not throw an exception if the connection is already closed. Dispose() Send(byte[]) Sends an binary message to the remote point. Send(byte[], int, int) Sends an binary message to the remote point. Send(ReadOnlyMemory<byte>) Sends an binary message to the remote point. Send(string) Sends an text message to the remote point. SendAsync(ReadOnlyMemory<byte>) Asynchronously sends an binary message to the remote point. SendAsync(string) Asynchronously sends an text message to the remote point. WaitForClose() Blocks the current call stack until the connection is terminated by either the client or the server. WaitForClose(TimeSpan) Blocks the current call stack until the connection is terminated by the client or the server, limited to the maximum timeout. WaitNext() Blocks the current thread and waits the next incoming message from this web socket instance. WaitNext(TimeSpan) Blocks the current thread and waits the next incoming message from this web socket instance within the maximum defined timeout. WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Web Socket. WithPing(string, TimeSpan) Configures the ping policy for this instance of HTTP Web Socket. Events OnReceive Represents the event which is called when this web socket receives an message from remote origin."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.ActiveConnections.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.ActiveConnections.html",
    "title": "Property ActiveConnections | Sisk",
    "keywords": "Property ActiveConnections Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ActiveConnections Gets an number indicating the amount of active web socket connections. public int ActiveConnections { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.All.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.All.html",
    "title": "Method All | Sisk",
    "keywords": "Method All Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll All() Gets all actives HttpWebSocket instances. public HttpWebSocket[] All() Returns HttpWebSocket[]"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Count.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.DropAll.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.DropAll.html",
    "title": "Method DropAll | Sisk",
    "keywords": "Method DropAll Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DropAll() Closes all registered and active HttpWebSocket in this collections. public void DropAll()"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Find.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Find.html",
    "title": "Method Find | Sisk",
    "keywords": "Method Find Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Find(Func<string, bool>) Gets all actives HttpWebSocket instances that matches their identifier predicate. public HttpWebSocket[] Find(Func<string, bool> predicate) Parameters predicate Func<string, bool> The expression on the an non-empty Web Socket identifier. Returns HttpWebSocket[]"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetByIdentifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetByIdentifier.html",
    "title": "Method GetByIdentifier | Sisk",
    "keywords": "Method GetByIdentifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetByIdentifier(string) Gets the Web Sockect connection for the specified identifier. public HttpWebSocket? GetByIdentifier(string identifier) Parameters identifier string The Web Socket identifier. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetEnumerator.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<HttpWebSocket> GetEnumerator() Returns IEnumerator<HttpWebSocket>"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketRegister.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketRegister.html",
    "title": "Event OnWebSocketRegister | Sisk",
    "keywords": "Event OnWebSocketRegister Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpWebSocket is registered in this collection. public event WebSocketRegistrationHandler? OnWebSocketRegister Returns WebSocketRegistrationHandler Represents an event that is fired when an is registered in this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketUnregister.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketUnregister.html",
    "title": "Event OnWebSocketUnregister | Sisk",
    "keywords": "Event OnWebSocketUnregister Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpWebSocket is closed and removed from this collection. public event WebSocketRegistrationHandler? OnWebSocketUnregister Returns WebSocketRegistrationHandler Represents an event that is fired when an is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.html",
    "title": "Class HttpWebSocketConnectionCollection | Sisk",
    "keywords": "Class HttpWebSocketConnectionCollection Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides a managed object to manage HttpWebSocket connections. public sealed class HttpWebSocketConnectionCollection : IReadOnlyCollection<HttpWebSocket>, IEnumerable<HttpWebSocket>, IEnumerable Inheritance object HttpWebSocketConnectionCollection Implements IReadOnlyCollection<HttpWebSocket> IEnumerable<HttpWebSocket> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ActiveConnections Gets an number indicating the amount of active web socket connections. Count Methods All() Gets all actives HttpWebSocket instances. DropAll() Closes all registered and active HttpWebSocket in this collections. Find(Func<string, bool>) Gets all actives HttpWebSocket instances that matches their identifier predicate. GetByIdentifier(string) Gets the Web Sockect connection for the specified identifier. GetEnumerator() Events OnWebSocketRegister Represents an event that is fired when an HttpWebSocket is registered in this collection. OnWebSocketUnregister Represents an event that is fired when an HttpWebSocket is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.GetString.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.GetString.html",
    "title": "Method GetString | Sisk",
    "keywords": "Method GetString Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetString(Encoding) Reads the message bytes as string using the specified encoding. public string GetString(Encoding encoding) Parameters encoding Encoding The encoding which will be used to decode the message. Returns string GetString() Reads the message bytes as string using the HTTP request encoding. public string GetString() Returns string"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.IsClose.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.IsClose.html",
    "title": "Property IsClose | Sisk",
    "keywords": "Property IsClose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsClose Gets an boolean indicating that this message is an remote closing message. public bool IsClose { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.IsEnd.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.IsEnd.html",
    "title": "Property IsEnd | Sisk",
    "keywords": "Property IsEnd Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsEnd Gets an boolean indicating that this message is the last chunk of the message. public bool IsEnd { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.Length.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.Length.html",
    "title": "Property Length | Sisk",
    "keywords": "Property Length Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Length Gets the message length in byte count. public int Length { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.MessageBytes.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.MessageBytes.html",
    "title": "Property MessageBytes | Sisk",
    "keywords": "Property MessageBytes Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll MessageBytes Gets an byte array with the message contents. public byte[] MessageBytes { get; } Property Value byte[]"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.Sender.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.Sender.html",
    "title": "Property Sender | Sisk",
    "keywords": "Property Sender Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Sender Gets the sender HttpWebSocket object instance which received this message. public HttpWebSocket Sender { get; } Property Value HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.html",
    "title": "Class WebSocketMessage | Sisk",
    "keywords": "Class WebSocketMessage Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an websocket request message received by an websocket server. public sealed class WebSocketMessage Inheritance object WebSocketMessage Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties IsClose Gets an boolean indicating that this message is an remote closing message. IsEnd Gets an boolean indicating that this message is the last chunk of the message. Length Gets the message length in byte count. MessageBytes Gets an byte array with the message contents. Sender Gets the sender HttpWebSocket object instance which received this message. Methods GetString() Reads the message bytes as string using the HTTP request encoding. GetString(Encoding) Reads the message bytes as string using the specified encoding."
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.-ctor.html",
    "title": "Constructor WebSocketRegistrationHandler | Sisk",
    "keywords": "Constructor WebSocketRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WebSocketRegistrationHandler(object, nint) public WebSocketRegistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpWebSocket, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpWebSocket ws, AsyncCallback callback, object @object) Parameters sender object ws HttpWebSocket callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpWebSocket) public virtual void Invoke(object sender, HttpWebSocket ws) Parameters sender object ws HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.html",
    "title": "Delegate WebSocketRegistrationHandler | Sisk",
    "keywords": "Delegate WebSocketRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpWebSocketConnectionCollection registers an new web socket connection. public delegate void WebSocketRegistrationHandler(object sender, HttpWebSocket ws) Parameters sender object Represents the caller HttpWebSocketConnectionCollection object. ws HttpWebSocket Represents the registered HttpWebSocket web socket connection. Constructors WebSocketRegistrationHandler(object, nint) Methods BeginInvoke(object, HttpWebSocket, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpWebSocket)"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.-ctor.html",
    "title": "Constructor WebSocketUnregistrationHandler | Sisk",
    "keywords": "Constructor WebSocketUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WebSocketUnregistrationHandler(object, nint) public WebSocketUnregistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpWebSocket, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpWebSocket ws, AsyncCallback callback, object @object) Parameters sender object ws HttpWebSocket callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpWebSocket) public virtual void Invoke(object sender, HttpWebSocket ws) Parameters sender object ws HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.html",
    "title": "Delegate WebSocketUnregistrationHandler | Sisk",
    "keywords": "Delegate WebSocketUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpWebSocketConnectionCollection is removed and had it's connection closed. public delegate void WebSocketUnregistrationHandler(object sender, HttpWebSocket ws) Parameters sender object Represents the caller HttpWebSocketConnectionCollection object. ws HttpWebSocket Represents the closed HttpWebSocket web socket connection. Constructors WebSocketUnregistrationHandler(object, nint) Methods BeginInvoke(object, HttpWebSocket, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpWebSocket)"
  },
  "api/Sisk.Core.Http.Streams.html": {
    "href": "api/Sisk.Core.Http.Streams.html",
    "title": "Namespace Sisk.Core.Http.Streams | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Streams Classes HttpEventSourceCollection Provides a managed object to manage HttpRequestEventSource connections. HttpRequestEventSource An HttpRequestEventSource instance opens a persistent connection to the request, which sends events in text/event-stream format. HttpResponseStreamManager Represents a way to manage HTTP requests with their output streams, without relying on synchronous content. HttpStreamPingPolicy Provides an automatic ping sender for HTTP Event Source connections. HttpWebSocket Provides an persistent bi-directional socket between the client and the HTTP server. HttpWebSocketConnectionCollection Provides a managed object to manage HttpWebSocket connections. WebSocketMessage Represents an websocket request message received by an websocket server. Delegates EventSourceRegistrationHandler Represents an function that is called when an HttpEventSourceCollection registers an new event source connection. EventSourceUnregistrationHandler Represents an function that is called when an HttpEventSourceCollection is removed and had their connection closed. WebSocketRegistrationHandler Represents an function that is called when an HttpWebSocketConnectionCollection registers an new web socket connection. WebSocketUnregistrationHandler Represents an function that is called when an HttpWebSocketConnectionCollection is removed and had it's connection closed."
  },
  "api/Sisk.Core.Http.html": {
    "href": "api/Sisk.Core.Http.html",
    "title": "Namespace Sisk.Core.Http | Sisk",
    "keywords": "Namespace Sisk.Core.Http Namespaces Sisk.Core.Http.Handlers Sisk.Core.Http.Hosting Sisk.Core.Http.Streams Classes BrotliContent Represents an HTTP content that is compressed using the Brotli algorithm. CompressedContent Represents a base class for HTTP contents served over an compressing stream. DefaultMessagePage Provides methods for creating informative static pages used by Sisk. DeflateContent Represents an HTTP content that is compressed using the Deflate algorithm. ForwardingResolver Provides HTTP forwarding resolving methods that can be used to resolving the client remote address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. GZipContent Represents an HTTP content that is compressed using the GZip algorithm. HtmlContent Provides HTTP content based on HTML contents. HttpContext Represents an context that is shared in a entire HTTP session. HttpKnownHeaderNames Provides most of the most commonly known HTTP headers for constants. HttpRequest Represents an HTTP request received by a Sisk server. HttpRequestException Represents an exception that is thrown while a request is being interpreted by the HTTP server. HttpResponse Represents an HTTP Response. HttpResponseExtensions Provides useful extensions for HttpResponse objects. HttpServer Provides an lightweight HTTP server powered by Sisk. HttpServerConfiguration Provides execution parameters for an HttpServer. HttpServerExecutionResult Represents the results of an request execution on the HTTP server. ListeningHost Provides a structure to contain the fields needed by an http server host. ListeningHostRepository Represents an fluent repository of ListeningHost that can add, modify, or remove listening hosts while an HttpServer is running. LogStream Provides a managed, asynchronous log writer which supports writing safe data to log files or text streams. PrefixedLogStream Represents a log stream that prefixes log messages with a custom string. RotatingLogPolicy Provides a managed utility for rotating log files by their file size. Structs HttpStatusInformation Represents a value that holds an HTTP response status information, with it's status code and description. ListeningPort Provides a structure to contain a listener port for an ListeningHost instance. Enums HttpServerExecutionStatus Represents the status of an execution of a request on an HttpServer. RequestListenAction Represents the HTTP server action when receiving an request."
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.-ctor.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.-ctor.html",
    "title": "Constructor AsyncRequestHandler | Sisk",
    "keywords": "Constructor AsyncRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll AsyncRequestHandler() protected AsyncRequestHandler()"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.Create.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>>, RequestHandlerExecutionMode) Gets an inline AsyncRequestHandler that resolves to the specified function. public static AsyncRequestHandler Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>> execute, RequestHandlerExecutionMode executionMode = RequestHandlerExecutionMode.BeforeResponse) Parameters execute Func<HttpRequest, HttpContext, Task<HttpResponse>> The function that the AsyncRequestHandler will run. executionMode RequestHandlerExecutionMode Optional. Determines where the request handler will be executed. Returns AsyncRequestHandler"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.ExecuteAsync.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.ExecuteAsync.html",
    "title": "Method ExecuteAsync | Sisk",
    "keywords": "Method ExecuteAsync Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecuteAsync(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. public abstract Task<HttpResponse?> ExecuteAsync(HttpRequest request, HttpContext context) Parameters request HttpRequest The entry HTTP request. context HttpContext The HTTP request context. It may contain information from other IRequestHandler. Returns Task<HttpResponse>"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecutionMode Gets or sets when this IRequestHandler should run. public virtual RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.Next.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.Next.html",
    "title": "Method Next | Sisk",
    "keywords": "Method Next Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Next() Returns an null HttpResponse reference, which points to the next request handler or route action. public HttpResponse? Next() Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.html",
    "title": "Class AsyncRequestHandler | Sisk",
    "keywords": "Class AsyncRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a class that implements IRequestHandler and its execution method is asynchronous. public abstract class AsyncRequestHandler : IRequestHandler Inheritance object AsyncRequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors AsyncRequestHandler() Properties ExecutionMode Gets or sets when this IRequestHandler should run. Methods Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>>, RequestHandlerExecutionMode) Gets an inline AsyncRequestHandler that resolves to the specified function. ExecuteAsync(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. Next() Returns an null HttpResponse reference, which points to the next request handler or route action."
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.-ctor.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.-ctor.html",
    "title": "Constructor ExceptionErrorCallback | Sisk",
    "keywords": "Constructor ExceptionErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExceptionErrorCallback(object, nint) public ExceptionErrorCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(Exception, HttpContext, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(Exception ex, HttpContext context, AsyncCallback callback, object @object) Parameters ex Exception context HttpContext callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.Invoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(Exception, HttpContext) public virtual HttpResponse Invoke(Exception ex, HttpContext context) Parameters ex Exception context HttpContext Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.html",
    "title": "Delegate ExceptionErrorCallback | Sisk",
    "keywords": "Delegate ExceptionErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route action threw an exception. public delegate HttpResponse ExceptionErrorCallback(Exception ex, HttpContext context) Parameters ex Exception Represents the function that is called after the route action threw an exception. context HttpContext Represents the function that is called after the route action threw an exception. Returns HttpResponse Represents the function that is called after the route action threw an exception. Constructors ExceptionErrorCallback(object, nint) Methods BeginInvoke(Exception, HttpContext, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(Exception, HttpContext)"
  },
  "api/Sisk.Core.Routing.IRequestHandler.Execute.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.Execute.html",
    "title": "Method Execute | Sisk",
    "keywords": "Method Execute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. HttpResponse? Execute(HttpRequest request, HttpContext context) Parameters request HttpRequest The entry HTTP request. context HttpContext The HTTP request context. It may contain information from other IRequestHandler. Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.IRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecutionMode Gets or sets when this IRequestHandler should run. RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.Core.Routing.IRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.html",
    "title": "Interface IRequestHandler | Sisk",
    "keywords": "Interface IRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an interface that is executed before a request. public interface IRequestHandler Properties ExecutionMode Gets or sets when this IRequestHandler should run. Methods Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued."
  },
  "api/Sisk.Core.Routing.LogOutput.html": {
    "href": "api/Sisk.Core.Routing.LogOutput.html",
    "title": "Enum LogOutput | Sisk",
    "keywords": "Enum LogOutput Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Determines the way the server can write log messages. This enumerator is for giving permissions for certain contexts to be able or not to write to the server logs, such as AccessLogsStream and ErrorsLogsStream. [Flags] public enum LogOutput Fields AccessLog = 2 Determines that the context or the route can write log messages only to the access logs through AccessLogsStream. Both = AccessLog | ErrorLog Determines that the context or the route can write log messages to both error and access logs. ErrorLog = 4 Determines that the context or the route can write error messages only to the error logs through ErrorsLogsStream. None = 0 Determines that the context or the route cannot write any log messages."
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.-ctor.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.-ctor.html",
    "title": "Constructor ParameterlessRouteAction | Sisk",
    "keywords": "Constructor ParameterlessRouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ParameterlessRouteAction(object, nint) public ParameterlessRouteAction(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(AsyncCallback, object) public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object) Parameters callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual object EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns object"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.Invoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke() public virtual object Invoke() Returns object"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.html",
    "title": "Delegate ParameterlessRouteAction | Sisk",
    "keywords": "Delegate ParameterlessRouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route is matched with the request. public delegate object ParameterlessRouteAction() Returns object Represents the function that is called after the route is matched with the request. Constructors ParameterlessRouteAction(object, nint) Methods BeginInvoke(AsyncCallback, object) EndInvoke(IAsyncResult) Invoke()"
  },
  "api/Sisk.Core.Routing.RegexRoute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RegexRoute.-ctor.html",
    "title": "Constructor RegexRoute | Sisk",
    "keywords": "Constructor RegexRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegexRoute(RouteMethod, string, RouteAction) Initializes a new instance of the RegexRoute class. public RegexRoute(RouteMethod method, string pattern, RouteAction action) Parameters method RouteMethod The HTTP method for this route. pattern string The regular expression pattern for this route. action RouteAction The action to be executed when this route is matched. RegexRoute(RouteMethod, string, string?, RouteAction, IRequestHandler[]?) Initializes a new instance of the RegexRoute class. public RegexRoute(RouteMethod method, string pattern, string? name, RouteAction action, IRequestHandler[]? beforeCallback) Parameters method RouteMethod The HTTP method for this route. pattern string The regular expression pattern for this route. name string The name of this route. action RouteAction The action to be executed when this route is matched. beforeCallback IRequestHandler[] The callback to be executed before the action."
  },
  "api/Sisk.Core.Routing.RegexRoute.html": {
    "href": "api/Sisk.Core.Routing.RegexRoute.html",
    "title": "Class RegexRoute | Sisk",
    "keywords": "Class RegexRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an Route which it's implementation already enables UseRegex. public sealed class RegexRoute : Route Inheritance object Route RegexRoute Inherited Members Route.AnyPath Route.ToString() Route.Get(string, Delegate) Route.Get(string, RouteAction) Route.Post(string, Delegate) Route.Post(string, RouteAction) Route.Put(string, Delegate) Route.Put(string, RouteAction) Route.Patch(string, Delegate) Route.Patch(string, RouteAction) Route.Head(string, Delegate) Route.Head(string, RouteAction) Route.Any(string, Delegate) Route.Any(string, RouteAction) Route.Delete(string, Delegate) Route.Delete(string, RouteAction) Route.Options(string, Delegate) Route.Options(string, RouteAction) Route.Bag Route.IsAsync Route.LogMode Route.UseRegex Route.UseCors Route.Method Route.Path Route.Name Route.Action Route.RequestHandlers Route.BypassGlobalRequestHandlers object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RegexRoute(RouteMethod, string, RouteAction) Initializes a new instance of the RegexRoute class. RegexRoute(RouteMethod, string, string?, RouteAction, IRequestHandler[]?) Initializes a new instance of the RegexRoute class."
  },
  "api/Sisk.Core.Routing.RegexRouteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RegexRouteAttribute.-ctor.html",
    "title": "Constructor RegexRouteAttribute | Sisk",
    "keywords": "Constructor RegexRouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegexRouteAttribute(RouteMethod, string) Creates an new RouteGetAttribute attribute instance with given path. public RegexRouteAttribute(RouteMethod method, string pattern) Parameters method RouteMethod The route entry point method. pattern string The Regex pattern which will match the route."
  },
  "api/Sisk.Core.Routing.RegexRouteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RegexRouteAttribute.html",
    "title": "Class RegexRouteAttribute | Sisk",
    "keywords": "Class RegexRouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an route, which it's path is defined by an regular expression. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RegexRouteAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RegexRouteAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RegexRouteAttribute(RouteMethod, string) Creates an new RouteGetAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RequestHandler.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.-ctor.html",
    "title": "Constructor RequestHandler | Sisk",
    "keywords": "Constructor RequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandler() protected RequestHandler()"
  },
  "api/Sisk.Core.Routing.RequestHandler.Create.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Create(Func<HttpRequest, HttpContext, HttpResponse?>, RequestHandlerExecutionMode) Gets an inline RequestHandler that resolves to the specified function. public static RequestHandler Create(Func<HttpRequest, HttpContext, HttpResponse?> execute, RequestHandlerExecutionMode executionMode = RequestHandlerExecutionMode.BeforeResponse) Parameters execute Func<HttpRequest, HttpContext, HttpResponse> The function that the RequestHandler will run. executionMode RequestHandlerExecutionMode Optional. Determines where the request handler will be executed. Returns RequestHandler"
  },
  "api/Sisk.Core.Routing.RequestHandler.Next.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.Next.html",
    "title": "Method Next | Sisk",
    "keywords": "Method Next Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Next() Returns an null HttpResponse reference, which points to the next request handler or route action. public HttpResponse? Next() Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RequestHandler.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.html",
    "title": "Class RequestHandler | Sisk",
    "keywords": "Class RequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an abstract class which implements IRequestHandler. public abstract class RequestHandler : IRequestHandler Inheritance object RequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RequestHandler() Methods Create(Func<HttpRequest, HttpContext, HttpResponse?>, RequestHandlerExecutionMode) Gets an inline RequestHandler that resolves to the specified function. Next() Returns an null HttpResponse reference, which points to the next request handler or route action."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute-1.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute-1.-ctor.html",
    "title": "Constructor RequestHandlerAttribute | Sisk",
    "keywords": "Constructor RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerAttribute() Creates an new instance of this RequestHandlerAttribute<T> class. public RequestHandlerAttribute() RequestHandlerAttribute(params object?[]) Creates an new instance of this RequestHandlerAttribute<T> class with the specified constructor arguments for T. public RequestHandlerAttribute(params object?[] constructorArguments) Parameters constructorArguments object[] An optional array of objects which is passed to the request handler constructor."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute-1.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute-1.html",
    "title": "Class RequestHandlerAttribute<T> | Sisk",
    "keywords": "Class RequestHandlerAttribute<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. public class RequestHandlerAttribute<T> : RequestHandlerAttribute where T : IRequestHandler Type Parameters T Inheritance object Attribute RequestHandlerAttribute RequestHandlerAttribute<T> Inherited Members RequestHandlerAttribute.RequestHandlerType RequestHandlerAttribute.ConstructorArguments Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RequestHandlerAttribute() Creates an new instance of this RequestHandlerAttribute<T> class. RequestHandlerAttribute(params object?[]) Creates an new instance of this RequestHandlerAttribute<T> class with the specified constructor arguments for T."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.-ctor.html",
    "title": "Constructor RequestHandlerAttribute | Sisk",
    "keywords": "Constructor RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerAttribute(Type) Creates a new instance of this attribute with the informed parameters. public RequestHandlerAttribute(Type handledBy) Parameters handledBy Type The type that implements IRequestHandler which will be instantiated."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments.html",
    "title": "Property ConstructorArguments | Sisk",
    "keywords": "Property ConstructorArguments Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ConstructorArguments Specifies parameters for the given type's constructor. public object?[] ConstructorArguments { get; set; } Property Value object[]"
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.RequestHandlerType.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.RequestHandlerType.html",
    "title": "Property RequestHandlerType | Sisk",
    "keywords": "Property RequestHandlerType Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerType Gets or sets the type that implements IRequestHandler which will be instantiated. public Type RequestHandlerType { get; set; } Property Value Type"
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.html",
    "title": "Class RequestHandlerAttribute | Sisk",
    "keywords": "Class RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true)] public class RequestHandlerAttribute : Attribute Inheritance object Attribute RequestHandlerAttribute Derived RequestHandlerAttribute<T> Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RequestHandlerAttribute(Type) Creates a new instance of this attribute with the informed parameters. Properties ConstructorArguments Specifies parameters for the given type's constructor. RequestHandlerType Gets or sets the type that implements IRequestHandler which will be instantiated."
  },
  "api/Sisk.Core.Routing.RequestHandlerExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerExecutionMode.html",
    "title": "Enum RequestHandlerExecutionMode | Sisk",
    "keywords": "Enum RequestHandlerExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Defines when the IRequestHandler should be executed. [Flags] public enum RequestHandlerExecutionMode Fields AfterResponse = 4 Indicates that the request handler should be executed after the route action. BeforeResponse = 2 Indicates that the request handler should be executed before the route action. Both = BeforeResponse | AfterResponse Indicates that the request handler should be executed before and after the route action."
  },
  "api/Sisk.Core.Routing.Route.-ctor.html": {
    "href": "api/Sisk.Core.Routing.Route.-ctor.html",
    "title": "Constructor Route | Sisk",
    "keywords": "Constructor Route Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Route(RouteMethod, string, Delegate?) Creates an new Route instance with given parameters. public Route(RouteMethod method, string path, Delegate? action) Parameters method RouteMethod The matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. path string The path expression that will be interpreted by the router and validated by the requests. action Delegate The function that is called after the route is matched with the request. Route(RouteMethod, string, string?, Delegate?, IRequestHandler[]?) Creates an new Route instance with given parameters. public Route(RouteMethod method, string path, string? name, Delegate? action, IRequestHandler[]? handlers) Parameters method RouteMethod The matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. path string The path expression that will be interpreted by the router and validated by the requests. name string The route name. It allows it to be found by other routes and makes it easier to create links. action Delegate The function that is called after the route is matched with the request. handlers IRequestHandler[] The RequestHandlers to run before the route's Action. Route() Creates an new Route instance with no parameters. public Route()"
  },
  "api/Sisk.Core.Routing.Route.Action.html": {
    "href": "api/Sisk.Core.Routing.Route.Action.html",
    "title": "Property Action | Sisk",
    "keywords": "Property Action Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Action Gets or sets the function that is called after the route is matched with the request. public Delegate? Action { get; set; } Property Value Delegate"
  },
  "api/Sisk.Core.Routing.Route.Any.html": {
    "href": "api/Sisk.Core.Routing.Route.Any.html",
    "title": "Method Any | Sisk",
    "keywords": "Method Any Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Any(string, Delegate?) Creates a route that responds to any HTTP request method. public static Route Any(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for any request method. Any(string, RouteAction) Creates a route that responds to any HTTP request method. public static Route Any(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for any request method."
  },
  "api/Sisk.Core.Routing.Route.AnyPath.html": {
    "href": "api/Sisk.Core.Routing.Route.AnyPath.html",
    "title": "Field AnyPath | Sisk",
    "keywords": "Field AnyPath Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an route path which captures any URL path. public const string AnyPath = \"/<<ANY>>\" Returns string Represents an route path which captures any URL path."
  },
  "api/Sisk.Core.Routing.Route.Bag.html": {
    "href": "api/Sisk.Core.Routing.Route.Bag.html",
    "title": "Property Bag | Sisk",
    "keywords": "Property Bag Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Bag Gets or sets an TypedValueDictionary for this route, which can hold contextual variables for this Route object. public TypedValueDictionary Bag { get; set; } Property Value TypedValueDictionary"
  },
  "api/Sisk.Core.Routing.Route.BypassGlobalRequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Route.BypassGlobalRequestHandlers.html",
    "title": "Property BypassGlobalRequestHandlers | Sisk",
    "keywords": "Property BypassGlobalRequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BypassGlobalRequestHandlers Gets or sets the global request handlers instances that will not run on this route. public IRequestHandler[] BypassGlobalRequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Route.Delete.html": {
    "href": "api/Sisk.Core.Routing.Route.Delete.html",
    "title": "Method Delete | Sisk",
    "keywords": "Method Delete Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Delete(string, Delegate?) Creates a route that responds to HTTP DELETE requests. public static Route Delete(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for DELETE requests. Delete(string, RouteAction) Creates a route that responds to HTTP DELETE requests. public static Route Delete(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for DELETE requests."
  },
  "api/Sisk.Core.Routing.Route.Get.html": {
    "href": "api/Sisk.Core.Routing.Route.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Get(string, Delegate?) Creates a route that responds to HTTP GET requests. public static Route Get(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for GET requests. Get(string, RouteAction) Creates a route that responds to HTTP GET requests. public static Route Get(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for GET requests."
  },
  "api/Sisk.Core.Routing.Route.Head.html": {
    "href": "api/Sisk.Core.Routing.Route.Head.html",
    "title": "Method Head | Sisk",
    "keywords": "Method Head Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Head(string, Delegate?) Creates a route that responds to HTTP HEAD requests. public static Route Head(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for HEAD requests. Head(string, RouteAction) Creates a route that responds to HTTP HEAD requests. public static Route Head(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for HEAD requests."
  },
  "api/Sisk.Core.Routing.Route.IsAsync.html": {
    "href": "api/Sisk.Core.Routing.Route.IsAsync.html",
    "title": "Property IsAsync | Sisk",
    "keywords": "Property IsAsync Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsAsync Gets an boolean indicating if this Route action return is an asynchronous Task. public bool IsAsync { get; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.LogMode.html": {
    "href": "api/Sisk.Core.Routing.Route.LogMode.html",
    "title": "Property LogMode | Sisk",
    "keywords": "Property LogMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll LogMode Gets or sets how this route can write messages to log files on the server. public LogOutput LogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Routing.Route.Method.html": {
    "href": "api/Sisk.Core.Routing.Route.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Method Gets or sets the matching HTTP method. public RouteMethod Method { get; set; } Property Value RouteMethod"
  },
  "api/Sisk.Core.Routing.Route.Name.html": {
    "href": "api/Sisk.Core.Routing.Route.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Name Gets or sets the route name. public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Route.Options.html": {
    "href": "api/Sisk.Core.Routing.Route.Options.html",
    "title": "Method Options | Sisk",
    "keywords": "Method Options Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Options(string, Delegate?) Creates a route that responds to HTTP OPTIONS requests. public static Route Options(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for OPTIONS requests. Options(string, RouteAction) Creates a route that responds to HTTP OPTIONS requests. public static Route Options(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for OPTIONS requests."
  },
  "api/Sisk.Core.Routing.Route.Patch.html": {
    "href": "api/Sisk.Core.Routing.Route.Patch.html",
    "title": "Method Patch | Sisk",
    "keywords": "Method Patch Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Patch(string, Delegate?) Creates a route that responds to HTTP PATCH requests. public static Route Patch(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for PATCH requests. Patch(string, RouteAction) Creates a route that responds to HTTP PATCH requests. public static Route Patch(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for PATCH requests."
  },
  "api/Sisk.Core.Routing.Route.Path.html": {
    "href": "api/Sisk.Core.Routing.Route.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. public string Path { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Route.Post.html": {
    "href": "api/Sisk.Core.Routing.Route.Post.html",
    "title": "Method Post | Sisk",
    "keywords": "Method Post Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Post(string, Delegate?) Creates a route that responds to HTTP POST requests. public static Route Post(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for POST requests. Post(string, RouteAction) Creates a route that responds to HTTP POST requests. public static Route Post(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for POST requests."
  },
  "api/Sisk.Core.Routing.Route.Put.html": {
    "href": "api/Sisk.Core.Routing.Route.Put.html",
    "title": "Method Put | Sisk",
    "keywords": "Method Put Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Put(string, Delegate?) Creates a route that responds to HTTP PUT requests. public static Route Put(string path, Delegate? action) Parameters path string The URL path for the route. action Delegate The action to be executed when the route is matched. Returns Route A Route object configured for PUT requests. Put(string, RouteAction) Creates a route that responds to HTTP PUT requests. public static Route Put(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for PUT requests."
  },
  "api/Sisk.Core.Routing.Route.RequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Route.RequestHandlers.html",
    "title": "Property RequestHandlers | Sisk",
    "keywords": "Property RequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlers Gets or sets the request handlers instances to run before the route action. public IRequestHandler[] RequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Route.ToString.html": {
    "href": "api/Sisk.Core.Routing.Route.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ToString() Gets an string notation for this Route object. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Routing.Route.UseCors.html": {
    "href": "api/Sisk.Core.Routing.Route.UseCors.html",
    "title": "Property UseCors | Sisk",
    "keywords": "Property UseCors Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. public bool UseCors { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.UseRegex.html": {
    "href": "api/Sisk.Core.Routing.Route.UseRegex.html",
    "title": "Property UseRegex | Sisk",
    "keywords": "Property UseRegex Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. public bool UseRegex { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.html": {
    "href": "api/Sisk.Core.Routing.Route.html",
    "title": "Class Route | Sisk",
    "keywords": "Class Route Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an HTTP route to be matched by an Router. public class Route Inheritance object Route Derived RegexRoute Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors Route() Creates an new Route instance with no parameters. Route(RouteMethod, string, Delegate?) Creates an new Route instance with given parameters. Route(RouteMethod, string, string?, Delegate?, IRequestHandler[]?) Creates an new Route instance with given parameters. Fields AnyPath Represents an route path which captures any URL path. Properties Action Gets or sets the function that is called after the route is matched with the request. Bag Gets or sets an TypedValueDictionary for this route, which can hold contextual variables for this Route object. BypassGlobalRequestHandlers Gets or sets the global request handlers instances that will not run on this route. IsAsync Gets an boolean indicating if this Route action return is an asynchronous Task. LogMode Gets or sets how this route can write messages to log files on the server. Method Gets or sets the matching HTTP method. Name Gets or sets the route name. Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. RequestHandlers Gets or sets the request handlers instances to run before the route action. UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. Methods Any(string, RouteAction) Creates a route that responds to any HTTP request method. Any(string, Delegate?) Creates a route that responds to any HTTP request method. Delete(string, RouteAction) Creates a route that responds to HTTP DELETE requests. Delete(string, Delegate?) Creates a route that responds to HTTP DELETE requests. Get(string, RouteAction) Creates a route that responds to HTTP GET requests. Get(string, Delegate?) Creates a route that responds to HTTP GET requests. Head(string, RouteAction) Creates a route that responds to HTTP HEAD requests. Head(string, Delegate?) Creates a route that responds to HTTP HEAD requests. Options(string, RouteAction) Creates a route that responds to HTTP OPTIONS requests. Options(string, Delegate?) Creates a route that responds to HTTP OPTIONS requests. Patch(string, RouteAction) Creates a route that responds to HTTP PATCH requests. Patch(string, Delegate?) Creates a route that responds to HTTP PATCH requests. Post(string, RouteAction) Creates a route that responds to HTTP POST requests. Post(string, Delegate?) Creates a route that responds to HTTP POST requests. Put(string, RouteAction) Creates a route that responds to HTTP PUT requests. Put(string, Delegate?) Creates a route that responds to HTTP PUT requests. ToString() Gets an string notation for this Route object."
  },
  "api/Sisk.Core.Routing.RouteAction.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.-ctor.html",
    "title": "Constructor RouteAction | Sisk",
    "keywords": "Constructor RouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteAction(object, nint) public RouteAction(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RouteAction.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(HttpRequest, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(HttpRequest request, AsyncCallback callback, object @object) Parameters request HttpRequest callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RouteAction.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual object EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns object"
  },
  "api/Sisk.Core.Routing.RouteAction.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(HttpRequest) public virtual object Invoke(HttpRequest request) Parameters request HttpRequest Returns object"
  },
  "api/Sisk.Core.Routing.RouteAction.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.html",
    "title": "Delegate RouteAction | Sisk",
    "keywords": "Delegate RouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route is matched with the request. public delegate object RouteAction(HttpRequest request) Parameters request HttpRequest The received request on the router. Returns object Represents the function that is called after the route is matched with the request. Constructors RouteAction(object, nint) Methods BeginInvoke(HttpRequest, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(HttpRequest)"
  },
  "api/Sisk.Core.Routing.RouteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.-ctor.html",
    "title": "Constructor RouteAttribute | Sisk",
    "keywords": "Constructor RouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteAttribute(RouteMethod, string) Creates an new RouteAttribute instance with given route method and path pattern. public RouteAttribute(RouteMethod method, string path) Parameters method RouteMethod The route entry point method. path string The route path."
  },
  "api/Sisk.Core.Routing.RouteAttribute.LogMode.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.LogMode.html",
    "title": "Property LogMode | Sisk",
    "keywords": "Property LogMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll LogMode Gets or sets how this route can write messages to log files on the server. public LogOutput LogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Method.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Method Gets or sets the matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. public RouteMethod Method { get; set; } Property Value RouteMethod"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Name.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Name Gets or sets the route name. It allows it to be found by other routes and makes it easier to create links. public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Path.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. public string Path { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouteAttribute.UseCors.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.UseCors.html",
    "title": "Property UseCors | Sisk",
    "keywords": "Property UseCors Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. public bool UseCors { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.RouteAttribute.UseRegex.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.UseRegex.html",
    "title": "Property UseRegex | Sisk",
    "keywords": "Property UseRegex Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. public bool UseRegex { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.RouteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.html",
    "title": "Class RouteAttribute | Sisk",
    "keywords": "Class RouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an class that, when applied to a method, will be recognized by a router as a route. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public class RouteAttribute : Attribute Inheritance object Attribute RouteAttribute Derived RegexRouteAttribute RouteDeleteAttribute RouteGetAttribute RoutePatchAttribute RoutePostAttribute RoutePutAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteAttribute(RouteMethod, string) Creates an new RouteAttribute instance with given route method and path pattern. Properties LogMode Gets or sets how this route can write messages to log files on the server. Method Gets or sets the matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. Name Gets or sets the route name. It allows it to be found by other routes and makes it easier to create links. Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates."
  },
  "api/Sisk.Core.Routing.RouteDeleteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteDeleteAttribute.-ctor.html",
    "title": "Constructor RouteDeleteAttribute | Sisk",
    "keywords": "Constructor RouteDeleteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteDeleteAttribute(string) Creates an new RouteDeleteAttribute attribute instance with given path. public RouteDeleteAttribute(string path) Parameters path string The DELETE route path. RouteDeleteAttribute() Creates an new RouteDeleteAttribute attribute instance with an root path (/). public RouteDeleteAttribute()"
  },
  "api/Sisk.Core.Routing.RouteDeleteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteDeleteAttribute.html",
    "title": "Class RouteDeleteAttribute | Sisk",
    "keywords": "Class RouteDeleteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP DELETE route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RouteDeleteAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RouteDeleteAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteDeleteAttribute() Creates an new RouteDeleteAttribute attribute instance with an root path (/). RouteDeleteAttribute(string) Creates an new RouteDeleteAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RouteGetAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteGetAttribute.-ctor.html",
    "title": "Constructor RouteGetAttribute | Sisk",
    "keywords": "Constructor RouteGetAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteGetAttribute(string) Creates an new RouteGetAttribute attribute instance with given path. public RouteGetAttribute(string path) Parameters path string The GET route path. RouteGetAttribute() Creates an new RouteGetAttribute attribute instance with an root path (/). public RouteGetAttribute()"
  },
  "api/Sisk.Core.Routing.RouteGetAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteGetAttribute.html",
    "title": "Class RouteGetAttribute | Sisk",
    "keywords": "Class RouteGetAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP GET route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RouteGetAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RouteGetAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteGetAttribute() Creates an new RouteGetAttribute attribute instance with an root path (/). RouteGetAttribute(string) Creates an new RouteGetAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RouteMatch.Parameters.html": {
    "href": "api/Sisk.Core.Routing.RouteMatch.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Parameters Gets a collection of parameters extracted from the route, or null if the route matching operation was not successful. public NameValueCollection? Parameters { get; } Property Value NameValueCollection"
  },
  "api/Sisk.Core.Routing.RouteMatch.Success.html": {
    "href": "api/Sisk.Core.Routing.RouteMatch.Success.html",
    "title": "Property Success | Sisk",
    "keywords": "Property Success Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Success Gets a value indicating whether the route matching operation was successful. public bool Success { get; } Property Value bool"
  },
  "api/Sisk.Core.Routing.RouteMatch.html": {
    "href": "api/Sisk.Core.Routing.RouteMatch.html",
    "title": "Class RouteMatch | Sisk",
    "keywords": "Class RouteMatch Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the result of a route matching operation. public sealed class RouteMatch Inheritance object RouteMatch Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Parameters Gets a collection of parameters extracted from the route, or null if the route matching operation was not successful. Success Gets a value indicating whether the route matching operation was successful."
  },
  "api/Sisk.Core.Routing.RouteMethod.html": {
    "href": "api/Sisk.Core.Routing.RouteMethod.html",
    "title": "Enum RouteMethod | Sisk",
    "keywords": "Enum RouteMethod Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an HTTP method to be matched in an Route. [Flags] public enum RouteMethod Fields Any = Get | Post | Put | Patch | Delete | Head | Options Represents any HTTP method. Delete = 32 Represents the HTTP DELETE method. Get = 2 Represents the HTTP GET method. Head = 128 Represents the HTTP HEAD method. Options = 256 Represents the HTTP OPTIONS method. Patch = 16 Represents the HTTP PATCH method. Post = 4 Represents the HTTP POST method. Put = 8 Represents the HTTP PUT method."
  },
  "api/Sisk.Core.Routing.RoutePatchAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePatchAttribute.-ctor.html",
    "title": "Constructor RoutePatchAttribute | Sisk",
    "keywords": "Constructor RoutePatchAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePatchAttribute(string) Creates an new RoutePatchAttribute attribute instance with given path. public RoutePatchAttribute(string path) Parameters path string The PATCH route path. RoutePatchAttribute() Creates an new RoutePatchAttribute attribute instance with an root path (/). public RoutePatchAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePatchAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePatchAttribute.html",
    "title": "Class RoutePatchAttribute | Sisk",
    "keywords": "Class RoutePatchAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP PATCH route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePatchAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePatchAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePatchAttribute() Creates an new RoutePatchAttribute attribute instance with an root path (/). RoutePatchAttribute(string) Creates an new RoutePatchAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RoutePostAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePostAttribute.-ctor.html",
    "title": "Constructor RoutePostAttribute | Sisk",
    "keywords": "Constructor RoutePostAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePostAttribute(string) Creates an new RoutePostAttribute attribute instance with given path. public RoutePostAttribute(string path) Parameters path string The POST route path. RoutePostAttribute() Creates an new RoutePostAttribute attribute instance with an root path (/). public RoutePostAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePostAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePostAttribute.html",
    "title": "Class RoutePostAttribute | Sisk",
    "keywords": "Class RoutePostAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP POST route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePostAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePostAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePostAttribute() Creates an new RoutePostAttribute attribute instance with an root path (/). RoutePostAttribute(string) Creates an new RoutePostAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.-ctor.html",
    "title": "Constructor RoutePrefixAttribute | Sisk",
    "keywords": "Constructor RoutePrefixAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePrefixAttribute(string) Initializes an new RoutePrefixAttribute with given prefix. public RoutePrefixAttribute(string prefix) Parameters prefix string"
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.Prefix.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the route prefix. public string Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.html",
    "title": "Class RoutePrefixAttribute | Sisk",
    "keywords": "Class RoutePrefixAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an attribute that, when applied to an class containing routes, all child routes will start with the specified prefix. [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public sealed class RoutePrefixAttribute : Attribute Inheritance object Attribute RoutePrefixAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePrefixAttribute(string) Initializes an new RoutePrefixAttribute with given prefix. Properties Prefix Gets or sets the route prefix."
  },
  "api/Sisk.Core.Routing.RoutePutAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePutAttribute.-ctor.html",
    "title": "Constructor RoutePutAttribute | Sisk",
    "keywords": "Constructor RoutePutAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePutAttribute(string) Creates an new RoutePutAttribute attribute instance with given path. public RoutePutAttribute(string path) Parameters path string The PUT route path. RoutePutAttribute() Creates an new RoutePutAttribute attribute instance with an root path (/). public RoutePutAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePutAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePutAttribute.html",
    "title": "Class RoutePutAttribute | Sisk",
    "keywords": "Class RoutePutAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP PUT route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePutAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePutAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePutAttribute() Creates an new RoutePutAttribute attribute instance with an root path (/). RoutePutAttribute(string) Creates an new RoutePutAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.Router.-ctor.html": {
    "href": "api/Sisk.Core.Routing.Router.-ctor.html",
    "title": "Constructor Router | Sisk",
    "keywords": "Constructor Router Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Router() Creates an new Router instance with default values. public Router() Router(IEnumerable<Route>) Creates an new Router instance with given route collection. public Router(IEnumerable<Route> routes) Parameters routes IEnumerable<Route> The route collection to import in this router."
  },
  "api/Sisk.Core.Routing.Router.AutoScanModules.html": {
    "href": "api/Sisk.Core.Routing.Router.AutoScanModules.html",
    "title": "Method AutoScanModules | Sisk",
    "keywords": "Method AutoScanModules Namespace Sisk.Core.Routing Assembly Sisk.Core.dll AutoScanModules(Type, Assembly) Scans for all types that implements the specified module type and associates an instance of each type to the router. public void AutoScanModules(Type moduleType, Assembly searchAssembly) Parameters moduleType Type An class which implements RouterModule, or the router module itself. searchAssembly Assembly The assembly to search the module type in. AutoScanModules<TModule>(Assembly) Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. public void AutoScanModules<TModule>(Assembly assembly) where TModule : RouterModule Parameters assembly Assembly The assembly to search TModule in. Type Parameters TModule An class which implements RouterModule, or the router module itself. AutoScanModules<TModule>() Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. public void AutoScanModules<TModule>() where TModule : RouterModule Type Parameters TModule An class which implements RouterModule, or the router module itself."
  },
  "api/Sisk.Core.Routing.Router.CallbackErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.CallbackErrorHandler.html",
    "title": "Property CallbackErrorHandler | Sisk",
    "keywords": "Property CallbackErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll CallbackErrorHandler Gets or sets the Router action exception handler. The response handler for this property will send an HTTP response to the client when an exception is caught during execution. This property is only called when ThrowExceptions is disabled. public ExceptionErrorCallback? CallbackErrorHandler { get; set; } Property Value ExceptionErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.CheckForRouteCollisions.html": {
    "href": "api/Sisk.Core.Routing.Router.CheckForRouteCollisions.html",
    "title": "Property CheckForRouteCollisions | Sisk",
    "keywords": "Property CheckForRouteCollisions Namespace Sisk.Core.Routing Assembly Sisk.Core.dll CheckForRouteCollisions Gets or sets whether this Router should check for possible routing collisions before starting the HTTP server. public bool CheckForRouteCollisions { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.Combine.html": {
    "href": "api/Sisk.Core.Routing.Router.Combine.html",
    "title": "Method Combine | Sisk",
    "keywords": "Method Combine Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Combine(params string[]) Combines an array of string parts into a single path. public static string Combine(params string[] parts) Parameters parts string[] An array of string parts to combine. Returns string A string representing the combined path."
  },
  "api/Sisk.Core.Routing.Router.GetDefinedRoutes.html": {
    "href": "api/Sisk.Core.Routing.Router.GetDefinedRoutes.html",
    "title": "Method GetDefinedRoutes | Sisk",
    "keywords": "Method GetDefinedRoutes Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetDefinedRoutes() Gets all routes defined on this router instance. public Route[] GetDefinedRoutes() Returns Route[]"
  },
  "api/Sisk.Core.Routing.Router.GetRouteFromName.html": {
    "href": "api/Sisk.Core.Routing.Router.GetRouteFromName.html",
    "title": "Method GetRouteFromName | Sisk",
    "keywords": "Method GetRouteFromName Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetRouteFromName(string) Gets an defined Route by their name property. public Route? GetRouteFromName(string name) Parameters name string The route name. Returns Route"
  },
  "api/Sisk.Core.Routing.Router.GetRouteFromPath.html": {
    "href": "api/Sisk.Core.Routing.Router.GetRouteFromPath.html",
    "title": "Method GetRouteFromPath | Sisk",
    "keywords": "Method GetRouteFromPath Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetRouteFromPath(RouteMethod, string) Gets the first matched Route by their HTTP method and path. public Route? GetRouteFromPath(RouteMethod method, string uri) Parameters method RouteMethod The HTTP method to match. uri string The URL expression. Returns Route GetRouteFromPath(string) Gets the first matched Route by their URL path. public Route? GetRouteFromPath(string uri) Parameters uri string The URL expression. Returns Route"
  },
  "api/Sisk.Core.Routing.Router.GlobalRequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Router.GlobalRequestHandlers.html",
    "title": "Property GlobalRequestHandlers | Sisk",
    "keywords": "Property GlobalRequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GlobalRequestHandlers Gets or sets the global requests handlers that will be executed in all matched routes. public IRequestHandler[] GlobalRequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Router.IsDefined.html": {
    "href": "api/Sisk.Core.Routing.Router.IsDefined.html",
    "title": "Method IsDefined | Sisk",
    "keywords": "Method IsDefined Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsDefined(RouteMethod, string) Gets an boolean indicating if there are any route that matches the specified method and route path. public bool IsDefined(RouteMethod method, string path) Parameters method RouteMethod The route method. path string The route path. Returns bool"
  },
  "api/Sisk.Core.Routing.Router.IsReadOnly.html": {
    "href": "api/Sisk.Core.Routing.Router.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsReadOnly Gets an boolean indicating where this Router is read-only or not. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.IsRouteExpressionsOverlap.html": {
    "href": "api/Sisk.Core.Routing.Router.IsRouteExpressionsOverlap.html",
    "title": "Method IsRouteExpressionsOverlap | Sisk",
    "keywords": "Method IsRouteExpressionsOverlap Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsRouteExpressionsOverlap(in ReadOnlySpan<char>, in ReadOnlySpan<char>, StringComparison) Determines whether two route expressions overlap. public static bool IsRouteExpressionsOverlap(in ReadOnlySpan<char> routeExpression1, in ReadOnlySpan<char> routeExpression2, StringComparison stringComparer = StringComparison.Ordinal) Parameters routeExpression1 ReadOnlySpan<char> The first route expression to compare. routeExpression2 ReadOnlySpan<char> The second route expression to compare. stringComparer StringComparison The string comparison to use when comparing the route expressions. Defaults to Ordinal. Returns bool true if the route expressions overlap; otherwise, false. IsRouteExpressionsOverlap(string, string, StringComparison) Determines whether two route expressions overlap. public static bool IsRouteExpressionsOverlap(string routeExpression1, string routeExpression2, StringComparison stringComparer = StringComparison.Ordinal) Parameters routeExpression1 string The first route expression to compare. routeExpression2 string The second route expression to compare. stringComparer StringComparison The string comparison to use when comparing the route expressions. Defaults to Ordinal. Returns bool true if the route expressions overlap; otherwise, false."
  },
  "api/Sisk.Core.Routing.Router.MapAny.html": {
    "href": "api/Sisk.Core.Routing.Router.MapAny.html",
    "title": "Method MapAny | Sisk",
    "keywords": "Method MapAny Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapAny(string, Delegate) Maps an route which matches any HTTP method, using the specified path and action function. public void MapAny(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapAny(string, RouteAction) Maps an route which matches any HTTP method, using the specified path and action function. public void MapAny(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapDelete.html": {
    "href": "api/Sisk.Core.Routing.Router.MapDelete.html",
    "title": "Method MapDelete | Sisk",
    "keywords": "Method MapDelete Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapDelete(string, Delegate) Maps an DELETE route using the specified path and action function. public void MapDelete(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapDelete(string, RouteAction) Maps an DELETE route using the specified path and action function. public void MapDelete(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapGet.html": {
    "href": "api/Sisk.Core.Routing.Router.MapGet.html",
    "title": "Method MapGet | Sisk",
    "keywords": "Method MapGet Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapGet(string, Delegate) Maps an GET route using the specified path and action function. public void MapGet(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapGet(string, RouteAction) Maps an GET route using the specified path and action function. public void MapGet(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapHead.html": {
    "href": "api/Sisk.Core.Routing.Router.MapHead.html",
    "title": "Method MapHead | Sisk",
    "keywords": "Method MapHead Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapHead(string, Delegate) Maps an HEAD route using the specified path and action function. public void MapHead(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapHead(string, RouteAction) Maps an HEAD route using the specified path and action function. public void MapHead(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapOptions.html": {
    "href": "api/Sisk.Core.Routing.Router.MapOptions.html",
    "title": "Method MapOptions | Sisk",
    "keywords": "Method MapOptions Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapOptions(string, Delegate) Maps an OPTIONS route using the specified path and action function. public void MapOptions(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapOptions(string, RouteAction) Maps an OPTIONS route using the specified path and action function. public void MapOptions(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPatch.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPatch.html",
    "title": "Method MapPatch | Sisk",
    "keywords": "Method MapPatch Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPatch(string, Delegate) Maps an PATCH route using the specified path and action function. public void MapPatch(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapPatch(string, RouteAction) Maps an PATCH route using the specified path and action function. public void MapPatch(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPost.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPost.html",
    "title": "Method MapPost | Sisk",
    "keywords": "Method MapPost Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPost(string, Delegate) Maps an POST route using the specified path and action function. public void MapPost(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapPost(string, RouteAction) Maps an POST route using the specified path and action function. public void MapPost(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPut.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPut.html",
    "title": "Method MapPut | Sisk",
    "keywords": "Method MapPut Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPut(string, Delegate) Maps an PUT route using the specified path and action function. public void MapPut(string path, Delegate action) Parameters path string The route path. action Delegate The route function to be called after matched. MapPut(string, RouteAction) Maps an PUT route using the specified path and action function. public void MapPut(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MatchRouteExpression.html": {
    "href": "api/Sisk.Core.Routing.Router.MatchRouteExpression.html",
    "title": "Method MatchRouteExpression | Sisk",
    "keywords": "Method MatchRouteExpression Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MatchRouteExpression(in ReadOnlySpan<char>, in ReadOnlySpan<char>, StringComparison) Attempts to match the specified route expression against the given path. public static RouteMatch MatchRouteExpression(in ReadOnlySpan<char> routeExpression, in ReadOnlySpan<char> path, StringComparison stringComparer = StringComparison.Ordinal) Parameters routeExpression ReadOnlySpan<char> The route expression to match. path ReadOnlySpan<char> The path to match against the route expression. stringComparer StringComparison The string comparison to use when matching the route expression. Defaults to Ordinal. Returns RouteMatch A RouteMatch object indicating the result of the match. MatchRouteExpression(string, string, StringComparison) Attempts to match the specified route expression against the given path. public static RouteMatch MatchRouteExpression(string routeExpression, string path, StringComparison stringComparer = StringComparison.Ordinal) Parameters routeExpression string The route expression to match. path string The path to match against the route expression. stringComparer StringComparison The string comparison to use when matching the route expression. Defaults to Ordinal. Returns RouteMatch A RouteMatch object indicating the result of the match."
  },
  "api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase.html": {
    "href": "api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase.html",
    "title": "Property MatchRoutesIgnoreCase | Sisk",
    "keywords": "Property MatchRoutesIgnoreCase Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MatchRoutesIgnoreCase Gets or sets whether this Router will match routes ignoring case. public bool MatchRoutesIgnoreCase { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler.html",
    "title": "Property MethodNotAllowedErrorHandler | Sisk",
    "keywords": "Property MethodNotAllowedErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MethodNotAllowedErrorHandler Gets or sets the Router \"405 Method Not Allowed\" handler. public RoutingErrorCallback? MethodNotAllowedErrorHandler { get; set; } Property Value RoutingErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.NotFoundErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.NotFoundErrorHandler.html",
    "title": "Property NotFoundErrorHandler | Sisk",
    "keywords": "Property NotFoundErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll NotFoundErrorHandler Gets or sets the Router \"404 Not Found\" handler. public RoutingErrorCallback? NotFoundErrorHandler { get; set; } Property Value RoutingErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.Prefix.html": {
    "href": "api/Sisk.Core.Routing.Router.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the prefix which will be applied to all next defining routes in this router. public string? Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Router.RegisterValueHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.RegisterValueHandler.html",
    "title": "Method RegisterValueHandler | Sisk",
    "keywords": "Method RegisterValueHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegisterValueHandler<T>(RouterActionHandlerCallback<T>) Register an type handling association to converting it to an HttpResponse object. public void RegisterValueHandler<T>(RouterActionHandlerCallback<T> actionHandler) where T : notnull Parameters actionHandler RouterActionHandlerCallback<T> The function that receives an object of the T and returns an HttpResponse response from the informed object. Type Parameters T"
  },
  "api/Sisk.Core.Routing.Router.ResolveActionResult.html": {
    "href": "api/Sisk.Core.Routing.Router.ResolveActionResult.html",
    "title": "Method ResolveActionResult | Sisk",
    "keywords": "Method ResolveActionResult Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ResolveActionResult(object?) Resolves the specified object into an valid HttpResponse using the defined value handlers or throws an exception if not possible. public HttpResponse ResolveActionResult(object? result) Parameters result object The object that will be converted to an valid HttpResponse. Returns HttpResponse Remarks This method can throw exceptions. To avoid exceptions while trying to convert the specified object into an HttpResponse, consider using TryResolveActionResult(object?, out HttpResponse?)."
  },
  "api/Sisk.Core.Routing.Router.Rewrite.html": {
    "href": "api/Sisk.Core.Routing.Router.Rewrite.html",
    "title": "Method Rewrite | Sisk",
    "keywords": "Method Rewrite Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Rewrite(string, string) Maps a rewrite route, which redirects all requests that match the given path to another path, keeping the body and headers of the original request. public void Rewrite(string rewritePath, string rewriteInto) Parameters rewritePath string The incoming HTTP request path. rewriteInto string The rewrited URL."
  },
  "api/Sisk.Core.Routing.Router.SetObject.html": {
    "href": "api/Sisk.Core.Routing.Router.SetObject.html",
    "title": "Method SetObject | Sisk",
    "keywords": "Method SetObject Namespace Sisk.Core.Routing Assembly Sisk.Core.dll SetObject(object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(object attrClassInstance) Parameters attrClassInstance object The instance of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature. SetObject(Type) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(Type attrClassType) Parameters attrClassType Type The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. SetObject(Type, object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(Type attrClassType, object instance) Parameters attrClassType Type The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. instance object The instance of the object where the route methods are. SetObject<TObject>() Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject<TObject>() Type Parameters TObject The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature. SetObject<TObject>(TObject) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject<TObject>(TObject instance) where TObject : notnull Parameters instance TObject The instance of TObject to invoke the instance methods on. Type Parameters TObject The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature."
  },
  "api/Sisk.Core.Routing.Router.SetRoute.html": {
    "href": "api/Sisk.Core.Routing.Router.SetRoute.html",
    "title": "Method SetRoute | Sisk",
    "keywords": "Method SetRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll SetRoute(RouteMethod, string, RouteAction) Defines an route with their method, path and action function. public void SetRoute(RouteMethod method, string path, RouteAction action) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action RouteAction The route function to be called after matched. SetRoute(RouteMethod, string, Delegate) Defines an route with their method, path and action function. public void SetRoute(RouteMethod method, string path, Delegate action) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action Delegate The route function to be called after matched. SetRoute(RouteMethod, string, Delegate, string?) Defines an route with their method, path, action function and name. public void SetRoute(RouteMethod method, string path, Delegate action, string? name) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action Delegate The route function to be called after matched. name string The route name. SetRoute(RouteMethod, string, Delegate, string?, IRequestHandler[]) Defines an route with their method, path, action function, name and request handlers. public void SetRoute(RouteMethod method, string path, Delegate action, string? name, IRequestHandler[] middlewares) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action Delegate The route function to be called after matched. name string The route name. middlewares IRequestHandler[] Handlers that run before calling your route action. SetRoute(Route) Defines an route in this Router instance. public void SetRoute(Route r) Parameters r Route The route to be defined in the Router."
  },
  "api/Sisk.Core.Routing.Router.TryResolveActionResult.html": {
    "href": "api/Sisk.Core.Routing.Router.TryResolveActionResult.html",
    "title": "Method TryResolveActionResult | Sisk",
    "keywords": "Method TryResolveActionResult Namespace Sisk.Core.Routing Assembly Sisk.Core.dll TryResolveActionResult(object?, out HttpResponse?) Tries to resolve the specified object into an valid HttpResponse using the defined value handlers. public bool TryResolveActionResult(object? result, out HttpResponse? response) Parameters result object The object that will be converted to an valid HttpResponse. response HttpResponse When this method returns, the response object. This parameter is not initialized. Returns bool When this method returns, the HttpResponse object."
  },
  "api/Sisk.Core.Routing.Router.html": {
    "href": "api/Sisk.Core.Routing.Router.html",
    "title": "Class Router | Sisk",
    "keywords": "Class Router Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a collection of Route and main executor of actions in the HttpServer. public sealed class Router Inheritance object Router Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors Router() Creates an new Router instance with default values. Router(IEnumerable<Route>) Creates an new Router instance with given route collection. Properties CallbackErrorHandler Gets or sets the Router action exception handler. The response handler for this property will send an HTTP response to the client when an exception is caught during execution. This property is only called when ThrowExceptions is disabled. CheckForRouteCollisions Gets or sets whether this Router should check for possible routing collisions before starting the HTTP server. GlobalRequestHandlers Gets or sets the global requests handlers that will be executed in all matched routes. IsReadOnly Gets an boolean indicating where this Router is read-only or not. MatchRoutesIgnoreCase Gets or sets whether this Router will match routes ignoring case. MethodNotAllowedErrorHandler Gets or sets the Router \"405 Method Not Allowed\" handler. NotFoundErrorHandler Gets or sets the Router \"404 Not Found\" handler. Prefix Gets or sets the prefix which will be applied to all next defining routes in this router. Methods AutoScanModules(Type, Assembly) Scans for all types that implements the specified module type and associates an instance of each type to the router. AutoScanModules<TModule>() Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. AutoScanModules<TModule>(Assembly) Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. Combine(params string[]) Combines an array of string parts into a single path. GetDefinedRoutes() Gets all routes defined on this router instance. GetRouteFromName(string) Gets an defined Route by their name property. GetRouteFromPath(RouteMethod, string) Gets the first matched Route by their HTTP method and path. GetRouteFromPath(string) Gets the first matched Route by their URL path. IsDefined(RouteMethod, string) Gets an boolean indicating if there are any route that matches the specified method and route path. IsRouteExpressionsOverlap(in ReadOnlySpan<char>, in ReadOnlySpan<char>, StringComparison) Determines whether two route expressions overlap. IsRouteExpressionsOverlap(string, string, StringComparison) Determines whether two route expressions overlap. MapAny(string, RouteAction) Maps an route which matches any HTTP method, using the specified path and action function. MapAny(string, Delegate) Maps an route which matches any HTTP method, using the specified path and action function. MapDelete(string, RouteAction) Maps an DELETE route using the specified path and action function. MapDelete(string, Delegate) Maps an DELETE route using the specified path and action function. MapGet(string, RouteAction) Maps an GET route using the specified path and action function. MapGet(string, Delegate) Maps an GET route using the specified path and action function. MapHead(string, RouteAction) Maps an HEAD route using the specified path and action function. MapHead(string, Delegate) Maps an HEAD route using the specified path and action function. MapOptions(string, RouteAction) Maps an OPTIONS route using the specified path and action function. MapOptions(string, Delegate) Maps an OPTIONS route using the specified path and action function. MapPatch(string, RouteAction) Maps an PATCH route using the specified path and action function. MapPatch(string, Delegate) Maps an PATCH route using the specified path and action function. MapPost(string, RouteAction) Maps an POST route using the specified path and action function. MapPost(string, Delegate) Maps an POST route using the specified path and action function. MapPut(string, RouteAction) Maps an PUT route using the specified path and action function. MapPut(string, Delegate) Maps an PUT route using the specified path and action function. MatchRouteExpression(in ReadOnlySpan<char>, in ReadOnlySpan<char>, StringComparison) Attempts to match the specified route expression against the given path. MatchRouteExpression(string, string, StringComparison) Attempts to match the specified route expression against the given path. RegisterValueHandler<T>(RouterActionHandlerCallback<T>) Register an type handling association to converting it to an HttpResponse object. ResolveActionResult(object?) Resolves the specified object into an valid HttpResponse using the defined value handlers or throws an exception if not possible. Rewrite(string, string) Maps a rewrite route, which redirects all requests that match the given path to another path, keeping the body and headers of the original request. SetObject(object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject(Type) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject(Type, object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject<TObject>() Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject<TObject>(TObject) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetRoute(Route) Defines an route in this Router instance. SetRoute(RouteMethod, string, RouteAction) Defines an route with their method, path and action function. SetRoute(RouteMethod, string, Delegate) Defines an route with their method, path and action function. SetRoute(RouteMethod, string, Delegate, string?) Defines an route with their method, path, action function and name. SetRoute(RouteMethod, string, Delegate, string?, IRequestHandler[]) Defines an route with their method, path, action function, name and request handlers. TryResolveActionResult(object?, out HttpResponse?) Tries to resolve the specified object into an valid HttpResponse using the defined value handlers."
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.-ctor.html",
    "title": "Constructor RouterActionHandlerCallback | Sisk",
    "keywords": "Constructor RouterActionHandlerCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouterActionHandlerCallback(object, nint) public RouterActionHandlerCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(T, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(T input, AsyncCallback callback, object @object) Parameters input T callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(T) public virtual HttpResponse Invoke(T input) Parameters input T Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.html",
    "title": "Delegate RouterActionHandlerCallback<T> | Sisk",
    "keywords": "Delegate RouterActionHandlerCallback<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that receives an object of the T and returns an HttpResponse response from the informed object. public delegate HttpResponse RouterActionHandlerCallback<T>(T input) where T : notnull Parameters input T The result router object. Returns HttpResponse Represents the function that receives an object of the T and returns an response from the informed object. Type Parameters T The input object type. Cannot be nullable. Constructors RouterActionHandlerCallback(object, nint) Methods BeginInvoke(T, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(T)"
  },
  "api/Sisk.Core.Routing.RouterModule.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.-ctor.html",
    "title": "Constructor RouterModule | Sisk",
    "keywords": "Constructor RouterModule Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouterModule() protected RouterModule()"
  },
  "api/Sisk.Core.Routing.RouterModule.HasPrefix.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.HasPrefix.html",
    "title": "Method HasPrefix | Sisk",
    "keywords": "Method HasPrefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll HasPrefix(string) Specifies a prefix for all routes defined by this module. protected void HasPrefix(string prefix) Parameters prefix string The prefix to be applied to all registered routes of this class. Remarks This method allows for the specification of a common prefix for all routes defined by this module, which can be useful for organizing and structuring routes in a large application."
  },
  "api/Sisk.Core.Routing.RouterModule.HasRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.HasRequestHandler.html",
    "title": "Method HasRequestHandler | Sisk",
    "keywords": "Method HasRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll HasRequestHandler(IRequestHandler) Registers an IRequestHandler on all routes defined by this module. protected void HasRequestHandler(IRequestHandler handler) Parameters handler IRequestHandler The IRequestHandler instance which will be applied to all registered routes of this class."
  },
  "api/Sisk.Core.Routing.RouterModule.OnRouteCreating.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.OnRouteCreating.html",
    "title": "Method OnRouteCreating | Sisk",
    "keywords": "Method OnRouteCreating Namespace Sisk.Core.Routing Assembly Sisk.Core.dll OnRouteCreating(Route) This method is called before a route is defined in the router and after it is created in this class, so its attributes and parameters can be modified. This method must be overloaded in the extending class and must not be called directly. protected virtual void OnRouteCreating(Route configuringRoute) Parameters configuringRoute Route The route being defined on the router."
  },
  "api/Sisk.Core.Routing.RouterModule.OnSetup.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.OnSetup.html",
    "title": "Method OnSetup | Sisk",
    "keywords": "Method OnSetup Namespace Sisk.Core.Routing Assembly Sisk.Core.dll OnSetup(Router) Method that is called when an Router is defining routes from the current RouterModule. protected virtual void OnSetup(Router parentRouter) Parameters parentRouter Router The Router which is defining routes from the current RouterModule. Remarks The base method OnSetup(Router) is mandatory to be called on all derived methods."
  },
  "api/Sisk.Core.Routing.RouterModule.Prefix.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the router prefix for this class. This property overrides any value defined by RoutePrefixAttribute set in this class. public string? Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouterModule.RequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.RequestHandlers.html",
    "title": "Property RequestHandlers | Sisk",
    "keywords": "Property RequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlers Gets or sets an list of IRequestHandler this RouterModule runs. public IList<IRequestHandler> RequestHandlers { get; set; } Property Value IList<IRequestHandler>"
  },
  "api/Sisk.Core.Routing.RouterModule.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.html",
    "title": "Class RouterModule | Sisk",
    "keywords": "Class RouterModule Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Indicates that extended class supports router modules, which allows the management of routes, request handlers and prefixes. public abstract class RouterModule Inheritance object RouterModule Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RouterModule() Properties Prefix Gets or sets the router prefix for this class. This property overrides any value defined by RoutePrefixAttribute set in this class. RequestHandlers Gets or sets an list of IRequestHandler this RouterModule runs. Methods HasPrefix(string) Specifies a prefix for all routes defined by this module. HasRequestHandler(IRequestHandler) Registers an IRequestHandler on all routes defined by this module. OnRouteCreating(Route) This method is called before a route is defined in the router and after it is created in this class, so its attributes and parameters can be modified. This method must be overloaded in the extending class and must not be called directly. OnSetup(Router) Method that is called when an Router is defining routes from the current RouterModule."
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.-ctor.html",
    "title": "Constructor RoutingErrorCallback | Sisk",
    "keywords": "Constructor RoutingErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutingErrorCallback(object, nint) public RoutingErrorCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(HttpContext, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(HttpContext context, AsyncCallback callback, object @object) Parameters context HttpContext callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(HttpContext) public virtual HttpResponse Invoke(HttpContext context) Parameters context HttpContext Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.html",
    "title": "Delegate RoutingErrorCallback | Sisk",
    "keywords": "Delegate RoutingErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called when an request reaches an error on the router. public delegate HttpResponse RoutingErrorCallback(HttpContext context) Parameters context HttpContext Represents the function that is called when an request reaches an error on the router. Returns HttpResponse Represents the function that is called when an request reaches an error on the router. Constructors RoutingErrorCallback(object, nint) Methods BeginInvoke(HttpContext, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(HttpContext)"
  },
  "api/Sisk.Core.Routing.ValueResult-1.html": {
    "href": "api/Sisk.Core.Routing.ValueResult-1.html",
    "title": "Class ValueResult<T> | Sisk",
    "keywords": "Class ValueResult<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mutable type for boxing objects by value or reference in a response from a router. public sealed class ValueResult<T> where T : notnull Type Parameters T The type of object to be boxed. Inheritance object ValueResult<T> Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode()"
  },
  "api/Sisk.Core.Routing.html": {
    "href": "api/Sisk.Core.Routing.html",
    "title": "Namespace Sisk.Core.Routing | Sisk",
    "keywords": "Namespace Sisk.Core.Routing Classes AsyncRequestHandler Represents a class that implements IRequestHandler and its execution method is asynchronous. RegexRoute Represents an Route which it's implementation already enables UseRegex. RegexRouteAttribute Represents a mapping to an route, which it's path is defined by an regular expression. This attribute is an shorthand from RouteAttribute. RequestHandler Represents an abstract class which implements IRequestHandler. RequestHandlerAttribute Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. RequestHandlerAttribute<T> Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. Route Represents an HTTP route to be matched by an Router. RouteAttribute Represents an class that, when applied to a method, will be recognized by a router as a route. RouteDeleteAttribute Represents a mapping to an HTTP DELETE route. This attribute is an shorthand from RouteAttribute. RouteGetAttribute Represents a mapping to an HTTP GET route. This attribute is an shorthand from RouteAttribute. RouteMatch Represents the result of a route matching operation. RoutePatchAttribute Represents a mapping to an HTTP PATCH route. This attribute is an shorthand from RouteAttribute. RoutePostAttribute Represents a mapping to an HTTP POST route. This attribute is an shorthand from RouteAttribute. RoutePrefixAttribute Represents an attribute that, when applied to an class containing routes, all child routes will start with the specified prefix. RoutePutAttribute Represents a mapping to an HTTP PUT route. This attribute is an shorthand from RouteAttribute. Router Represents a collection of Route and main executor of actions in the HttpServer. RouterModule Indicates that extended class supports router modules, which allows the management of routes, request handlers and prefixes. ValueResult<T> Represents a mutable type for boxing objects by value or reference in a response from a router. Interfaces IRequestHandler Represents an interface that is executed before a request. Enums LogOutput Determines the way the server can write log messages. This enumerator is for giving permissions for certain contexts to be able or not to write to the server logs, such as AccessLogsStream and ErrorsLogsStream. RequestHandlerExecutionMode Defines when the IRequestHandler should be executed. RouteMethod Represents an HTTP method to be matched in an Route. Delegates ExceptionErrorCallback Represents the function that is called after the route action threw an exception. ParameterlessRouteAction Represents the function that is called after the route is matched with the request. RouteAction Represents the function that is called after the route is matched with the request. RouterActionHandlerCallback<T> Represents the function that receives an object of the T and returns an HttpResponse response from the informed object. RoutingErrorCallback Represents the function that is called when an request reaches an error on the router."
  },
  "api/Sisk.Core.html": {
    "href": "api/Sisk.Core.html",
    "title": "Namespace Sisk.Core | Sisk",
    "keywords": "Namespace Sisk.Core Namespaces Sisk.Core.Entity Sisk.Core.Helpers Sisk.Core.Http Sisk.Core.Routing"
  },
  "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.-ctor.html",
    "title": "Constructor ApiEndpointAttribute | Sisk",
    "keywords": "Constructor ApiEndpointAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiEndpointAttribute(string) Initializes a new instance of the ApiEndpointAttribute class with the specified endpoint name. public ApiEndpointAttribute(string name) Parameters name string The name of the API endpoint."
  },
  "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the API endpoint. public string? Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Group.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Group.html",
    "title": "Property Group | Sisk",
    "keywords": "Property Group Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Group Gets or sets the group to which the API endpoint belongs. public string? Group { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Name.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Name Gets or sets the name of the API endpoint. public string Name { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiEndpointAttribute.html",
    "title": "Class ApiEndpointAttribute | Sisk",
    "keywords": "Class ApiEndpointAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API endpoint, allowing metadata such as name, description, and group to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public sealed class ApiEndpointAttribute : Attribute Inheritance object Attribute ApiEndpointAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiEndpointAttribute(string) Initializes a new instance of the ApiEndpointAttribute class with the specified endpoint name. Properties Description Gets or sets the description of the API endpoint. Group Gets or sets the group to which the API endpoint belongs. Name Gets or sets the name of the API endpoint."
  },
  "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.-ctor.html",
    "title": "Constructor ApiHeaderAttribute | Sisk",
    "keywords": "Constructor ApiHeaderAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiHeaderAttribute(string) Initializes a new instance of the ApiHeaderAttribute class with the specified header name. public ApiHeaderAttribute(string headerName) Parameters headerName string The name of the header."
  },
  "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the header. public string? Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.HeaderName.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.HeaderName.html",
    "title": "Property HeaderName | Sisk",
    "keywords": "Property HeaderName Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll HeaderName Gets the name of the header. public string HeaderName { get; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.IsRequired.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.IsRequired.html",
    "title": "Property IsRequired | Sisk",
    "keywords": "Property IsRequired Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll IsRequired Gets or sets a value indicating whether the header is required. public bool IsRequired { get; set; } Property Value bool"
  },
  "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiHeaderAttribute.html",
    "title": "Class ApiHeaderAttribute | Sisk",
    "keywords": "Class ApiHeaderAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API header, allowing metadata such as header name, description, and requirement status to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ApiHeaderAttribute : Attribute Inheritance object Attribute ApiHeaderAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiHeaderAttribute(string) Initializes a new instance of the ApiHeaderAttribute class with the specified header name. Properties Description Gets or sets the description of the header. HeaderName Gets the name of the header. IsRequired Gets or sets a value indicating whether the header is required."
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.-ctor.html",
    "title": "Constructor ApiParameterAttribute | Sisk",
    "keywords": "Constructor ApiParameterAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiParameterAttribute(string, string) Initializes a new instance of the ApiParameterAttribute class with the specified name and type name. public ApiParameterAttribute(string name, string typeName) Parameters name string The name of the parameter. typeName string The type name of the parameter."
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the parameter. public string? Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.IsRequired.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.IsRequired.html",
    "title": "Property IsRequired | Sisk",
    "keywords": "Property IsRequired Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll IsRequired Gets or sets a value indicating whether the parameter is required. public bool IsRequired { get; set; } Property Value bool"
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.Name.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Name Gets the name of the parameter. public string Name { get; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.TypeName.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.TypeName.html",
    "title": "Property TypeName | Sisk",
    "keywords": "Property TypeName Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll TypeName Gets the type name of the parameter. public string TypeName { get; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiParameterAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiParameterAttribute.html",
    "title": "Class ApiParameterAttribute | Sisk",
    "keywords": "Class ApiParameterAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API parameter, allowing metadata such as name, type, description, and requirement status to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ApiParameterAttribute : Attribute Inheritance object Attribute ApiParameterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiParameterAttribute(string, string) Initializes a new instance of the ApiParameterAttribute class with the specified name and type name. Properties Description Gets or sets the description of the parameter. IsRequired Gets or sets a value indicating whether the parameter is required. Name Gets the name of the parameter. TypeName Gets the type name of the parameter."
  },
  "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.-ctor.html",
    "title": "Constructor ApiPathParameterAttribute | Sisk",
    "keywords": "Constructor ApiPathParameterAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiPathParameterAttribute(string) Initializes a new instance of the ApiPathParameterAttribute class with the specified name. public ApiPathParameterAttribute(string name) Parameters name string The name of the path parameter."
  },
  "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the path parameter. public string? Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Name.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Name Gets the name of the path parameter. public string Name { get; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Type.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.Type.html",
    "title": "Property Type | Sisk",
    "keywords": "Property Type Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Type Gets or sets the type of the path parameter. public string? Type { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiPathParameterAttribute.html",
    "title": "Class ApiPathParameterAttribute | Sisk",
    "keywords": "Class ApiPathParameterAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API path parameter, allowing metadata such as name, type, and description to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ApiPathParameterAttribute : Attribute Inheritance object Attribute ApiPathParameterAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiPathParameterAttribute(string) Initializes a new instance of the ApiPathParameterAttribute class with the specified name. Properties Description Gets or sets the description of the path parameter. Name Gets the name of the path parameter. Type Gets or sets the type of the path parameter."
  },
  "api/Sisk.Documenting.Annotations.ApiRequestAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiRequestAttribute.-ctor.html",
    "title": "Constructor ApiRequestAttribute | Sisk",
    "keywords": "Constructor ApiRequestAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiRequestAttribute(string) Initializes a new instance of the ApiRequestAttribute class with the specified description. public ApiRequestAttribute(string description) Parameters description string The description of the API request."
  },
  "api/Sisk.Documenting.Annotations.ApiRequestAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiRequestAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the API request. public string Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiRequestAttribute.Example.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiRequestAttribute.Example.html",
    "title": "Property Example | Sisk",
    "keywords": "Property Example Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Example Gets or sets the actual example request content. public string? Example { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiRequestAttribute.ExampleLanguage.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiRequestAttribute.ExampleLanguage.html",
    "title": "Property ExampleLanguage | Sisk",
    "keywords": "Property ExampleLanguage Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ExampleLanguage Gets or sets the programming language used in the example, if applicable. public string? ExampleLanguage { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiRequestAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiRequestAttribute.html",
    "title": "Class ApiRequestAttribute | Sisk",
    "keywords": "Class ApiRequestAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API request, allowing metadata such as description, example language, and example content to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ApiRequestAttribute : Attribute Inheritance object Attribute ApiRequestAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiRequestAttribute(string) Initializes a new instance of the ApiRequestAttribute class with the specified description. Properties Description Gets or sets the description of the API request. Example Gets or sets the actual example request content. ExampleLanguage Gets or sets the programming language used in the example, if applicable."
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.-ctor.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.-ctor.html",
    "title": "Constructor ApiResponseAttribute | Sisk",
    "keywords": "Constructor ApiResponseAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ApiResponseAttribute(HttpStatusCode) Initializes a new instance of the ApiResponseAttribute class with the specified status code. public ApiResponseAttribute(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode The HTTP status code for the response."
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.Description.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Description Gets or sets the description of the response. public string? Description { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.Example.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.Example.html",
    "title": "Property Example | Sisk",
    "keywords": "Property Example Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Example Gets or sets the example response content. public string? Example { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.ExampleLanguage.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.ExampleLanguage.html",
    "title": "Property ExampleLanguage | Sisk",
    "keywords": "Property ExampleLanguage Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll ExampleLanguage Gets or sets the programming language used in the example, if applicable. public string? ExampleLanguage { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.StatusCode.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.StatusCode.html",
    "title": "Property StatusCode | Sisk",
    "keywords": "Property StatusCode Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll StatusCode Gets the HTTP status code for the response. public HttpStatusCode StatusCode { get; } Property Value HttpStatusCode"
  },
  "api/Sisk.Documenting.Annotations.ApiResponseAttribute.html": {
    "href": "api/Sisk.Documenting.Annotations.ApiResponseAttribute.html",
    "title": "Class ApiResponseAttribute | Sisk",
    "keywords": "Class ApiResponseAttribute Namespace Sisk.Documenting.Annotations Assembly Sisk.Documenting.dll Specifies an attribute for an API response, allowing metadata such as status code, description, example content, and example language to be associated with methods. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ApiResponseAttribute : Attribute Inheritance object Attribute ApiResponseAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ApiResponseAttribute(HttpStatusCode) Initializes a new instance of the ApiResponseAttribute class with the specified status code. Properties Description Gets or sets the description of the response. Example Gets or sets the example response content. ExampleLanguage Gets or sets the programming language used in the example, if applicable. StatusCode Gets the HTTP status code for the response."
  },
  "api/Sisk.Documenting.Annotations.html": {
    "href": "api/Sisk.Documenting.Annotations.html",
    "title": "Namespace Sisk.Documenting.Annotations | Sisk",
    "keywords": "Namespace Sisk.Documenting.Annotations Classes ApiEndpointAttribute Specifies an attribute for an API endpoint, allowing metadata such as name, description, and group to be associated with methods. ApiHeaderAttribute Specifies an attribute for an API header, allowing metadata such as header name, description, and requirement status to be associated with methods. ApiParameterAttribute Specifies an attribute for an API parameter, allowing metadata such as name, type, description, and requirement status to be associated with methods. ApiPathParameterAttribute Specifies an attribute for an API path parameter, allowing metadata such as name, type, and description to be associated with methods. ApiRequestAttribute Specifies an attribute for an API request, allowing metadata such as description, example language, and example content to be associated with methods. ApiResponseAttribute Specifies an attribute for an API response, allowing metadata such as status code, description, example content, and example language to be associated with methods."
  },
  "api/Sisk.Documenting.ApiDocumentation.ApiVersion.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.ApiVersion.html",
    "title": "Property ApiVersion | Sisk",
    "keywords": "Property ApiVersion Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApiVersion Gets or sets the version of the API. public string? ApiVersion { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiDocumentation.ApplicationDescription.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.ApplicationDescription.html",
    "title": "Property ApplicationDescription | Sisk",
    "keywords": "Property ApplicationDescription Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApplicationDescription Gets or sets the description of the application. public string? ApplicationDescription { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiDocumentation.ApplicationName.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.ApplicationName.html",
    "title": "Property ApplicationName | Sisk",
    "keywords": "Property ApplicationName Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApplicationName Gets or sets the name of the application. public string? ApplicationName { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiDocumentation.Endpoints.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.Endpoints.html",
    "title": "Property Endpoints | Sisk",
    "keywords": "Property Endpoints Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Endpoints Gets or sets the array of API endpoints. public ApiEndpoint[] Endpoints { get; } Property Value ApiEndpoint[]"
  },
  "api/Sisk.Documenting.ApiDocumentation.Generate.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.Generate.html",
    "title": "Method Generate | Sisk",
    "keywords": "Method Generate Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Generate(Router, ApiIdentifier) Generates an instance of ApiDocumentation by reading documentation from the specified router and identifier. public static ApiDocumentation Generate(Router router, ApiIdentifier identifier) Parameters router Router The router used to generate the documentation. identifier ApiIdentifier The identifier for the API documentation. Returns ApiDocumentation An instance of ApiDocumentation."
  },
  "api/Sisk.Documenting.ApiDocumentation.html": {
    "href": "api/Sisk.Documenting.ApiDocumentation.html",
    "title": "Class ApiDocumentation | Sisk",
    "keywords": "Class ApiDocumentation Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents the API documentation, including application details and endpoints. public sealed class ApiDocumentation Inheritance object ApiDocumentation Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ApiVersion Gets or sets the version of the API. ApplicationDescription Gets or sets the description of the application. ApplicationName Gets or sets the name of the application. Endpoints Gets or sets the array of API endpoints. Methods Generate(Router, ApiIdentifier) Generates an instance of ApiDocumentation by reading documentation from the specified router and identifier."
  },
  "api/Sisk.Documenting.ApiEndpoint.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets the description of the API endpoint. public string? Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpoint.Group.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Group.html",
    "title": "Property Group | Sisk",
    "keywords": "Property Group Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Group Gets the group to which the API endpoint belongs. public string? Group { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpoint.Headers.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Headers Gets the headers associated with the API endpoint. public ApiEndpointHeader[] Headers { get; } Property Value ApiEndpointHeader[]"
  },
  "api/Sisk.Documenting.ApiEndpoint.Name.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Name Gets the name of the API endpoint. public string Name { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpoint.Parameters.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Parameters Gets the parameters accepted by the API endpoint. public ApiEndpointParameter[] Parameters { get; } Property Value ApiEndpointParameter[]"
  },
  "api/Sisk.Documenting.ApiEndpoint.Path.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Path Gets the path of the API endpoint. public string Path { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpoint.PathParameters.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.PathParameters.html",
    "title": "Property PathParameters | Sisk",
    "keywords": "Property PathParameters Namespace Sisk.Documenting Assembly Sisk.Documenting.dll PathParameters Gets the path parameters for the API endpoint. public ApiEndpointPathParameter[] PathParameters { get; } Property Value ApiEndpointPathParameter[]"
  },
  "api/Sisk.Documenting.ApiEndpoint.RequestExamples.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.RequestExamples.html",
    "title": "Property RequestExamples | Sisk",
    "keywords": "Property RequestExamples Namespace Sisk.Documenting Assembly Sisk.Documenting.dll RequestExamples Gets the parameters accepted by the API endpoint. public ApiEndpointRequestExample[] RequestExamples { get; } Property Value ApiEndpointRequestExample[]"
  },
  "api/Sisk.Documenting.ApiEndpoint.Responses.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.Responses.html",
    "title": "Property Responses | Sisk",
    "keywords": "Property Responses Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Responses Gets the possible responses from the API endpoint. public ApiEndpointResponse[] Responses { get; } Property Value ApiEndpointResponse[]"
  },
  "api/Sisk.Documenting.ApiEndpoint.RouteMethod.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.RouteMethod.html",
    "title": "Property RouteMethod | Sisk",
    "keywords": "Property RouteMethod Namespace Sisk.Documenting Assembly Sisk.Documenting.dll RouteMethod Gets the route method used for the API endpoint. public RouteMethod RouteMethod { get; } Property Value RouteMethod"
  },
  "api/Sisk.Documenting.ApiEndpoint.html": {
    "href": "api/Sisk.Documenting.ApiEndpoint.html",
    "title": "Class ApiEndpoint | Sisk",
    "keywords": "Class ApiEndpoint Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents an API endpoint, including its metadata, request and response details. public sealed class ApiEndpoint Inheritance object ApiEndpoint Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the API endpoint. Group Gets the group to which the API endpoint belongs. Headers Gets the headers associated with the API endpoint. Name Gets the name of the API endpoint. Parameters Gets the parameters accepted by the API endpoint. Path Gets the path of the API endpoint. PathParameters Gets the path parameters for the API endpoint. RequestExamples Gets the parameters accepted by the API endpoint. Responses Gets the possible responses from the API endpoint. RouteMethod Gets the route method used for the API endpoint."
  },
  "api/Sisk.Documenting.ApiEndpointHeader.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpointHeader.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets or sets the description of the header. public string? Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointHeader.HeaderName.html": {
    "href": "api/Sisk.Documenting.ApiEndpointHeader.HeaderName.html",
    "title": "Property HeaderName | Sisk",
    "keywords": "Property HeaderName Namespace Sisk.Documenting Assembly Sisk.Documenting.dll HeaderName Gets or sets the name of the header. public string HeaderName { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointHeader.IsRequired.html": {
    "href": "api/Sisk.Documenting.ApiEndpointHeader.IsRequired.html",
    "title": "Property IsRequired | Sisk",
    "keywords": "Property IsRequired Namespace Sisk.Documenting Assembly Sisk.Documenting.dll IsRequired Gets or sets a value indicating whether the header is required. public bool IsRequired { get; } Property Value bool"
  },
  "api/Sisk.Documenting.ApiEndpointHeader.html": {
    "href": "api/Sisk.Documenting.ApiEndpointHeader.html",
    "title": "Class ApiEndpointHeader | Sisk",
    "keywords": "Class ApiEndpointHeader Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents a header for an API endpoint, including its name and requirements. public sealed class ApiEndpointHeader Inheritance object ApiEndpointHeader Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets or sets the description of the header. HeaderName Gets or sets the name of the header. IsRequired Gets or sets a value indicating whether the header is required."
  },
  "api/Sisk.Documenting.ApiEndpointParameter.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpointParameter.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets the description of the parameter. public string? Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointParameter.IsRequired.html": {
    "href": "api/Sisk.Documenting.ApiEndpointParameter.IsRequired.html",
    "title": "Property IsRequired | Sisk",
    "keywords": "Property IsRequired Namespace Sisk.Documenting Assembly Sisk.Documenting.dll IsRequired Gets a value indicating whether the parameter is required. public bool IsRequired { get; } Property Value bool"
  },
  "api/Sisk.Documenting.ApiEndpointParameter.Name.html": {
    "href": "api/Sisk.Documenting.ApiEndpointParameter.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Name Gets the name of the parameter. public string Name { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointParameter.TypeName.html": {
    "href": "api/Sisk.Documenting.ApiEndpointParameter.TypeName.html",
    "title": "Property TypeName | Sisk",
    "keywords": "Property TypeName Namespace Sisk.Documenting Assembly Sisk.Documenting.dll TypeName Gets the type name of the parameter. public string TypeName { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointParameter.html": {
    "href": "api/Sisk.Documenting.ApiEndpointParameter.html",
    "title": "Class ApiEndpointParameter | Sisk",
    "keywords": "Class ApiEndpointParameter Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents a parameter for an API endpoint, including its name, type, and requirements. public sealed class ApiEndpointParameter Inheritance object ApiEndpointParameter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the parameter. IsRequired Gets a value indicating whether the parameter is required. Name Gets the name of the parameter. TypeName Gets the type name of the parameter."
  },
  "api/Sisk.Documenting.ApiEndpointPathParameter.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpointPathParameter.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets the description of the path parameter. public string? Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointPathParameter.Name.html": {
    "href": "api/Sisk.Documenting.ApiEndpointPathParameter.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Name Gets the name of the path parameter. public string Name { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointPathParameter.Type.html": {
    "href": "api/Sisk.Documenting.ApiEndpointPathParameter.Type.html",
    "title": "Property Type | Sisk",
    "keywords": "Property Type Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Type Gets the type of the path parameter. public string? Type { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointPathParameter.html": {
    "href": "api/Sisk.Documenting.ApiEndpointPathParameter.html",
    "title": "Class ApiEndpointPathParameter | Sisk",
    "keywords": "Class ApiEndpointPathParameter Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents a path parameter for an API endpoint, including its name, type, and description. public sealed class ApiEndpointPathParameter Inheritance object ApiEndpointPathParameter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the path parameter. Name Gets the name of the path parameter. Type Gets the type of the path parameter."
  },
  "api/Sisk.Documenting.ApiEndpointRequestExample.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpointRequestExample.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets the description of the request example. public string Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointRequestExample.Example.html": {
    "href": "api/Sisk.Documenting.ApiEndpointRequestExample.Example.html",
    "title": "Property Example | Sisk",
    "keywords": "Property Example Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Example Gets the actual example request content. public string? Example { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointRequestExample.ExampleLanguage.html": {
    "href": "api/Sisk.Documenting.ApiEndpointRequestExample.ExampleLanguage.html",
    "title": "Property ExampleLanguage | Sisk",
    "keywords": "Property ExampleLanguage Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ExampleLanguage Gets the programming language used in the example, if applicable. public string? ExampleLanguage { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointRequestExample.html": {
    "href": "api/Sisk.Documenting.ApiEndpointRequestExample.html",
    "title": "Class ApiEndpointRequestExample | Sisk",
    "keywords": "Class ApiEndpointRequestExample Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents an example request for an API endpoint, including its description and example content. public sealed class ApiEndpointRequestExample Inheritance object ApiEndpointRequestExample Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the request example. Example Gets the actual example request content. ExampleLanguage Gets the programming language used in the example, if applicable."
  },
  "api/Sisk.Documenting.ApiEndpointResponse.Description.html": {
    "href": "api/Sisk.Documenting.ApiEndpointResponse.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Description Gets the description of the response. public string? Description { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointResponse.Example.html": {
    "href": "api/Sisk.Documenting.ApiEndpointResponse.Example.html",
    "title": "Property Example | Sisk",
    "keywords": "Property Example Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Example Gets the example response content. public string? Example { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointResponse.ExampleLanguage.html": {
    "href": "api/Sisk.Documenting.ApiEndpointResponse.ExampleLanguage.html",
    "title": "Property ExampleLanguage | Sisk",
    "keywords": "Property ExampleLanguage Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ExampleLanguage Gets the programming language used in the example, if applicable. public string? ExampleLanguage { get; } Property Value string"
  },
  "api/Sisk.Documenting.ApiEndpointResponse.StatusCode.html": {
    "href": "api/Sisk.Documenting.ApiEndpointResponse.StatusCode.html",
    "title": "Property StatusCode | Sisk",
    "keywords": "Property StatusCode Namespace Sisk.Documenting Assembly Sisk.Documenting.dll StatusCode Gets the HTTP status code for the response. public HttpStatusCode StatusCode { get; } Property Value HttpStatusCode"
  },
  "api/Sisk.Documenting.ApiEndpointResponse.html": {
    "href": "api/Sisk.Documenting.ApiEndpointResponse.html",
    "title": "Class ApiEndpointResponse | Sisk",
    "keywords": "Class ApiEndpointResponse Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents a response for an API endpoint, including the status code and example content. public sealed class ApiEndpointResponse Inheritance object ApiEndpointResponse Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the response. Example Gets the example response content. ExampleLanguage Gets the programming language used in the example, if applicable. StatusCode Gets the HTTP status code for the response."
  },
  "api/Sisk.Documenting.ApiIdentifier.-ctor.html": {
    "href": "api/Sisk.Documenting.ApiIdentifier.-ctor.html",
    "title": "Constructor ApiIdentifier | Sisk",
    "keywords": "Constructor ApiIdentifier Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApiIdentifier() public ApiIdentifier()"
  },
  "api/Sisk.Documenting.ApiIdentifier.ApplicationDescription.html": {
    "href": "api/Sisk.Documenting.ApiIdentifier.ApplicationDescription.html",
    "title": "Property ApplicationDescription | Sisk",
    "keywords": "Property ApplicationDescription Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApplicationDescription Gets or sets the description of the application. public string? ApplicationDescription { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.ApiIdentifier.ApplicationName.html": {
    "href": "api/Sisk.Documenting.ApiIdentifier.ApplicationName.html",
    "title": "Property ApplicationName | Sisk",
    "keywords": "Property ApplicationName Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApplicationName Gets or sets the name of the application. public string? ApplicationName { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.ApiIdentifier.ApplicationVersion.html": {
    "href": "api/Sisk.Documenting.ApiIdentifier.ApplicationVersion.html",
    "title": "Property ApplicationVersion | Sisk",
    "keywords": "Property ApplicationVersion Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ApplicationVersion Gets or sets the version of the application. public string? ApplicationVersion { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.ApiIdentifier.html": {
    "href": "api/Sisk.Documenting.ApiIdentifier.html",
    "title": "Class ApiIdentifier | Sisk",
    "keywords": "Class ApiIdentifier Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Represents an identifier for an API, including application details such as name, version, and description. public sealed class ApiIdentifier Inheritance object ApiIdentifier Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors ApiIdentifier() Properties ApplicationDescription Gets or sets the description of the application. ApplicationName Gets or sets the name of the application. ApplicationVersion Gets or sets the version of the application."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.-ctor.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.-ctor.html",
    "title": "Constructor HtmlDocumentationExporter | Sisk",
    "keywords": "Constructor HtmlDocumentationExporter Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll HtmlDocumentationExporter() Creates an new instance of the HtmlDocumentationExporter class. public HtmlDocumentationExporter()"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateCodeBlock.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateCodeBlock.html",
    "title": "Method CreateCodeBlock | Sisk",
    "keywords": "Method CreateCodeBlock Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll CreateCodeBlock(string, string?) Creates an HTML code block element from the provided code and language. protected virtual HtmlElement? CreateCodeBlock(string code, string? language) Parameters code string The code to display in the code block. language string The programming language of the code, or null for no language highlighting. Returns HtmlElement The HTML element representing the code block, or null if no code is provided."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateEndpointBadge.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateEndpointBadge.html",
    "title": "Method CreateEndpointBadge | Sisk",
    "keywords": "Method CreateEndpointBadge Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll CreateEndpointBadge(RouteMethod, string?) Creates an HTML badge element for an API endpoint. protected virtual HtmlElement? CreateEndpointBadge(RouteMethod method, string? path) Parameters method RouteMethod The HTTP method of the endpoint (e.g. GET, POST, PUT, etc.). path string The path of the endpoint, or null for no path display. Returns HtmlElement The HTML element representing the endpoint badge, or null if no badge is applicable."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateParagraphs.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.CreateParagraphs.html",
    "title": "Method CreateParagraphs | Sisk",
    "keywords": "Method CreateParagraphs Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll CreateParagraphs(string?) Creates one or more HTML paragraph elements from the provided text. protected virtual object? CreateParagraphs(string? text) Parameters text string The text to display in the paragraphs, or null for no paragraphs. Returns object The HTML element representing the paragraphs, or null if no text is provided."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Ellipsis.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Ellipsis.html",
    "title": "Method Ellipsis | Sisk",
    "keywords": "Method Ellipsis Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Ellipsis(string?, int) Truncates a string to the specified size, appending an ellipsis if necessary. protected string? Ellipsis(string? s, int size) Parameters s string The string to truncate, or null for no truncation. size int The maximum length of the string, including the ellipsis. Returns string The truncated string, or the original string if it is already within the size limit, or null if the input string is null."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.ExportDocumentationContent.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.ExportDocumentationContent.html",
    "title": "Method ExportDocumentationContent | Sisk",
    "keywords": "Method ExportDocumentationContent Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll ExportDocumentationContent(ApiDocumentation) Exports the API documentation as HTTP content. public HttpContent ExportDocumentationContent(ApiDocumentation documentation) Parameters documentation ApiDocumentation The API documentation to export. Returns HttpContent The exported API documentation as HTTP content."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.ExportHtml.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.ExportHtml.html",
    "title": "Method ExportHtml | Sisk",
    "keywords": "Method ExportHtml Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll ExportHtml(ApiDocumentation) Exports the API documentation as an HTML string. public string ExportHtml(ApiDocumentation d) Parameters d ApiDocumentation The API documentation to export. Returns string The exported HTML string."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Footer.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Footer.html",
    "title": "Property Footer | Sisk",
    "keywords": "Property Footer Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Footer Gets or sets an optional object to append after the generated contents, right at the end of the <main> tag of the generated page. public object? Footer { get; set; } Property Value object"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointHeaders.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointHeaders.html",
    "title": "Property FormatEndpointHeaders | Sisk",
    "keywords": "Property FormatEndpointHeaders Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatEndpointHeaders Gets or sets the format string for endpoint headers. public string FormatEndpointHeaders { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointParameters.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointParameters.html",
    "title": "Property FormatEndpointParameters | Sisk",
    "keywords": "Property FormatEndpointParameters Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatEndpointParameters Gets or sets the format string for endpoint request parameters. public string FormatEndpointParameters { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointPathParameters.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointPathParameters.html",
    "title": "Property FormatEndpointPathParameters | Sisk",
    "keywords": "Property FormatEndpointPathParameters Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatEndpointPathParameters Gets or sets the format string for endpoint path parameters. public string FormatEndpointPathParameters { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointRequestExamples.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointRequestExamples.html",
    "title": "Property FormatEndpointRequestExamples | Sisk",
    "keywords": "Property FormatEndpointRequestExamples Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatEndpointRequestExamples Gets or sets the format string for endpoint request examples. public string FormatEndpointRequestExamples { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointResponses.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatEndpointResponses.html",
    "title": "Property FormatEndpointResponses | Sisk",
    "keywords": "Property FormatEndpointResponses Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatEndpointResponses Gets or sets the format string for endpoint responses. public string FormatEndpointResponses { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatMainTitleServiceVersion.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatMainTitleServiceVersion.html",
    "title": "Property FormatMainTitleServiceVersion | Sisk",
    "keywords": "Property FormatMainTitleServiceVersion Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatMainTitleServiceVersion Gets or sets the format string for the main title service version. public string FormatMainTitleServiceVersion { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatRequiredText.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.FormatRequiredText.html",
    "title": "Property FormatRequiredText | Sisk",
    "keywords": "Property FormatRequiredText Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll FormatRequiredText Gets or sets the format string for required text. public string FormatRequiredText { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.GetRouteMethodHexColor.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.GetRouteMethodHexColor.html",
    "title": "Method GetRouteMethodHexColor | Sisk",
    "keywords": "Method GetRouteMethodHexColor Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll GetRouteMethodHexColor(RouteMethod) Gets the hex color code associated with the specified route method. protected virtual string GetRouteMethodHexColor(RouteMethod rm) Parameters rm RouteMethod The route method to get the color for. Returns string The hex color code as a string."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Head.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Head.html",
    "title": "Property Head | Sisk",
    "keywords": "Property Head Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Head Gets or sets an optional object to append inside the <head> tag of the generated page. public object? Head { get; set; } Property Value object"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Header.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Header.html",
    "title": "Property Header | Sisk",
    "keywords": "Property Header Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Header Gets or sets an optional object to append after the main title, at the beginning of the <main> tag of the generated page. public object? Header { get; set; } Property Value object"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.PageTitle.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.PageTitle.html",
    "title": "Property PageTitle | Sisk",
    "keywords": "Property PageTitle Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll PageTitle Gets or sets the title of the HTML page. public string PageTitle { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Script.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Script.html",
    "title": "Property Script | Sisk",
    "keywords": "Property Script Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Script Gets or sets the JavaScript script to be included in the HTML page. public string? Script { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Style.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.Style.html",
    "title": "Property Style | Sisk",
    "keywords": "Property Style Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Style Gets or sets the CSS styles of the HTML page. public string Style { get; set; } Property Value string"
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.TransformId.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.TransformId.html",
    "title": "Method TransformId | Sisk",
    "keywords": "Method TransformId Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll TransformId(string) Transforms an unsafe ID into a safe and valid HTML ID. protected string TransformId(string unsafeId) Parameters unsafeId string The ID to transform, which may contain invalid characters. Returns string The transformed ID, which is safe for use in HTML."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.WriteEndpointDescription.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.WriteEndpointDescription.html",
    "title": "Method WriteEndpointDescription | Sisk",
    "keywords": "Method WriteEndpointDescription Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll WriteEndpointDescription(ApiEndpoint) Writes the description of an API endpoint. protected virtual HtmlElement? WriteEndpointDescription(ApiEndpoint endpoint) Parameters endpoint ApiEndpoint The API endpoint to write the description for. Returns HtmlElement The HTML element representing the endpoint description, or null if no description is available."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.WriteMainTitle.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.WriteMainTitle.html",
    "title": "Method WriteMainTitle | Sisk",
    "keywords": "Method WriteMainTitle Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll WriteMainTitle(ApiDocumentation) Writes the main title of the API documentation. protected virtual HtmlElement? WriteMainTitle(ApiDocumentation documentation) Parameters documentation ApiDocumentation The API documentation to write the title for. Returns HtmlElement The HTML element representing the main title."
  },
  "api/Sisk.Documenting.Html.HtmlDocumentationExporter.html": {
    "href": "api/Sisk.Documenting.Html.HtmlDocumentationExporter.html",
    "title": "Class HtmlDocumentationExporter | Sisk",
    "keywords": "Class HtmlDocumentationExporter Namespace Sisk.Documenting.Html Assembly Sisk.Documenting.Html.dll Represents a class for exporting API documentation to HTML format. public class HtmlDocumentationExporter : IApiDocumentationExporter Inheritance object HtmlDocumentationExporter Implements IApiDocumentationExporter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HtmlDocumentationExporter() Creates an new instance of the HtmlDocumentationExporter class. Properties Footer Gets or sets an optional object to append after the generated contents, right at the end of the <main> tag of the generated page. FormatEndpointHeaders Gets or sets the format string for endpoint headers. FormatEndpointParameters Gets or sets the format string for endpoint request parameters. FormatEndpointPathParameters Gets or sets the format string for endpoint path parameters. FormatEndpointRequestExamples Gets or sets the format string for endpoint request examples. FormatEndpointResponses Gets or sets the format string for endpoint responses. FormatMainTitleServiceVersion Gets or sets the format string for the main title service version. FormatRequiredText Gets or sets the format string for required text. Head Gets or sets an optional object to append inside the <head> tag of the generated page. Header Gets or sets an optional object to append after the main title, at the beginning of the <main> tag of the generated page. PageTitle Gets or sets the title of the HTML page. Script Gets or sets the JavaScript script to be included in the HTML page. Style Gets or sets the CSS styles of the HTML page. Methods CreateCodeBlock(string, string?) Creates an HTML code block element from the provided code and language. CreateEndpointBadge(RouteMethod, string?) Creates an HTML badge element for an API endpoint. CreateParagraphs(string?) Creates one or more HTML paragraph elements from the provided text. Ellipsis(string?, int) Truncates a string to the specified size, appending an ellipsis if necessary. ExportDocumentationContent(ApiDocumentation) Exports the API documentation as HTTP content. ExportHtml(ApiDocumentation) Exports the API documentation as an HTML string. GetRouteMethodHexColor(RouteMethod) Gets the hex color code associated with the specified route method. TransformId(string) Transforms an unsafe ID into a safe and valid HTML ID. WriteEndpointDescription(ApiEndpoint) Writes the description of an API endpoint. WriteMainTitle(ApiDocumentation) Writes the main title of the API documentation."
  },
  "api/Sisk.Documenting.Html.html": {
    "href": "api/Sisk.Documenting.Html.html",
    "title": "Namespace Sisk.Documenting.Html | Sisk",
    "keywords": "Namespace Sisk.Documenting.Html Classes HtmlDocumentationExporter Represents a class for exporting API documentation to HTML format."
  },
  "api/Sisk.Documenting.IApiDocumentationExporter.ExportDocumentationContent.html": {
    "href": "api/Sisk.Documenting.IApiDocumentationExporter.ExportDocumentationContent.html",
    "title": "Method ExportDocumentationContent | Sisk",
    "keywords": "Method ExportDocumentationContent Namespace Sisk.Documenting Assembly Sisk.Documenting.dll ExportDocumentationContent(ApiDocumentation) Exports the specified API documentation content. HttpContent ExportDocumentationContent(ApiDocumentation documentation) Parameters documentation ApiDocumentation The API documentation to export. Returns HttpContent An HttpContent representing the exported documentation."
  },
  "api/Sisk.Documenting.IApiDocumentationExporter.html": {
    "href": "api/Sisk.Documenting.IApiDocumentationExporter.html",
    "title": "Interface IApiDocumentationExporter | Sisk",
    "keywords": "Interface IApiDocumentationExporter Namespace Sisk.Documenting Assembly Sisk.Documenting.dll Defines a contract for exporting API documentation content. public interface IApiDocumentationExporter Methods ExportDocumentationContent(ApiDocumentation) Exports the specified API documentation content."
  },
  "api/Sisk.Documenting.html": {
    "href": "api/Sisk.Documenting.html",
    "title": "Namespace Sisk.Documenting | Sisk",
    "keywords": "Namespace Sisk.Documenting Namespaces Sisk.Documenting.Annotations Sisk.Documenting.Html Classes ApiDocumentation Represents the API documentation, including application details and endpoints. ApiEndpoint Represents an API endpoint, including its metadata, request and response details. ApiEndpointHeader Represents a header for an API endpoint, including its name and requirements. ApiEndpointParameter Represents a parameter for an API endpoint, including its name, type, and requirements. ApiEndpointPathParameter Represents a path parameter for an API endpoint, including its name, type, and description. ApiEndpointRequestExample Represents an example request for an API endpoint, including its description and example content. ApiEndpointResponse Represents a response for an API endpoint, including the status code and example content. ApiIdentifier Represents an identifier for an API, including application details such as name, version, and description. Interfaces IApiDocumentationExporter Defines a contract for exporting API documentation content."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.-ctor.html",
    "title": "Constructor IniDocument | Sisk",
    "keywords": "Constructor IniDocument Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IniDocument(IEnumerable<IniSection>) Creates an new IniDocument instance from the specified IniSection collection. public IniDocument(IEnumerable<IniSection> sections) Parameters sections IEnumerable<IniSection> The list of IniSection. IniDocument() Creates an new empty IniDocument instance with no INI sections added to it. public IniDocument()"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromFile.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromFile.html",
    "title": "Method FromFile | Sisk",
    "keywords": "Method FromFile Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromFile(string, Encoding?, bool) Creates an new IniDocument document from the specified file using the specified encoding. public static IniDocument FromFile(string filePath, Encoding? encoding = null, bool throwIfNotExists = true) Parameters filePath string The absolute or relative file path to the INI document. encoding Encoding Optional. The encoding used to read the file. Defaults to UTF-8. throwIfNotExists bool Optional. Defines whether this method should throw if the specified file doens't exists or return an empty INI document. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromStream.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromStream.html",
    "title": "Method FromStream | Sisk",
    "keywords": "Method FromStream Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. public static IniDocument FromStream(Stream stream, Encoding? encoding = null) Parameters stream Stream The input stream where the INI document is. encoding Encoding Optional. The encoding used to read the stream. Defaults to UTF-8. Returns IniDocument FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. public static IniDocument FromStream(TextReader reader) Parameters reader TextReader The TextReader instance. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromString.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromString.html",
    "title": "Method FromString | Sisk",
    "keywords": "Method FromString Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. public static IniDocument FromString(string iniConfiguration) Parameters iniConfiguration string The UTF-8 string. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.GetEntries.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.GetEntries.html",
    "title": "Method GetEntries | Sisk",
    "keywords": "Method GetEntries Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEntries() Retrieves all entries in the INI document. public IEnumerable<KeyValuePair<string, string[]>> GetEntries() Returns IEnumerable<KeyValuePair<string, string[]>> An enumerable collection of key-value pairs, where each key is the entry name and each value is an array of strings representing the entry values."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.GetEntry.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.GetEntry.html",
    "title": "Method GetEntry | Sisk",
    "keywords": "Method GetEntry Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEntry(string, StringComparison) Retrieves the values of a specific entry in the INI document. public string[] GetEntry(string name, StringComparison stringComparison = StringComparison.OrdinalIgnoreCase) Parameters name string The name of the entry to retrieve. stringComparison StringComparison The string comparison to use when searching for the entry. Defaults to OrdinalIgnoreCase. Returns string[] An array of strings representing the values of the entry, or an empty array if the entry is not found."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.GetSection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.GetSection.html",
    "title": "Method GetSection | Sisk",
    "keywords": "Method GetSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetSection(string) Gets an defined INI section from this document. The search is case-insensitive. public IniSection? GetSection(string sectionName) Parameters sectionName string The section name. Returns IniSection The IniSection object if found, or null if not defined."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.Global.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.Global.html",
    "title": "Property Global | Sisk",
    "keywords": "Property Global Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Global Gets the global INI section, which is the primary section in the document. public IniSection Global { get; } Property Value IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.Sections.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.Sections.html",
    "title": "Property Sections | Sisk",
    "keywords": "Property Sections Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Sections Gets all INI sections defined in this INI document. public IniSectionCollection Sections { get; } Property Value IniSectionCollection"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.ToString.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll ToString() Gets the INI document string from this IniDocument. public override string ToString() Returns string"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.html",
    "title": "Class IniDocument | Sisk",
    "keywords": "Class IniDocument Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an INI document. public sealed class IniDocument Inheritance object IniDocument Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniDocument() Creates an new empty IniDocument instance with no INI sections added to it. IniDocument(IEnumerable<IniSection>) Creates an new IniDocument instance from the specified IniSection collection. Properties Global Gets the global INI section, which is the primary section in the document. Sections Gets all INI sections defined in this INI document. Methods FromFile(string, Encoding?, bool) Creates an new IniDocument document from the specified file using the specified encoding. FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. GetEntries() Retrieves all entries in the INI document. GetEntry(string, StringComparison) Retrieves the values of a specific entry in the INI document. GetSection(string) Gets an defined INI section from this document. The search is case-insensitive. ToString() Gets the INI document string from this IniDocument."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.-ctor.html",
    "title": "Constructor IniSection | Sisk",
    "keywords": "Constructor IniSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IniSection(string) Initializes a new instance of the IniSection class with the specified name. public IniSection(string name) Parameters name string The name of the INI section. IniSection(string, IEnumerable<KeyValuePair<string, string>>) Initializes a new instance of the IniSection class with the specified name and items. public IniSection(string name, IEnumerable<KeyValuePair<string, string>> items) Parameters name string The name of the INI section. items IEnumerable<KeyValuePair<string, string>> A collection of key-value pairs to be added to the section."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Add.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Add(string, string[]) public void Add(string key, string[] value) Parameters key string value string[] Add(string, string?) Adds a new key-value pair to the INI section. public void Add(string key, string? value) Parameters key string The key to be added. value string The value associated with the key, or null to set an empty value. Add(KeyValuePair<string, string[]>) public void Add(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Clear.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Clear() public void Clear()"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Contains.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Contains(KeyValuePair<string, string[]>) public bool Contains(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.ContainsKey.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. public bool ContainsKey(string key) Parameters key string The property name. Returns bool An bool indicating if the specified property name is defined or not."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.CopyTo.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll CopyTo(KeyValuePair<string, string[]>[], int) This method is not supported and will throw an NotSupportedException. public void CopyTo(KeyValuePair<string, string[]>[] array, int arrayIndex) Parameters array KeyValuePair<string, string[]>[] arrayIndex int"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Count.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Count Gets the number of properties in this INI section. public int Count { get; } Property Value int"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Equals.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool Equals(IniSection?) public bool Equals(IniSection? other) Parameters other IniSection Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetEnumerator.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEnumerator() public IEnumerator<KeyValuePair<string, string[]>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, string[]>>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetHashCode.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetMany.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetMany.html",
    "title": "Method GetMany | Sisk",
    "keywords": "Method GetMany Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetMany(string) Gets all values defined in this INI section by their property name. public string[] GetMany(string key) Parameters key string The property name. Returns string[] All values associated with the specified property name."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetOne.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetOne.html",
    "title": "Method GetOne | Sisk",
    "keywords": "Method GetOne Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetOne(string) Gets the last value defined in this INI section by their property name. public string? GetOne(string key) Parameters key string The property name. Returns string The last value associated with the specified property name, or null if nothing is found."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.IsReadOnly.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IsReadOnly public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Item.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll this[string] Gets all values associated with the specified property name, performing an case-insensitive search. public string[] this[string key] { get; set; } Parameters key string The property name. Property Value string[]"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Keys.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Keys Gets all keys defined in this INI section, without duplicates. public ICollection<string> Keys { get; } Property Value ICollection<string>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Name.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Name Gets the INI section name. public string Name { get; } Property Value string"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Remove.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Remove(string) public bool Remove(string key) Parameters key string Returns bool Remove(KeyValuePair<string, string[]>) public bool Remove(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.TryGetValue.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll TryGetValue(string, out string[]) public bool TryGetValue(string key, out string[] value) Parameters key string value string[] Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Values.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Values Gets all values defined in this INI section. public ICollection<string[]> Values { get; } Property Value ICollection<string[]>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.html",
    "title": "Class IniSection | Sisk",
    "keywords": "Class IniSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an INI section, which contains it's own properties. public sealed class IniSection : IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable, IEquatable<IniSection> Inheritance object IniSection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable IEquatable<IniSection> Inherited Members object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors IniSection(string) Initializes a new instance of the IniSection class with the specified name. IniSection(string, IEnumerable<KeyValuePair<string, string>>) Initializes a new instance of the IniSection class with the specified name and items. Properties Count Gets the number of properties in this INI section. IsReadOnly this[string] Gets all values associated with the specified property name, performing an case-insensitive search. Keys Gets all keys defined in this INI section, without duplicates. Name Gets the INI section name. Values Gets all values defined in this INI section. Methods Add(KeyValuePair<string, string[]>) Add(string, string?) Adds a new key-value pair to the INI section. Add(string, string[]) Clear() Contains(KeyValuePair<string, string[]>) ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. CopyTo(KeyValuePair<string, string[]>[], int) This method is not supported and will throw an NotSupportedException. Equals(IniSection?) Equals(object?) GetEnumerator() GetHashCode() GetMany(string) Gets all values defined in this INI section by their property name. GetOne(string) Gets the last value defined in this INI section by their property name. Remove(KeyValuePair<string, string[]>) Remove(string) TryGetValue(string, out string[])"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Add.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Add(IniSection) public void Add(IniSection item) Parameters item IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Clear.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Clear() public void Clear()"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Contains.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Contains(IniSection) public bool Contains(IniSection item) Parameters item IniSection Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.CopyTo.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll CopyTo(IniSection[], int) public void CopyTo(IniSection[] array, int arrayIndex) Parameters array IniSection[] arrayIndex int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Count.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetEnumerator.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEnumerator() public IEnumerator<IniSection> GetEnumerator() Returns IEnumerator<IniSection>"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetGlobal.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetGlobal.html",
    "title": "Method GetGlobal | Sisk",
    "keywords": "Method GetGlobal Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetGlobal() Gets the global IniSection in this collection or creates a new one if it doens't exists. public IniSection GetGlobal() Returns IniSection The global IniSection."
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.IndexOf.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.IndexOf.html",
    "title": "Method IndexOf | Sisk",
    "keywords": "Method IndexOf Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IndexOf(IniSection) public int IndexOf(IniSection item) Parameters item IniSection Returns int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Insert.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Insert.html",
    "title": "Method Insert | Sisk",
    "keywords": "Method Insert Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Insert(int, IniSection) public void Insert(int index, IniSection item) Parameters index int item IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.IsReadOnly.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IsReadOnly public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Item.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll this[int] public IniSection this[int index] { get; set; } Parameters index int Property Value IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Remove.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Remove(IniSection) public bool Remove(IniSection item) Parameters item IniSection Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.RemoveAt.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.RemoveAt.html",
    "title": "Method RemoveAt | Sisk",
    "keywords": "Method RemoveAt Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.html",
    "title": "Class IniSectionCollection | Sisk",
    "keywords": "Class IniSectionCollection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an collection of IniSection. public sealed class IniSectionCollection : IList<IniSection>, ICollection<IniSection>, IReadOnlyList<IniSection>, IReadOnlyCollection<IniSection>, IEnumerable<IniSection>, ICollection, IEnumerable Inheritance object IniSectionCollection Implements IList<IniSection> ICollection<IniSection> IReadOnlyList<IniSection> IReadOnlyCollection<IniSection> IEnumerable<IniSection> ICollection IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Count IsReadOnly this[int] Methods Add(IniSection) Clear() Contains(IniSection) CopyTo(IniSection[], int) GetEnumerator() GetGlobal() Gets the global IniSection in this collection or creates a new one if it doens't exists. IndexOf(IniSection) Insert(int, IniSection) Remove(IniSection) RemoveAt(int)"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.-ctor.html",
    "title": "Constructor IniReader | Sisk",
    "keywords": "Constructor IniReader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniReader(TextReader) Creates an new IniReader with the specified text reader. public IniReader(TextReader reader) Parameters reader TextReader The TextReader instace to read the INI document."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Dispose.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.IniNamingComparer.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.IniNamingComparer.html",
    "title": "Property IniNamingComparer | Sisk",
    "keywords": "Property IniNamingComparer Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniNamingComparer Gets or sets the default StringComparer used by the INI reader and instances to compare key names. public static StringComparer IniNamingComparer { get; set; } Property Value StringComparer"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Read.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Read.html",
    "title": "Method Read | Sisk",
    "keywords": "Method Read Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Read() Reads the INI document from the input stream. public IniDocument Read() Returns IniDocument An IniDocument file containing all properties and data from the input stream."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Reader.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Reader.html",
    "title": "Property Reader | Sisk",
    "keywords": "Property Reader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Reader Gets the TextReader which is providing data to this INI reader. public TextReader Reader { get; } Property Value TextReader"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.html",
    "title": "Class IniReader | Sisk",
    "keywords": "Class IniReader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Provides an INI-document reader and parser. public sealed class IniReader : IDisposable Inheritance object IniReader Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniReader(TextReader) Creates an new IniReader with the specified text reader. Properties IniNamingComparer Gets or sets the default StringComparer used by the INI reader and instances to compare key names. Reader Gets the TextReader which is providing data to this INI reader. Methods Dispose() Read() Reads the INI document from the input stream."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.-ctor.html",
    "title": "Constructor IniWriter | Sisk",
    "keywords": "Constructor IniWriter Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniWriter(TextWriter) Initializes a new instance of the IniWriter class. public IniWriter(TextWriter writer) Parameters writer TextWriter The underlying text writer."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.CommentChar.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.CommentChar.html",
    "title": "Property CommentChar | Sisk",
    "keywords": "Property CommentChar Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll CommentChar Gets or sets the default comment character. public char CommentChar { get; set; } Property Value char"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Dispose.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Dispose() Releases all resources used by the IniWriter object. public void Dispose()"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.NewLineBehavior.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.NewLineBehavior.html",
    "title": "Property NewLineBehavior | Sisk",
    "keywords": "Property NewLineBehavior Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll NewLineBehavior Gets or sets the behavior for writing new lines inside properties values. public IniWritingNewLineBehavior NewLineBehavior { get; set; } Property Value IniWritingNewLineBehavior"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Write.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Write.html",
    "title": "Method Write | Sisk",
    "keywords": "Method Write Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Write(string, string?) Writes a key-value pair to the INI file. public void Write(string key, string? value) Parameters key string The key to write. value string The value to write. Write(in KeyValuePair<string, string[]>) Writes a key-value pair to the INI file, where the value is an array of strings. public void Write(in KeyValuePair<string, string[]> value) Parameters value KeyValuePair<string, string[]> The key-value pair to write. Write(IniSection) Writes an INI section to the INI file. public void Write(IniSection section) Parameters section IniSection The section to write. Write(IniDocument) Writes an INI document to the INI file. public void Write(IniDocument document) Parameters document IniDocument The document to write."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.WriteComment.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.WriteComment.html",
    "title": "Method WriteComment | Sisk",
    "keywords": "Method WriteComment Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll WriteComment(string) Writes a comment to the INI file. public void WriteComment(string commentString) Parameters commentString string The comment to write."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Writer.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Writer.html",
    "title": "Property Writer | Sisk",
    "keywords": "Property Writer Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Writer Gets the underlying text writer. public TextWriter Writer { get; } Property Value TextWriter"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.html",
    "title": "Class IniWriter | Sisk",
    "keywords": "Class IniWriter Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Represents a writer for INI files. public sealed class IniWriter : IDisposable Inheritance object IniWriter Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniWriter(TextWriter) Initializes a new instance of the IniWriter class. Properties CommentChar Gets or sets the default comment character. NewLineBehavior Gets or sets the behavior for writing new lines inside properties values. Writer Gets the underlying text writer. Methods Dispose() Releases all resources used by the IniWriter object. Write(IniDocument) Writes an INI document to the INI file. Write(IniSection) Writes an INI section to the INI file. Write(in KeyValuePair<string, string[]>) Writes a key-value pair to the INI file, where the value is an array of strings. Write(string, string?) Writes a key-value pair to the INI file. WriteComment(string) Writes a comment to the INI file."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWritingNewLineBehavior.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWritingNewLineBehavior.html",
    "title": "Enum IniWritingNewLineBehavior | Sisk",
    "keywords": "Enum IniWritingNewLineBehavior Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Specifies the behavior for writing new lines in an INI file. [Flags] public enum IniWritingNewLineBehavior Fields Escape = 4 Escapes the new line characters when writing new lines. Quote = 1 Quotes the value when writing new lines. Split = 2 Splits the value into multiple lines when writing new lines."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.html",
    "title": "Namespace Sisk.IniConfiguration.Core.Serialization | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration.Core.Serialization Classes IniReader Provides an INI-document reader and parser. IniWriter Represents a writer for INI files. Enums IniWritingNewLineBehavior Specifies the behavior for writing new lines in an INI file."
  },
  "api/Sisk.IniConfiguration.Core.html": {
    "href": "api/Sisk.IniConfiguration.Core.html",
    "title": "Namespace Sisk.IniConfiguration.Core | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration.Core Namespaces Sisk.IniConfiguration.Core.Serialization Classes IniDocument Represents an INI document. IniSection Represents an INI section, which contains it's own properties. IniSectionCollection Represents an collection of IniSection."
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.-ctor.html",
    "title": "Constructor IniConfigurationReader | Sisk",
    "keywords": "Constructor IniConfigurationReader Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll IniConfigurationReader() public IniConfigurationReader()"
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.ReadConfiguration.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.ReadConfiguration.html",
    "title": "Method ReadConfiguration | Sisk",
    "keywords": "Method ReadConfiguration Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file. public void ReadConfiguration(ConfigurationContext context) Parameters context ConfigurationContext The configuration context object."
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.html",
    "title": "Class IniConfigurationReader | Sisk",
    "keywords": "Class IniConfigurationReader Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Provides an INI-Document based configuration-reader pipeline. public sealed class IniConfigurationReader : IConfigurationReader Inheritance object IniConfigurationReader Implements IConfigurationReader Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniConfigurationReader() Methods ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file."
  },
  "api/Sisk.IniConfiguration.html": {
    "href": "api/Sisk.IniConfiguration.html",
    "title": "Namespace Sisk.IniConfiguration | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration Namespaces Sisk.IniConfiguration.Core Classes IniConfigurationReader Provides an INI-Document based configuration-reader pipeline."
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.-ctor.html",
    "title": "Constructor MethodDescriptionAttribute | Sisk",
    "keywords": "Constructor MethodDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll MethodDescriptionAttribute(string) Initializes a new instance of the MethodDescriptionAttribute class with the specified description. public MethodDescriptionAttribute(string description) Parameters description string The description of the method."
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Category.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Category.html",
    "title": "Property Category | Sisk",
    "keywords": "Property Category Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Category Optional. Gets or sets the web method category. public string? Category { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Description.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Description Gets the description of the method. public string Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.html",
    "title": "Class MethodDescriptionAttribute | Sisk",
    "keywords": "Class MethodDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Specifies a description for a method. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public sealed class MethodDescriptionAttribute : Attribute Inheritance object Attribute MethodDescriptionAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors MethodDescriptionAttribute(string) Initializes a new instance of the MethodDescriptionAttribute class with the specified description. Properties Category Optional. Gets or sets the web method category. Description Gets the description of the method."
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.-ctor.html",
    "title": "Constructor ParamDescriptionAttribute | Sisk",
    "keywords": "Constructor ParamDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll ParamDescriptionAttribute(string, string) Initializes a new instance of the ParamDescriptionAttribute class with the specified description. public ParamDescriptionAttribute(string paramName, string description) Parameters paramName string The parameter name. description string The description of the method parameter."
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.Description.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Description Gets the description of the method parameter. public string Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.ParameterName.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.ParameterName.html",
    "title": "Property ParameterName | Sisk",
    "keywords": "Property ParameterName Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll ParameterName Gets the target parameter name. public string ParameterName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.html",
    "title": "Class ParamDescriptionAttribute | Sisk",
    "keywords": "Class ParamDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Specifies a description for a method parameter. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ParamDescriptionAttribute : Attribute Inheritance object Attribute ParamDescriptionAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ParamDescriptionAttribute(string, string) Initializes a new instance of the ParamDescriptionAttribute class with the specified description. Properties Description Gets the description of the method parameter. ParameterName Gets the target parameter name."
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.-ctor.html",
    "title": "Constructor WebMethodAttribute | Sisk",
    "keywords": "Constructor WebMethodAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll WebMethodAttribute() Creates an new WebMethodAttribute with no parameters. public WebMethodAttribute() WebMethodAttribute(string) Creates an new WebMethodAttribute with given parameters. public WebMethodAttribute(string methodName) Parameters methodName string The method name."
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.Name.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Name Gets or sets the method name. public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.html",
    "title": "Class WebMethodAttribute | Sisk",
    "keywords": "Class WebMethodAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Represents an JSON-RPC method. [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public sealed class WebMethodAttribute : Attribute Inheritance object Attribute WebMethodAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors WebMethodAttribute() Creates an new WebMethodAttribute with no parameters. WebMethodAttribute(string) Creates an new WebMethodAttribute with given parameters. Properties Name Gets or sets the method name."
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.-ctor.html",
    "title": "Constructor WebNameAttribute | Sisk",
    "keywords": "Constructor WebNameAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll WebNameAttribute(string) Creates an new instance of the WebMethodAttribute attribute. public WebNameAttribute(string name) Parameters name string The method-group name."
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.Name.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Name Gets or sets the name associated with the method group. public string Name { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.html",
    "title": "Class WebNameAttribute | Sisk",
    "keywords": "Class WebNameAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Represents an attribute which holds the class name for a group of JSON-RPC methods. [AttributeUsage(AttributeTargets.Class)] public sealed class WebNameAttribute : Attribute Inheritance object Attribute WebNameAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors WebNameAttribute(string) Creates an new instance of the WebMethodAttribute attribute. Properties Name Gets or sets the name associated with the method group."
  },
  "api/Sisk.JsonRPC.Annotations.html": {
    "href": "api/Sisk.JsonRPC.Annotations.html",
    "title": "Namespace Sisk.JsonRPC.Annotations | Sisk",
    "keywords": "Namespace Sisk.JsonRPC.Annotations Classes MethodDescriptionAttribute Specifies a description for a method. ParamDescriptionAttribute Specifies a description for a method parameter. WebMethodAttribute Represents an JSON-RPC method. WebNameAttribute Represents an attribute which holds the class name for a group of JSON-RPC methods."
  },
  "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array. byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation The JSON-RPC documentation to export. Returns byte[] A byte array containing the exported documentation."
  },
  "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.html": {
    "href": "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.html",
    "title": "Interface IJsonRpcDocumentationExporter | Sisk",
    "keywords": "Interface IJsonRpcDocumentationExporter Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Defines a method to export JSON-RPC documentation to a byte array. public interface IJsonRpcDocumentationExporter Methods ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Export.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Export.html",
    "title": "Method Export | Sisk",
    "keywords": "Method Export Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Export(IJsonRpcDocumentationExporter) Exports this JsonRpcDocumentation with the specified IJsonRpcDocumentationExporter. public byte[] Export(IJsonRpcDocumentationExporter exporter) Parameters exporter IJsonRpcDocumentationExporter The IJsonRpcDocumentationExporter instance. Returns byte[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.ExportToJson.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.ExportToJson.html",
    "title": "Method ExportToJson | Sisk",
    "keywords": "Method ExportToJson Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportToJson(JsonOptions) Gets an JSON string representation of this JsonRpcDocumentation. public string ExportToJson(JsonOptions options) Parameters options JsonOptions The LightJson.JsonOptions used to encode this documentation. Returns string ExportToJson() Gets an JSON string representation of this JsonRpcDocumentation. public string ExportToJson() Returns string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Metadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Metadata.html",
    "title": "Property Metadata | Sisk",
    "keywords": "Property Metadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Metadata Gets the used JsonRpcDocumentationMetadata for this JsonRpcDocumentation. public JsonRpcDocumentationMetadata? Metadata { get; } Property Value JsonRpcDocumentationMetadata"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Methods.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Methods.html",
    "title": "Property Methods | Sisk",
    "keywords": "Property Methods Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Methods Gets the collection of JSON-RPC methods. public JsonRpcDocumentationMethod[] Methods { get; } Property Value JsonRpcDocumentationMethod[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.html",
    "title": "Class JsonRpcDocumentation | Sisk",
    "keywords": "Class JsonRpcDocumentation Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Represents the documentation for JSON-RPC methods. public sealed class JsonRpcDocumentation Inheritance object JsonRpcDocumentation Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Metadata Gets the used JsonRpcDocumentationMetadata for this JsonRpcDocumentation. Methods Gets the collection of JSON-RPC methods. Methods Export(IJsonRpcDocumentationExporter) Exports this JsonRpcDocumentation with the specified IJsonRpcDocumentationExporter. ExportToJson() Gets an JSON string representation of this JsonRpcDocumentation. ExportToJson(JsonOptions) Gets an JSON string representation of this JsonRpcDocumentation."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.-ctor.html",
    "title": "Constructor JsonRpcDocumentationMetadata | Sisk",
    "keywords": "Constructor JsonRpcDocumentationMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcDocumentationMetadata() public JsonRpcDocumentationMetadata()"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.AllowedMethods.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.AllowedMethods.html",
    "title": "Property AllowedMethods | Sisk",
    "keywords": "Property AllowedMethods Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll AllowedMethods Gets or sets an array of HttpMethod that are allowed for the JSON-RPC service at ServicePath. public string[] AllowedMethods { get; set; } Property Value string[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationDescription.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationDescription.html",
    "title": "Property ApplicationDescription | Sisk",
    "keywords": "Property ApplicationDescription Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ApplicationDescription Gets or sets the description of the application. public string? ApplicationDescription { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationName.html",
    "title": "Property ApplicationName | Sisk",
    "keywords": "Property ApplicationName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ApplicationName Gets or sets the name of the application. public string? ApplicationName { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ServicePath.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ServicePath.html",
    "title": "Property ServicePath | Sisk",
    "keywords": "Property ServicePath Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ServicePath Gets or sets the path where the JSON-RPC service can receive remote procedures. public string? ServicePath { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.html",
    "title": "Class JsonRpcDocumentationMetadata | Sisk",
    "keywords": "Class JsonRpcDocumentationMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Represents the documentation metadata for JSON-RPC documentation. public sealed class JsonRpcDocumentationMetadata Inheritance object JsonRpcDocumentationMetadata Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcDocumentationMetadata() Properties AllowedMethods Gets or sets an array of HttpMethod that are allowed for the JSON-RPC service at ServicePath. ApplicationDescription Gets or sets the description of the application. ApplicationName Gets or sets the name of the application. ServicePath Gets or sets the path where the JSON-RPC service can receive remote procedures."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Category.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Category.html",
    "title": "Property Category | Sisk",
    "keywords": "Property Category Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Category Gets the category of the JSON-RPC method. public string? Category { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Description.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Description Gets the description of the JSON-RPC method. public string? Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.MethodName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.MethodName.html",
    "title": "Property MethodName | Sisk",
    "keywords": "Property MethodName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll MethodName Gets the name of the JSON-RPC method. public string MethodName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Parameters.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Parameters Gets the parameters of this JSON-RPC method. public JsonRpcDocumentationParameter[] Parameters { get; } Property Value JsonRpcDocumentationParameter[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.ReturnType.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.ReturnType.html",
    "title": "Property ReturnType | Sisk",
    "keywords": "Property ReturnType Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ReturnType Gets the return type of the JSON-RPC method. public Type ReturnType { get; } Property Value Type"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.html",
    "title": "Class JsonRpcDocumentationMethod | Sisk",
    "keywords": "Class JsonRpcDocumentationMethod Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Represents the documentation for a single JSON-RPC method. public sealed class JsonRpcDocumentationMethod Inheritance object JsonRpcDocumentationMethod Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Category Gets the category of the JSON-RPC method. Description Gets the description of the JSON-RPC method. MethodName Gets the name of the JSON-RPC method. Parameters Gets the parameters of this JSON-RPC method. ReturnType Gets the return type of the JSON-RPC method."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.Description.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Description Gets the description of the parameter. public string? Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.IsOptional.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.IsOptional.html",
    "title": "Property IsOptional | Sisk",
    "keywords": "Property IsOptional Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll IsOptional Gets a value indicating whether the parameter is optional. public bool IsOptional { get; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterName.html",
    "title": "Property ParameterName | Sisk",
    "keywords": "Property ParameterName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ParameterName Gets the name of the parameter. public string ParameterName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterType.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterType.html",
    "title": "Property ParameterType | Sisk",
    "keywords": "Property ParameterType Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ParameterType Gets the type of the parameter. public Type ParameterType { get; } Property Value Type"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.html",
    "title": "Class JsonRpcDocumentationParameter | Sisk",
    "keywords": "Class JsonRpcDocumentationParameter Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Represents the documentation for a parameter of a JSON-RPC method. public sealed class JsonRpcDocumentationParameter Inheritance object JsonRpcDocumentationParameter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description Gets the description of the parameter. IsOptional Gets a value indicating whether the parameter is optional. ParameterName Gets the name of the parameter. ParameterType Gets the type of the parameter."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.-ctor.html",
    "title": "Constructor JsonRpcHtmlExport | Sisk",
    "keywords": "Constructor JsonRpcHtmlExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcHtmlExport() public JsonRpcHtmlExport()"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.EncodeDocumentationHtml.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.EncodeDocumentationHtml.html",
    "title": "Method EncodeDocumentationHtml | Sisk",
    "keywords": "Method EncodeDocumentationHtml Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll EncodeDocumentationHtml(JsonRpcDocumentation) Encodes the specified JsonRpcDocumentation into a HTML string. protected string EncodeDocumentationHtml(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation The JsonRpcDocumentation instance. Returns string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array. public byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation The JSON-RPC documentation to export. Returns byte[] A byte array containing the exported documentation."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportMetadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportMetadata.html",
    "title": "Property ExportMetadata | Sisk",
    "keywords": "Property ExportMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportMetadata Gets or sets an boolean indicating if the documentation metadata should be exported in the HTML. public bool ExportMetadata { get; set; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportSummary.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportSummary.html",
    "title": "Property ExportSummary | Sisk",
    "keywords": "Property ExportSummary Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportSummary Gets or sets an boolean indicating if an summary should be exported in the HTML. public bool ExportSummary { get; set; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Header.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Header.html",
    "title": "Property Header | Sisk",
    "keywords": "Property Header Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Header Gets or sets an optional object to append to the header of the exported HTML. public object? Header { get; set; } Property Value object"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Style.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Style.html",
    "title": "Property Style | Sisk",
    "keywords": "Property Style Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Style Gets or sets the CSS styles used in the HTML export. public string? Style { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.html",
    "title": "Class JsonRpcHtmlExport | Sisk",
    "keywords": "Class JsonRpcHtmlExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Provides an HTML-based IJsonRpcDocumentationExporter. public class JsonRpcHtmlExport : IJsonRpcDocumentationExporter Inheritance object JsonRpcHtmlExport Implements IJsonRpcDocumentationExporter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcHtmlExport() Properties ExportMetadata Gets or sets an boolean indicating if the documentation metadata should be exported in the HTML. ExportSummary Gets or sets an boolean indicating if an summary should be exported in the HTML. Header Gets or sets an optional object to append to the header of the exported HTML. Style Gets or sets the CSS styles used in the HTML export. Methods EncodeDocumentationHtml(JsonRpcDocumentation) Encodes the specified JsonRpcDocumentation into a HTML string. ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.-ctor.html",
    "title": "Constructor JsonRpcJsonExport | Sisk",
    "keywords": "Constructor JsonRpcJsonExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcJsonExport() Creates an new JsonRpcJsonExport instance with default parameters. public JsonRpcJsonExport() JsonRpcJsonExport(JsonOptions) Creates an new JsonRpcJsonExport instance with the provided LightJson.JsonOptions instance. public JsonRpcJsonExport(JsonOptions options) Parameters options JsonOptions"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.EncodeDocumentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.EncodeDocumentation.html",
    "title": "Method EncodeDocumentation | Sisk",
    "keywords": "Method EncodeDocumentation Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll EncodeDocumentation(JsonRpcDocumentation) Encodes the specified documentation into an LightJson.JsonValue. public JsonValue EncodeDocumentation(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation The JSON-RPC documentation to encode. Returns JsonValue"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array. public byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation The JSON-RPC documentation to export. Returns byte[] A byte array containing the exported documentation."
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.JsonOptions.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.JsonOptions.html",
    "title": "Property JsonOptions | Sisk",
    "keywords": "Property JsonOptions Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonOptions The JsonOptions instance used to encode the documentation. public JsonOptions JsonOptions { get; set; } Property Value JsonOptions"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.html",
    "title": "Class JsonRpcJsonExport | Sisk",
    "keywords": "Class JsonRpcJsonExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Provides an JSON-based IJsonRpcDocumentationExporter. public sealed class JsonRpcJsonExport : IJsonRpcDocumentationExporter Inheritance object JsonRpcJsonExport Implements IJsonRpcDocumentationExporter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcJsonExport() Creates an new JsonRpcJsonExport instance with default parameters. JsonRpcJsonExport(JsonOptions) Creates an new JsonRpcJsonExport instance with the provided LightJson.JsonOptions instance. Properties JsonOptions The JsonOptions instance used to encode the documentation. Methods EncodeDocumentation(JsonRpcDocumentation) Encodes the specified documentation into an LightJson.JsonValue. ExportDocumentBytes(JsonRpcDocumentation) Exports the JSON-RPC documentation to a byte array."
  },
  "api/Sisk.JsonRPC.Documentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.html",
    "title": "Namespace Sisk.JsonRPC.Documentation | Sisk",
    "keywords": "Namespace Sisk.JsonRPC.Documentation Classes JsonRpcDocumentation Represents the documentation for JSON-RPC methods. JsonRpcDocumentationMetadata Represents the documentation metadata for JSON-RPC documentation. JsonRpcDocumentationMethod Represents the documentation for a single JSON-RPC method. JsonRpcDocumentationParameter Represents the documentation for a parameter of a JSON-RPC method. JsonRpcHtmlExport Provides an HTML-based IJsonRpcDocumentationExporter. JsonRpcJsonExport Provides an JSON-based IJsonRpcDocumentationExporter. Interfaces IJsonRpcDocumentationExporter Defines a method to export JSON-RPC documentation to a byte array."
  },
  "api/Sisk.JsonRPC.JsonRpcError.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.-ctor.html",
    "title": "Constructor JsonRpcError | Sisk",
    "keywords": "Constructor JsonRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcError() Creates an new instance of the JsonRpcError structure. public JsonRpcError() JsonRpcError(int, string) Creates an new instance of the JsonRpcError structure with given parameters. public JsonRpcError(int code, string message) Parameters code int The JSON-RPC error code. message string The JSON-RPC error message. JsonRpcError(int, string, JsonValue) Creates an new instance of the JsonRpcError structure with given parameters. public JsonRpcError(int code, string message, JsonValue data) Parameters code int The JSON-RPC error code. message string The JSON-RPC error message. data JsonValue The JSON-RPC error additional data."
  },
  "api/Sisk.JsonRPC.JsonRpcError.Code.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Code.html",
    "title": "Property Code | Sisk",
    "keywords": "Property Code Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Code Gets the JSON-RPC error code. public int Code { get; } Property Value int"
  },
  "api/Sisk.JsonRPC.JsonRpcError.Data.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Data.html",
    "title": "Property Data | Sisk",
    "keywords": "Property Data Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Data Gets the JSON-RPC error additional data. public JsonValue Data { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcError.Message.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Message.html",
    "title": "Property Message | Sisk",
    "keywords": "Property Message Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Message Gets the JSON-RPC error message. public string Message { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcError.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.html",
    "title": "Struct JsonRpcError | Sisk",
    "keywords": "Struct JsonRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents an JSON-RPC error. public readonly struct JsonRpcError Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors JsonRpcError() Creates an new instance of the JsonRpcError structure. JsonRpcError(int, string) Creates an new instance of the JsonRpcError structure with given parameters. JsonRpcError(int, string, JsonValue) Creates an new instance of the JsonRpcError structure with given parameters. Properties Code Gets the JSON-RPC error code. Data Gets the JSON-RPC error additional data. Message Gets the JSON-RPC error message."
  },
  "api/Sisk.JsonRPC.JsonRpcException.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.-ctor.html",
    "title": "Constructor JsonRpcException | Sisk",
    "keywords": "Constructor JsonRpcException Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcException(string) Initializes a new instance of the JsonRpcException class with a specified error message. public JsonRpcException(string message) Parameters message string The error message that explains the reason for the exception. JsonRpcException(string, int, object?) Initializes a new instance of the JsonRpcException class with a specified error message, error code, and additional data. public JsonRpcException(string message, int code, object? data) Parameters message string The error message that explains the reason for the exception. code int The error code associated with the JSON-RPC error. data object Additional data associated with the error."
  },
  "api/Sisk.JsonRPC.JsonRpcException.AsRpcError.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.AsRpcError.html",
    "title": "Method AsRpcError | Sisk",
    "keywords": "Method AsRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AsRpcError() Converts the current JsonRpcException into a JsonRpcError. public JsonRpcError AsRpcError() Returns JsonRpcError A JsonRpcError representing the error details."
  },
  "api/Sisk.JsonRPC.JsonRpcException.Code.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.Code.html",
    "title": "Property Code | Sisk",
    "keywords": "Property Code Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Code Gets the error code associated with the JSON-RPC error. public int Code { get; } Property Value int"
  },
  "api/Sisk.JsonRPC.JsonRpcException.Data.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.Data.html",
    "title": "Property Data | Sisk",
    "keywords": "Property Data Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Data Gets additional data associated with the error, if any. public object? Data { get; } Property Value object"
  },
  "api/Sisk.JsonRPC.JsonRpcException.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.html",
    "title": "Class JsonRpcException | Sisk",
    "keywords": "Class JsonRpcException Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents an error that occur during the JSON-RPC application execution. public class JsonRpcException : Exception, ISerializable Inheritance object Exception JsonRpcException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcException(string) Initializes a new instance of the JsonRpcException class with a specified error message. JsonRpcException(string, int, object?) Initializes a new instance of the JsonRpcException class with a specified error message, error code, and additional data. Properties Code Gets the error code associated with the JSON-RPC error. Data Gets additional data associated with the error, if any. Methods AsRpcError() Converts the current JsonRpcException into a JsonRpcError."
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.-ctor.html",
    "title": "Constructor JsonRpcHandler | Sisk",
    "keywords": "Constructor JsonRpcHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcHandler(HttpServer) Initializes a new instance of the JsonRpcHandler class. public JsonRpcHandler(HttpServer parentServer) Parameters parentServer HttpServer Defines the HttpServer where the JSON-RPC instance will run on."
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.GetDocumentation.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.GetDocumentation.html",
    "title": "Method GetDocumentation | Sisk",
    "keywords": "Method GetDocumentation Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll GetDocumentation() Gets the documentation for this JSON-RPC handler. public JsonRpcDocumentation GetDocumentation() Returns JsonRpcDocumentation GetDocumentation(JsonRpcDocumentationMetadata) Gets the documentation for this JSON-RPC handler. public JsonRpcDocumentation GetDocumentation(JsonRpcDocumentationMetadata metadata) Parameters metadata JsonRpcDocumentationMetadata The JsonRpcDocumentationMetadata to generate in the documentation. Returns JsonRpcDocumentation"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.JsonSerializerOptions.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.JsonSerializerOptions.html",
    "title": "Property JsonSerializerOptions | Sisk",
    "keywords": "Property JsonSerializerOptions Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonSerializerOptions Gets the JSON serializer options used for serialization and deserialization. public JsonOptions JsonSerializerOptions { get; } Property Value JsonOptions"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.Methods.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.Methods.html",
    "title": "Property Methods | Sisk",
    "keywords": "Property Methods Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Methods Gets the collection of JSON-RPC methods available in this handler. public JsonRpcMethodCollection Methods { get; } Property Value JsonRpcMethodCollection"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.Transport.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.Transport.html",
    "title": "Property Transport | Sisk",
    "keywords": "Property Transport Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Transport Gets the transport layer used for communication. public JsonRpcTransportLayer Transport { get; } Property Value JsonRpcTransportLayer"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.html",
    "title": "Class JsonRpcHandler | Sisk",
    "keywords": "Class JsonRpcHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents a handler for JSON-RPC requests. public sealed class JsonRpcHandler Inheritance object JsonRpcHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcHandler(HttpServer) Initializes a new instance of the JsonRpcHandler class. Properties JsonSerializerOptions Gets the JSON serializer options used for serialization and deserialization. Methods Gets the collection of JSON-RPC methods available in this handler. Transport Gets the transport layer used for communication. Methods GetDocumentation() Gets the documentation for this JSON-RPC handler. GetDocumentation(JsonRpcDocumentationMetadata) Gets the documentation for this JSON-RPC handler."
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.-ctor.html",
    "title": "Constructor JsonRpcMethodCollection | Sisk",
    "keywords": "Constructor JsonRpcMethodCollection Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcMethodCollection() public JsonRpcMethodCollection()"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethod.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethod.html",
    "title": "Method AddMethod | Sisk",
    "keywords": "Method AddMethod Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AddMethod(string, Delegate) Adds a method to the collection with the specified name. public void AddMethod(string name, Delegate method) Parameters name string The name of the method to add. method Delegate The delegate representing the method to add."
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethodsFromType.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethodsFromType.html",
    "title": "Method AddMethodsFromType | Sisk",
    "keywords": "Method AddMethodsFromType Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AddMethodsFromType<T>(T, bool) Adds methods from the specified type to the collection, optionally prefixing method names with the type name. public void AddMethodsFromType<T>(T target, bool prefixTypes = false) where T : notnull Parameters target T The target object instance containing the methods. prefixTypes bool Indicates whether to prefix method names with the type name. Type Parameters T The type from which to scan and add methods. AddMethodsFromType(Type, object?, bool) Adds methods from the specified type to the collection, optionally prefixing method names with the type name. public void AddMethodsFromType(Type type, object? target, bool prefixTypes) Parameters type Type The type from which to scan and add methods. target object The target object instance containing the methods. prefixTypes bool Indicates whether to prefix method names with the type name. AddMethodsFromType(Type, object?) Adds methods from the specified type to the collection without prefixing method names. public void AddMethodsFromType(Type type, object? target) Parameters type Type The type from which to scan and add methods. target object The target object instance containing the methods. AddMethodsFromType(Type) Adds methods from the specified type to the collection without prefixing method names. public void AddMethodsFromType(Type type) Parameters type Type The type from which to scan and add methods."
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.RemoveMethod.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.RemoveMethod.html",
    "title": "Method RemoveMethod | Sisk",
    "keywords": "Method RemoveMethod Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll RemoveMethod(string) Removes a method from the collection by its name. public void RemoveMethod(string name) Parameters name string The name of the method to remove."
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.html",
    "title": "Class JsonRpcMethodCollection | Sisk",
    "keywords": "Class JsonRpcMethodCollection Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents a collection of JSON-RPC methods, allowing for dynamic addition and removal of methods. public sealed class JsonRpcMethodCollection Inheritance object JsonRpcMethodCollection Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcMethodCollection() Methods AddMethod(string, Delegate) Adds a method to the collection with the specified name. AddMethodsFromType(Type) Adds methods from the specified type to the collection without prefixing method names. AddMethodsFromType(Type, object?) Adds methods from the specified type to the collection without prefixing method names. AddMethodsFromType(Type, object?, bool) Adds methods from the specified type to the collection, optionally prefixing method names with the type name. AddMethodsFromType<T>(T, bool) Adds methods from the specified type to the collection, optionally prefixing method names with the type name. RemoveMethod(string) Removes a method from the collection by its name."
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Id.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Id.html",
    "title": "Property Id | Sisk",
    "keywords": "Property Id Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Id Gets the ID of the JSON-RPC message. public JsonValue Id { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Method.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Method Gets the method name of the JSON-RPC message. public string Method { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Parameters.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Parameters Gets the LightJson.JsonValue containing the message parameter values. public JsonValue Parameters { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Version.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Version.html",
    "title": "Property Version | Sisk",
    "keywords": "Property Version Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Version Gets the version used in the JSON-RPC message. public string Version { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.html",
    "title": "Class JsonRpcRequest | Sisk",
    "keywords": "Class JsonRpcRequest Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents an JSON-RPC request message. public sealed class JsonRpcRequest Inheritance object JsonRpcRequest Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Id Gets the ID of the JSON-RPC message. Method Gets the method name of the JSON-RPC message. Parameters Gets the LightJson.JsonValue containing the message parameter values. Version Gets the version used in the JSON-RPC message."
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.CreateErrorResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.CreateErrorResponse.html",
    "title": "Method CreateErrorResponse | Sisk",
    "keywords": "Method CreateErrorResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll CreateErrorResponse(JsonValue, JsonRpcError) Creates an new error JsonRpcResponse with given parameters. public static JsonRpcResponse CreateErrorResponse(JsonValue id, JsonRpcError error) Parameters id JsonValue The JSON-RPC response id. error JsonRpcError The JSON-RPC response error. Returns JsonRpcResponse"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.CreateSuccessResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.CreateSuccessResponse.html",
    "title": "Method CreateSuccessResponse | Sisk",
    "keywords": "Method CreateSuccessResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll CreateSuccessResponse(JsonValue, JsonValue) Creates an new success JsonRpcResponse with given parameters. public static JsonRpcResponse CreateSuccessResponse(JsonValue id, JsonValue result) Parameters id JsonValue The JSON-RPC response id. result JsonValue The JSON-RPC response object. Returns JsonRpcResponse"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Error.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Error.html",
    "title": "Property Error | Sisk",
    "keywords": "Property Error Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Error Gets the JSON-RPC response error. public JsonRpcError? Error { get; } Property Value JsonRpcError?"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Id.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Id.html",
    "title": "Property Id | Sisk",
    "keywords": "Property Id Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Id Gets the JSON-RPC response id. public JsonValue Id { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Result.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Result.html",
    "title": "Property Result | Sisk",
    "keywords": "Property Result Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Result Gets the JSON-RPC response result. public JsonValue? Result { get; } Property Value JsonValue?"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Version.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Version.html",
    "title": "Property Version | Sisk",
    "keywords": "Property Version Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Version Gets the JSON-RPC response version. This property will always return \"2.0\". public string Version { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.html",
    "title": "Class JsonRpcResponse | Sisk",
    "keywords": "Class JsonRpcResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents an JSON-RPC response message. public sealed class JsonRpcResponse Inheritance object JsonRpcResponse Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Error Gets the JSON-RPC response error. Id Gets the JSON-RPC response id. Result Gets the JSON-RPC response result. Version Gets the JSON-RPC response version. This property will always return \"2.0\". Methods CreateErrorResponse(JsonValue, JsonRpcError) Creates an new error JsonRpcResponse with given parameters. CreateSuccessResponse(JsonValue, JsonValue) Creates an new success JsonRpcResponse with given parameters."
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Handler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Handler.html",
    "title": "Property Handler | Sisk",
    "keywords": "Property Handler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Handler Gets the configuring JsonRpcHandler. public JsonRpcHandler Handler { get; } Property Value JsonRpcHandler"
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Router.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Router Gets the target Router which are being configured. public Router Router { get; } Property Value Router"
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.html",
    "title": "Class JsonRpcServerConfigurationEventArgs | Sisk",
    "keywords": "Class JsonRpcServerConfigurationEventArgs Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Represents the class which contains event data for the JSON-RPC configuration event. public sealed class JsonRpcServerConfigurationEventArgs : EventArgs Inheritance object EventArgs JsonRpcServerConfigurationEventArgs Inherited Members EventArgs.Empty object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Handler Gets the configuring JsonRpcHandler. Router Gets the target Router which are being configured."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.-ctor.html",
    "title": "Constructor JsonRpcServerHandler | Sisk",
    "keywords": "Constructor JsonRpcServerHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcServerHandler() Creates an new instance of the JsonRpcServerHandler class. public JsonRpcServerHandler()"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.ConfigureAction.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.ConfigureAction.html",
    "title": "Event ConfigureAction | Sisk",
    "keywords": "Event ConfigureAction Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Gets or sets the action which will be called in the configuring Router with this handler. public event EventHandler<JsonRpcServerConfigurationEventArgs>? ConfigureAction Returns EventHandler<JsonRpcServerConfigurationEventArgs> Gets or sets the action which will be called in the configuring with this handler."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected override void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected override void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.html",
    "title": "Class JsonRpcServerHandler | Sisk",
    "keywords": "Class JsonRpcServerHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Provides an HttpServerHandler for configuring the JSON-RPC handler for the HTTP server. public sealed class JsonRpcServerHandler : HttpServerHandler Inheritance object HttpServerHandler JsonRpcServerHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcServerHandler() Creates an new instance of the JsonRpcServerHandler class. Methods OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. Events ConfigureAction Gets or sets the action which will be called in the configuring Router with this handler."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.UseJsonRPC.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.UseJsonRPC.html",
    "title": "Method UseJsonRPC | Sisk",
    "keywords": "Method UseJsonRPC Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll UseJsonRPC(HttpServerHostContextBuilder, EventHandler<JsonRpcServerConfigurationEventArgs>) Enables JSON-RPC in this HTTP server. public static HttpServerHostContextBuilder UseJsonRPC(this HttpServerHostContextBuilder builder, EventHandler<JsonRpcServerConfigurationEventArgs> configure) Parameters builder HttpServerHostContextBuilder The self HttpServerHostContextBuilder for fluent chaining. configure EventHandler<JsonRpcServerConfigurationEventArgs> The event handler callback that is called to configure routes and web methods for the JSON-RPC. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.html",
    "title": "Class JsonRpcServerHandlerExtensions | Sisk",
    "keywords": "Class JsonRpcServerHandlerExtensions Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Provides extensions methods for the HTTP server and JSON-RPC handler. public static class JsonRpcServerHandlerExtensions Inheritance object JsonRpcServerHandlerExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods UseJsonRPC(HttpServerHostContextBuilder, EventHandler<JsonRpcServerConfigurationEventArgs>) Enables JSON-RPC in this HTTP server."
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpGet.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpGet.html",
    "title": "Property HttpGet | Sisk",
    "keywords": "Property HttpGet Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll HttpGet Gets the action to handle HTTP GET requests. public RouteAction HttpGet { get; } Property Value RouteAction"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpPost.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpPost.html",
    "title": "Property HttpPost | Sisk",
    "keywords": "Property HttpPost Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll HttpPost Gets the action to handle HTTP POST requests. public RouteAction HttpPost { get; } Property Value RouteAction"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.WebSocket.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.WebSocket.html",
    "title": "Property WebSocket | Sisk",
    "keywords": "Property WebSocket Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll WebSocket Gets the event handler for WebSocket message reception. public EventHandler<WebSocketMessage> WebSocket { get; } Property Value EventHandler<WebSocketMessage>"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.html",
    "title": "Class JsonRpcTransportLayer | Sisk",
    "keywords": "Class JsonRpcTransportLayer Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Provides transport layers for handling JSON-RPC communications. public sealed class JsonRpcTransportLayer Inheritance object JsonRpcTransportLayer Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpGet Gets the action to handle HTTP GET requests. HttpPost Gets the action to handle HTTP POST requests. WebSocket Gets the event handler for WebSocket message reception."
  },
  "api/Sisk.JsonRPC.html": {
    "href": "api/Sisk.JsonRPC.html",
    "title": "Namespace Sisk.JsonRPC | Sisk",
    "keywords": "Namespace Sisk.JsonRPC Namespaces Sisk.JsonRPC.Annotations Sisk.JsonRPC.Documentation Classes JsonRpcException Represents an error that occur during the JSON-RPC application execution. JsonRpcHandler Represents a handler for JSON-RPC requests. JsonRpcMethodCollection Represents a collection of JSON-RPC methods, allowing for dynamic addition and removal of methods. JsonRpcRequest Represents an JSON-RPC request message. JsonRpcResponse Represents an JSON-RPC response message. JsonRpcServerConfigurationEventArgs Represents the class which contains event data for the JSON-RPC configuration event. JsonRpcServerHandler Provides an HttpServerHandler for configuring the JSON-RPC handler for the HTTP server. JsonRpcServerHandlerExtensions Provides extensions methods for the HTTP server and JSON-RPC handler. JsonRpcTransportLayer Provides transport layers for handling JSON-RPC communications. Structs JsonRpcError Represents an JSON-RPC error."
  },
  "api/Sisk.Ssl.CertificateUtil.CreateDevelopmentCertificate.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.CreateDevelopmentCertificate.html",
    "title": "Method CreateDevelopmentCertificate | Sisk",
    "keywords": "Method CreateDevelopmentCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CreateDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names. public static X509Certificate2 CreateDevelopmentCertificate(params string[] dnsNames) Parameters dnsNames string[] The certificate DNS names. Returns X509Certificate2"
  },
  "api/Sisk.Ssl.CertificateUtil.CreateTrustedDevelopmentCertificate.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.CreateTrustedDevelopmentCertificate.html",
    "title": "Method CreateTrustedDevelopmentCertificate | Sisk",
    "keywords": "Method CreateTrustedDevelopmentCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CreateTrustedDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names and adds them to the local user's certificate store. public static X509Certificate2 CreateTrustedDevelopmentCertificate(params string[] dnsNames) Parameters dnsNames string[] The certificate DNS names. Returns X509Certificate2"
  },
  "api/Sisk.Ssl.CertificateUtil.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.html",
    "title": "Class CertificateUtil | Sisk",
    "keywords": "Class CertificateUtil Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides a set of useful functions to issue development certificates for the SslProxy. public static class CertificateUtil Inheritance object CertificateUtil Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods CreateDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names. CreateTrustedDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names and adds them to the local user's certificate store."
  },
  "api/Sisk.Ssl.SslProxy.-ctor.html": {
    "href": "api/Sisk.Ssl.SslProxy.-ctor.html",
    "title": "Constructor SslProxy | Sisk",
    "keywords": "Constructor SslProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SslProxy(int, X509Certificate, IPEndPoint) Initializes a new instance of the SslProxy class. public SslProxy(int sslListeningPort, X509Certificate certificate, IPEndPoint remoteEndpoint) Parameters sslListeningPort int The port number on which the proxy server listens for incoming connections. certificate X509Certificate The SSL/TLS certificate used by the proxy server. remoteEndpoint IPEndPoint The remote endpoint to which the proxy server forwards traffic."
  },
  "api/Sisk.Ssl.SslProxy.AllowedProtocols.html": {
    "href": "api/Sisk.Ssl.SslProxy.AllowedProtocols.html",
    "title": "Property AllowedProtocols | Sisk",
    "keywords": "Property AllowedProtocols Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. public SslProtocols AllowedProtocols { get; set; } Property Value SslProtocols"
  },
  "api/Sisk.Ssl.SslProxy.CheckCertificateRevocation.html": {
    "href": "api/Sisk.Ssl.SslProxy.CheckCertificateRevocation.html",
    "title": "Property CheckCertificateRevocation | Sisk",
    "keywords": "Property CheckCertificateRevocation Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. public bool CheckCertificateRevocation { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.ClientCertificateRequired.html": {
    "href": "api/Sisk.Ssl.SslProxy.ClientCertificateRequired.html",
    "title": "Property ClientCertificateRequired | Sisk",
    "keywords": "Property ClientCertificateRequired Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. public bool ClientCertificateRequired { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.Dispose.html": {
    "href": "api/Sisk.Ssl.SslProxy.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Ssl.SslProxy.GatewayEndpoint.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayEndpoint.html",
    "title": "Property GatewayEndpoint | Sisk",
    "keywords": "Property GatewayEndpoint Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayEndpoint Gets the proxy endpoint. public IPEndPoint GatewayEndpoint { get; } Property Value IPEndPoint"
  },
  "api/Sisk.Ssl.SslProxy.GatewayHostname.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayHostname.html",
    "title": "Property GatewayHostname | Sisk",
    "keywords": "Property GatewayHostname Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayHostname Gets or sets an fixed proxy host header value for incoming requests. public string? GatewayHostname { get; set; } Property Value string"
  },
  "api/Sisk.Ssl.SslProxy.GatewayTimeout.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayTimeout.html",
    "title": "Property GatewayTimeout | Sisk",
    "keywords": "Property GatewayTimeout Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayTimeout Gets or sets the maximum time that the gateway should take to respond to a connection or message from the proxy. public TimeSpan GatewayTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Ssl.SslProxy.ProxyAuthorization.html": {
    "href": "api/Sisk.Ssl.SslProxy.ProxyAuthorization.html",
    "title": "Property ProxyAuthorization | Sisk",
    "keywords": "Property ProxyAuthorization Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ProxyAuthorization Gets or sets the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. public string? ProxyAuthorization { get; set; } Property Value string"
  },
  "api/Sisk.Ssl.SslProxy.ServerCertificate.html": {
    "href": "api/Sisk.Ssl.SslProxy.ServerCertificate.html",
    "title": "Property ServerCertificate | Sisk",
    "keywords": "Property ServerCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ServerCertificate Gets the SSL certificate used by the proxy server. public X509Certificate ServerCertificate { get; } Property Value X509Certificate"
  },
  "api/Sisk.Ssl.SslProxy.Start.html": {
    "href": "api/Sisk.Ssl.SslProxy.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Start() Starts the SslProxy and start routing traffic to the set remote endpoint. public void Start()"
  },
  "api/Sisk.Ssl.SslProxy.UseGatewayHttps.html": {
    "href": "api/Sisk.Ssl.SslProxy.UseGatewayHttps.html",
    "title": "Property UseGatewayHttps | Sisk",
    "keywords": "Property UseGatewayHttps Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll UseGatewayHttps Gets or sets whether the SslProxy should use HTTPS for the gateway connection or plain HTTP. public bool UseGatewayHttps { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.html": {
    "href": "api/Sisk.Ssl.SslProxy.html",
    "title": "Class SslProxy | Sisk",
    "keywords": "Class SslProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Represents a HTTP/1.1 proxy server that forwards traffic over SSL/HTTPS into an insecure HTTP gateway. public sealed class SslProxy : IDisposable Inheritance object SslProxy Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SslProxy(int, X509Certificate, IPEndPoint) Initializes a new instance of the SslProxy class. Properties AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. GatewayEndpoint Gets the proxy endpoint. GatewayHostname Gets or sets an fixed proxy host header value for incoming requests. GatewayTimeout Gets or sets the maximum time that the gateway should take to respond to a connection or message from the proxy. ProxyAuthorization Gets or sets the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. ServerCertificate Gets the SSL certificate used by the proxy server. UseGatewayHttps Gets or sets whether the SslProxy should use HTTPS for the gateway connection or plain HTTP. Methods Dispose() Start() Starts the SslProxy and start routing traffic to the set remote endpoint."
  },
  "api/Sisk.Ssl.SslProxyExtensions.UseSsl.html": {
    "href": "api/Sisk.Ssl.SslProxyExtensions.UseSsl.html",
    "title": "Method UseSsl | Sisk",
    "keywords": "Method UseSsl Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll UseSsl(HttpServerHostContextBuilder, short, X509Certificate?, SslProtocols, bool, object?, bool) Configures the HttpServerHostContext to use SslProxy with the specified parameters. public static HttpServerHostContextBuilder UseSsl(this HttpServerHostContextBuilder builder, short sslListeningPort, X509Certificate? certificate = null, SslProtocols allowedProtocols = SslProtocols.Tls12 | SslProtocols.Tls13, bool clientCertificateRequired = false, object? proxyAuthorization = null, bool onlyUseIPv4 = false) Parameters builder HttpServerHostContextBuilder The HttpServerHostContextBuilder instance to configure. sslListeningPort short The port number on which the server will listen for SSL/HTTPS connections. certificate X509Certificate Optional. The SSL/HTTPS certificate to use for encrypting communications. allowedProtocols SslProtocols Optional. The SSL/HTTPS protocols allowed for the connection. Defaults to Tls12 and Tls13. clientCertificateRequired bool Optional. Specifies whether a client certificate is required for authentication. Defaults to false. proxyAuthorization object Optional. Specifies the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. onlyUseIPv4 bool Optional. Specifies whether DNS Resolve may also use IPv6 addresses or should only use IPv4 addresses Returns HttpServerHostContextBuilder The configured HttpServerHostContextBuilder instance."
  },
  "api/Sisk.Ssl.SslProxyExtensions.html": {
    "href": "api/Sisk.Ssl.SslProxyExtensions.html",
    "title": "Class SslProxyExtensions | Sisk",
    "keywords": "Class SslProxyExtensions Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides extension methods for SslProxy. public static class SslProxyExtensions Inheritance object SslProxyExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods UseSsl(HttpServerHostContextBuilder, short, X509Certificate?, SslProtocols, bool, object?, bool) Configures the HttpServerHostContext to use SslProxy with the specified parameters."
  },
  "api/Sisk.Ssl.SslProxyServerHandler.-ctor.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.-ctor.html",
    "title": "Constructor SslProxyServerHandler | Sisk",
    "keywords": "Constructor SslProxyServerHandler Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SslProxyServerHandler(SslProxy) Creates an new SslProxyServerHandler instance with the specified SslProxy instance. public SslProxyServerHandler(SslProxy secureProxy) Parameters secureProxy SslProxy The SslProxy instance."
  },
  "api/Sisk.Ssl.SslProxyServerHandler.SecureProxy.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.SecureProxy.html",
    "title": "Property SecureProxy | Sisk",
    "keywords": "Property SecureProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SecureProxy Gets the SslProxy instance used in this server handler. public SslProxy SecureProxy { get; } Property Value SslProxy"
  },
  "api/Sisk.Ssl.SslProxyServerHandler.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.html",
    "title": "Class SslProxyServerHandler | Sisk",
    "keywords": "Class SslProxyServerHandler Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides event handlers and hooks for SslProxy. public sealed class SslProxyServerHandler : HttpServerHandler Inheritance object HttpServerHandler SslProxyServerHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SslProxyServerHandler(SslProxy) Creates an new SslProxyServerHandler instance with the specified SslProxy instance. Properties SecureProxy Gets the SslProxy instance used in this server handler."
  },
  "api/Sisk.Ssl.html": {
    "href": "api/Sisk.Ssl.html",
    "title": "Namespace Sisk.Ssl | Sisk",
    "keywords": "Namespace Sisk.Ssl Classes CertificateUtil Provides a set of useful functions to issue development certificates for the SslProxy. SslProxy Represents a HTTP/1.1 proxy server that forwards traffic over SSL/HTTPS into an insecure HTTP gateway. SslProxyExtensions Provides extension methods for SslProxy. SslProxyServerHandler Provides event handlers and hooks for SslProxy."
  },
  "api/Sisk.html": {
    "href": "api/Sisk.html",
    "title": "Namespace Sisk | Sisk",
    "keywords": "Namespace Sisk Namespaces Sisk.BasicAuth Sisk.Cadente Sisk.Core Sisk.Documenting Sisk.IniConfiguration Sisk.JsonRPC Sisk.Ssl"
  },
  "api/TinyComponents.HtmlElement.-ctor.html": {
    "href": "api/TinyComponents.HtmlElement.-ctor.html",
    "title": "Constructor HtmlElement | Sisk",
    "keywords": "Constructor HtmlElement Namespace TinyComponents Assembly TinyComponents.dll HtmlElement() Initializes a new instance of the HtmlElement class with no container HTML element. public HtmlElement() HtmlElement(string) Initializes a new instance of the HtmlElement class with the specified tag name. public HtmlElement(string tagName) Parameters tagName string The name of the tag to be used for the HTML element. The tag name will be converted to lowercase. HtmlElement(string, object?) Initializes a new instance of the HtmlElement class with the specified tag name and content. public HtmlElement(string tagName, object? content) Parameters tagName string The name of the tag to be used for the HTML element. The tag name will be converted to lowercase. content object Optional parameter that defines content for the creating HTML tag. HtmlElement(string, string?) Initializes a new instance of the HtmlElement class with the specified tag name and content. public HtmlElement(string tagName, string? content) Parameters tagName string The name of the tag to be used for the HTML element. The tag name will be converted to lowercase. content string Optional parameter that defines content for the creating HTML tag. HtmlElement(string, Action<HtmlElement>) Initializes a new instance of the HtmlElement class with the specified tag name. public HtmlElement(string tagName, Action<HtmlElement> content) Parameters tagName string The name of the tag to be used for the HTML element. The tag name will be converted to lowercase. content Action<HtmlElement> Optional parameter that defines content for the creating HTML tag."
  },
  "api/TinyComponents.HtmlElement.Attributes.html": {
    "href": "api/TinyComponents.HtmlElement.Attributes.html",
    "title": "Property Attributes | Sisk",
    "keywords": "Property Attributes Namespace TinyComponents Assembly TinyComponents.dll Attributes Gets or sets the collection of HTML attributes for the element. public NodeAttributeCollection Attributes { get; set; } Property Value NodeAttributeCollection"
  },
  "api/TinyComponents.HtmlElement.Children.html": {
    "href": "api/TinyComponents.HtmlElement.Children.html",
    "title": "Property Children | Sisk",
    "keywords": "Property Children Namespace TinyComponents Assembly TinyComponents.dll Children Gets or sets the collection of child elements within this element. public ICollection<object?> Children { get; set; } Property Value ICollection<object>"
  },
  "api/TinyComponents.HtmlElement.ClassList.html": {
    "href": "api/TinyComponents.HtmlElement.ClassList.html",
    "title": "Property ClassList | Sisk",
    "keywords": "Property ClassList Namespace TinyComponents Assembly TinyComponents.dll ClassList Gets or sets the list of CSS classes for the HTML element. Initializes with an empty list. Use this to apply CSS class names to the element. public ICollection<string> ClassList { get; set; } Property Value ICollection<string>"
  },
  "api/TinyComponents.HtmlElement.Create.html": {
    "href": "api/TinyComponents.HtmlElement.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace TinyComponents Assembly TinyComponents.dll Create(string) Creates an HtmlElement from the specified emmet template. public static HtmlElement Create(string emmetString) Parameters emmetString string Returns HtmlElement Create(string, object?, object?, object?[]?, bool) Creates an HtmlElement from the specified emmet template and adds the specified style, attributes, and children. public static HtmlElement Create(string emmetString, object? style = null, object? attributes = null, object?[]? children = null, bool selfClosing = false) Parameters emmetString string The emmet template string. style object An object containing style properties to apply to the element. Can be null. attributes object An object containing attribute names and values to apply to the element. Can be null. children object[] An array of objects to put as children of the creating element. Can be null. selfClosing bool An boolean indicating if the creating element should be self-closed or not. Returns HtmlElement A new HtmlElement based on the emmet template with the specified style, attributes, and children. Create(string, Action<HtmlElement>) Creates an HtmlElement from the specified emmet template and configures it using the specified action. public static HtmlElement Create(string emmetString, Action<HtmlElement> self) Parameters emmetString string The emmet template string. self Action<HtmlElement> An action to configure the created HtmlElement. Returns HtmlElement A new HtmlElement based on the emmet template and configured using the specified action."
  },
  "api/TinyComponents.HtmlElement.Format.html": {
    "href": "api/TinyComponents.HtmlElement.Format.html",
    "title": "Method Format | Sisk",
    "keywords": "Method Format Namespace TinyComponents Assembly TinyComponents.dll Format(FormattableString) Formats the specified HTML string format, escaping the string interpolation pieces. public static string Format(FormattableString htmlString) Parameters htmlString FormattableString The instance of FormattableString. Returns string"
  },
  "api/TinyComponents.HtmlElement.Fragment.html": {
    "href": "api/TinyComponents.HtmlElement.Fragment.html",
    "title": "Method Fragment | Sisk",
    "keywords": "Method Fragment Namespace TinyComponents Assembly TinyComponents.dll Fragment(params object?[]) Creates an fragment HtmlElement with specified children. public static HtmlElement Fragment(params object?[] children) Parameters children object[] An array of objects to put as children of the creating fragment. Returns HtmlElement Fragment(Action<HtmlElement>) Creates an fragment HtmlElement with specified self-action. public static HtmlElement Fragment(Action<HtmlElement> action) Parameters action Action<HtmlElement> An action that defines content for the creating HTML element. Returns HtmlElement"
  },
  "api/TinyComponents.HtmlElement.GetAttributes.html": {
    "href": "api/TinyComponents.HtmlElement.GetAttributes.html",
    "title": "Method GetAttributes | Sisk",
    "keywords": "Method GetAttributes Namespace TinyComponents Assembly TinyComponents.dll GetAttributes() Represents the protected method which gets the attributes to be rendered. protected virtual IDictionary<string, object?> GetAttributes() Returns IDictionary<string, object>"
  },
  "api/TinyComponents.HtmlElement.Id.html": {
    "href": "api/TinyComponents.HtmlElement.Id.html",
    "title": "Property Id | Sisk",
    "keywords": "Property Id Namespace TinyComponents Assembly TinyComponents.dll Id Gets or sets the ID attribute of the HTML element. Used to uniquely identify the element within the page. public string? Id { get; set; } Property Value string"
  },
  "api/TinyComponents.HtmlElement.Name.html": {
    "href": "api/TinyComponents.HtmlElement.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace TinyComponents Assembly TinyComponents.dll Name Gets or sets the name attribute of the HTML element. The name is used to reference elements in JavaScript, or to reference form data after a form is submitted. public string? Name { get; set; } Property Value string"
  },
  "api/TinyComponents.HtmlElement.SelfClosing.html": {
    "href": "api/TinyComponents.HtmlElement.SelfClosing.html",
    "title": "Property SelfClosing | Sisk",
    "keywords": "Property SelfClosing Namespace TinyComponents Assembly TinyComponents.dll SelfClosing Gets or sets a value indicating whether the element is self-closing. public bool SelfClosing { get; set; } Property Value bool"
  },
  "api/TinyComponents.HtmlElement.Style.html": {
    "href": "api/TinyComponents.HtmlElement.Style.html",
    "title": "Property Style | Sisk",
    "keywords": "Property Style Namespace TinyComponents Assembly TinyComponents.dll Style Gets or sets the CSS style object used to render the style attribute. public object? Style { get; set; } Property Value object"
  },
  "api/TinyComponents.HtmlElement.TabIndex.html": {
    "href": "api/TinyComponents.HtmlElement.TabIndex.html",
    "title": "Property TabIndex | Sisk",
    "keywords": "Property TabIndex Namespace TinyComponents Assembly TinyComponents.dll TabIndex Gets or sets the tab index of the HTML element. public int? TabIndex { get; set; } Property Value int?"
  },
  "api/TinyComponents.HtmlElement.TagName.html": {
    "href": "api/TinyComponents.HtmlElement.TagName.html",
    "title": "Property TagName | Sisk",
    "keywords": "Property TagName Namespace TinyComponents Assembly TinyComponents.dll TagName Gets or sets the tag name of the HTML element (e.g., \"div\", \"span\"). public string TagName { get; set; } Property Value string"
  },
  "api/TinyComponents.HtmlElement.ToString.html": {
    "href": "api/TinyComponents.HtmlElement.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Renders the HTML element into a string with optional pretty formatting. public override string ToString() Returns string The rendered HTML string."
  },
  "api/TinyComponents.HtmlElement.TooltipTitle.html": {
    "href": "api/TinyComponents.HtmlElement.TooltipTitle.html",
    "title": "Property TooltipTitle | Sisk",
    "keywords": "Property TooltipTitle Namespace TinyComponents Assembly TinyComponents.dll TooltipTitle Gets or sets the tooltip text to display for the HTML element. public string? TooltipTitle { get; set; } Property Value string"
  },
  "api/TinyComponents.HtmlElement.html": {
    "href": "api/TinyComponents.HtmlElement.html",
    "title": "Class HtmlElement | Sisk",
    "keywords": "Class HtmlElement Namespace TinyComponents Assembly TinyComponents.dll Represents an HTML element for rendering public class HtmlElement : INode Inheritance object HtmlElement Implements INode Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods HtmlElementExtensions.WithClass<THtmlElement>(THtmlElement, params string[]) HtmlElementExtensions.WithId<THtmlElement>(THtmlElement, string) HtmlElementExtensions.WithName<THtmlElement>(THtmlElement, string) HtmlElementExtensions.WithStyle<THtmlElement>(THtmlElement, object) XmlNodeExtensions.SelfClosed<TXmlNode>(TXmlNode) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string, object?) XmlNodeExtensions.WithAttributes<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, Action<TXmlNode>) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, string?) Constructors HtmlElement() Initializes a new instance of the HtmlElement class with no container HTML element. HtmlElement(string) Initializes a new instance of the HtmlElement class with the specified tag name. HtmlElement(string, Action<HtmlElement>) Initializes a new instance of the HtmlElement class with the specified tag name. HtmlElement(string, object?) Initializes a new instance of the HtmlElement class with the specified tag name and content. HtmlElement(string, string?) Initializes a new instance of the HtmlElement class with the specified tag name and content. Properties Attributes Gets or sets the collection of HTML attributes for the element. Children Gets or sets the collection of child elements within this element. ClassList Gets or sets the list of CSS classes for the HTML element. Initializes with an empty list. Use this to apply CSS class names to the element. Id Gets or sets the ID attribute of the HTML element. Used to uniquely identify the element within the page. Name Gets or sets the name attribute of the HTML element. The name is used to reference elements in JavaScript, or to reference form data after a form is submitted. SelfClosing Gets or sets a value indicating whether the element is self-closing. Style Gets or sets the CSS style object used to render the style attribute. TabIndex Gets or sets the tab index of the HTML element. TagName Gets or sets the tag name of the HTML element (e.g., \"div\", \"span\"). TooltipTitle Gets or sets the tooltip text to display for the HTML element. Methods Create(string) Creates an HtmlElement from the specified emmet template. Create(string, Action<HtmlElement>) Creates an HtmlElement from the specified emmet template and configures it using the specified action. Create(string, object?, object?, object?[]?, bool) Creates an HtmlElement from the specified emmet template and adds the specified style, attributes, and children. Format(FormattableString) Formats the specified HTML string format, escaping the string interpolation pieces. Fragment(Action<HtmlElement>) Creates an fragment HtmlElement with specified self-action. Fragment(params object?[]) Creates an fragment HtmlElement with specified children. GetAttributes() Represents the protected method which gets the attributes to be rendered. ToString() Renders the HTML element into a string with optional pretty formatting. Operators operator +(HtmlElement, object?)"
  },
  "api/TinyComponents.HtmlElement.op_Addition.html": {
    "href": "api/TinyComponents.HtmlElement.op_Addition.html",
    "title": "Operator operator + | Sisk",
    "keywords": "Operator operator + Namespace TinyComponents Assembly TinyComponents.dll operator +(HtmlElement, object?) public static HtmlElement operator +(HtmlElement a, object? b) Parameters a HtmlElement b object Returns HtmlElement"
  },
  "api/TinyComponents.HtmlElementExtensions.WithClass.html": {
    "href": "api/TinyComponents.HtmlElementExtensions.WithClass.html",
    "title": "Method WithClass | Sisk",
    "keywords": "Method WithClass Namespace TinyComponents Assembly TinyComponents.dll WithClass<THtmlElement>(THtmlElement, params string[]) Specifies the HTML element class list of this HtmlElement. public static THtmlElement WithClass<THtmlElement>(this THtmlElement node, params string[] classNames) where THtmlElement : HtmlElement Parameters node THtmlElement The current HtmlElement. classNames string[] One or more classes to add to this HtmlElement. Returns THtmlElement The self HtmlElement object for fluent chaining. Type Parameters THtmlElement The object type which implements HtmlElement."
  },
  "api/TinyComponents.HtmlElementExtensions.WithId.html": {
    "href": "api/TinyComponents.HtmlElementExtensions.WithId.html",
    "title": "Method WithId | Sisk",
    "keywords": "Method WithId Namespace TinyComponents Assembly TinyComponents.dll WithId<THtmlElement>(THtmlElement, string) Specifies the HTML element ID of this HtmlElement. public static THtmlElement WithId<THtmlElement>(this THtmlElement node, string id) where THtmlElement : HtmlElement Parameters node THtmlElement The current HtmlElement. id string The element ID. Returns THtmlElement The self HtmlElement object for fluent chaining. Type Parameters THtmlElement The object type which implements HtmlElement."
  },
  "api/TinyComponents.HtmlElementExtensions.WithName.html": {
    "href": "api/TinyComponents.HtmlElementExtensions.WithName.html",
    "title": "Method WithName | Sisk",
    "keywords": "Method WithName Namespace TinyComponents Assembly TinyComponents.dll WithName<THtmlElement>(THtmlElement, string) Specifies the HTML element name of this HtmlElement. public static THtmlElement WithName<THtmlElement>(this THtmlElement node, string name) where THtmlElement : HtmlElement Parameters node THtmlElement The current HtmlElement. name string The element name. Returns THtmlElement The self HtmlElement object for fluent chaining. Type Parameters THtmlElement The object type which implements HtmlElement."
  },
  "api/TinyComponents.HtmlElementExtensions.WithStyle.html": {
    "href": "api/TinyComponents.HtmlElementExtensions.WithStyle.html",
    "title": "Method WithStyle | Sisk",
    "keywords": "Method WithStyle Namespace TinyComponents Assembly TinyComponents.dll WithStyle<THtmlElement>(THtmlElement, object) Adds css styles through the style attribute on this HtmlElement. public static THtmlElement WithStyle<THtmlElement>(this THtmlElement node, object styleObject) where THtmlElement : HtmlElement Parameters node THtmlElement The current HtmlElement. styleObject object The object which contains CSS properties and values to style the component. Returns THtmlElement The self HtmlElement object for fluent chaining. Type Parameters THtmlElement The object type which implements HtmlElement."
  },
  "api/TinyComponents.HtmlElementExtensions.html": {
    "href": "api/TinyComponents.HtmlElementExtensions.html",
    "title": "Class HtmlElementExtensions | Sisk",
    "keywords": "Class HtmlElementExtensions Namespace TinyComponents Assembly TinyComponents.dll Provides extension methods for HtmlElement objects. public static class HtmlElementExtensions Inheritance object HtmlElementExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WithClass<THtmlElement>(THtmlElement, params string[]) Specifies the HTML element class list of this HtmlElement. WithId<THtmlElement>(THtmlElement, string) Specifies the HTML element ID of this HtmlElement. WithName<THtmlElement>(THtmlElement, string) Specifies the HTML element name of this HtmlElement. WithStyle<THtmlElement>(THtmlElement, object) Adds css styles through the style attribute on this HtmlElement."
  },
  "api/TinyComponents.INode.Attributes.html": {
    "href": "api/TinyComponents.INode.Attributes.html",
    "title": "Property Attributes | Sisk",
    "keywords": "Property Attributes Namespace TinyComponents Assembly TinyComponents.dll Attributes Gets or sets an collection of attributes for this node. NodeAttributeCollection Attributes { get; set; } Property Value NodeAttributeCollection"
  },
  "api/TinyComponents.INode.Children.html": {
    "href": "api/TinyComponents.INode.Children.html",
    "title": "Property Children | Sisk",
    "keywords": "Property Children Namespace TinyComponents Assembly TinyComponents.dll Children Gets or sets the collection of child elements (object) within this node. ICollection<object?> Children { get; set; } Property Value ICollection<object>"
  },
  "api/TinyComponents.INode.SelfClosing.html": {
    "href": "api/TinyComponents.INode.SelfClosing.html",
    "title": "Property SelfClosing | Sisk",
    "keywords": "Property SelfClosing Namespace TinyComponents Assembly TinyComponents.dll SelfClosing Gets or sets a value indicating whether this XML node is self-closing. bool SelfClosing { get; set; } Property Value bool"
  },
  "api/TinyComponents.INode.TagName.html": {
    "href": "api/TinyComponents.INode.TagName.html",
    "title": "Property TagName | Sisk",
    "keywords": "Property TagName Namespace TinyComponents Assembly TinyComponents.dll TagName Gets or sets the tag name of the XML node. string TagName { get; set; } Property Value string"
  },
  "api/TinyComponents.INode.html": {
    "href": "api/TinyComponents.INode.html",
    "title": "Interface INode | Sisk",
    "keywords": "Interface INode Namespace TinyComponents Assembly TinyComponents.dll Represents an renderable node. public interface INode Extension Methods XmlNodeExtensions.SelfClosed<TXmlNode>(TXmlNode) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string, object?) XmlNodeExtensions.WithAttributes<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, Action<TXmlNode>) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, string?) Properties Attributes Gets or sets an collection of attributes for this node. Children Gets or sets the collection of child elements (object) within this node. SelfClosing Gets or sets a value indicating whether this XML node is self-closing. TagName Gets or sets the tag name of the XML node."
  },
  "api/TinyComponents.MarkdownText.-ctor.html": {
    "href": "api/TinyComponents.MarkdownText.-ctor.html",
    "title": "Constructor MarkdownText | Sisk",
    "keywords": "Constructor MarkdownText Namespace TinyComponents Assembly TinyComponents.dll MarkdownText() Initializes a new instance of the MarkdownText class with default settings and an empty text. public MarkdownText() MarkdownText(string) Initializes a new instance of the MarkdownText class with the specified Markdown text and default settings. public MarkdownText(string markdownText) Parameters markdownText string The Markdown text to be converted."
  },
  "api/TinyComponents.MarkdownText.MarkdownSettings.html": {
    "href": "api/TinyComponents.MarkdownText.MarkdownSettings.html",
    "title": "Property MarkdownSettings | Sisk",
    "keywords": "Property MarkdownSettings Namespace TinyComponents Assembly TinyComponents.dll MarkdownSettings Gets or sets the Markdown settings used for conversion. public CommonMarkSettings MarkdownSettings { get; set; } Property Value CommonMarkSettings See Also CommonMarkSettings"
  },
  "api/TinyComponents.MarkdownText.Text.html": {
    "href": "api/TinyComponents.MarkdownText.Text.html",
    "title": "Property Text | Sisk",
    "keywords": "Property Text Namespace TinyComponents Assembly TinyComponents.dll Text Gets or sets the Markdown text to be converted. public string Text { get; set; } Property Value string"
  },
  "api/TinyComponents.MarkdownText.ToString.html": {
    "href": "api/TinyComponents.MarkdownText.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Converts the Markdown text to HTML using the specified settings. public override string ToString() Returns string The converted HTML text. See Also CommonMark.CommonMarkConverter.Convert(System.String,CommonMark.CommonMarkSettings)"
  },
  "api/TinyComponents.MarkdownText.html": {
    "href": "api/TinyComponents.MarkdownText.html",
    "title": "Class MarkdownText | Sisk",
    "keywords": "Class MarkdownText Namespace TinyComponents Assembly TinyComponents.dll Represents a Markdown text with settings for rendering. public sealed class MarkdownText Inheritance object MarkdownText Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors MarkdownText() Initializes a new instance of the MarkdownText class with default settings and an empty text. MarkdownText(string) Initializes a new instance of the MarkdownText class with the specified Markdown text and default settings. Properties MarkdownSettings Gets or sets the Markdown settings used for conversion. Text Gets or sets the Markdown text to be converted. Methods ToString() Converts the Markdown text to HTML using the specified settings."
  },
  "api/TinyComponents.NodeAttributeCollection.-ctor.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.-ctor.html",
    "title": "Constructor NodeAttributeCollection | Sisk",
    "keywords": "Constructor NodeAttributeCollection Namespace TinyComponents Assembly TinyComponents.dll NodeAttributeCollection() Creates an new instance of the NodeAttributeCollection. public NodeAttributeCollection()"
  },
  "api/TinyComponents.NodeAttributeCollection.Add.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace TinyComponents Assembly TinyComponents.dll Add(string, object?) public void Add(string key, object? value) Parameters key string value object Add(KeyValuePair<string, object?>) public void Add(KeyValuePair<string, object?> item) Parameters item KeyValuePair<string, object>"
  },
  "api/TinyComponents.NodeAttributeCollection.Clear.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace TinyComponents Assembly TinyComponents.dll Clear() public void Clear()"
  },
  "api/TinyComponents.NodeAttributeCollection.Contains.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace TinyComponents Assembly TinyComponents.dll Contains(KeyValuePair<string, object?>) public bool Contains(KeyValuePair<string, object?> item) Parameters item KeyValuePair<string, object> Returns bool"
  },
  "api/TinyComponents.NodeAttributeCollection.ContainsKey.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace TinyComponents Assembly TinyComponents.dll ContainsKey(string) public bool ContainsKey(string key) Parameters key string Returns bool"
  },
  "api/TinyComponents.NodeAttributeCollection.CopyTo.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace TinyComponents Assembly TinyComponents.dll CopyTo(KeyValuePair<string, object?>[], int) public void CopyTo(KeyValuePair<string, object?>[] array, int arrayIndex) Parameters array KeyValuePair<string, object>[] arrayIndex int"
  },
  "api/TinyComponents.NodeAttributeCollection.Count.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace TinyComponents Assembly TinyComponents.dll Count public int Count { get; } Property Value int"
  },
  "api/TinyComponents.NodeAttributeCollection.GetEnumerator.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace TinyComponents Assembly TinyComponents.dll GetEnumerator() public IEnumerator<KeyValuePair<string, object?>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, object>>"
  },
  "api/TinyComponents.NodeAttributeCollection.IsReadOnly.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace TinyComponents Assembly TinyComponents.dll IsReadOnly public bool IsReadOnly { get; } Property Value bool"
  },
  "api/TinyComponents.NodeAttributeCollection.Item.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace TinyComponents Assembly TinyComponents.dll this[string] public object? this[string key] { get; set; } Parameters key string Property Value object"
  },
  "api/TinyComponents.NodeAttributeCollection.Keys.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace TinyComponents Assembly TinyComponents.dll Keys public ICollection<string> Keys { get; } Property Value ICollection<string>"
  },
  "api/TinyComponents.NodeAttributeCollection.Remove.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace TinyComponents Assembly TinyComponents.dll Remove(string) public bool Remove(string key) Parameters key string Returns bool Remove(KeyValuePair<string, object?>) public bool Remove(KeyValuePair<string, object?> item) Parameters item KeyValuePair<string, object> Returns bool"
  },
  "api/TinyComponents.NodeAttributeCollection.TryGetValue.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace TinyComponents Assembly TinyComponents.dll TryGetValue(string, out object?) public bool TryGetValue(string key, out object? value) Parameters key string value object Returns bool"
  },
  "api/TinyComponents.NodeAttributeCollection.Values.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace TinyComponents Assembly TinyComponents.dll Values public ICollection<object?> Values { get; } Property Value ICollection<object>"
  },
  "api/TinyComponents.NodeAttributeCollection.html": {
    "href": "api/TinyComponents.NodeAttributeCollection.html",
    "title": "Class NodeAttributeCollection | Sisk",
    "keywords": "Class NodeAttributeCollection Namespace TinyComponents Assembly TinyComponents.dll Represents an dictionary collection of attributes. public class NodeAttributeCollection : IDictionary<string, object?>, ICollection<KeyValuePair<string, object?>>, IEnumerable<KeyValuePair<string, object?>>, IEnumerable Inheritance object NodeAttributeCollection Implements IDictionary<string, object> ICollection<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors NodeAttributeCollection() Creates an new instance of the NodeAttributeCollection. Properties Count IsReadOnly this[string] Keys Values Methods Add(KeyValuePair<string, object?>) Add(string, object?) Clear() Contains(KeyValuePair<string, object?>) ContainsKey(string) CopyTo(KeyValuePair<string, object?>[], int) GetEnumerator() Remove(KeyValuePair<string, object?>) Remove(string) TryGetValue(string, out object?)"
  },
  "api/TinyComponents.NodeComment.-ctor.html": {
    "href": "api/TinyComponents.NodeComment.-ctor.html",
    "title": "Constructor NodeComment | Sisk",
    "keywords": "Constructor NodeComment Namespace TinyComponents Assembly TinyComponents.dll NodeComment(string) Initializes a new instance of the NodeComment class with the specified comment. public NodeComment(string comment) Parameters comment string The comment text."
  },
  "api/TinyComponents.NodeComment.Comment.html": {
    "href": "api/TinyComponents.NodeComment.Comment.html",
    "title": "Property Comment | Sisk",
    "keywords": "Property Comment Namespace TinyComponents Assembly TinyComponents.dll Comment Gets or sets the comment text. public string Comment { get; set; } Property Value string"
  },
  "api/TinyComponents.NodeComment.ToString.html": {
    "href": "api/TinyComponents.NodeComment.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Returns a string representation of the comment in the format of an XML comment. public override string ToString() Returns string A string representation of the comment."
  },
  "api/TinyComponents.NodeComment.html": {
    "href": "api/TinyComponents.NodeComment.html",
    "title": "Class NodeComment | Sisk",
    "keywords": "Class NodeComment Namespace TinyComponents Assembly TinyComponents.dll Represents a node comment in a document. public sealed class NodeComment Inheritance object NodeComment Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors NodeComment(string) Initializes a new instance of the NodeComment class with the specified comment. Properties Comment Gets or sets the comment text. Methods ToString() Returns a string representation of the comment in the format of an XML comment."
  },
  "api/TinyComponents.RenderableFunction.-ctor.html": {
    "href": "api/TinyComponents.RenderableFunction.-ctor.html",
    "title": "Constructor RenderableFunction | Sisk",
    "keywords": "Constructor RenderableFunction Namespace TinyComponents Assembly TinyComponents.dll RenderableFunction(Func<object?>) Creates an new RenderableFunction class with the specified function. public RenderableFunction(Func<object?> callable) Parameters callable Func<object> The function which will result the contents to be rendered."
  },
  "api/TinyComponents.RenderableFunction.Callable.html": {
    "href": "api/TinyComponents.RenderableFunction.Callable.html",
    "title": "Property Callable | Sisk",
    "keywords": "Property Callable Namespace TinyComponents Assembly TinyComponents.dll Callable Gets or sets the renderable function. public Func<object?> Callable { get; set; } Property Value Func<object>"
  },
  "api/TinyComponents.RenderableFunction.ToString.html": {
    "href": "api/TinyComponents.RenderableFunction.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Invokes Callable and returns its result as an string. public override string? ToString() Returns string"
  },
  "api/TinyComponents.RenderableFunction.html": {
    "href": "api/TinyComponents.RenderableFunction.html",
    "title": "Class RenderableFunction | Sisk",
    "keywords": "Class RenderableFunction Namespace TinyComponents Assembly TinyComponents.dll Represents an object which their renderable contents is called by an function. public sealed class RenderableFunction Inheritance object RenderableFunction Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RenderableFunction(Func<object?>) Creates an new RenderableFunction class with the specified function. Properties Callable Gets or sets the renderable function. Methods ToString() Invokes Callable and returns its result as an string."
  },
  "api/TinyComponents.RenderableText.-ctor.html": {
    "href": "api/TinyComponents.RenderableText.-ctor.html",
    "title": "Constructor RenderableText | Sisk",
    "keywords": "Constructor RenderableText Namespace TinyComponents Assembly TinyComponents.dll RenderableText(object?) Creates an new instance of RenderableText with the specified text contents from the object, encoding it as an HTML entity. public RenderableText(object? textContents) Parameters textContents object The object which will be encoded. RenderableText(object?, bool) Creates an new instance of RenderableText with the specified text contents from the object. public RenderableText(object? textContents, bool escape) Parameters textContents object The object which will be encoded. escape bool Determines if the text contents should be HTML encoded or not."
  },
  "api/TinyComponents.RenderableText.Contents.html": {
    "href": "api/TinyComponents.RenderableText.Contents.html",
    "title": "Property Contents | Sisk",
    "keywords": "Property Contents Namespace TinyComponents Assembly TinyComponents.dll Contents Gets or sets the contents which this text will render. public object? Contents { get; set; } Property Value object"
  },
  "api/TinyComponents.RenderableText.Escape.html": {
    "href": "api/TinyComponents.RenderableText.Escape.html",
    "title": "Property Escape | Sisk",
    "keywords": "Property Escape Namespace TinyComponents Assembly TinyComponents.dll Escape Gets or sets whether this text should be XML/HTML encoded or not. public bool Escape { get; set; } Property Value bool"
  },
  "api/TinyComponents.RenderableText.Raw.html": {
    "href": "api/TinyComponents.RenderableText.Raw.html",
    "title": "Method Raw | Sisk",
    "keywords": "Method Raw Namespace TinyComponents Assembly TinyComponents.dll Raw(object?) Creates an new instance of RenderableText with the provided raw, unencoded text. public static RenderableText Raw(object? contents) Parameters contents object The object which will be converted to text. Returns RenderableText An RenderableText with the content value."
  },
  "api/TinyComponents.RenderableText.SafeRenderSubject.html": {
    "href": "api/TinyComponents.RenderableText.SafeRenderSubject.html",
    "title": "Method SafeRenderSubject | Sisk",
    "keywords": "Method SafeRenderSubject Namespace TinyComponents Assembly TinyComponents.dll SafeRenderSubject(object?) Renders the specified object into an safe HTML content. public static string SafeRenderSubject(object? obj) Parameters obj object The object to be rendered. Returns string"
  },
  "api/TinyComponents.RenderableText.ToString.html": {
    "href": "api/TinyComponents.RenderableText.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Renders this RenderableText into an string. public override string ToString() Returns string The string representation of this RenderableText."
  },
  "api/TinyComponents.RenderableText.html": {
    "href": "api/TinyComponents.RenderableText.html",
    "title": "Class RenderableText | Sisk",
    "keywords": "Class RenderableText Namespace TinyComponents Assembly TinyComponents.dll Represents an simple renderable text. public sealed class RenderableText Inheritance object RenderableText Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RenderableText(object?) Creates an new instance of RenderableText with the specified text contents from the object, encoding it as an HTML entity. RenderableText(object?, bool) Creates an new instance of RenderableText with the specified text contents from the object. Properties Contents Gets or sets the contents which this text will render. Escape Gets or sets whether this text should be XML/HTML encoded or not. Methods Raw(object?) Creates an new instance of RenderableText with the provided raw, unencoded text. SafeRenderSubject(object?) Renders the specified object into an safe HTML content. ToString() Renders this RenderableText into an string."
  },
  "api/TinyComponents.XmlNode.-ctor.html": {
    "href": "api/TinyComponents.XmlNode.-ctor.html",
    "title": "Constructor XmlNode | Sisk",
    "keywords": "Constructor XmlNode Namespace TinyComponents Assembly TinyComponents.dll XmlNode(string) Initializes a new instance of the XmlNode class with the specified tag name. public XmlNode(string tagName) Parameters tagName string The name of the tag to be used for the XML element. The tag name will be converted to lowercase. XmlNode(string, object?) Initializes a new instance of the XmlNode class with the specified tag name and content. public XmlNode(string tagName, object? content) Parameters tagName string The name of the tag to be used for the XML element. The tag name will be converted to lowercase. content object Optional parameter that defines content for the creating XML tag. XmlNode(string, string) Initializes a new instance of the XmlNode class with the specified tag name and content. public XmlNode(string tagName, string content) Parameters tagName string The name of the tag to be used for the XML element. The tag name will be converted to lowercase. content string Optional parameter that defines content for the creating XML tag. XmlNode(string, Action<XmlNode>) Initializes a new instance of the XmlNode class with the specified tag name. public XmlNode(string tagName, Action<XmlNode> content) Parameters tagName string The name of the tag to be used for the XML element. The tag name will be converted to lowercase. content Action<XmlNode> Optional parameter that defines content for the creating XML tag."
  },
  "api/TinyComponents.XmlNode.Attributes.html": {
    "href": "api/TinyComponents.XmlNode.Attributes.html",
    "title": "Property Attributes | Sisk",
    "keywords": "Property Attributes Namespace TinyComponents Assembly TinyComponents.dll Attributes Gets or sets the collection of attributes for this node. public NodeAttributeCollection Attributes { get; set; } Property Value NodeAttributeCollection"
  },
  "api/TinyComponents.XmlNode.Children.html": {
    "href": "api/TinyComponents.XmlNode.Children.html",
    "title": "Property Children | Sisk",
    "keywords": "Property Children Namespace TinyComponents Assembly TinyComponents.dll Children Gets or sets the collection of child elements within this node. public ICollection<object?> Children { get; set; } Property Value ICollection<object>"
  },
  "api/TinyComponents.XmlNode.SelfClosing.html": {
    "href": "api/TinyComponents.XmlNode.SelfClosing.html",
    "title": "Property SelfClosing | Sisk",
    "keywords": "Property SelfClosing Namespace TinyComponents Assembly TinyComponents.dll SelfClosing Gets or sets a value indicating whether this XML node is self-closing. public bool SelfClosing { get; set; } Property Value bool"
  },
  "api/TinyComponents.XmlNode.TagName.html": {
    "href": "api/TinyComponents.XmlNode.TagName.html",
    "title": "Property TagName | Sisk",
    "keywords": "Property TagName Namespace TinyComponents Assembly TinyComponents.dll TagName Gets or sets the tag name of the XML node. public string TagName { get; set; } Property Value string"
  },
  "api/TinyComponents.XmlNode.ToString.html": {
    "href": "api/TinyComponents.XmlNode.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace TinyComponents Assembly TinyComponents.dll ToString() Renders this XmlNode into it's XML string representation. public override string ToString() Returns string"
  },
  "api/TinyComponents.XmlNode.html": {
    "href": "api/TinyComponents.XmlNode.html",
    "title": "Class XmlNode | Sisk",
    "keywords": "Class XmlNode Namespace TinyComponents Assembly TinyComponents.dll Represents an renderable XML node. public class XmlNode : INode Inheritance object XmlNode Implements INode Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Extension Methods XmlNodeExtensions.SelfClosed<TXmlNode>(TXmlNode) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string) XmlNodeExtensions.WithAttribute<TXmlNode>(TXmlNode, string, object?) XmlNodeExtensions.WithAttributes<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, Action<TXmlNode>) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, object?) XmlNodeExtensions.WithContent<TXmlNode>(TXmlNode, string?) Constructors XmlNode(string) Initializes a new instance of the XmlNode class with the specified tag name. XmlNode(string, Action<XmlNode>) Initializes a new instance of the XmlNode class with the specified tag name. XmlNode(string, object?) Initializes a new instance of the XmlNode class with the specified tag name and content. XmlNode(string, string) Initializes a new instance of the XmlNode class with the specified tag name and content. Properties Attributes Gets or sets the collection of attributes for this node. Children Gets or sets the collection of child elements within this node. SelfClosing Gets or sets a value indicating whether this XML node is self-closing. TagName Gets or sets the tag name of the XML node. Methods ToString() Renders this XmlNode into it's XML string representation. Operators operator +(XmlNode, object?) operator +(XmlNode, string?) operator +(XmlNode, XmlNode?)"
  },
  "api/TinyComponents.XmlNode.op_Addition.html": {
    "href": "api/TinyComponents.XmlNode.op_Addition.html",
    "title": "Operator operator + | Sisk",
    "keywords": "Operator operator + Namespace TinyComponents Assembly TinyComponents.dll operator +(XmlNode, XmlNode?) public static XmlNode operator +(XmlNode a, XmlNode? b) Parameters a XmlNode b XmlNode Returns XmlNode operator +(XmlNode, object?) public static XmlNode operator +(XmlNode a, object? b) Parameters a XmlNode b object Returns XmlNode operator +(XmlNode, string?) public static XmlNode operator +(XmlNode a, string? b) Parameters a XmlNode b string Returns XmlNode"
  },
  "api/TinyComponents.XmlNodeExtensions.SelfClosed.html": {
    "href": "api/TinyComponents.XmlNodeExtensions.SelfClosed.html",
    "title": "Method SelfClosed | Sisk",
    "keywords": "Method SelfClosed Namespace TinyComponents Assembly TinyComponents.dll SelfClosed<TXmlNode>(TXmlNode) Specifies that this INode will be self-closed. public static TXmlNode SelfClosed<TXmlNode>(this TXmlNode node) where TXmlNode : INode Parameters node TXmlNode The current INode. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode."
  },
  "api/TinyComponents.XmlNodeExtensions.WithAttribute.html": {
    "href": "api/TinyComponents.XmlNodeExtensions.WithAttribute.html",
    "title": "Method WithAttribute | Sisk",
    "keywords": "Method WithAttribute Namespace TinyComponents Assembly TinyComponents.dll WithAttribute<TXmlNode>(TXmlNode, string) Specifies an attribute for this INode. public static TXmlNode WithAttribute<TXmlNode>(this TXmlNode node, string value) where TXmlNode : INode Parameters node TXmlNode The current INode. value string The attribute name and value. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode. WithAttribute<TXmlNode>(TXmlNode, string, object?) Specifies an attribute for this INode. public static TXmlNode WithAttribute<TXmlNode>(this TXmlNode node, string name, object? value) where TXmlNode : INode Parameters node TXmlNode The current INode. name string The attribute name. value object The attribute value. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode."
  },
  "api/TinyComponents.XmlNodeExtensions.WithAttributes.html": {
    "href": "api/TinyComponents.XmlNodeExtensions.WithAttributes.html",
    "title": "Method WithAttributes | Sisk",
    "keywords": "Method WithAttributes Namespace TinyComponents Assembly TinyComponents.dll WithAttributes<TXmlNode>(TXmlNode, object?) Specifies multiple attributes for this INode from an object. public static TXmlNode WithAttributes<TXmlNode>(this TXmlNode node, object? attributesObject) where TXmlNode : INode Parameters node TXmlNode The current INode. attributesObject object The object containing attribute names and values. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode."
  },
  "api/TinyComponents.XmlNodeExtensions.WithContent.html": {
    "href": "api/TinyComponents.XmlNodeExtensions.WithContent.html",
    "title": "Method WithContent | Sisk",
    "keywords": "Method WithContent Namespace TinyComponents Assembly TinyComponents.dll WithContent<TXmlNode>(TXmlNode, Action<TXmlNode>) Specifies children contents for this INode. public static TXmlNode WithContent<TXmlNode>(this TXmlNode node, Action<TXmlNode> selector) where TXmlNode : INode Parameters node TXmlNode The current INode. selector Action<TXmlNode> The action which will be executed in the self INode. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode. WithContent<TXmlNode>(TXmlNode, object?) Specifies children contents for this INode. public static TXmlNode WithContent<TXmlNode>(this TXmlNode node, object? contents) where TXmlNode : INode Parameters node TXmlNode The current INode. contents object The children object. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode. WithContent<TXmlNode>(TXmlNode, string?) Specifies children contents for this INode. public static TXmlNode WithContent<TXmlNode>(this TXmlNode node, string? contents) where TXmlNode : INode Parameters node TXmlNode The current INode. contents string The children object. Returns TXmlNode The self INode object for fluent chaining. Type Parameters TXmlNode The object type which implements INode."
  },
  "api/TinyComponents.XmlNodeExtensions.html": {
    "href": "api/TinyComponents.XmlNodeExtensions.html",
    "title": "Class XmlNodeExtensions | Sisk",
    "keywords": "Class XmlNodeExtensions Namespace TinyComponents Assembly TinyComponents.dll Provides extension methods for INode objects. public static class XmlNodeExtensions Inheritance object XmlNodeExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods SelfClosed<TXmlNode>(TXmlNode) Specifies that this INode will be self-closed. WithAttribute<TXmlNode>(TXmlNode, string) Specifies an attribute for this INode. WithAttribute<TXmlNode>(TXmlNode, string, object?) Specifies an attribute for this INode. WithAttributes<TXmlNode>(TXmlNode, object?) Specifies multiple attributes for this INode from an object. WithContent<TXmlNode>(TXmlNode, Action<TXmlNode>) Specifies children contents for this INode. WithContent<TXmlNode>(TXmlNode, object?) Specifies children contents for this INode. WithContent<TXmlNode>(TXmlNode, string?) Specifies children contents for this INode."
  },
  "api/TinyComponents.html": {
    "href": "api/TinyComponents.html",
    "title": "Namespace TinyComponents | Sisk",
    "keywords": "Namespace TinyComponents Classes HtmlElement Represents an HTML element for rendering HtmlElementExtensions Provides extension methods for HtmlElement objects. MarkdownText Represents a Markdown text with settings for rendering. NodeAttributeCollection Represents an dictionary collection of attributes. NodeComment Represents a node comment in a document. RenderableFunction Represents an object which their renderable contents is called by an function. RenderableText Represents an simple renderable text. XmlNode Represents an renderable XML node. XmlNodeExtensions Provides extension methods for INode objects. Interfaces INode Represents an renderable node."
  },
  "docs/advanced/forwarding-resolvers.html": {
    "href": "docs/advanced/forwarding-resolvers.html",
    "title": "Forwarding Resolvers | Sisk",
    "keywords": "Forwarding Resolvers A Forwarding Resolver is a helper that helps decode information that identifies the client through a request, proxy, CDN or load-balancers. When your Sisk service runs through a reverse or forward proxy, the client's IP address, host and protocol may be different from the original request as it is a forwarding from one service to another. This Sisk functionality allows you to control and resolve this information before working with the request. These proxies usually provide useful headers to identify their client. Currently, with the ForwardingResolver class, it is possible to resolve the client IP address, host, and HTTP protocol used. After version 1.0 of Sisk, the server no longer has a standard implementation to decode these headers for security reasons that vary from service to service. For example, the X-Forwarded-For header includes information about the IP addresses that forwarded the request. This header is used by proxies to carry a chain of information to the final service and includes the IP of all proxies used, including the client's real address. The problem is: sometimes it is challenging to identify the client's remote IP and there is no specific rule to identify this header. It is highly recommended to read the documentation for the headers you are about to implement below: Read about the X-Forwarded-For header here. Read about the X-Forwarded-Host header here. Read about the X-Forwarded-Proto header here. The ForwardingResolver class This class has three virtual methods that allow the most appropriate implementation for each service. Each method is responsible for resolving information from the request through a proxy: the client's IP address, the host of the request and the security protocol used. By default, Sisk will always use the information from the original request, without resolving any headers. The example below shows how this implementation can be used. This example resolves the client's IP through the X-Forwarded-For header and throws an error when more than one IP was forwarded in the request. Important Do not use this example in production code. Always check if the implementation is appropriate for use. Read the header documentation before implementing it. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"The X-Forwarded-For header is missing.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Too many addresses in the X-Forwarded-For header.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/advanced/http-server-handlers.html": {
    "href": "docs/advanced/http-server-handlers.html",
    "title": "Http server handlers | Sisk",
    "keywords": "Http server handlers In Sisk version 0.16, we've introduced the HttpServerHandler class, which aims to extend the overral Sisk behavior and provide additional event handlers to Sisk, such as handling Http requests, routers, context bags and more. The class concentrates events that occur during the lifetime of the entire HTTP server and also of a request. The Http protocol does not have sessions, and therefore it is not possible to preserve information from one request to another. Sisk for now provides a way for you to implement sessions, contexts, database connections and other useful providers to help your work. Please refer to this page to read where each event is triggered and what its purpose is. You can also view the lifecycle of an HTTP request to understand what happens with a request and where events are fired. The HTTP server allows you to use multiple handlers at the same time. Each event call is synchronous, that is, it will blocked the current thread for each request or context until all handlers associated with that function are executed and completed. Unlike RequestHandlers, they cannot be applied to some route groups or specific routes. Instead, they are applied to the entire HTTP server. You can apply conditions within your Http Server Handler. Furthermore, singletons of each HttpServerHandler are defined for every Sisk application, so only one instance per HttpServerHandler is defined. A practical example of using HttpServerHandler is to automatically dispose a database connection at the end of the request. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // checks if the request has defined an DbContext // in it's context bag if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // allows the user to create an dbcontext from an http request // and store it in its request bag public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } With the code above, the GetDbContext extension allows a connection context to be created directly from the HttpRequest object. An undisposed connection can cause problems when running with the database, so it is terminated in OnHttpRequestClose. You can register a handler on an Http server in your builder or directly with HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } With this, the UsersController class can make use of the database context as: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } The code above uses methods like JsonOk and JsonMessage that are built into ApiController, which is inherited from a RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Developers can implement sessions, contexts, and database connections using this class. The provided code showcases a practical example with the DatabaseConnectionHandler, automating database connection disposal at the end of each request. Integration is straightforward, with handlers registered during server setup. The HttpServerHandler class offers a powerful toolset for managing resources and extending Sisk behavior in HTTP applications."
  },
  "docs/advanced/manual-setup.html": {
    "href": "docs/advanced/manual-setup.html",
    "title": "Manual (advanced) setup | Sisk",
    "keywords": "Manual (advanced) setup In this section, we will create our HTTP server without any predefined standards, in a completely abstract way. Here, you can manually build how your HTTP server will function. Each ListeningHost has a router, and an HTTP server can have multiple ListeningHosts, each pointing to a different host on a different port. First, we need to understand the request/response concept. It is quite simple: for every request, there must be a response. Sisk follows this principle as well. Let's create a method that responds with a \"Hello, World!\" message in HTML, specifying the status code and headers. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hello, world!</h1> </body> </html> \") }; return indexResponse; } The next step is to associate this method with an HTTP route. Routers Routers are abstractions of request routes and serve as the bridge between requests and responses for the service. Routers manage service routes, functions, and errors. A router can have several routes, and each route can perform different operations on that path, such as executing a function, serving a page, or providing a resource from the server. Let's create our first router and associate our IndexPage method with the index path. Router mainRouter = new Router(); // SetRoute will associate all index routes with our method. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Now our router can receive requests and send responses. However, mainRouter is not tied to a host or a server, so it will not work on its own. The next step is to create our ListeningHost. Listening Hosts and Ports A ListeningHost can host a router and multiple listening ports for the same router. A ListeningPort is a prefix where the HTTP server will listen. Here, we can create a ListeningHost that points to two endpoints for our router: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Now our HTTP server will listen to the specified endpoints and redirect its requests to our router. Server Configuration Server configuration is responsible for most of the behavior of the HTTP server itself. In this configuration, we can associate ListeningHosts with our server. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Add our ListeningHost to this server configuration Next, we can create our HTTP server: HttpServer server = new HttpServer(config); server.Start(); // Starts the server Console.ReadKey(); // Prevents the application from exiting Now we can compile our executable and run our HTTP server with the command: dotnet watch At runtime, open your browser and navigate to the server path, and you should see:"
  },
  "docs/advanced/multi-host-setup.html": {
    "href": "docs/advanced/multi-host-setup.html",
    "title": "Multiple listening hosts per server | Sisk",
    "keywords": "Multiple listening hosts per server The Sisk Framework has always supported the use of more than one host per server, that is, a single HTTP server can listen on multiple ports and each port has its own router and its own service running on it. This way, it is easy to separate responsibilities and manage services on a single HTTP server with Sisk. The example below shows the creation of two ListeningHosts, each listening to a different port, with different routers and actions. Read manually creating your app to understand the details about this abstraction. static void Main(string[] args) { // create two listening hosts, which each one has it's own router and // listens to it's own port // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hello from the host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hello from the host B!\")); // create an server configuration and adds both // listening hosts on it // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // creates an http server which uses the specified // configuration // HttpServer server = new HttpServer(configuration); // starts the server server.Start(); Console.WriteLine(\"Try to reach host A in {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Try to reach host B in {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/advanced/request-lifecycle.html": {
    "href": "docs/advanced/request-lifecycle.html",
    "title": "Request lifecycle | Sisk",
    "keywords": "Request lifecycle Below is explained the entire life cycle of a request through an example of an HTTP request. Receiving the request: each request creates an HTTP context between the request itself and the response that will be delivered to the client. This context comes from the built-in listener in Sisk, which can be the HttpListener, Kestrel, or Cadente. External request validation: the validation of HttpServerConfiguration.RemoteRequestsAction is validated for the request. If the request is external and the property is Drop, the connection is closed without a response to the client with an HttpServerExecutionStatus = RemoteRequestDropped. Forwarding Resolver configuration: if a ForwardingResolver is configured, it will call the OnResolveRequestHost method on the original host of the request. DNS matching: with the host resolved and with more than one ListeningHost configured, the server will look for the corresponding host for the request. If no ListeningHost matches, a 400 Bad Request response is returned to the client and an HttpServerExecutionStatus = DnsUnknownHost status is returned to the HTTP context. If a ListeningHost matches, but its Router is not yet initialized, a 503 Service Unavailable response is returned to the client and an HttpServerExecutionStatus = ListeningHostNotReady status is returned to the HTTP context. Router binding: the router of the corresponding ListeningHost is associated with the received HTTP server. If the router is already associated with another HTTP server, which is not allowed because the router actively uses the server's configuration resources, an InvalidOperationException is thrown. This only occurs during the initialization of the HTTP server, not during the creation of the HTTP context. Pre-definition of headers: Predefines the X-Request-Id header in the response if it is configured to do so. Predefines the X-Powered-By header in the response if it is configured to do so. Content size validation: validates if the request content is less than HttpServerConfiguration.MaximumContentLength only if it is greater than zero. If the request sends a Content-Length greater than the configured one, a 413 Payload Too Large response is returned to the client and an HttpServerExecutionStatus = ContentTooLarge status is returned to the HTTP context. The OnHttpRequestOpen event is invoked for all configured HTTP server handlers. Routing the action: the server invokes the router for the received request. If the router does not find a route that matches the request: If the Router.NotFoundErrorHandler property is configured, the action is invoked, and the response of the action is forwarded to the HTTP client. If the previous property is null, a default 404 Not Found response is returned to the client. If the router finds a matching route, but the route's method does not match the request's method: If the Router.MethodNotAllowedErrorHandler property is configured, the action is invoked and the response of the action is forwarded to the HTTP client. If the previous property is null, a default 405 Method Not Allowed response is returned to the client. If the request is of the OPTIONS method: The router returns a 200 Ok response to the client only if no route matches the request method (the route's method is not explicitly RouteMethod.Options). If the HttpServerConfiguration.ForceTrailingSlash property is enabled, the matched route is not a regex, the request path does not end with /, and the request method is GET: A 307 Temporary Redirect HTTP response with the Location header with the path and query to the same location with a / at the end is returned to the client. The OnContextBagCreated event is invoked for all configured HTTP server handlers. All global IRequestHandler instances with the BeforeResponse flag are executed. If any handler returns a non-null response, that response is forwarded to the HTTP client and the context is closed. If an error is thrown in this step and HttpServerConfiguration.ThrowExceptions is disabled: If the Router.CallbackErrorHandler property is enabled, it is invoked and the resulting response is returned to the client. If the previous property is not defined, an empty response is returned to the server, which forwards a response according to the type of exception thrown, which is usually 500 Internal Server Error. All IRequestHandler instances defined in the route and with the BeforeResponse flag are executed. If any handler returns a non-null response, that response is forwarded to the HTTP client and the context is closed. If an error is thrown in this step and HttpServerConfiguration.ThrowExceptions is disabled: If the Router.CallbackErrorHandler property is enabled, it is invoked and the resulting response is returned to the client. If the previous property is not defined, an empty response is returned to the server, which forwards a response according to the type of exception thrown, which is usually 500 Internal Server Error. The router's action is invoked and transformed into an HTTP response. If an error is thrown in this step and HttpServerConfiguration.ThrowExceptions is disabled: If the Router.CallbackErrorHandler property is enabled, it is invoked and the resulting response is returned to the client. If the previous property is not defined, an empty response is returned to the server, which forwards a response according to the type of exception thrown, which is usually 500 Internal Server Error. All global IRequestHandler instances with the AfterResponse flag are executed. If any handler returns a non-null response, the handler's response replaces the previous response and is immediately forwarded to the HTTP client. If an error is thrown in this step and HttpServerConfiguration.ThrowExceptions is disabled: If the Router.CallbackErrorHandler property is enabled, it is invoked and the resulting response is returned to the client. If the previous property is not defined, an empty response is returned to the server, which forwards a response according to the type of exception thrown, which is usually 500 Internal Server Error. All IRequestHandler instances defined in the route and with the AfterResponse flag are executed. If any handler returns a non-null response, the handler's response replaces the previous response and is immediately forwarded to the HTTP client. If an error is thrown in this step and HttpServerConfiguration.ThrowExceptions is disabled: If the Router.CallbackErrorHandler property is enabled, it is invoked and the resulting response is returned to the client. If the previous property is not defined, an empty response is returned to the server, which forwards a response according to the type of exception thrown, which is usually 500 Internal Server Error. Processing the response: with the response ready, the server prepares it for sending to the client. The Cross-Origin Resource Sharing Policy (CORS) headers are defined in the response according to what was configured in the current ListeningHost.CrossOriginResourceSharingPolicy. The status code and headers of the response are sent to the client. The response content is sent to the client: If the response content is a descendant of ByteArrayContent, the response bytes are directly copied to the response output stream. If the previous condition is not met, the response is serialized to a stream and copied to the response output stream. The streams are closed and the response content is discarded. If HttpServerConfiguration.DisposeDisposableContextValues is enabled, all objects defined in the request context that inherit from IDisposable are discarded. The OnHttpRequestClose event is invoked for all configured HTTP server handlers. If an exception was thrown on the server, the OnException event is invoked for all configured HTTP server handlers. If the route allows access-logging and HttpServerConfiguration.AccessLogsStream is not null, a log line is written to the log output. If the route allows error-logging, there is an exception, and HttpServerConfiguration.ErrorsLogsStream is not null, a log line is written to the error log output. If the server is waiting for a request through HttpServer.WaitNext, the mutex is released and the context becomes available to the user."
  },
  "docs/changelogs.html": {
    "href": "docs/changelogs.html",
    "title": "Changelogs | Sisk",
    "keywords": "Changelogs Every change made to Sisk is recorded through the changelog. You can view the changelogs for all Sisk versions here."
  },
  "docs/cn/advanced/forwarding-resolvers.html": {
    "href": "docs/cn/advanced/forwarding-resolvers.html",
    "title": "转发解析器 | Sisk",
    "keywords": "转发解析器 转发解析器是一个帮助器，帮助解码通过请求、代理、CDN 或负载均衡器识别客户端的信息。当您的 Sisk 服务运行通过反向或正向代理时，客户端的 IP 地址、主机和协议可能与原始请求不同，因为这是从一个服务到另一个服务的转发。这个 Sisk 功能允许您在处理请求之前控制和解析此信息。这些代理通常提供有用的头部来识别其客户端。 目前，使用 ForwardingResolver 类，可以解析客户端 IP 地址、主机和使用的 HTTP 协议。在 Sisk 1.0 版本之后，服务器不再有标准实现来解码这些头部，因为安全原因从服务到服务不同。 例如，X-Forwarded-For 头部包含有关转发请求的 IP 地址的信息。这个头部由代理使用，以携带一系列信息到最终服务，并包括所有使用的代理的 IP 地址，包括客户端的真实地址。问题是：有时很难识别客户端的远程 IP 地址，并且没有特定的规则来识别这个头部。强烈推荐阅读以下头部的文档： 阅读关于 X-Forwarded-For 头部的信息 这里。 阅读关于 X-Forwarded-Host 头部的信息 这里。 阅读关于 X-Forwarded-Proto 头部的信息 这里。 ForwardingResolver 类 这个类有三个虚拟方法，允许为每个服务实现最合适的解决方案。每个方法负责通过代理解析请求的信息：客户端的 IP 地址、请求的主机和使用的安全协议。默认情况下，Sisk 将始终使用原始请求的信息，而不解析任何头部。 下面的例子展示了如何使用这个实现。这个例子通过 X-Forwarded-For 头部解析客户端的 IP 地址，并在请求中转发多个 IP 地址时抛出错误。 Important 不要在生产代码中使用这个例子。始终检查实现是否适合使用。在实现之前阅读头部文档。 class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"X-Forwarded-For 头部缺失.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"X-Forwarded-For 头部中有太多地址.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/cn/advanced/http-server-handlers.html": {
    "href": "docs/cn/advanced/http-server-handlers.html",
    "title": "HTTP 服务器处理器 | Sisk",
    "keywords": "HTTP 服务器处理器 在 Sisk 0.16 版本中，我们引入了 HttpServerHandler 类，该类旨在扩展 Sisk 的整体行为，并为 Sisk 提供额外的事件处理程序，例如处理 HTTP 请求、路由器、上下文包等。 该类集中了整个 HTTP 服务器和请求的生命周期中发生的事件。HTTP 协议没有会话，因此无法在请求之间保留信息。Sisk 目前提供了一种方式，允许您实现会话、上下文、数据库连接和其他有用的提供程序，以帮助您的工作。 请参阅 此页面 以了解每个事件的触发位置和其目的。你也可以查看 HTTP 请求的生命周期 以了解请求发生了什么以及事件在哪里触发。HTTP 服务器允许你同时使用多个处理程序。每个事件调用都是同步的，即它将阻塞当前线程，直到与该函数关联的所有处理程序都执行并完成。 与 RequestHandlers 不同，它们不能应用于某些路由组或特定路由。相反，它们应用于整个 HTTP 服务器。你可以在你的 HTTP 服务器处理程序中应用条件。此外，每个 Sisk 应用程序都定义了每个 HttpServerHandler 的单例，因此每个 HttpServerHandler 只有一个实例。 使用 HttpServerHandler 的一个实用示例是自动在请求结束时释放数据库连接。 // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // 检查请求是否在其上下文包中定义了 DbContext if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // 允许用户从 HTTP 请求创建 DbContext 并将其存储在其请求包中 public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } 上面的代码中，GetDbContext 扩展方法允许直接从 HttpRequest 对象创建连接上下文并将其存储在其请求包中。未释放的连接可能会在运行数据库时引起问题，因此在 OnHttpRequestClose 中终止它。 你可以在你的构建器中或直接使用 HttpServer.RegisterHandler 注册处理程序到 HTTP 服务器。 // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } 这样，UsersController 类就可以使用数据库上下文： // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } 上面的代码使用了 ApiController 中的 JsonOk 和 JsonMessage 方法，该方法继承自 RouterController： // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } 开发人员可以使用此类实现会话、上下文和数据库连接。提供的代码展示了一个使用 DatabaseConnectionHandler 的实用示例，自动在每个请求结束时释放数据库连接。 集成非常简单，处理程序在服务器设置期间注册。HttpServerHandler 类提供了一个强大的工具集，用于在 HTTP 应用程序中管理资源和扩展 Sisk 行为。"
  },
  "docs/cn/advanced/manual-setup.html": {
    "href": "docs/cn/advanced/manual-setup.html",
    "title": "手动（高级）设置 | Sisk",
    "keywords": "手动（高级）设置 在本节中，我们将创建一个没有任何预定义标准的 HTTP 服务器，以完全抽象的方式。这里，您可以手动构建您的 HTTP 服务器的功能。每个 ListeningHost 都有一个路由器，一个 HTTP 服务器可以有多个 ListeningHost，每个 ListeningHost 指向不同的主机和端口。 首先，我们需要了解请求/响应概念。它非常简单：对于每个请求，必须有一个响应。Sisk 也遵循这个原则。让我们创建一个方法，响应一个“Hello, World！”消息，指定状态代码和头部。 // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hello, world!</h1> </body> </html> \") }; return indexResponse; } 下一步是将此方法与一个 HTTP 路由关联起来。 路由器 路由器是请求路由的抽象，作为服务的请求和响应之间的桥梁。路由器管理服务路由、函数和错误。 一个路由器可以有多个路由，每个路由可以在该路径上执行不同的操作，例如执行函数、提供页面或提供服务器资源。 让我们创建我们的第一个路由器，并将我们的 IndexPage 方法与索引路径关联起来。 Router mainRouter = new Router(); // SetRoute 将所有索引路由与我们的方法关联起来。 mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); 现在我们的路由器可以接收请求并发送响应。然而，mainRouter 不绑定到任何主机或服务器，因此它不能单独工作。下一步是创建我们的 ListeningHost。 Listening Hosts 和 Ports 一个 ListeningHost 可以托管一个路由器和多个监听端口，用于同一个路由器。一个 ListeningPort 是 HTTP 服务器将监听的前缀。 这里，我们可以创建一个 ListeningHost，它指向两个端点，用于我们的路由器： ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; 现在我们的 HTTP 服务器将监听指定的端点，并将其请求重定向到我们的路由器。 服务器配置 服务器配置负责大部分 HTTP 服务器自身的行为。在此配置中，我们可以将 ListeningHosts 关联到我们的服务器。 HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // 将我们的 ListeningHost 添加到此服务器配置 接下来，我们可以创建我们的 HTTP 服务器： HttpServer server = new HttpServer(config); server.Start(); // 启动服务器 Console.ReadKey(); // 防止应用程序退出 现在我们可以编译我们的可执行文件，并使用以下命令运行我们的 HTTP 服务器： dotnet watch 在运行时，打开您的浏览器，并导航到服务器路径，您应该会看到："
  },
  "docs/cn/advanced/multi-host-setup.html": {
    "href": "docs/cn/advanced/multi-host-setup.html",
    "title": "每个服务器多个监听主机 | Sisk",
    "keywords": "每个服务器多个监听主机 Sisk Framework一直支持在每个服务器上使用多个主机，即单个HTTP服务器可以监听多个端口，每个端口都有自己的路由器和服务运行在上面。 这样，使用Sisk就可以轻松地分离责任并管理单个HTTP服务器上的服务。下面的例子展示了创建两个ListeningHosts，每个监听不同的端口，具有不同的路由器和动作。 阅读手动创建您的应用以了解有关此抽象的详细信息。 static void Main(string[] args) { // 创建两个监听主机，每个都有自己的路由器和监听端口 // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"来自主机A的问候！\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"来自主机B的问候！\")); // 创建一个服务器配置并添加两个监听主机 // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // 创建一个使用指定配置的HTTP服务器 // HttpServer server = new HttpServer(configuration); // 启动服务器 server.Start(); Console.WriteLine(\"尝试访问主机A在 {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"尝试访问主机B在 {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/cn/advanced/request-lifecycle.html": {
    "href": "docs/cn/advanced/request-lifecycle.html",
    "title": "请求生命周期 | Sisk",
    "keywords": "请求生命周期 以下是通过一个 HTTP 请求示例解释的整个请求生命周期。 接收请求： 每个请求都会在请求本身和将要发送给客户端的响应之间创建一个 HTTP 上下文。这个上下文来自 Sisk 中的内置监听器，可以是 HttpListener、Kestrel 或 Cadente。 外部请求验证：验证 HttpServerConfiguration.RemoteRequestsAction 的请求。 如果请求是外部的，并且该属性是 Drop，则在不向客户端发送响应的情况下关闭连接，HttpServerExecutionStatus = RemoteRequestDropped。 转发解析器配置：如果配置了 ForwardingResolver，它将在请求的原始主机上调用 OnResolveRequestHost 方法。 DNS 匹配：在解析主机并配置了多个 ListeningHost的情况下，服务器将查找对应的主机。 如果没有 ListeningHost 匹配，返回 400 Bad Request 响应给客户端，HttpServerExecutionStatus = DnsUnknownHost 状态返回给 HTTP 上下文。 如果 ListeningHost 匹配，但其 Router 尚未初始化，返回 503 Service Unavailable 响应给客户端，HttpServerExecutionStatus = ListeningHostNotReady 状态返回给 HTTP 上下文。 路由器绑定：将 ListeningHost 的路由器与接收的 HTTP 服务器关联。 如果路由器已经与另一个 HTTP 服务器关联，这是不允许的，因为路由器正在使用服务器的配置资源，会抛出 InvalidOperationException。这只会在 HTTP 服务器初始化期间发生，而不是在创建 HTTP 上下文期间。 预定义头部： 如果配置了，预定义响应中的 X-Request-Id 头部。 如果配置了，预定义响应中的 X-Powered-By 头部。 内容大小验证：验证请求内容是否小于 HttpServerConfiguration.MaximumContentLength，仅当其大于零时。 如果请求发送的 Content-Length 大于配置的，返回 413 Payload Too Large 响应给客户端，HttpServerExecutionStatus = ContentTooLarge 状态返回给 HTTP 上下文。 为所有配置的 HTTP 服务器处理程序调用 OnHttpRequestOpen 事件。 路由操作： 服务器为接收的请求调用路由器。 如果路由器找不到匹配请求的路由： 如果 Router.NotFoundErrorHandler 属性配置了，调用该操作，并将操作的响应转发给 HTTP 客户端。 如果前面的属性为 null，返回默认的 404 Not Found 响应给客户端。 如果路由器找到匹配的路由，但路由的方法不匹配请求的方法： 如果 Router.MethodNotAllowedErrorHandler 属性配置了，调用该操作，并将操作的响应转发给 HTTP 客户端。 如果前面的属性为 null，返回默认的 405 Method Not Allowed 响应给客户端。 如果请求的方法是 OPTIONS： 路由器仅当没有路由匹配请求方法（路由的方法不是显式 RouteMethod.Options）时，返回 200 Ok 响应给客户端。 如果 HttpServerConfiguration.ForceTrailingSlash 属性启用了，匹配的路由不是正则表达式，请求路径不以 / 结尾，且请求方法是 GET： 返回 307 Temporary Redirect HTTP 响应给客户端，Location 头部包含路径和查询，以相同的位置但在结尾添加 /。 为所有配置的 HTTP 服务器处理程序调用 OnContextBagCreated 事件。 执行所有全局 IRequestHandler 实例，具有 BeforeResponse 标志。 如果任何处理程序返回非 null 响应，则该响应转发给 HTTP 客户端，且上下文关闭。 如果此步骤中抛出错误，并且 HttpServerConfiguration.ThrowExceptions 禁用了： 如果 Router.CallbackErrorHandler 属性启用了，调用它，并将结果响应返回给客户端。 如果前面的属性未定义，返回空响应给服务器，服务器根据抛出的异常类型转发响应，通常为 500 Internal Server Error。 执行所有在路由中定义的 IRequestHandler 实例，具有 BeforeResponse 标志。 如果任何处理程序返回非 null 响应，则该响应转发给 HTTP 客户端，且上下文关闭。 如果此步骤中抛出错误，并且 HttpServerConfiguration.ThrowExceptions 禁用了： 如果 Router.CallbackErrorHandler 属性启用了，调用它，并将结果响应返回给客户端。 如果前面的属性未定义，返回空响应给服务器，服务器根据抛出的异常类型转发响应，通常为 500 Internal Server Error。 调用路由器的操作，并将其转换为 HTTP 响应。 如果此步骤中抛出错误，并且 HttpServerConfiguration.ThrowExceptions 禁用了： 如果 Router.CallbackErrorHandler 属性启用了，调用它，并将结果响应返回给客户端。 如果前面的属性未定义，返回空响应给服务器，服务器根据抛出的异常类型转发响应，通常为 500 Internal Server Error。 执行所有全局 IRequestHandler 实例，具有 AfterResponse 标志。 如果任何处理程序返回非 null 响应，则处理程序的响应替换前一个响应，并立即转发给 HTTP 客户端。 如果此步骤中抛出错误，并且 HttpServerConfiguration.ThrowExceptions 禁用了： 如果 Router.CallbackErrorHandler 属性启用了，调用它，并将结果响应返回给客户端。 如果前面的属性未定义，返回空响应给服务器，服务器根据抛出的异常类型转发响应，通常为 500 Internal Server Error。 执行所有在路由中定义的 IRequestHandler 实例，具有 AfterResponse 标志。 如果任何处理程序返回非 null 响应，则处理程序的响应替换前一个响应，并立即转发给 HTTP 客户端。 如果此步骤中抛出错误，并且 HttpServerConfiguration.ThrowExceptions 禁用了： 如果 Router.CallbackErrorHandler 属性启用了，调用它，并将结果响应返回给客户端。 如果前面的属性未定义，返回空响应给服务器，服务器根据抛出的异常类型转发响应，通常为 500 Internal Server Error。 处理响应： 准备好响应后，服务器为发送给客户端做准备。 根据 ListeningHost.CrossOriginResourceSharingPolicy 的配置，在响应中定义跨源资源共享（CORS）头部。 发送响应的状态代码和头部给客户端。 发送响应内容给客户端： 如果响应内容是 ByteArrayContent 的后代，则直接将响应字节复制到响应输出流中。 如果前面的条件不满足，响应被序列化为流并复制到响应输出流中。 关闭流并丢弃响应内容。 如果 HttpServerConfiguration.DisposeDisposableContextValues 启用了，丢弃所有在请求上下文中定义的继承自 IDisposable 的对象。 为所有配置的 HTTP 服务器处理程序调用 OnHttpRequestClose 事件。 如果服务器抛出了异常，为所有配置的 HTTP 服务器处理程序调用 OnException 事件。 如果路由允许访问日志记录，并且 HttpServerConfiguration.AccessLogsStream 不为 null，写入一行日志到日志输出中。 如果路由允许错误日志记录，并且存在异常，并且 HttpServerConfiguration.ErrorsLogsStream 不为 null，写入一行日志到错误日志输出中。 如果服务器通过 HttpServer.WaitNext 等待请求，释放互斥锁，且上下文变得可用于用户。"
  },
  "docs/cn/changelogs.html": {
    "href": "docs/cn/changelogs.html",
    "title": "变更日志 | Sisk",
    "keywords": "变更日志 每对 Sisk 进行的更改都会通过变更日志记录。你可以在 这里 查看所有 Sisk 版本的变更日志。"
  },
  "docs/cn/deploying.html": {
    "href": "docs/cn/deploying.html",
    "title": "部署 Sisk 应用 | Sisk",
    "keywords": "部署 Sisk 应用 部署 Sisk 应用的过程包括将您的项目发布到生产环境中。虽然这个过程相对简单，但有一些细节需要注意，以避免对部署的基础设施造成安全和稳定性的问题。 理想情况下，在进行所有可能的测试后，您应该准备好将应用程序部署到云端。 发布您的应用 发布 Sisk 应用或服务是生成适合生产环境的二进制文件。在这个例子中，我们将编译二进制文件以便在安装了 .NET Runtime 的机器上运行。 您需要在机器上安装 .NET SDK 来构建应用程序，并在目标服务器上安装 .NET Runtime 来运行应用程序。您可以在 这里 学习如何在 Linux 服务器上安装 .NET Runtime，这里 学习如何在 Windows 上安装，这里 学习如何在 Mac OS 上安装。 在项目所在的文件夹中，打开终端并使用 .NET 发布命令： $ dotnet publish -r linux-x64 -c Release 这将在 bin/Release/publish/linux-x64 中生成二进制文件。 Note 如果您的应用程序使用 Sisk.ServiceProvider 包，您应该将 service-config.json 文件复制到主机服务器中，连同 dotnet publish 生成的所有二进制文件。 您可以预先配置文件，包括环境变量、监听端口和主机，以及其他服务器配置。 下一步是将这些文件传输到将要托管应用程序的服务器。 之后，给二进制文件授予执行权限。假设我们的项目名称是 \"my-app\"： $ cd /home/htdocs $ chmod +x my-app $ ./my-app 运行应用程序后，检查是否有任何错误消息。如果没有产生错误消息，那么您的应用程序正在运行。 此时，应用程序可能无法从外部网络访问，因为尚未配置访问规则，例如防火墙。我们将在下一步中考虑这一点。 您应该有应用程序监听的虚拟主机地址。这是手动在应用程序中设置的，并取决于您如何实例化 Sisk 服务。 如果您 不 使用 Sisk.ServiceProvider 包，您应该在定义 HttpServer 实例的地方找到它： HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk 应该监听 http://localhost:5000/ 手动关联 ListeningHost： config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); 或者，如果您使用 Sisk.ServiceProvider 包，在您的 service-config.json 中： { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } 从这里，我们可以创建一个反向代理来监听您的服务并使流量在开放网络上可用。 代理您的应用 代理您的服务意味着不直接将 Sisk 服务暴露在外部网络中。这是一种常见的服务器部署做法，因为： 允许您在应用程序中关联 SSL 证书； 创建访问规则以避免过载； 控制带宽和请求限制； 为您的应用程序分离负载均衡器； 防止基础设施故障造成的安全损害。 您可以通过反向代理服务器，如 Nginx 或 Apache，或使用 HTTP-over-DNS 隧道，如 Cloudflared，来提供您的应用程序。 另外，请记得正确解析代理的转发头，以便通过 转发解析器 获取客户端信息，例如 IP 地址和主机。 创建隧道、配置防火墙并运行应用程序后，下一步是为您的应用程序创建一个服务。 Note 在非 Windows 系统上，直接在 Sisk 服务中使用 SSL 证书是不可能的。这是 HttpListener 的实现方式，这是 Sisk 中 HTTP 队列管理的核心模块，这种实现方式在操作系统之间有所不同。如果您 将证书与 IIS 中的虚拟主机关联，则可以在 Sisk 服务中使用 SSL。对于其他系统，强烈推荐使用反向代理。 创建服务 创建服务将使您的应用程序始终可用，即使在服务器实例重启或发生不可恢复的崩溃后。 在这个简单的教程中，我们将使用前一个教程的内容作为示例，以保持服务始终活跃。 访问服务配置文件所在的文件夹： cd /etc/systemd/system 创建您的 my-app.service 文件并包含以下内容： my-app.service INI [Unit] Description=<description about your app> [Service] # 设置将启动服务的用户 User=<user which will launch the service> # ExecStart 路径不是相对于 WorkingDirectory 的。 # 将其设置为可执行文件的完整路径 WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # 设置服务在崩溃后始终重启 Restart=always RestartSec=3 [Install] WantedBy=multi-user.target 重启服务管理器模块： $ sudo systemctl daemon-reload 从文件名启动新创建的服务并检查是否正在运行： $ sudo systemctl start my-app $ sudo systemctl status my-app 现在，如果您的应用程序正在运行 (\"Active: active\")，请启用服务以便在系统重启后继续运行： $ sudo systemctl enable my-app 现在，您已经准备好向所有人展示您的 Sisk 应用。"
  },
  "docs/cn/extensions/basic-auth.html": {
    "href": "docs/cn/extensions/basic-auth.html",
    "title": "基本身份验证 | Sisk",
    "keywords": "基本身份验证 基本身份验证包添加了一个请求处理程序，能够处理基本身份验证方案，并且只需进行很少的配置和努力即可在您的 Sisk 应用程序中使用。 基本 HTTP 身份验证是一种最小的输入形式，通过用户 ID 和密码对请求进行身份验证，会话完全由客户端控制，并且没有身份验证或访问令牌。 更多关于基本身份验证方案的信息，请参阅 MDN 规范。 安装 要开始使用，请在您的项目中安装 Sisk.BasicAuth 包： > dotnet add package Sisk.BasicAuth 您可以在 Nuget 存储库 中查看更多关于如何在您的项目中安装它的信息。 创建身份验证处理程序 您可以控制整个模块或个别路由的身份验证方案。为此，让我们首先编写第一个基本身份验证处理程序。 在以下示例中，连接到数据库，检查用户是否存在以及密码是否有效，然后将用户存储在上下文包中。 public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"要进入此页面，请提供您的凭据。\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // 在这种情况下，我们使用电子邮件作为用户 ID 字段，因此我们将使用电子邮件查找用户。 User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"抱歉！没有找到此电子邮件的用户。\"); } // 验证此用户的凭据密码是否有效。 if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"无效的凭据。\"); } // 将已登录的用户添加到 HTTP 上下文中 // 并继续执行 context.Bag.Add(\"loggedUser\", user); return null; } } 因此，只需将此请求处理程序与我们的路由或类关联即可。 public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"您好，\" + loggedUser.Name + \"!\"; } } 或者使用 RouterModule 类： public class UsersController : RouterModule { public ClientModule() { // 现在此类中的所有路由都将由 UserAuthHandler 处理。 base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"您好，\" + loggedUser.Name + \"!\"; } } 备注 基本身份验证的主要责任由客户端承担。存储、缓存控制和加密都在客户端本地处理。服务器只接收凭据并验证是否允许访问。 请注意，此方法不是最安全的，因为它将大量责任放在客户端上，客户端可能难以跟踪和维护其凭据的安全性。另外，密码必须在安全连接上下文（SSL）中传输，因为它们没有内置加密。请求头的简短拦截可能会暴露用户的访问凭据。 对于生产环境中的应用程序，请选择更强大的身份验证解决方案，并避免使用太多现成的组件，因为它们可能无法适应项目的需求，最终会使其暴露于安全风险之中。"
  },
  "docs/cn/extensions/ini-configuration.html": {
    "href": "docs/cn/extensions/ini-configuration.html",
    "title": "INI 配置提供程序 | Sisk",
    "keywords": "INI 配置提供程序 Sisk 有一种方法可以获取启动配置，而不仅仅是 JSON。事实上，任何实现 IConfigurationReader 的管道都可以与 PortableConfigurationBuilder.WithConfigurationPipeline一起使用，从任何文件类型中读取服务器配置。 Sisk.IniConfiguration 包提供了一个基于流的 INI 文件读取器，它不会为常见的语法错误抛出异常，并且具有简单的配置语法。这个包可以在 Sisk 框架之外使用，为需要高效 INI 文档读取器的项目提供了灵活性。 安装 要安装包，可以从以下开始： $ dotnet add package Sisk.IniConfiguration 你也可以安装核心包，它不包括 INI IConfigurationReader，也不包括 Sisk 依赖项，只包括 INI 序列化器： $ dotnet add package Sisk.IniConfiguration.Core 使用主包，你可以在代码中使用它，如下面的示例所示： class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // 使用 IniConfigurationReader 配置读取器 config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } 上面的代码将在进程的当前目录（CurrentDirectory）中查找一个 app.ini 文件。INI 文件的内容如下： [Server] # 支持多个监听地址 Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI 风格和语法 当前实现风格： 属性和节名是 大小写不敏感 的。 属性名和值是 修剪 的，除非值被引号括起来。 值可以用单引号或双引号括起来。引号内可以包含换行符。 支持使用 # 和 ; 的注释。尾随注释也是允许的。 属性可以有多个值。 详细信息，Sisk 中使用的 INI 解析器的“风格”文档可以在 这里 找到。 使用以下 INI 代码作为示例： One = 1 Value = 这是一个值 Another value = \"这个值 有一个换行符\" ; 下面的代码有一些颜色 [some section] Color = Red Color = Blue Color = Yellow ; 不要使用黄色 解析它： // 从字符串解析 INI 文本 IniDocument doc = IniDocument.FromString(iniText); // 获取一个值 string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // 获取多个值 string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); 配置参数 节和名称 允许多个值 描述 Server.Listen 是 服务器监听地址/端口。 Server.Encoding 否 服务器默认编码。 Server.MaximumContentLength 否 服务器最大内容长度（以字节为单位）。 Server.IncludeRequestIdHeader 否 指定是否应发送 X-Request-Id 标头。 Server.ThrowExceptions 否 指定是否应抛出未处理的异常。 Server.AccessLogsStream 否 指定访问日志输出流。 Server.ErrorsLogsStream 否 指定错误日志输出流。 Cors.AllowMethods 否 指定 CORS Allow-Methods 标头值。 Cors.AllowHeaders 否 指定 CORS Allow-Headers 标头值。 Cors.AllowOrigins 否 指定多个 Allow-Origin 标头，逗号分隔。AllowOrigins 有更多信息。 Cors.AllowOrigin 否 指定一个 Allow-Origin 标头。 Cors.ExposeHeaders 否 指定 CORS Expose-Headers 标头值。 Cors.AllowCredentials 否 指定 CORS Allow-Credentials 标头值。 Cors.MaxAge 否 指定 CORS Max-Age 标头值。"
  },
  "docs/cn/extensions/json-rpc.html": {
    "href": "docs/cn/extensions/json-rpc.html",
    "title": "JSON-RPC 扩展 | Sisk",
    "keywords": "JSON-RPC 扩展 Sisk 有一个实验性的 JSON-RPC 2.0 API 模块，允许您创建更简单的应用程序。该扩展严格实现了 JSON-RPC 2.0 传输接口，并提供通过 HTTP GET、POST 请求和 WebSockets 的传输。 您可以通过 Nuget 安装该扩展，使用以下命令。请注意，在实验/测试版本中，您需要在 Visual Studio 中启用搜索预发布包的选项。 dotnet add package Sisk.JsonRpc 传输接口 JSON-RPC 是一种无状态、异步的远程过程调用（RDP）协议，使用 JSON 进行单向数据通信。JSON-RPC 请求通常由一个 ID 标识，响应由相同的 ID 发送。并非所有请求都需要响应，这些被称为“通知”。 JSON-RPC 2.0 规范 详细解释了传输的工作原理。该传输与其使用位置无关。Sisk 通过 HTTP 实现该协议，遵循 JSON-RPC over HTTP 的规定，部分支持 GET 请求，完全支持 POST 请求。WebSockets 也被支持，提供异步消息通信。 JSON-RPC 请求类似于： { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } 成功响应类似于： { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC 方法 以下示例显示如何使用 Sisk 创建 JSON-RPC API。一个数学运算类执行远程操作并将序列化的响应发送给客户端。 Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // 添加所有标记为 WebMethod 的方法到 JSON-RPC 处理器 args.Handler.Methods.AddMethodsFromType(new MathOperations()); // 将 /service 路由映射到处理 JSON-RPC POST 和 GET 请求 args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // 在 GET /ws 创建一个 WebSocket 处理器 args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } 上面的示例将 Sum 和 Sqrt 方法映射到 JSON-RPC 处理器，这些方法将在 GET /service、POST /service 和 GET /ws 中可用。方法名称不区分大小写。 方法参数将自动反序列化为其特定类型。使用带有命名参数的请求也是支持的。JSON 序列化由 LightJson 库执行。当类型不能正确反序列化时，您可以为该类型创建一个特定的 JSON 转换器 并稍后将其与 JsonSerializerOptions 关联起来。 您还可以直接在方法中获取 JSON-RPC 请求的原始 $.params 对象。 MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } 为此，@params 必须是方法中唯一的参数，且名称必须为 params（在 C# 中，@ 用于转义此参数名称）。 参数反序列化适用于命名对象和位置数组。例如，以下方法可以通过以下两种请求调用： [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } 对于数组，参数的顺序必须遵循。 { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } 自定义序列化器 您可以在 JsonRpcHandler.JsonSerializerOptions 属性中自定义 JSON 序列化器。在此属性中，您可以启用 JSON5 以用于反序列化消息。虽然这不是 JSON-RPC 2.0 的一部分，但 JSON5 是 JSON 的一个扩展，允许更易读和更具可读性的写作。 Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // 使用一个标准化的名称比较器。该比较器仅比较名称中的字母和数字，并丢弃其他符号。例如： // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // 启用 JSON5 以用于 JSON 解释器。即使激活此选项，普通 JSON 仍然被允许 e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // 将 POST /service 路由映射到 JSON-RPC 处理器 e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/cn/extensions/service-providers.html": {
    "href": "docs/cn/extensions/service-providers.html",
    "title": "服务提供者 | Sisk",
    "keywords": "服务提供者 服务提供者是一种将 Sisk 应用程序移植到不同环境的方式，使用一个可移植的配置文件。该功能允许您在不修改应用程序代码的情况下更改服务器的端口、参数和其他选项。该模块依赖于 Sisk 构造语法，可以通过 UsePortableConfiguration 方法进行配置。 一个配置提供者是通过 IConfigurationProvider 实现的，它提供了一个配置读取器，可以接受任何实现。默认情况下，Sisk 提供了一个 JSON 配置读取器，但也存在一个用于 INI 文件的包。您也可以创建自己的配置提供者并将其注册为： using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); 如前所述，默认的提供者是一个 JSON 文件。默认情况下，文件名为 service-config.json，并在运行进程的当前目录中搜索，而不是可执行文件目录。 您可以选择更改文件名，以及 Sisk 应该在哪里查找配置文件，使用： using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); 上面的代码将在运行进程的当前目录中查找 config.toml 文件。如果找不到，它将在可执行文件所在的目录中搜索。如果文件不存在，createIfDontExists 参数将被尊重，创建一个空文件在最后测试的路径（基于 lookupDirectories），并在控制台中抛出一个错误，防止应用程序初始化。 Tip 您可以查看 INI 配置读取器和 JSON 配置读取器的源代码，以了解如何实现 IConfigurationProvider。 从 JSON 文件读取配置 默认情况下，Sisk 提供了一个配置提供者，用于从 JSON 文件读取配置。该文件遵循一个固定的结构，包含以下参数： { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // 配置文件也支持注释 ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // 新增于 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } 从配置文件创建的参数可以在服务器构造函数中访问： using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); 每个配置读取器提供了一种读取服务器初始化参数的方式。一些属性被指示在进程环境中而不是在配置文件中定义，例如敏感的 API 数据、API 密钥等。 配置文件结构 JSON 配置文件由以下属性组成： 属性 必需 描述 Server 必需 代表服务器本身及其设置。 Server.AccessLogsStream 可选 默认为 console。指定访问日志输出流。可以是文件名、null 或 console。 Server.ErrorsLogsStream 可选 默认为 null。指定错误日志输出流。可以是文件名、null 或 console。 Server.MaximumContentLength 可选 默认为 0。指定最大内容长度（以字节为单位）。零表示无限。 Server.IncludeRequestIdHeader 可选 默认为 false。指定是否应发送 X-Request-Id 标头。 Server.ThrowExceptions 可选 默认为 true。指定是否应抛出未处理的异常。设置为 false 时为生产环境，true 时为调试环境。 ListeningHost 必需 代表服务器监听主机。 ListeningHost.Label 可选 代表应用程序标签。 ListeningHost.Ports 必需 代表一个字符串数组，匹配 ListeningPort 语法。 ListeningHost.CrossOriginResourceSharingPolicy 可选 设置应用程序的 CORS 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials 可选 默认为 false。指定 Allow-Credentials 标头。 ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders 可选 默认为 null。此属性期望一个字符串数组。指定 Expose-Headers 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin 可选 默认为 null。此属性期望一个字符串。指定 Allow-Origin 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins 可选 默认为 null。此属性期望一个字符串数组。指定多个 Allow-Origin 标头。请参阅 AllowOrigins 以获取更多信息。 ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods 可选 默认为 null。此属性期望一个字符串数组。指定 Allow-Methods 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders 可选 默认为 null。此属性期望一个字符串数组。指定 Allow-Headers 标头。 ListeningHost.CrossOriginResourceSharingPolicy.MaxAge 可选 默认为 null。此属性期望一个整数。指定 Max-Age 标头（以秒为单位）。 ListeningHost.Parameters 可选 指定提供给应用程序设置方法的属性。"
  },
  "docs/cn/extensions/ssl-proxy.html": {
    "href": "docs/cn/extensions/ssl-proxy.html",
    "title": "SSL 代理 | Sisk",
    "keywords": "SSL 代理 Warning 此功能是实验性的，不应在生产环境中使用。如果您想让 Sisk 与 SSL 协作，请参阅 此文档。 Sisk SSL 代理是一个模块，提供了一个 HTTPS 连接，用于 Sisk 中的 ListeningHost，并将 HTTPS 消息路由到不安全的 HTTP 上下文。该模块是为使用 HttpListener 运行的服务提供 SSL 连接而构建的，因为 HttpListener 不支持 SSL。 代理在同一应用程序中运行，并监听 HTTP/1.1 消息，将它们以相同的协议转发给 Sisk。目前，此功能是高度实验性的，可能不稳定到不能在生产环境中使用。 目前，SslProxy 支持几乎所有 HTTP/1.1 功能，例如 keep-alive、分块编码、WebSockets 等。对于打开到 SSL 代理的连接，会创建一个到目标服务器的 TCP 连接，并将代理转发到已建立的连接。 SslProxy 可以与 HttpServer.CreateBuilder 一起使用，如下所示： using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // 添加 SSL 到项目 .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); 您必须为代理提供一个有效的 SSL 证书。为了确保证书被浏览器接受，请记得将其导入到操作系统中，以便它能够正常工作。"
  },
  "docs/cn/faq.html": {
    "href": "docs/cn/faq.html",
    "title": "常见问题 | Sisk",
    "keywords": "常见问题 关于 Sisk 的常见问题。 Sisk 是开源的吗？ 完全开源。Sisk 使用的所有源代码都已发布并经常更新在 GitHub 上。 是否接受贡献？ 只要贡献符合 Sisk 哲学，所有贡献都非常欢迎！贡献不仅限于代码！您可以通过文档、测试、翻译、捐赠和帖子等方式贡献。 Sisk 是否有资金支持？ 不。目前没有任何组织或项目为 Sisk 提供资金支持。 我可以在生产环境中使用 Sisk 吗？ 绝对可以。该项目已经开发超过三年，并在商业应用中进行了大量测试，这些应用已经投入生产。Sisk 被用于重要的商业项目作为主要基础设施。 已经编写并提供了在不同系统和环境中 部署 的指南。 Sisk 是否具有身份验证、监控和数据库服务？ 不。Sisk 不具有这些功能。它是一个用于开发 HTTP 网络应用程序的框架，但它仍然是一个最小的框架，仅提供应用程序运行所需的功能。 您可以使用任何第三方库来实现所需的所有服务。Sisk 被设计为无关、灵活和与任何东西一起工作。 为什么我应该使用 Sisk 而不是 <框架>？ 我不知道。您告诉我。 Sisk 被创建以填补 .NET 中 HTTP 网络应用程序的通用场景。已建立的项目，例如 ASP.NET，解决了各种问题，但具有不同的偏见。与较大的框架不同，Sisk 需要用户了解他们正在做什么和构建什么。基本的 Web 开发和 HTTP 协议知识对于使用 Sisk 至关重要。 Sisk 更接近 Node.js 的 Express，而不是 ASP.NET Core。它是一个高级抽象，允许您创建具有所需 HTTP 逻辑的应用程序。 我需要学习什么才能使用 Sisk？ 您需要了解： Web 开发（HTTP、Restful 等） .NET 仅此而已。拥有这两个主题的基本知识，您可以在几个小时内使用 Sisk 开发一个高级应用程序。 我可以使用 Sisk 开发商业应用程序吗？ 绝对可以。 Sisk是在 MIT 许可证下创建的，这意味着您可以在任何商业项目中使用 Sisk，无论是商业还是非商业，均无需专有许可证。 我们要求的是，在您的应用程序中，您需要在某个地方添加一个关于使用的开源项目的通知，并且 Sisk 在其中。"
  },
  "docs/cn/features/content-streaming.html": {
    "href": "docs/cn/features/content-streaming.html",
    "title": "流式内容 | Sisk",
    "keywords": "流式内容 Sisk 支持读取和发送流式内容到和从客户端。这一功能对于在请求的生命周期中序列化和反序列化内容的内存开销非常有用。 请求内容流 小内容会自动加载到 HTTP 连接缓冲区内存中，快速加载到 HttpRequest.Body 和 HttpRequest.RawBody。对于较大的内容，可以使用 HttpRequest.GetRequestStream 方法来获取请求内容读取流。 值得注意的是，HttpRequest.GetMultipartFormContent 方法会将整个请求内容读入内存，因此对于读取大内容可能不太有用。 考虑以下示例： Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // 请求没有内容 return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"文件发送成功。\" } ) }; } 在上面的示例中，UploadDocument 方法读取请求内容并将内容保存到文件中。除了 Stream.CopyToAsync 使用的读取缓冲区外，不会进行任何额外的内存分配。上面的示例消除了对非常大文件的内存分配压力，可以优化应用程序性能。 一个良好的做法是在可能耗时的操作中始终使用 CancellationToken，例如发送文件，因为它取决于客户端和服务器之间的网络速度。 可以通过以下方式调整 CancellationToken： Controller/UploadDocument.cs C# // 下面的取消令牌将在 30 秒超时时抛出异常。 CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"上传超出了最大上传时间（30 秒）。\" } ) }; } 响应内容流 发送响应内容也是可能的。目前，有两种方法可以做到这一点：通过 HttpRequest.GetResponseStream 方法和使用 StreamContent 类型的内容。 考虑一个需要提供图像文件的场景。可以使用以下代码： Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // 示例方法来获取个人资料图片 var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } 上面的方法每次读取图像内容时都会进行内存分配。如果图像很大，这可能会导致性能问题，并且在峰值情况下，甚至可能导致内存过载和服务器崩溃。在这些情况下，缓存可能很有用，但它不会消除问题，因为仍然需要为该文件保留内存。缓存可以缓解每次请求都需要分配内存的压力，但对于大文件来说，它是不够的。 通过流式传输发送图像可以解决这个问题。与其读取整个图像内容，不如创建一个文件的读取流，并使用一个小缓冲区将其复制到客户端。 通过 GetResponseStream 方法发送 HttpRequest.GetResponseStream 方法创建一个对象，允许将 HTTP 响应的块作为内容流准备好时发送。这种方法更为手动，需要在发送内容之前定义状态、头部和内容大小。 Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // 在这种发送形式中，必须在发送内容之前定义状态和头部 var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // 在这种发送形式中，必须在发送内容之前定义内容大小 requestStreamManager.SetContentLength ( fs.Length ); // 如果不知道内容大小，可以使用分块编码来发送内容 requestStreamManager.SendChunked = true; // 然后，将内容写入输出流 await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } 通过 StreamContent 发送内容 StreamContent 类允许将数据源作为字节流发送内容。这种发送形式更为简单，消除了之前的要求，甚至允许使用 压缩编码 来减少内容大小。 Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important 在这种类型的内容中，不要将流封装在 using 块中。内容将在 HTTP 服务器完成内容流时自动丢弃，无论是否有错误。"
  },
  "docs/cn/features/cors.html": {
    "href": "docs/cn/features/cors.html",
    "title": "启用 Sisk 中的 CORS（跨源资源共享） | Sisk",
    "keywords": "启用 Sisk 中的 CORS（跨源资源共享） Sisk 有一个工具，可以用于处理公开服务时的 跨源资源共享 (CORS)。此功能不是 HTTP 协议的一部分，而是由 W3C 定义的 Web 浏览器的特定功能。这种安全机制可以防止 Web 页面向与提供 Web 页面的域不同的域发送请求。服务提供者可以允许某些域访问其资源，或者只允许一个域。 同源 要将资源识别为“同源”，请求必须在其请求中标识 Origin 标头： GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... 并且远程服务器必须用具有与请求的源相同值的 Access-Control-Allow-Origin 标头响应： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... 此验证是 显式 的：主机、端口和协议必须与请求的相同。检查以下示例： 服务器响应其 Access-Control-Allow-Origin 为 https://example.com： https://example.net - 域不同。 http://example.com - 方案不同。 http://example.com:5555 - 端口不同。 https://www.example.com - 主机不同。 在规范中，仅允许请求和响应的标头的语法。URL 路径被忽略。默认端口（HTTP 的 80 和 HTTPS 的 443）被省略。 Origin: null Origin: <scheme>://<hostname> Origin: <scheme>://<hostname>:<port> 启用 CORS 您可以在 ListeningHost 中使用 CrossOriginResourceSharingHeaders 对象。 您可以在初始化服务器时配置 CORS： static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } 上面的代码将为 所有响应 发送以下标头： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type 这些标头需要发送给 Web 客户端，包括错误和重定向。 您可能会注意到 CrossOriginResourceSharingHeaders 类有两个类似的属性：AllowOrigin 和 AllowOrigins。注意，一个是复数，另一个是单数。 AllowOrigin 属性是静态的：仅指定的源将被发送给所有响应。 AllowOrigins 属性是动态的：服务器检查请求的源是否包含在此列表中。如果找到，则它将被发送给该源的响应。 源中的通配符 或者，您可以在响应的源中使用通配符 (*) 来指定任何源都可以访问资源。然而，此值不允许用于具有凭据（授权标头）的请求，并且此操作 将导致错误。 您可以通过显式列出将被允许的源来解决这个问题，或者使用 AllowOrigins 属性，也可以使用 AutoAllowOrigin 常量作为 AllowOrigin 的值。此魔术属性将为请求的 Origin 标头的相同值定义 Access-Control-Allow-Origin 标头。 应用 CORS 的其他方式 如果您处理 服务提供者，您可以覆盖配置文件中定义的值： static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // 将覆盖配置文件中定义的源。 cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } 在特定路由上禁用 CORS UseCors 属性可用于路由和所有路由属性，并且可以使用以下示例禁用： [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } 替换响应中的值 您可以在路由器操作中显式替换或删除值： [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // 删除 Access-Control-Allow-Credentials 标头 request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // 替换 Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } 预检请求 预检请求是客户端在实际请求之前发送的 OPTIONS 方法请求。 Sisk 服务器将始终用 200 OK 和适用的 CORS 标头响应请求，然后客户端可以继续实际请求。这种情况仅在为 Options 显式配置路由方法时不适用。 全局禁用 CORS 不可能这样做。要不使用 CORS，请不要配置它。"
  },
  "docs/cn/features/discard-syntax.html": {
    "href": "docs/cn/features/discard-syntax.html",
    "title": "放弃语法 | Sisk",
    "keywords": "放弃语法 HTTP 服务器可以用于监听来自操作的回调请求，例如 OAuth 身份验证，并在接收到该请求后可以被丢弃。这在需要后台操作但不想为其设置整个 HTTP 应用的情况下非常有用。 以下示例展示了如何在端口 5555 上创建一个监听 HTTP 服务器，并等待下一个上下文： using (var server = HttpServer.CreateListener(5555)) { // 等待下一个 HTTP 请求 var context = await server.WaitNextAsync(); Console.WriteLine($\"请求路径: {context.Request.Path}\"); } WaitNext 函数等待下一个已完成的请求处理上下文。一旦获得此操作的结果，服务器已经完全处理了请求并将响应发送给客户端。"
  },
  "docs/cn/features/instancing.html": {
    "href": "docs/cn/features/instancing.html",
    "title": "依赖注入 | Sisk",
    "keywords": "依赖注入 通常，会为请求的生命周期内持续存在的成员和实例分配内存，例如数据库连接、已验证的用户或会话令牌。实现这一点的一种可能方法是通过 HttpContext.RequestBag ，它创建一个在整个请求生命周期内持续存在的字典。 该字典可以被 请求处理程序 访问，并在整个请求过程中定义变量。例如，验证用户的请求处理程序将用户设置在 HttpContext.RequestBag 中，在请求逻辑中，可以通过 HttpContext.RequestBag.Get<User>() 来检索该用户。 以下是一个示例： RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } 这是对此操作的初步示例。User 实例是在专门用于身份验证的请求处理程序中创建的，并且所有使用此请求处理程序的路由都保证在其 HttpContext.RequestBag 实例中将有一个 User。 可以通过诸如 GetOrAdd 或 GetOrAddAsync 之类的方法来定义获取实例的逻辑，当实例尚未在 RequestBag 中定义时。 从 1.3 版本开始，引入了静态属性 HttpContext.Current ，允许访问当前执行的 HttpContext 的请求上下文。这使得可以在当前请求之外暴露 HttpContext 的成员，并在路由对象中定义实例。 以下示例定义了一个控制器，该控制器具有通常由请求上下文访问的成员。 Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // 创建一个 DbContext 或获取现有的一个 return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // 如果属性在请求包中没有定义 User 时访问，将抛出异常 public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // 也支持暴露 HttpRequest 实例 public HttpRequest Request { get => HttpContext.Current.Request; } } 并定义继承自控制器的类型： Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } 对于上面的示例，您需要在路由器中配置一个 值处理程序 ，以便路由器返回的对象转换为有效的 HttpResponse。 请注意，方法不带有 HttpRequest request 参数，如其他方法中所示。这是因为，从 1.3 版本开始，路由器支持两种类型的委托用于路由响应：RouteAction ，这是默认的委托，它接收一个 HttpRequest 参数，以及 ParameterlessRouteAction 。HttpRequest 对象仍然可以通过静态 HttpContext 的 Request 属性访问。 在上面的示例中，我们定义了一个可处置对象 DbContext ，并且我们需要确保在 HTTP 会话结束时处置所有在 DbContext 中创建的实例。为此，我们可以使用两种方法来实现这一点。一种方法是创建一个在路由器操作之后执行的 请求处理程序 ，另一种方法是通过自定义 服务器处理程序。 对于第一种方法，我们可以直接在继承自 RouterModule 的 OnSetup 方法中内联创建请求处理程序： Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // 获取请求处理程序上下文中定义的 DbContext 并处置它 ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip 从 Sisk 1.4 版本开始，引入了属性 HttpServerConfiguration.DisposeDisposableContextValues ，它默认启用，用于定义 HTTP 服务器是否应在 HTTP 会话关闭时处置上下文包中的所有 IDisposable 值。 上述方法将确保在 HTTP 会话结束时处置 DbContext。您可以为需要在响应结束时处置的其他成员执行此操作。 对于第二种方法，您可以创建一个自定义的 服务器处理程序 ，它将在 HTTP 会话结束时处置 DbContext。 Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } 并在应用程序生成器中使用它： Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); 这是处理代码清理并将请求的依赖项与将使用的模块类型分离的一种方法，减少了路由器操作中重复的代码量。这是一种类似于在 ASP.NET 等框架中使用依赖注入的做法。"
  },
  "docs/cn/features/logging.html": {
    "href": "docs/cn/features/logging.html",
    "title": "日志记录 | Sisk",
    "keywords": "日志记录 您可以配置 Sisk 自动写入访问和错误日志。它也可以定义日志轮换、扩展和频率。 LogStream 类提供了一种异步写入日志和保持可等待写入队列的方式。 在本文中，我们将向您展示如何为您的应用程序配置日志记录。 基于文件的访问日志 日志写入文件时，会打开文件，写入行文本，然后为每行写入关闭文件。这种过程是为了保持日志的写入响应性。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } 上面的代码将写入所有传入的请求到 logs/access.log 文件。注意，如果文件不存在，它将自动创建，但是文件夹不会自动创建。您不需要创建 logs/ 目录，因为 LogStream 类会自动创建它。 基于流的日志记录 您可以将日志文件写入 TextWriter 对象实例，例如 Console.Out，通过在构造函数中传递 TextWriter 对象： Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); 对于流式日志记录中的每个消息，TextWriter.Flush() 方法都会被调用。 访问日志格式 您可以通过预定义变量自定义访问日志格式。考虑以下行： config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; 它将写入一条消息，如下所示： 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] 您可以通过表格中描述的格式格式化日志文件： 值 代表什么 示例 %dd 月份中的某一天（以两位数字格式化） 05 %dmmm 月份的全名 July %dmm 月份的缩写（三个字母） Jul %dm 月份号（以两位数字格式化） 07 %dy 年份（以四位数字格式化） 2023 %th 12 小时格式的小时 03 %tH 24 小时格式的小时（HH） 15 %ti 分钟（以两位数字格式化） 30 %ts 秒（以两位数字格式化） 45 %tm 毫秒（以三位数字格式化） 123 %tz 时区偏移（以 UTC 为单位的总小时） +03:00 %ri 客户端的远程 IP 地址 192.168.1.100 %rm HTTP 方法（大写） GET %rs URI 方案（http/https） https %ra URI 权威（域） example.com %rh 请求的主机 www.example.com %rp 请求的端口 443 %rz 请求的路径 /path/to/resource %rq 查询字符串 ?key=value&another=123 %sc HTTP 响应状态代码 200 %sd HTTP 响应状态描述 OK %lin 请求的可读大小 1.2 KB %linr 请求的原始大小（字节） 1234 %lou 响应的可读大小 2.5 KB %lour 响应的原始大小（字节） 2560 %lms 耗时的毫秒数 120 %ls 执行状态 Executed 日志轮换 Tip 在 Sisk 0.15 及更早版本中，此功能仅在 Sisk.ServiceProvider 包中可用。在 Sisk 0.16 及更高版本中，此功能已在核心包中实现。 您可以配置 HTTP 服务器，当日志文件达到一定大小时，将其轮换到压缩的 .gz 文件。大小是由您定义的阈值周期性检查的。 config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); 上面的代码将每 6 小时检查一次 LogStream 的文件是否达到 1MB 限制。如果达到限制，文件将被压缩到 .gz 文件，然后 access.log 将被清空。 在此过程中，写入文件将被锁定，直到文件被压缩和清空。在此期间，所有要写入的行将在队列中等待压缩完成。 此功能仅适用于基于文件的 LogStreams。 错误日志记录 当服务器不将错误抛给调试器时，它会将错误转发到日志写入器。您可以使用以下代码配置错误写入： config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); 此属性仅在错误未被回调或 Router.CallbackErrorHandler 属性捕获时写入日志。 服务器写入的错误始终包含日期和时间、请求头（不包括正文）、错误跟踪和内部异常跟踪（如果有）。 其他日志实例 您的应用程序可以有零个或多个 LogStreams，没有限制。因此，您可以将应用程序的日志定向到其他文件，而不是默认的 AccessLog 或 ErrorLog。 LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"应用程序在 {0} 启动\", DateTime.Now); 扩展 LogStream 您可以扩展 LogStream 类以写入自定义格式，兼容当前的 Sisk 日志引擎。以下示例允许通过 Spectre.Console 库将彩色消息写入控制台： CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } 另一种自动为每个请求/响应写入自定义日志的方法是创建 HttpServerHandler。以下示例更为完整。它将请求和响应的正文以 JSON 格式写入控制台。它可以用于调试请求。这个示例使用了 ContextBag 和 HttpServerHandler。 Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // 在此时，连接已经打开，客户端已经发送了指定内容为 JSON 的头。 // 下一行读取内容并将其存储在请求中。 // // 如果在请求操作中不读取内容，GC 可能会在发送响应给客户端后收集内容，因此内容可能在响应关闭后不可用。 // _ = request.RawBody; // 在上下文中添加提示，指示此请求具有 JSON 正文 request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // 使用 CypherPotato.LightJson 库重新格式化 JSON var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // 检查响应是否为 JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // 获取内部服务器处理状态 responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/cn/features/server-sent-events.html": {
    "href": "docs/cn/features/server-sent-events.html",
    "title": "服务器发送事件 | Sisk",
    "keywords": "服务器发送事件 Sisk 支持开箱即用地通过服务器发送事件发送消息。您可以创建可 disposable 和持久的连接，在运行时获取连接并使用它们。 此功能有一些受到浏览器限制的限制，例如只能发送文本消息，无法永久关闭连接。服务器端关闭的连接将由客户端每 5 秒（某些浏览器为 3 秒）尝试重新连接。 这些连接对于在不每次由客户端请求信息的情况下，从服务器向客户端发送事件非常有用。 创建 SSE 连接 SSE 连接的工作方式与常规 HTTP 请求类似，但不是发送响应并立即关闭连接，而是保持连接打开以发送消息。 调用 HttpRequest.GetEventSource() 方法，请求将进入等待状态，同时创建 SSE 实例。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Hello, world!\"); return sse.Close(); }); 在上面的代码中，我们创建了一个 SSE 连接并发送一条“Hello, world”消息，然后从服务器端关闭 SSE 连接。 Note 当关闭服务器端连接时，默认情况下客户端将尝试再次连接，该连接将重新启动，永久执行该方法。 通常，在从服务器关闭连接时，转发终止消息以防止客户端尝试再次连接是很常见的。 追加头部 如果您需要发送头部，可以在发送任何消息之前使用 HttpRequestEventSource.AppendHeader 方法。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hello!\"); return sse.Close(); }); 注意，必须在发送任何消息之前发送头部。 等待失败连接 连接通常在服务器由于可能的客户端断开连接而无法发送消息时终止。因此，连接会自动终止，类的实例将被丢弃。 即使重新连接，类的实例也不会工作，因为它与之前的连接相关联。在某些情况下，您可能需要在稍后需要此连接，而不想通过路由的回调方法管理它。 为此，我们可以用标识符标识 SSE 连接，并在稍后使用它，甚至在路由的回调之外。此外，我们使用 WaitForFail 标记连接，以便在不终止路由和自动终止连接的情况下。 KeepAlive 中的 SSE 连接将等待发送错误（由断开连接引起）以恢复方法执行。也可以为此设置超时。在超时后，如果未发送任何消息，则连接将被终止，执行将恢复。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // 在 15 秒内无任何消息时终止连接 return sse.Close(); }); 上述方法将创建连接，处理它并等待断开连接或错误。 HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // 连接仍然活跃 evs.Send(\"Hello again!\"); } 上面的代码片段将尝试查找新创建的连接，如果存在，则向其发送消息。 所有已标识的活动服务器连接都将可在集合 HttpServer.EventSources 中。该集合仅存储活动和已标识的连接。关闭的连接将从集合中删除。 Note 值得注意的是，KeepAlive 由可能以无法控制的方式连接到 Sisk 的组件（例如，Web 代理，HTTP 内核或网络驱动程序）建立的限制，并且它们在一段时间内后关闭空闲连接。 因此，通过发送周期性 ping 或延长连接关闭前的时间来保持连接打开非常重要。阅读下一节以更好地了解发送周期性 ping。 设置连接 ping 策略 Ping 策略是一种自动向客户端发送周期性消息的方法。此功能允许服务器在不将连接无限期保持打开的情况下，了解客户端何时已断开与该连接的连接。 [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } 在上面的代码中，每 5 秒将向客户端发送一个新的 ping 消息。这将保持 TCP 连接活跃，防止由于不活动而关闭。此外，当发送消息失败时，连接将自动关闭，释放连接使用的资源。 查询连接 您可以使用谓词搜索活动连接的标识符，以便能够广播，例如。 HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcasting to all event sources that starts with 'my-connection-'\"); } 您还可以使用 All 方法获取所有活动 SSE 连接。"
  },
  "docs/cn/features/websockets.html": {
    "href": "docs/cn/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk 也支持 Web Sockets，可以接收和发送消息到客户端。 此功能在大多数浏览器中运行良好，但在 Sisk 中仍处于实验阶段。如果您发现任何错误，请在 GitHub 上报告。 异步接受和接收消息 下面的示例展示了 WebSocket 在实践中的工作原理，包括建立连接、接收消息并在控制台中显示。 WebSocket 接收到的所有消息都是以字节形式接收的，因此您需要在收到消息时解码它们。 默认情况下，消息被分成块，最后一个块作为消息的最后一个数据包发送。您可以使用 WebSocketBufferSize 标志配置数据包大小。此缓冲适用于发送和接收消息。 router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // 获取接收消息的 HttpWebSocket 上下文 HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); Note 不要以这种方式使用异步事件。您可能会在 HTTP 服务器域之外抛出异常，这可能会使您的应用程序崩溃。 如果您需要处理异步代码并同时处理多个消息，可以使用消息循环： router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Received message: {messageText}\"); await ws.SendAsync(\"Hello from server!\"); } return ws.Close(); }); 同步接受和接收消息 下面的示例包含一种使用同步 WebSocket 的方法，在这种方法中，您接收消息，处理它们，然后完成使用套接字。 router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); 发送消息 Send 方法有三个重载，允许您发送文本、字节数组或字节跨度。如果服务器的 WebSocketBufferSize 标志大于总有效负载大小，则所有这些方法都会被分块。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // 将被编码为 UTF-8 字节数组 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } 等待 WebSocket 关闭 WaitForClose() 方法阻塞当前调用栈，直到连接被客户端或服务器终止。 这样，请求回调的执行将被阻塞，直到客户端或服务器断开连接。 您也可以使用 Close() 方法手动关闭连接。此方法返回一个空的 HttpResponse 对象，该对象不会发送到客户端，但作为接收 HTTP 请求的函数的返回值。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // 等待客户端关闭连接 ws.WaitForClose(); // 等待 60 秒内没有消息交换 // 或直到某一方关闭连接 ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Ping 策略 与服务器端事件中的 ping 策略类似，您也可以配置 ping 策略，以在 TCP 连接中保持活动状态。 ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/cn/fundamentals/request-handlers.html": {
    "href": "docs/cn/fundamentals/request-handlers.html",
    "title": "请求处理 | Sisk",
    "keywords": "请求处理 请求处理器，也称为“中间件”，是运行在请求在路由器上执行之前或之后的函数。它们可以为每个路由或每个路由器定义。 请求处理器有两种类型： BeforeResponse：定义请求处理器将在调用路由器操作之前执行。 AfterResponse：定义请求处理器将在调用路由器操作之后执行。在此上下文中发送 HTTP 响应将覆盖路由器操作的响应。 两种请求处理器都可以覆盖实际路由器回调函数的响应。另外，请求处理器可以用于验证请求，例如身份验证、内容或其他信息，例如存储信息、日志或可以在响应之前或之后执行的其他步骤。 这样，请求处理器可以中断整个执行过程并在完成周期之前返回响应，丢弃过程中的所有其他内容。 示例：假设用户身份验证请求处理器未能对其进行身份验证。它将防止请求生命周期继续并挂起。如果这发生在第二个请求处理器中，第三个及以后的处理器将不会被评估。 创建请求处理器 要创建请求处理器，我们可以创建一个继承 IRequestHandler 接口的类，以以下格式： Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // 返回 null 表示请求周期可以继续 return null; } else { // 返回 HttpResponse 对象表示此响应将覆盖相邻的响应。 return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 在上面的示例中，我们指示如果请求中存在 Authorization 标头，则应继续并调用下一个请求处理器或路由器回调，否则将返回未经授权的响应。 每当请求处理器返回 null 时，表示请求必须继续并调用下一个对象或以路由器的响应结束周期。 将请求处理器与单个路由关联 您可以为路由定义一个或多个请求处理器。 Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // before request handler new ValidateJsonContentRequestHandler(), // before request handler // -- 方法 IndexPage 将在此处执行 new WriteToLogRequestHandler() // after request handler }); 或者创建一个 Route 对象： Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); 将请求处理器与路由器关联 您可以定义一个全局请求处理器，它将在路由器上的所有路由上运行。 Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; 将请求处理器与属性关联 您可以将请求处理器定义为方法属性，连同路由属性。 Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } } 请注意，需要传递所需的请求处理器类型，而不是对象实例。这样，请求处理器将由路由器解析器实例化。您可以使用 ConstructorArguments 属性传递类构造函数的参数。 示例： Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } 您还可以创建自己的属性，它实现了 RequestHandler： Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } 并将其用作： Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } 跳过全局请求处理器 在路由器上定义全局请求处理器后，您可以在特定路由上忽略此请求处理器。 Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: 与全局请求处理器中相同的实例 new AuthenticateUserRequestHandler() // wrong: 不会跳过全局请求处理器 } }); Note 如果您要跳过请求处理器，则必须使用与之前实例化的相同的引用来跳过。创建另一个请求处理器实例将不会跳过全局请求处理器，因为其引用将更改。请记住在 GlobalRequestHandlers 和 BypassGlobalRequestHandlers 中使用相同的请求处理器引用。"
  },
  "docs/cn/fundamentals/requests.html": {
    "href": "docs/cn/fundamentals/requests.html",
    "title": "请求 | Sisk",
    "keywords": "请求 请求是代表 HTTP 请求消息的结构。 HttpRequest 对象包含处理 HTTP 消息的有用函数，遍布您的应用程序。 一个 HTTP 请求由方法、路径、版本、头部和正文组成。 在本文档中，我们将教您如何获取这些元素。 获取请求方法 要获取接收到的请求的方法，可以使用 Method 属性： static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } 此属性返回请求的方法，表示为 HttpMethod 对象。 Note 与路由方法不同，此属性不服务于 RouteMethod.Any 项。相反，它返回实际的请求方法。 获取请求 URL 组件 您可以通过请求的某些属性从 URL 中获取各种组件。对于此示例，让我们考虑以下 URL： http://localhost:5000/user/login?email=foo@bar.com 组件名称 描述 组件值 Path 获取请求路径。 /user/login FullPath 获取请求路径和查询字符串。 /user/login?email=foo@bar.com FullUrl 获取整个 URL 请求字符串。 http://localhost:5000/user/login?email=foo@bar.com Host 获取请求主机。 localhost Authority 获取请求主机和端口。 localhost:5000 QueryString 获取请求查询。 ?email=foo@bar.com Query 获取请求查询作为命名值集合。 {StringValueCollection 对象} IsSecure 确定请求是否使用 SSL（true）或不使用（false）。 false 您也可以使用 HttpRequest.Uri 属性，该属性包含上述所有内容。 获取请求正文 一些请求包含正文，例如表单、文件或 API 事务。您可以从以下属性获取请求正文： // 以字符串形式获取请求正文，使用请求编码作为编码器 string body = request.Body; // 或以字节数组形式获取 byte[] bodyBytes = request.RawBody; // 或者，您可以流式传输它。 Stream requestStream = request.GetRequestStream(); 还可以使用 HasContents 和 IsContentAvailable 属性确定请求是否包含正文以及是否已加载。 无法通过 GetRequestStream 多次读取请求内容。如果使用此方法读取，则 RawBody 和 Body 的值也将不可用。在请求的上下文中不需要处理请求流，因为它会在创建的 HTTP 会话结束时被处理。您还可以使用 HttpRequest.RequestEncoding 属性获取解码请求的最佳编码。 服务器对读取请求内容有限制，这适用于 HttpRequest.Body 和 HttpRequest.RawBody。这些属性将整个输入流复制到一个局部缓冲区，大小与 HttpRequest.ContentLength 相同。 如果客户端发送的内容大于 HttpServerConfiguration.MaximumContentLength（在用户配置中定义），则返回状态代码 413 的响应给客户端。如果没有配置限制或限制太大，服务器将在客户端发送的内容超过 Int32.MaxValue（2 GB）时抛出 OutOfMemoryException，并且尝试通过上述属性之一访问内容。您仍然可以通过流式处理来处理内容。 Note 虽然 Sisk 允许这样做，但为了创建应用程序，始终遵循 HTTP 语义并避免在不允许内容的方法中获取或提供内容是一个好主意。请阅读有关 RFC 9110“HTTP 语义” 的信息。 获取请求上下文 HTTP 上下文是 Sisk 的一个独特对象，存储 HTTP 服务器、路由、路由器和请求处理程序信息。您可以使用它来组织自己在这些对象难以组织的环境中。 RequestBag 对象包含存储的信息，该信息从一个请求处理程序传递到另一个点，并可以在最终目标中使用。此对象也可以由在路由回调之后运行的请求处理程序使用。 Tip 此属性也可以通过 HttpRequest.Bag 属性访问。 Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 上面的请求处理程序将在请求包中定义 AuthenticatedUser，并可以在最终回调中使用： Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } 您还可以使用 Bag.Set() 和 Bag.Get() 帮助器方法按类型单例获取或设置对象。 Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } 获取表单数据 您可以使用以下示例在 NameValueCollection 中获取表单数据的值： Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } 获取多部分表单数据 Sisk 的 HTTP 请求允许您获取上传的多部分内容，例如文件、表单字段或任何二进制内容。 Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // 以下方法将整个请求输入读入 MultipartObject 数组 var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // 多部分表单数据对象的文件名。 // 如果对象不是文件，则返回 null。 Console.WriteLine(\"File name : \" + uploadedObject.Filename); // 多部分表单数据字段名称。 Console.WriteLine(\"Field name : \" + uploadedObject.Name); // 多部分表单数据内容长度。 Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // 根据文件头确定每个已知内容类型的图像格式。 // 如果内容不是公认的常见文件格式，则以下方法将返回 MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } 您可以阅读更多关于 Sisk 多部分表单对象及其方法、属性和功能的信息。 服务器发送事件支持 Sisk 支持 服务器发送事件，允许将块作为流发送并保持服务器和客户端之间的连接。 调用 HttpRequest.GetEventSource 方法将使 HttpRequest 进入其监听状态。从此，HTTP 请求的上下文不再期望 HttpResponse，因为它将与服务器发送的数据包重叠。 发送所有数据包后，回调必须返回 Close 方法，该方法将发送最终响应给服务器并指示流式处理已结束。 由于无法预测将要发送的所有数据包的总长度，因此无法使用 Content-Length 标头确定连接的末尾。 大多数浏览器的默认设置不支持服务器发送事件发送 HTTP 标头或除 GET 方法以外的方法。因此，在使用需要特定请求标头的请求处理程序的事件源请求时要小心，因为它们可能没有这些标头。 此外，大多数浏览器在收到所有数据包后如果客户端没有调用 EventSource.close 方法，则会重新启动流，这将导致服务器端进行无限的额外处理。为了避免此类问题，通常会发送一个最终数据包，指示事件源已完成发送所有数据包。 以下示例显示浏览器如何与支持服务器发送事件的服务器进行通信。 sse-example.html HTML <html> <body> <b>Fruits:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> 并逐渐将消息发送给客户端： Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { await serverEvents.SendAsync(fruit); await Task.Delay(1500); } return serverEvents.Close(); } } 运行此代码时，我们期望得到类似以下的结果： 解析代理 IP 和主机 Sisk 可以与代理一起使用，因此 IP 地址可以在客户端到代理的交易中被代理端点替换。 您可以在 Sisk 中使用 转发解析器 定义自己的解析器。 标头编码 标头编码可能是某些实现的问题。在 Windows 上，不支持 UTF-8 标头，因此使用 ASCII。Sisk 具有内置的编码转换器，可以用于解码不正确编码的标头。 此操作代价高昂，默认情况下禁用，但可以在 NormalizeHeadersEncodings 标志下启用。"
  },
  "docs/cn/fundamentals/responses.html": {
    "href": "docs/cn/fundamentals/responses.html",
    "title": "响应 | Sisk",
    "keywords": "响应 响应表示HTTP请求的对象，是服务器发送给客户端的HTTP响应，用来指示请求的资源、页面、文档、文件或其他对象。 一个HTTP响应由状态、头部和内容组成。 在本文档中，我们将教您如何使用Sisk构建HTTP响应。 设置HTTP状态 自HTTP/1.0以来，HTTP状态列表保持不变，Sisk支持所有这些状态。 HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 或使用流畅语法： new HttpResponse() .WithStatus(200) // 或 .WithStatus(HttpStatusCode.Ok) // 或 .WithStatus(HttpStatusInformation.Ok); 您可以在此处查看可用的HttpStatusCode的完整列表。您也可以通过使用HttpStatusInformation结构提供自己的状态代码。 正文和内容类型 Sisk支持本地.NET内容对象来发送响应正文。例如，您可以使用StringContent类发送JSON响应： HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); 服务器将始终尝试从您在内容中定义的内容中计算Content-Length，如果您没有在头部明确定义。如果服务器无法从响应内容中隐含地获取Content-Length头部，响应将使用分块编码发送。 您也可以通过发送StreamContent或使用GetResponseStream方法来流式传输响应。 响应头部 您可以添加、编辑或删除响应中发送的头部。下面示例演示了如何向客户端发送重定向响应： HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); 或使用流畅语法： new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); 当您使用HttpHeaderCollection的Add方法时，您正在添加一个头部到请求中，而不改变已经发送的头部。Set方法用指定的值替换具有相同名称的头部。HttpHeaderCollection的索引器内部调用Set方法来替换头部。 发送Cookie Sisk有方法方便地在客户端定义Cookie。通过此方法设置的Cookie已经URL编码并符合RFC-6265标准。 HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); 或使用流畅语法： new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); 还有其他更完整的版本相同的メソッド。 分块响应 您可以设置传输编码为分块，以发送大响应。 HttpResponse res = new HttpResponse(); res.SendChunked = true; 使用分块编码时，Content-Length头部会自动省略。 响应流 响应流是一种托管方式，允许您分段发送响应。这是比使用HttpResponse对象更底层的操作，因为它们需要您手动发送头部和内容，然后关闭连接。 此示例打开文件的只读流，将流复制到响应输出流，并不加载整个文件到内存中。这对于服务中型或大文件非常有用。 // 获取响应输出流 using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // 设置响应编码使用分块编码 // 并且您不应该在分块编码时发送content-length头部 responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // 将文件流复制到响应输出流 fileStream.CopyTo(responseStream.ResponseStream); // 关闭流 return responseStream.Close(); GZip、Deflate和Brotli压缩 您可以使用Sisk中的HTTP内容压缩发送压缩内容的响应。首先，将您的HttpContent对象封装在以下压缩器之一中，以向客户端发送压缩响应。 router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // 或 Content = new BrotliContent(new HtmlContent(myHtml)), // 或 Content = new DeflateContent(new HtmlContent(myHtml)), }; }); 您也可以将这些压缩内容与流一起使用。 router.MapGet(\"/archive.zip\", request => { // 不要在这里应用“using”。HttpServer将在发送响应后丢弃您的内容。 // after sending the response. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); 使用这些内容时，Content-Encoding头部会自动设置。 自动压缩 可以通过EnableAutomaticResponseCompression属性自动压缩HTTP响应。此属性自动将路由器中的响应内容封装在请求接受的可压缩内容中，前提是响应不是从CompressedContent继承的。 对于请求，只有一个可压缩的内容被选择，按照以下顺序： BrotliContent（br） GZipContent（gzip） DeflateContent（deflate） 如果请求指定接受这些压缩方法之一，则响应将自动压缩。 隐式响应类型 除了HttpResponse之外，您还可以使用其他返回类型，但需要配置路由器如何处理每种类型的对象。 概念是始终返回引用类型并将其转换为有效的HttpResponse对象。返回HttpResponse的路由不会进行任何转换。 值类型（结构）不能用作返回类型，因为它们与RouterCallback不兼容，因此必须将它们封装在ValueResult中才能在处理程序中使用。 考虑以下不使用HttpResponse作为返回类型的路由器模块的示例： [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } 因此，现在需要在路由器中定义如何处理每种类型的对象。对象始终是处理程序的第一个参数，输出类型必须是有效的HttpResponse。此外，路由的输出对象永远不应为空。 对于ValueResult类型，不需要指示输入对象是ValueResult，而只需要T，因为ValueResult是其原始组件的反射对象。 类型关联不会比较已注册的内容与路由器回调返回的对象类型。相反，它检查路由器结果的类型是否可分配给已注册的类型。 注册Object类型的处理程序将退回到所有先前未验证的类型。值处理程序的插入顺序也很重要，因此注册Object处理程序将忽略所有其他特定于类型的处理程序。始终首先注册特定的值处理程序以确保顺序。 Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // 注册对象的值处理程序必须是最后一个 // 值处理程序，用作后备 r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); 关于可枚举对象和数组的说明 实现了IEnumerable的隐式响应对象在通过定义的值处理程序转换之前，会通过ToArray()方法读取到内存中。为了发生这种情况，IEnumerable对象被转换为对象数组，响应转换器将始终接收Object[]而不是原始类型。 考虑以下场景： using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"String array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Object array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); 在上面的示例中，IEnumerable<string>转换器永远不会被调用，因为输入对象始终是Object[]，并且不能转换为IEnumerable<string>。但是，接收IEnumerable<object>的转换器将接收其输入，因为其值是兼容的。 如果您需要实际处理将被枚举的对象类型，则需要使用反射来获取集合元素的类型。所有可枚举对象（列表、数组和集合）都由HTTP响应转换器转换为对象数组。 实现了IAsyncEnumerable的值如果启用了ConvertIAsyncEnumerableIntoEnumerable属性，则由服务器自动处理，类似于IEnumerable。异步枚举被转换为阻塞枚举器，然后转换为同步对象数组。"
  },
  "docs/cn/fundamentals/routing.html": {
    "href": "docs/cn/fundamentals/routing.html",
    "title": "路由 | Sisk",
    "keywords": "路由 Router 是构建服务器的第一步。它负责存储 Route 对象，这些对象是将 URL 和其方法映射到服务器执行的操作的端点。每个操作负责接收请求并将响应发送回客户端。 路由是路径表达式（“路径模式”）和它们可以监听的 HTTP 方法的对。 当请求发送到服务器时，它将尝试找到匹配接收到的请求的路由，然后调用该路由的操作并将结果响应发送回客户端。 有多种方式在 Sisk 中定义路由：它们可以是静态的、动态的或自动扫描的，通过属性定义或直接在 Router 对象中定义。 Router mainRouter = new Router(); // 将 GET / 映射到以下操作 mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); 要了解路由可以做什么，我们需要了解请求可以做什么。 HttpRequest 将包含所有需要的信息。 Sisk 还包括一些额外的功能，可以加快整体开发速度。 对于服务器接收到的每个操作，都会调用类型为 RouteAction 的委托。该委托包含一个参数，持有 HttpRequest 对象，该对象包含有关请求的所有必要信息。从该委托返回的对象必须是 HttpResponse 或通过 隐式响应类型 映射到它的对象。 匹配路由 当请求发送到 HTTP 服务器时，Sisk 搜索满足请求路径表达式的路由。该表达式始终在路由和请求路径之间进行测试，而不考虑查询字符串。 此测试没有优先级，并且仅限于单个路由。 当没有路由与该请求匹配时，返回 Router.NotFoundErrorHandler 响应给客户端。 当路径模式匹配，但 HTTP 方法不匹配时，发送 Router.MethodNotAllowedErrorHandler 响应给客户端。 Sisk 检查路由碰撞的可能性，以避免这些问题。 当定义路由时，Sisk 将查找可能与正在定义的路由碰撞的可能路由。 该测试包括检查路径和路由设置为接受的方法。 使用路径模式创建路由 您可以使用各种 SetRoute 方法定义路由。 // SetRoute 方式 mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // Map* 方式 mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 空 200 ok }); // Route.* 帮助方法 mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // StreamContent 内部 // 流在发送响应后被释放。 Content = new StreamContent(imageStream) }; }); // 多个参数 mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); RouteParameters 属性的 HttpResponse 包含有关请求路径变量的所有信息。 每个发送到服务器的路径在执行路径模式测试之前都会被规范化，遵循以下规则： 所有空段都从路径中删除，例如：////foo//bar 变为 /foo/bar。 路径匹配是 区分大小写 的，除非 Router.MatchRoutesIgnoreCase 设置为 true。 Query 和 RouteParameters 属性的 HttpRequest 返回 StringValueCollection 对象，其中每个索引属性返回非空 StringValue，可以用作选项/单子将其原始值转换为托管对象。 以下示例读取路由参数“id”并从中获取 Guid。如果参数不是有效的 Guid，抛出异常，并在服务器不处理 Router.CallbackErrorHandler 时返回 500 错误给客户端。 mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note 路径的尾部 / 在请求路径和路由路径中都被忽略，即，如果您尝试访问定义为 /index/page 的路由，您也可以使用 /index/page/ 访问它。 您还可以通过启用 ForceTrailingSlash 标志强制 URL 以 / 结尾。 使用类实例创建路由 您还可以使用反射和 RouteAttribute 属性动态定义路由。这样，具有此属性的类的实例将在目标路由器中定义其路由。 要将方法定义为路由，它必须用 RouteAttribute 标记，例如该属性本身或 RouteGetAttribute。该方法可以是静态的、实例的、公共的或私有的。当使用 SetObject(type) 或 SetObject<TType>() 方法时，实例方法将被忽略。 Controller/MyController.cs C# public class MyController { // 将匹配 GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // 静态方法也可以 [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } 以下行将定义 MyController 的 Index 和 Hello 方法作为路由，因为它们都被标记为路由，并且提供了类的实例，而不是其类型。如果提供的是其类型而不是实例，则仅定义静态方法。 var myController = new MyController(); mainRouter.SetObject(myController); 从 Sisk 0.16 版开始，可以启用 AutoScan，它将搜索实现 RouterModule 的用户定义类，并将其自动关联到路由器。这不支持 AOT 编译。 mainRouter.AutoScanModules<ApiController>(); 上述指令将搜索所有实现 ApiController 的类型，但不包括该类型本身。两个可选参数指示方法将如何搜索这些类型。第一个参数表示将在其中搜索类型的程序集，第二个参数表示定义类型的方式。 正则路由 您可以将路由标记为使用正则表达式进行解释，而不是使用默认的 HTTP 路径匹配方法。 Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); 或者使用 RegexRoute 类： mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); })); 您还可以从正则表达式模式中捕获组到 HttpRequest.RouteParameters 内容中： Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } } 路由前缀 您可以使用 RoutePrefix 属性为类或模块中的所有路由添加前缀，并将前缀设置为字符串。 请参见以下使用 BREAD 体系结构（浏览、读取、编辑、添加和删除）的示例： Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } 在上面的示例中，HttpResponse 参数已省略，以便通过全局上下文 HttpContext.Current 使用。请参阅下一节以获取更多信息。 无请求参数的路由 路由可以在不需要 HttpRequest 参数的情况下定义，并且仍然可以在请求上下文中获取请求及其组件。 让我们考虑一个 ControllerBase 抽象，它作为 API 的所有控制器的基础，并且该抽象提供 Request 属性来获取当前线程的 HttpRequest。 Controller/ControllerBase.cs C# public abstract class ControllerBase { // 从当前线程获取请求 public HttpRequest Request { get => HttpContext.Current.Request; } // 下面的行从当前 HTTP 会话获取数据库，或者如果不存在则创建一个新的。 public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } 并且所有其后代都可以使用不带请求参数的路由语法： Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // 从当前请求读取 JSON 数据 UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } 有关当前上下文和依赖注入的更多详细信息，请参阅 依赖注入 教程。 任意方法路由 您可以定义一个路由，以便仅通过其路径匹配，并跳过 HTTP 方法。这可以在路由回调内部对方法进行验证时很有用。 // 将匹配 / 的任何 HTTP 方法 mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); 任意路径路由 任意路径路由将测试从 HTTP 服务器接收的任何路径，并且仅限于路由方法。 如果路由方法为 RouteMethod.Any 且路由在其路径表达式中使用 Route.AnyPath，则此路由将监听来自 HTTP 服务器的所有请求，并且无法定义其他路由。 // 下面的路由将匹配所有 POST 请求 mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); 忽略大小写路由匹配 默认情况下，路由与请求的解释是区分大小写的。要使其忽略大小写，请启用此选项： mainRouter.MatchRoutesIgnoreCase = true; 这也将为使用正则表达式匹配的路由启用 RegexOptions.IgnoreCase 选项。 未找到（404）回调处理程序 您可以为请求不匹配任何已知路由时创建自定义回调。 mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // 自 0.14 版以来 Content = new HtmlContent(\"<h1>Not found</h1>\") // 旧版本 Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; 方法不允许（405）回调处理程序 您还可以为请求匹配其路径但不匹配方法时创建自定义回调。 mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; 内部错误处理程序 路由回调可以在服务器执行期间抛出错误。如果不正确处理，可能会终止 HTTP 服务器的整体功能。路由器具有一个回调，当路由回调失败并防止服务中断时将被调用。 此方法仅在 ThrowExceptions 设置为 false 时可访问。 mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/cn/getting-started.html": {
    "href": "docs/cn/getting-started.html",
    "title": "入门指南 | Sisk",
    "keywords": "入门指南 欢迎来到 Sisk 文档！ 最后，什么是 Sisk Framework？它是一个开源的轻量级库，使用 .NET 构建，旨在成为最小化、灵活和抽象的。它允许开发人员快速创建互联网服务，几乎不需要任何配置。Sisk 使您的现有应用程序能够拥有一个托管的 HTTP 模块，完整且可丢弃。 Sisk 的价值观包括代码透明度、模块化、性能和可扩展性，并且可以处理各种类型的应用程序，例如 Restful、JSON-RPC、Web-sockets 等。 其主要功能包括： 资源 描述 路由 支持前缀、自定义方法、路径变量、值转换器等的路径路由器。 请求处理器 也称为中间件，提供一个接口来构建自己的请求处理器，与请求之前或之后的操作一起工作。 压缩 使用 Sisk轻松压缩响应内容。 Web sockets 提供接受完整 Web sockets 的路由，用于读取和写入客户端。 服务器发送事件 提供向支持 SSE 协议的客户端发送服务器事件的功能。 日志记录 简化日志记录。记录错误、访问、定义按大小轮换日志、同一日志的多个输出流等。 多主机 为多个端口创建 HTTP 服务器，每个端口都有自己的路由器，每个路由器都有自己的应用程序。 服务器处理器 扩展您自己的 HTTP 服务器实现。使用扩展、改进和新功能进行自定义。 第一步 Sisk 可以在任何 .NET 环境中运行。在本指南中，我们将教您如何使用 .NET 创建 Sisk 应用程序。如果您尚未安装它，请从 这里 下载 SDK。 在本教程中，我们将介绍如何创建项目结构、接收请求、获取 URL 参数和发送响应。本指南将重点介绍使用 C# 构建一个简单的服务器。您也可以使用您喜欢的编程语言。 Note 您可能对快速入门项目感兴趣。请查看 此存储库 以获取更多信息。 创建项目 让我们将项目命名为\"My Sisk Application\"。一旦您设置了 .NET，您可以使用以下命令创建项目： dotnet new console -n my-sisk-application 接下来，导航到您的项目目录，并使用 .NET 实用工具安装 Sisk： cd my-sisk-application dotnet add package Sisk.HttpServer 您可以在 这里 找到在项目中安装 Sisk 的其他方法。 现在，让我们创建一个 HTTP 服务器实例。对于这个示例，我们将配置它以监听端口 5000。 构建 HTTP 服务器 Sisk 允许您一步一步地手动构建应用程序，因为它路由到 HttpServer 对象。然而，这可能对于大多数项目来说并不方便。因此，我们可以使用构建器方法，它使得让应用程序启动变得更容易。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } 了解 Sisk 的每个重要组件至关重要。稍后在本文档中，您将了解更多关于 Sisk 工作原理的信息。 手动（高级）设置 您可以在文档的 此部分 中了解每个 Sisk 机制的工作原理，它解释了 HttpServer、Router、ListeningPort 和其他组件之间的行为和关系。"
  },
  "docs/cn/installing.html": {
    "href": "docs/cn/installing.html",
    "title": "安装 | Sisk",
    "keywords": "安装 您可以通过 Nuget、dotnet cli 或 其他选项 安装 Sisk。您可以通过在开发者控制台中运行以下命令轻松设置 Sisk 环境： dotnet add package Sisk.HttpServer 此命令将在您的项目中安装 Sisk 的最新版本。"
  },
  "docs/cn/native-aot.html": {
    "href": "docs/cn/native-aot.html",
    "title": "Native AOT 支持 | Sisk",
    "keywords": "Native AOT 支持 .NET Native AOT 允许发布本机 .NET 应用程序，这些应用程序是自给自足的，不需要在目标主机上安装 .NET 运行时。另外，Native AOT 提供诸如： 应用程序大小大大减小 初始化速度大大提高 内存消耗降低 Sisk Framework 本质上允许几乎所有功能使用 Native AOT，而无需对源代码进行改造以适应 Native AOT。 不支持的功能 然而，Sisk 使用反射，尽管很少，为某些功能提供支持。下面提到的功能可能在本机代码执行期间部分可用或完全不可用： 自动扫描模块 的路由器：此资源扫描执行程序集中的嵌入类型，并注册符合 路由器模块 的类型。此资源需要可以在程序集修剪期间排除的类型。 Sisk 中的所有其他功能都与 AOT 兼容。通常会找到一个或多个方法，这些方法会产生 AOT 警告，但是相同的方法，如果没有在此处提及，具有重载，可以传递类型、参数或类型信息，以帮助 AOT 编译器编译对象。"
  },
  "docs/cn/registering-namespace.html": {
    "href": "docs/cn/registering-namespace.html",
    "title": "在 Windows 上配置命名空间预留 | Sisk",
    "keywords": "在 Windows 上配置命名空间预留 Sisk 与 HttpListener 网络接口一起工作，将虚拟主机绑定到系统以侦听请求。 在 Windows 上，此绑定有一些限制，只允许将 localhost 绑定为有效主机。当尝试侦听另一个主机时，服务器会抛出访问被拒绝错误。此教程解释了如何授予在系统上侦听任何主机的授权。 Namespace Setup.bat BATCH @echo off :: 在这里插入前缀，不要包含空格或引号 SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause 在 PREFIX 中，是服务器将要侦听的前缀（“侦听主机->端口”）。它必须以 URL 方案、主机、端口和末尾斜杠的格式编写，例如： Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ 这样，您就可以通过以下方式在应用程序中侦听： Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/cn/ssl.html": {
    "href": "docs/cn/ssl.html",
    "title": "使用 SSL | Sisk",
    "keywords": "使用 SSL 在开发中使用 SSL 可能是必要的，尤其是在需要安全的环境中，例如大多数 Web 开发场景。Sisk 构建在 HttpListener 之上，HttpListener 不支持原生的 HTTPS，只支持 HTTP。然而，有一些变通方法可以让你在 Sisk 中使用 SSL。请参见以下内容： 通过 IIS 在 Windows 上 可用平台：Windows 工作量：中等 如果你在 Windows 上，你可以使用 IIS 来启用 HTTP 服务器的 SSL。为了使其生效，建议你先按照 此教程 进行操作，如果你想让你的应用程序监听其他主机而不是 \"localhost\"。 要使其生效，你必须通过 Windows 功能安装 IIS。IIS 对 Windows 和 Windows Server 用户免费。要在你的应用程序中配置 SSL，请准备好 SSL 证书，即使它是自签名的。接下来，你可以查看 如何在 IIS 7 或更高版本上设置 SSL。 通过 mitmproxy 可用平台：Linux、macOS、Windows 工作量：简单 mitmproxy 是一个拦截代理工具，允许开发人员和安全测试人员检查、修改和记录客户端（例如 Web 浏览器）和服务器之间的 HTTP 和 HTTPS 流量。你可以使用 mitmdump 实用程序在客户端和 Sisk 应用程序之间启动反向 SSL 代理。 首先，在你的机器上安装 mitmproxy。 启动你的 Sisk 应用程序。对于这个例子，我们将使用 8000 端口作为不安全的 HTTP 端口。 启动 mitmproxy 服务器以监听安全端口 8001： mitmdump --mode reverse:http://localhost:8000/ -p 8001 就这样！你可以通过 https://localhost:8001/ 访问你的应用程序。你的应用程序不需要运行才能启动 mitmdump。 或者，你可以在你的项目中添加对 mitmproxy 帮助程序 的引用。这仍然需要在你的计算机上安装 mitmproxy。 通过 Sisk.SslProxy 包 可用平台：Linux、macOS、Windows 工作量：简单 Sisk.SslProxy 包是启用 Sisk 应用程序 SSL 的一种简单方法。然而，它是一个 非常实验性 的包。使用这个包可能会不稳定，但你可以成为少数人中的一员，他们将为使这个包可行和稳定做出贡献。要开始使用，你可以安装 Sisk.SslProxy 包： dotnet add package Sisk.SslProxy Note 你必须在 Visual Studio 包管理器中启用 \"启用预发布包\" 来安装 Sisk.SslProxy。 再次提醒，这是一个实验项目，所以不要考虑将其投入生产。 目前，Sisk.SslProxy 可以处理大多数 HTTP/1.1 功能，包括 HTTP Continue、Chunked-Encoding、WebSockets 和 SSE。请参阅 这里 了解更多关于 SslProxy 的信息。"
  },
  "docs/de/advanced/forwarding-resolvers.html": {
    "href": "docs/de/advanced/forwarding-resolvers.html",
    "title": "Weiterleitungsauflöser | Sisk",
    "keywords": "Weiterleitungsauflöser Ein Weiterleitungsauflöser ist ein Helfer, der hilft, Informationen zu decodieren, die den Client durch eine Anfrage, Proxy, CDN oder Lastenausgleich identifizieren. Wenn Ihr Sisk-Dienst über einen Reverse- oder Forward-Proxy läuft, kann die IP-Adresse, der Host und das Protokoll des Clients von der ursprünglichen Anfrage abweichen, da es sich um eine Weiterleitung von einem Dienst zum anderen handelt. Diese Sisk-Funktion ermöglicht es Ihnen, diese Informationen zu kontrollieren und aufzulösen, bevor Sie mit der Anfrage arbeiten. Diese Proxys liefern normalerweise nützliche Header, um den Client zu identifizieren. Derzeit ist es mit der ForwardingResolver-Klasse möglich, die IP-Adresse, den Host und das HTTP-Protokoll des Clients aufzulösen. Nach Version 1.0 von Sisk hat der Server keine Standardimplementierung mehr, um diese Header aus Sicherheitsgründen, die von Dienst zu Dienst variieren, zu decodieren. Zum Beispiel enthält der X-Forwarded-For-Header Informationen über die IP-Adressen, die die Anfrage weitergeleitet haben. Dieser Header wird von Proxys verwendet, um eine Kette von Informationen an den Enddienst zu übermitteln und enthält die IP-Adresse aller verwendeten Proxys, einschließlich der tatsächlichen Adresse des Clients. Das Problem ist: manchmal ist es schwierig, die IP-Adresse des Clients zu identifizieren, und es gibt keine spezifische Regel, um diesen Header zu identifizieren. Es wird dringend empfohlen, die Dokumentation für die Header zu lesen, die Sie unten implementieren werden: Lesen Sie über den X-Forwarded-For-Header hier. Lesen Sie über den X-Forwarded-Host-Header hier. Lesen Sie über den X-Forwarded-Proto-Header hier. Die ForwardingResolver-Klasse Diese Klasse hat drei virtuelle Methoden, die die am besten geeignete Implementierung für jeden Dienst ermöglichen. Jede Methode ist für die Auflösung von Informationen aus der Anfrage über einen Proxy verantwortlich: die IP-Adresse des Clients, den Host der Anfrage und das Sicherheitsprotokoll, das verwendet wird. Standardmäßig verwendet Sisk immer die Informationen aus der ursprünglichen Anfrage, ohne Header aufzulösen. Das folgende Beispiel zeigt, wie diese Implementierung verwendet werden kann. Dieses Beispiel löst die IP-Adresse des Clients über den X-Forwarded-For-Header auf und wirft einen Fehler, wenn mehr als eine IP-Adresse in der Anfrage weitergeleitet wurde. Important Verwenden Sie dieses Beispiel nicht in Produktionscode. Überprüfen Sie immer, ob die Implementierung für die Verwendung geeignet ist. Lesen Sie die Header-Dokumentation, bevor Sie sie implementieren. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hallo, Welt!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"Der X-Forwarded-For-Header fehlt.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Zu viele Adressen im X-Forwarded-For-Header.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/de/advanced/http-server-handlers.html": {
    "href": "docs/de/advanced/http-server-handlers.html",
    "title": "Http-Server-Handler | Sisk",
    "keywords": "Http-Server-Handler In Sisk-Version 0.16 haben wir die HttpServerHandler-Klasse eingeführt, die darauf abzielt, das Gesamtverhalten von Sisk zu erweitern und zusätzliche Ereignishandler für Sisk bereitzustellen, wie z. B. das Handling von Http-Anfragen, Routern, Kontextbeuteln und mehr. Die Klasse konzentriert sich auf Ereignisse, die während der Lebensdauer des gesamten HTTP-Servers und auch einer Anfrage auftreten. Das Http-Protokoll hat keine Sitzungen, und daher ist es nicht möglich, Informationen von einer Anfrage zur nächsten zu erhalten. Sisk bietet derzeit eine Möglichkeit, Sitzungen, Kontexte, Datenbankverbindungen und andere nützliche Anbieter zu implementieren, um Ihre Arbeit zu unterstützen. Bitte besuchen Sie diese Seite, um zu lesen, wo jedes Ereignis ausgelöst wird und welchen Zweck es hat. Sie können auch den Lebenszyklus einer HTTP-Anfrage anzeigen, um zu verstehen, was mit einer Anfrage passiert und wo Ereignisse ausgelöst werden. Der HTTP-Server ermöglicht es Ihnen, mehrere Handler gleichzeitig zu verwenden. Jeder Ereignisanruf ist synchron, d. h. er blockiert den aktuellen Thread für jede Anfrage oder jeden Kontext, bis alle zugehörigen Handler ausgeführt und abgeschlossen sind. Im Gegensatz zu RequestHandlern können sie nicht auf bestimmte Routengruppen oder spezifische Routen angewendet werden. Stattdessen werden sie auf den gesamten HTTP-Server angewendet. Sie können Bedingungen innerhalb Ihres Http-Server-Handlers anwenden. Darüber hinaus werden Singleton-Instanzen jedes HttpServerHandlers für jede Sisk-Anwendung definiert, so dass nur eine Instanz pro HttpServerHandler definiert ist. Ein praktisches Beispiel für die Verwendung von HttpServerHandler ist die automatische Entsorgung einer Datenbankverbindung am Ende der Anfrage. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // prüft, ob die Anfrage einen DbContext definiert hat // in ihrem Kontextbeutel if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // ermöglicht es dem Benutzer, einen DbContext aus einer Http-Anfrage zu erstellen // und ihn in seinem Kontextbeutel zu speichern public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } Mit dem obigen Code ermöglicht die GetDbContext-Erweiterung die Erstellung eines Verbindungskontexts direkt aus dem HttpRequest-Objekt. Eine nicht entsorgte Verbindung kann Probleme beim Ausführen mit der Datenbank verursachen, daher wird sie in OnHttpRequestClose beendet. Sie können einen Handler auf einem Http-Server in Ihrem Builder oder direkt mit HttpServer.RegisterHandler registrieren. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } Mit diesem Code kann die UsersController-Klasse den Datenbankkontext wie folgt verwenden: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Benutzer hinzugefügt.\"); } } Der obige Code verwendet Methoden wie JsonOk und JsonMessage, die in ApiController integriert sind, die von RouterController abgeleitet ist: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Entwickler können Sitzungen, Kontexte und Datenbankverbindungen mithilfe dieser Klasse implementieren. Der bereitgestellte Code zeigt ein praktisches Beispiel mit dem DatabaseConnectionHandler, der die automatische Entsorgung einer Datenbankverbindung am Ende jeder Anfrage ermöglicht. Die Integration ist einfach, mit Handlern, die während der Servereinrichtung registriert werden. Die HttpServerHandler-Klasse bietet ein leistungsfähiges Werkzeugset für die Verwaltung von Ressourcen und die Erweiterung des Sisk-Verhaltens in HTTP-Anwendungen."
  },
  "docs/de/advanced/manual-setup.html": {
    "href": "docs/de/advanced/manual-setup.html",
    "title": "Manuel (erweitert) Setup | Sisk",
    "keywords": "Manuel (erweitert) Setup In diesem Abschnitt erstellen wir unseren HTTP-Server ohne vordefinierte Standards, auf eine völlig abstrakte Weise. Hier können Sie manuell aufbauen, wie Ihr HTTP-Server funktionieren wird. Jeder ListeningHost hat einen Router und ein HTTP-Server kann mehrere ListeningHosts haben, die jeweils auf einen anderen Host auf einem anderen Port zeigen. Zunächst müssen wir das Konzept von Anfrage/Antwort verstehen. Es ist ziemlich einfach: für jede Anfrage muss es eine Antwort geben. Sisk folgt diesem Prinzip auch. Lassen Sie uns eine Methode erstellen, die mit einer \"Hallo, Welt!\"-Nachricht in HTML antwortet, wobei der Statuscode und die Header angegeben werden. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hallo, Welt!</h1> </body> </html> \") }; return indexResponse; } Der nächste Schritt ist, diese Methode mit einer HTTP-Route zu verknüpfen. Router Router sind Abstraktionen von Anfrage-Routen und dienen als Brücke zwischen Anfragen und Antworten für den Dienst. Router verwalten Dienst-Routen, Funktionen und Fehler. Ein Router kann mehrere Routen haben und jede Route kann unterschiedliche Operationen auf diesem Pfad ausführen, wie z.B. die Ausführung einer Funktion, das Servieren einer Seite oder die Bereitstellung einer Ressource vom Server. Lassen Sie uns unseren ersten Router erstellen und unsere IndexPage-Methode mit dem Index-Pfad verknüpfen. Router mainRouter = new Router(); // SetRoute wird alle Index-Routen mit unserer Methode verknüpfen. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Jetzt kann unser Router Anfragen empfangen und Antworten senden. Allerdings ist mainRouter nicht an einen Host oder einen Server gebunden, daher wird er nicht alleine funktionieren. Der nächste Schritt ist, unseren ListeningHost zu erstellen. Listening Hosts und Ports Ein ListeningHost kann einen Router und mehrere Listening-Ports für denselben Router hosten. Ein ListeningPort ist ein Präfix, an dem der HTTP-Server zuhört. Hier können wir einen ListeningHost erstellen, der auf zwei Endpunkte für unseren Router zeigt: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Jetzt wird unser HTTP-Server auf den angegebenen Endpunkten zuhören und seine Anfragen an unseren Router weiterleiten. Server-Konfiguration Die Server-Konfiguration ist für das meiste Verhalten des HTTP-Servers selbst verantwortlich. In dieser Konfiguration können wir ListeningHosts mit unserem Server verknüpfen. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Fügen Sie unseren ListeningHost zu dieser Server-Konfiguration hinzu Als Nächstes können wir unseren HTTP-Server erstellen: HttpServer server = new HttpServer(config); server.Start(); // Startet den Server Console.ReadKey(); // Verhindert, dass die Anwendung beendet wird Jetzt können wir unsere ausführbare Datei kompilieren und unseren HTTP-Server mit dem Befehl starten: dotnet watch Bei der Laufzeit öffnen Sie Ihren Browser und navigieren zum Server-Pfad, und Sie sollten sehen:"
  },
  "docs/de/advanced/multi-host-setup.html": {
    "href": "docs/de/advanced/multi-host-setup.html",
    "title": "Mehrere Lauscher-Hosts pro Server | Sisk",
    "keywords": "Mehrere Lauscher-Hosts pro Server Das Sisk Framework unterstützt seit jeher die Verwendung von mehr als einem Host pro Server, d.h. ein einzelner HTTP-Server kann auf mehreren Ports hören und jeder Port hat seinen eigenen Router und seinen eigenen Dienst, der darauf läuft. Auf diese Weise ist es einfach, Verantwortlichkeiten zu trennen und Dienste auf einem einzelnen HTTP-Server mit Sisk zu verwalten. Das folgende Beispiel zeigt die Erstellung von zwei ListeningHosts, von denen jeder auf einem anderen Port hört, mit unterschiedlichen Routern und Aktionen. Lesen Sie manuell Ihre App erstellen, um die Details über diese Abstraktion zu verstehen. static void Main(string[] args) { // Erstellen von zwei Listening-Hosts, von denen jeder seinen eigenen Router und // Port hat // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hallo vom Host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hallo vom Host B!\")); // Erstellen einer Server-Konfiguration und Hinzufügen beider // Listening-Hosts // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // Erstellen eines HTTP-Servers, der die angegebene // Konfiguration verwendet // HttpServer server = new HttpServer(configuration); // Starten des Servers server.Start(); Console.WriteLine(\"Versuchen Sie, Host A unter {0} zu erreichen\", server.ListeningPrefixes[0]); Console.WriteLine(\"Versuchen Sie, Host B unter {0} zu erreichen\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/de/advanced/request-lifecycle.html": {
    "href": "docs/de/advanced/request-lifecycle.html",
    "title": "Anfragelebenszyklus | Sisk",
    "keywords": "Anfragelebenszyklus Im Folgenden wird der gesamte Lebenszyklus einer Anfrage anhand eines Beispiels einer HTTP-Anfrage erläutert. Empfangen der Anfrage: Jede Anfrage erstellt einen HTTP-Kontext zwischen der Anfrage selbst und der Antwort, die an den Client geliefert wird. Dieser Kontext stammt vom integrierten Listener in Sisk, der entweder HttpListener, Kestrel oder Cadente sein kann. Externe Anfragevalidierung: Die Validierung von HttpServerConfiguration.RemoteRequestsAction wird für die Anfrage überprüft. Wenn die Anfrage extern ist und die Eigenschaft Drop ist, wird die Verbindung ohne Antwort an den Client geschlossen und ein HttpServerExecutionStatus = RemoteRequestDropped zurückgegeben. Weiterleitungs-Resolver-Konfiguration: Wenn ein ForwardingResolver konfiguriert ist, wird die Methode OnResolveRequestHost auf dem ursprünglichen Host der Anfrage aufgerufen. DNS-Matching: Mit dem aufgelösten Host und mehr als einem konfigurierten ListeningHost sucht der Server nach dem entsprechenden Host für die Anfrage. Wenn kein ListeningHost übereinstimmt, wird eine 400 Bad Request-Antwort an den Client zurückgegeben und ein HttpServerExecutionStatus = DnsUnknownHost-Status an den HTTP-Kontext zurückgegeben. Wenn ein ListeningHost übereinstimmt, aber sein Router noch nicht initialisiert ist, wird eine 503 Service Unavailable-Antwort an den Client zurückgegeben und ein HttpServerExecutionStatus = ListeningHostNotReady-Status an den HTTP-Kontext zurückgegeben. Router-Bindung: Der Router des entsprechenden ListeningHost wird mit dem empfangenen HTTP-Server verknüpft. Wenn der Router bereits mit einem anderen HTTP-Server verknüpft ist, was nicht zulässig ist, da der Router die Konfigurationsressourcen des Servers aktiv verwendet, wird eine InvalidOperationException ausgelöst. Dies tritt nur während der Initialisierung des HTTP-Servers auf, nicht während der Erstellung des HTTP-Kontexts. Vordefinition von Headern: Definiert den X-Request-Id-Header in der Antwort, wenn dies konfiguriert ist. Definiert den X-Powered-By-Header in der Antwort, wenn dies konfiguriert ist. Inhaltsgrößenvalidierung: Überprüft, ob der Anfrageinhalt kleiner als HttpServerConfiguration.MaximumContentLength ist, nur wenn dieser größer als Null ist. Wenn die Anfrage eine Content-Length größer als die konfigurierte sendet, wird eine 413 Payload Too Large-Antwort an den Client zurückgegeben und ein HttpServerExecutionStatus = ContentTooLarge-Status an den HTTP-Kontext zurückgegeben. Das OnHttpRequestOpen-Ereignis wird für alle konfigurierten HTTP-Server-Handler aufgerufen. Weiterleiten der Aktion: Der Server ruft den Router für die empfangene Anfrage auf. Wenn der Router keine Route findet, die der Anfrage entspricht: Wenn die Router.NotFoundErrorHandler-Eigenschaft konfiguriert ist, wird die Aktion aufgerufen und die Antwort der Aktion an den HTTP-Client weitergeleitet. Wenn die vorherige Eigenschaft Null ist, wird eine Standard-404 Not Found-Antwort an den Client zurückgegeben. Wenn der Router eine passende Route findet, aber die Methode der Route nicht der Anfragemethode entspricht: Wenn die Router.MethodNotAllowedErrorHandler-Eigenschaft konfiguriert ist, wird die Aktion aufgerufen und die Antwort der Aktion an den HTTP-Client weitergeleitet. Wenn die vorherige Eigenschaft Null ist, wird eine Standard-405 Method Not Allowed-Antwort an den Client zurückgegeben. Wenn die Anfrage die OPTIONS-Methode ist: Der Router gibt eine 200 Ok-Antwort an den Client zurück, nur wenn keine Route der Anfrage entspricht (die Route ist nicht explizit RouteMethod.Options). Wenn die HttpServerConfiguration.ForceTrailingSlash-Eigenschaft aktiviert ist, die passende Route keine Regex ist, der Anfragepfad nicht mit / endet und die Anfragemethode GET ist: Eine 307 Temporary Redirect-HTTP-Antwort mit dem Location-Header mit dem Pfad und der Abfrage an dieselbe Position mit einem / am Ende wird an den Client zurückgegeben. Das OnContextBagCreated-Ereignis wird für alle konfigurierten HTTP-Server-Handler aufgerufen. Alle globalen IRequestHandler-Instanzen mit der BeforeResponse-Flag werden ausgeführt. Wenn ein Handler eine nicht-Null-Antwort zurückgibt, wird diese Antwort an den HTTP-Client weitergeleitet und der Kontext geschlossen. Wenn ein Fehler in diesem Schritt auftritt und HttpServerConfiguration.ThrowExceptions deaktiviert ist: Wenn die Router.CallbackErrorHandler-Eigenschaft aktiviert ist, wird sie aufgerufen und die resultierende Antwort an den Client zurückgegeben. Wenn die vorherige Eigenschaft nicht definiert ist, wird eine leere Antwort an den Server zurückgegeben, der eine Antwort entsprechend dem Typ des ausgelösten Fehlers zurückgibt, der normalerweise 500 Internal Server Error ist. Alle IRequestHandler-Instanzen, die in der Route definiert sind und die BeforeResponse-Flag haben, werden ausgeführt. Wenn ein Handler eine nicht-Null-Antwort zurückgibt, wird diese Antwort an den HTTP-Client weitergeleitet und der Kontext geschlossen. Wenn ein Fehler in diesem Schritt auftritt und HttpServerConfiguration.ThrowExceptions deaktiviert ist: Wenn die Router.CallbackErrorHandler-Eigenschaft aktiviert ist, wird sie aufgerufen und die resultierende Antwort an den Client zurückgegeben. Wenn die vorherige Eigenschaft nicht definiert ist, wird eine leere Antwort an den Server zurückgegeben, der eine Antwort entsprechend dem Typ des ausgelösten Fehlers zurückgibt, der normalerweise 500 Internal Server Error ist. Die Aktion des Routers wird aufgerufen und in eine HTTP-Antwort umgewandelt. Wenn ein Fehler in diesem Schritt auftritt und HttpServerConfiguration.ThrowExceptions deaktiviert ist: Wenn die Router.CallbackErrorHandler-Eigenschaft aktiviert ist, wird sie aufgerufen und die resultierende Antwort an den Client zurückgegeben. Wenn die vorherige Eigenschaft nicht definiert ist, wird eine leere Antwort an den Server zurückgegeben, der eine Antwort entsprechend dem Typ des ausgelösten Fehlers zurückgibt, der normalerweise 500 Internal Server Error ist. Alle globalen IRequestHandler-Instanzen mit der AfterResponse-Flag werden ausgeführt. Wenn ein Handler eine nicht-Null-Antwort zurückgibt, ersetzt die Antwort des Handlers die vorherige Antwort und wird sofort an den HTTP-Client weitergeleitet. Wenn ein Fehler in diesem Schritt auftritt und HttpServerConfiguration.ThrowExceptions deaktiviert ist: Wenn die Router.CallbackErrorHandler-Eigenschaft aktiviert ist, wird sie aufgerufen und die resultierende Antwort an den Client zurückgegeben. Wenn die vorherige Eigenschaft nicht definiert ist, wird eine leere Antwort an den Server zurückgegeben, der eine Antwort entsprechend dem Typ des ausgelösten Fehlers zurückgibt, der normalerweise 500 Internal Server Error ist. Alle IRequestHandler-Instanzen, die in der Route definiert sind und die AfterResponse-Flag haben, werden ausgeführt. Wenn ein Handler eine nicht-Null-Antwort zurückgibt, ersetzt die Antwort des Handlers die vorherige Antwort und wird sofort an den HTTP-Client weitergeleitet. Wenn ein Fehler in diesem Schritt auftritt und HttpServerConfiguration.ThrowExceptions deaktiviert ist: Wenn die Router.CallbackErrorHandler-Eigenschaft aktiviert ist, wird sie aufgerufen und die resultierende Antwort an den Client zurückgegeben. Wenn die vorherige Eigenschaft nicht definiert ist, wird eine leere Antwort an den Server zurückgegeben, der eine Antwort entsprechend dem Typ des ausgelösten Fehlers zurückgibt, der normalerweise 500 Internal Server Error ist. Verarbeiten der Antwort: Mit der Antwort bereit, bereitet der Server sie für den Versand an den Client vor. Die Cross-Origin Resource Sharing Policy (CORS)-Header werden in der Antwort definiert, entsprechend der Konfiguration in der aktuellen ListeningHost.CrossOriginResourceSharingPolicy. Der Statuscode und die Header der Antwort werden an den Client gesendet. Der Inhalt der Antwort wird an den Client gesendet: Wenn der Inhalt der Antwort ein Nachfahre von ByteArrayContent ist, werden die Antwortbytes direkt in den Ausgabestream der Antwort kopiert. Wenn die vorherige Bedingung nicht erfüllt ist, wird die Antwort in einen Stream serialisiert und in den Ausgabestream der Antwort kopiert. Die Streams werden geschlossen und der Inhalt der Antwort wird verworfen. Wenn HttpServerConfiguration.DisposeDisposableContextValues aktiviert ist, werden alle Objekte, die im Anfragekontext definiert sind und von IDisposable erben, verworfen. Das OnHttpRequestClose-Ereignis wird für alle konfigurierten HTTP-Server-Handler aufgerufen. Wenn auf dem Server eine Ausnahme ausgelöst wurde, wird das OnException-Ereignis für alle konfigurierten HTTP-Server-Handler aufgerufen. Wenn die Route Zugriffsprotokollierung zulässt und HttpServerConfiguration.AccessLogsStream nicht Null ist, wird eine Protokollzeile in die Protokollausgabe geschrieben. Wenn die Route Fehlerprotokollierung zulässt, eine Ausnahme vorliegt und HttpServerConfiguration.ErrorsLogsStream nicht Null ist, wird eine Protokollzeile in die Fehlerprotokollausgabe geschrieben. Wenn der Server auf eine Anfrage durch HttpServer.WaitNext wartet, wird die Sperre freigegeben und der Kontext wird dem Benutzer zur Verfügung gestellt."
  },
  "docs/de/changelogs.html": {
    "href": "docs/de/changelogs.html",
    "title": "Changelog | Sisk",
    "keywords": "Changelog Jeder Änderung an Sisk wird über das Changelog protokolliert. Sie können die Changelogs für alle Sisk-Versionen hier einsehen."
  },
  "docs/de/deploying.html": {
    "href": "docs/de/deploying.html",
    "title": "Bereitstellung Ihrer Sisk-Anwendung | Sisk",
    "keywords": "Bereitstellung Ihrer Sisk-Anwendung Der Prozess der Bereitstellung einer Sisk-Anwendung besteht darin, Ihr Projekt in die Produktion zu veröffentlichen. Obwohl der Prozess relativ einfach ist, ist es wichtig, Details zu beachten, die für die Sicherheit und Stabilität der Infrastruktur der Bereitstellung von entscheidender Bedeutung sein können. Idealerweise sollten Sie bereit sein, Ihre Anwendung in die Cloud zu veröffentlichen, nachdem Sie alle möglichen Tests durchgeführt haben, um Ihre Anwendung bereit zu machen. Veröffentlichen Ihrer App Das Veröffentlichen Ihrer Sisk-Anwendung oder eines Dienstes bedeutet, Binärdateien zu generieren, die für die Produktion bereit und optimiert sind. In diesem Beispiel werden wir die Binärdateien für die Produktion kompilieren, um auf einem Computer mit der .NET-Laufzeitumgebung zu laufen. Sie benötigen die .NET-SDK auf Ihrem Computer, um Ihre App zu erstellen, und die .NET-Laufzeitumgebung auf dem Zielserver, um Ihre App auszuführen. Sie können erfahren, wie Sie die .NET-Laufzeitumgebung auf Ihrem Linux-Server hier, Windows und Mac OS installieren. Öffnen Sie im Ordner, in dem sich Ihr Projekt befindet, ein Terminal und verwenden Sie den .NET-Veröffentlichungsbefehl: $ dotnet publish -r linux-x64 -c Release Dies generiert Ihre Binärdateien im Ordner bin/Release/publish/linux-x64. Note Wenn Ihre App mit dem Sisk.ServiceProvider-Paket läuft, sollten Sie Ihre service-config.json in den Host-Server zusammen mit allen Binärdateien kopieren, die von dotnet publish generiert werden. Sie können die Datei vor konfigurieren, mit Umgebungsvariablen, Lauscher-Ports und -Hosts sowie zusätzlichen Server-Konfigurationen. Der nächste Schritt besteht darin, diese Dateien auf den Server zu übertragen, auf dem Ihre Anwendung gehostet wird. Anschließend geben Sie der Binärdatei Ausführungsrechte. In diesem Fall nehmen wir an, dass unser Projektname \"my-app\" ist: $ cd /home/htdocs $ chmod +x my-app $ ./my-app Nachdem Sie Ihre Anwendung gestartet haben, überprüfen Sie, ob sie Fehlermeldungen produziert. Wenn sie keine Fehlermeldungen produziert, bedeutet dies, dass Ihre Anwendung läuft. An diesem Punkt ist es wahrscheinlich nicht möglich, auf Ihre Anwendung von außerhalb des Servers zuzugreifen, da Zugriffsregeln wie Firewall nicht konfiguriert sind. Wir werden dies in den nächsten Schritten berücksichtigen. Sie sollten die Adresse des virtuellen Hosts haben, auf dem Ihre Anwendung läuft. Dies wird manuell in der Anwendung festgelegt und hängt davon ab, wie Sie Ihren Sisk-Dienst instanziieren. Wenn Sie nicht das Sisk.ServiceProvider-Paket verwenden, sollten Sie es finden, wo Sie Ihre HttpServer-Instanz definiert haben: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk sollte auf http://localhost:5000/ lauschen Manuelle Zuweisung eines ListeningHost: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Oder wenn Sie das Sisk.ServiceProvider-Paket verwenden, in Ihrer service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } Daraus können wir einen Reverse-Proxy erstellen, um Ihren Dienst zu hören und den Datenverkehr über das offene Netzwerk verfügbar zu machen. Proxying Ihrer Anwendung Das Proxying Ihres Dienstes bedeutet, dass Sie Ihren Sisk-Dienst nicht direkt einem externen Netzwerk aussetzen. Diese Praxis ist sehr häufig bei Server-Bereitstellungen, da: Sie damit ein SSL-Zertifikat in Ihrer Anwendung verknüpfen können; Sie Zugriffsregeln vor dem Zugriff auf den Dienst erstellen und Überlastungen vermeiden können; Sie die Bandbreite und Anfragegrenzen kontrollieren können; Sie Lastenausgleich für Ihre Anwendung trennen können; Sie Sicherheitsschäden an der fehlgeschlagenen Infrastruktur verhindern können. Sie können Ihre Anwendung durch einen Reverse-Proxy wie Nginx oder Apache bereitstellen, oder Sie können einen http-over-dns-Tunnel wie Cloudflared verwenden. Außerdem sollten Sie daran denken, die Weiterleitungsheader Ihres Proxys korrekt aufzulösen, um die Informationen Ihres Clients, wie z.B. die IP-Adresse und den Host, über Weiterleitungs-Resolver zu erhalten. Der nächste Schritt nach der Erstellung Ihres Tunnels, der Firewall-Konfiguration und dem Ausführen Ihrer Anwendung besteht darin, einen Dienst für Ihre Anwendung zu erstellen. Note Die Verwendung von SSL-Zertifikaten direkt im Sisk-Dienst auf nicht-Windows-Systemen ist nicht möglich. Dies ist ein Punkt der Implementierung von HttpListener, der das zentrale Modul für die HTTP-Warteschlangenverwaltung in Sisk ist, und diese Implementierung variiert von Betriebssystem zu Betriebssystem. Sie können SSL in Ihrem Sisk-Dienst verwenden, wenn Sie ein Zertifikat mit dem virtuellen Host mit IIS verknüpfen. Für andere Systeme wird die Verwendung eines Reverse-Proxys dringend empfohlen. Erstellen eines Dienstes Das Erstellen eines Dienstes macht Ihre Anwendung immer verfügbar, auch nach dem Neustart Ihres Servers oder einem nicht wiederherstellbaren Absturz. In diesem einfachen Tutorial werden wir den Inhalt des vorherigen Tutorials als Showcase verwenden, um Ihren Dienst immer aktiv zu halten. Greifen Sie auf den Ordner zu, in dem sich die Dienstkonfigurationsdateien befinden: cd /etc/systemd/system Erstellen Sie Ihre my-app.service-Datei und fügen Sie den Inhalt hinzu: my-app.service INI [Unit] Description=<Beschreibung über Ihre App> [Service] # Setzen Sie den Benutzer, der den Dienst starten wird User=<Benutzer, der den Dienst starten wird> # Der ExecStart-Pfad ist nicht relativ zum WorkingDirectory. # Setzen Sie ihn als vollständigen Pfad zur ausführbaren Datei WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # Setzen Sie den Dienst so, dass er immer nach einem Absturz neu startet Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Starten Sie Ihren Dienst-Manager-Modul neu: $ sudo systemctl daemon-reload Starten Sie Ihren neu erstellten Dienst mit dem Namen der Datei, die Sie festgelegt haben, und überprüfen Sie, ob er läuft: $ sudo systemctl start my-app $ sudo systemctl status my-app Wenn Ihre App läuft (\"Active: active\"), aktivieren Sie Ihren Dienst, um ihn nach einem System-Neustart weiterlaufen zu lassen: $ sudo systemctl enable my-app Jetzt sind Sie bereit, Ihre Sisk-Anwendung vorzustellen."
  },
  "docs/de/extensions/basic-auth.html": {
    "href": "docs/de/extensions/basic-auth.html",
    "title": "Basic Auth | Sisk",
    "keywords": "Basic Auth Das Basic-Auth-Paket fügt einen Anfrage-Handler hinzu, der in der Lage ist, das Basic-Authentifizierungsschema in Ihrer Sisk-Anwendung mit sehr wenig Konfiguration und Aufwand zu handhaben. Basic-HTTP-Authentifizierung ist eine minimale Eingabeform der Authentifizierung von Anfragen durch eine Benutzer-ID und ein Passwort, wobei die Sitzung ausschließlich vom Client gesteuert wird und es keine Authentifizierungs- oder Zugriffstoken gibt. Erfahren Sie mehr über das Basic-Authentifizierungsschema in der MDN-Spezifikation. Installation Um loszulegen, installieren Sie das Sisk.BasicAuth-Paket in Ihrem Projekt: > dotnet add package Sisk.BasicAuth Sie können weitere Möglichkeiten zur Installation in Ihrem Projekt im Nuget-Repository anzeigen. Erstellen Ihres Auth-Handlers Sie können das Authentifizierungsschema für ein ganzes Modul oder für einzelne Routen steuern. Dazu müssen wir zunächst unseren ersten Basic-Authentifizierungs-Handler schreiben. Im folgenden Beispiel wird eine Verbindung zur Datenbank hergestellt, es wird überprüft, ob der Benutzer existiert und ob das Passwort gültig ist, und anschließend wird der Benutzer im Kontext-Beutel gespeichert. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Um diese Seite zu betreten, geben Sie bitte Ihre Anmeldeinformationen ein.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // In diesem Fall verwenden wir die E-Mail-Adresse als Benutzer-ID-Feld, also suchen wir nach einem Benutzer mit seiner E-Mail-Adresse. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Entschuldigung! Kein Benutzer mit dieser E-Mail-Adresse gefunden.\"); } // Überprüft, ob das Passwort für diesen Benutzer gültig ist. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Ungültige Anmeldeinformationen.\"); } // Fügt den angemeldeten Benutzer zum HTTP-Kontext hinzu // und setzt die Ausführung fort context.Bag.Add(\"loggedUser\", user); return null; } } Assoziieren Sie einfach diesen Anfrage-Handler mit unserer Route oder Klasse. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hallo, \" + loggedUser.Name + \"!\"; } } Oder mit der RouterModule-Klasse: public class UsersController : RouterModule { public ClientModule() { // Jetzt werden alle Routen in dieser Klasse vom UserAuthHandler gehandhabt. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hallo, \" + loggedUser.Name + \"!\"; } } Hinweise Die primäre Verantwortung für die Basic-Authentifizierung liegt auf der Client-Seite. Speicherung, Cache-Steuerung und Verschlüsselung werden alle lokal auf dem Client gehandhabt. Der Server erhält nur die Anmeldeinformationen und überprüft, ob der Zugriff erlaubt ist oder nicht. Beachten Sie, dass diese Methode nicht eine der sichersten ist, da sie eine erhebliche Verantwortung auf den Client legt, der schwierig zu verfolgen und die Sicherheit seiner Anmeldeinformationen zu gewährleisten ist. Darüber hinaus ist es wichtig, dass Passwörter in einem sicheren Verbindungskontext (SSL) übertragen werden, da sie keine inhärente Verschlüsselung haben. Eine kurze Abfangung der Header einer Anfrage kann die Zugangsdaten Ihres Benutzers offenlegen. Wählen Sie für Produktionsanwendungen robustere Authentifizierungslösungen und vermeiden Sie die Verwendung von zu vielen vorgefertigten Komponenten, da diese möglicherweise nicht an die Bedürfnisse Ihres Projekts angepasst sind und es letztendlich Sicherheitsrisiken aussetzen."
  },
  "docs/de/extensions/ini-configuration.html": {
    "href": "docs/de/extensions/ini-configuration.html",
    "title": "INI-Konfiguration | Sisk",
    "keywords": "INI-Konfiguration Sisk hat eine Methode für das Abrufen von Startkonfigurationen, die nicht JSON sind. Tatsächlich kann jede Pipeline, die IConfigurationReader implementiert, mit PortableConfigurationBuilder.WithConfigurationPipeline verwendet werden, um die Serverkonfiguration aus jeder Dateityp zu lesen. Das Sisk.IniConfiguration-Paket bietet einen streambasierten INI-Dateileser, der keine Ausnahmen für häufige Syntaxfehler auslöst und eine einfache Konfigurationssyntax hat. Dieses Paket kann außerhalb des Sisk-Frameworks verwendet werden und bietet Flexibilität für Projekte, die einen effizienten INI-Dokumentleser benötigen. Installation Um das Paket zu installieren, können Sie mit folgendem Befehl beginnen: $ dotnet add package Sisk.IniConfiguration Sie können auch das Core-Paket installieren, das weder den INI-IConfigurationReader noch die Sisk-Abhängigkeit enthält, sondern nur die INI-Serialisierer: $ dotnet add package Sisk.IniConfiguration.Core Mit dem Hauptpaket können Sie es in Ihrem Code wie im folgenden Beispiel verwenden: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // verwendet den IniConfigurationReader-Konfigurationsleser config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hallo, {name}!\"); } } Der obige Code sucht nach einer app.ini-Datei im aktuellen Verzeichnis des Prozesses (CurrentDirectory). Die INI-Datei sieht wie folgt aus: [Server] # Mehrere Zuhöradressen werden unterstützt Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI-Geschmack und Syntax Aktuelle Implementierung des Geschmacks: Eigenschaften- und Sektionsnamen sind groß-/kleinschreibungsunabhängig. Eigenschaftsnamen und Werte sind gekürzt, sofern Werte nicht in Anführungszeichen gesetzt sind. Werte können mit einfachen oder doppelten Anführungszeichen in Anführungszeichen gesetzt werden. Anführungszeichen können Zeilenumbrüche enthalten. Kommentare werden mit # und ; unterstützt. Nachgestellte Kommentare sind ebenfalls erlaubt. Eigenschaften können mehrere Werte haben. Im Detail finden Sie die Dokumentation für den \"Geschmack\" des INI-Parsers, der in Sisk verwendet wird, in diesem Dokument. Verwenden Sie beispielsweise den folgenden INI-Code: One = 1 Value = dies ist ein Wert Another value = \"dieser Wert hat einen Zeilenumbruch darin\" ; der Code unten hat einige Farben [some section] Color = Red Color = Blue Color = Yellow ; verwenden Sie nicht gelb Analysieren Sie ihn mit: // analysieren Sie den INI-Text aus der Zeichenfolge IniDocument doc = IniDocument.FromString(iniText); // erhalten Sie einen Wert string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // erhalten Sie mehrere Werte string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Konfigurationsparameter Sektion und Name Mehrere Werte zulassen Beschreibung Server.Listen Ja Die Zuhöradressen/Ports des Servers. Server.Encoding Nein Die Standardcodierung des Servers. Server.MaximumContentLength Nein Die maximale Inhaltslänge des Servers in Bytes. Server.IncludeRequestIdHeader Nein Gibt an, ob der HTTP-Server den X-Request-Id-Header senden soll. Server.ThrowExceptions Nein Gibt an, ob unbehandelte Ausnahmen ausgelöst werden sollen. Server.AccessLogsStream Nein Gibt den Ausgabestream für den Zugriff auf die Protokolle an. Server.ErrorsLogsStream Nein Gibt den Ausgabestream für die Fehlerprotokolle an. Cors.AllowMethods Nein Gibt den Wert des CORS-Allow-Methods-Headers an. Cors.AllowHeaders Nein Gibt den Wert des CORS-Allow-Headers-Headers an. Cors.AllowOrigins Nein Gibt mehrere Allow-Origin-Header, getrennt durch Kommata, an. AllowOrigins für weitere Informationen. Cors.AllowOrigin Nein Gibt einen Allow-Origin-Header an. Cors.ExposeHeaders Nein Gibt den Wert des CORS-Expose-Headers-Headers an. Cors.AllowCredentials Nein Gibt den Wert des CORS-Allow-Credentials-Headers an. Cors.MaxAge Nein Gibt den Wert des CORS-Max-Age-Headers an."
  },
  "docs/de/extensions/json-rpc.html": {
    "href": "docs/de/extensions/json-rpc.html",
    "title": "JSON-RPC-Erweiterung | Sisk",
    "keywords": "JSON-RPC-Erweiterung Sisk hat ein experimentelles Modul für eine JSON-RPC 2.0-API, mit der Sie noch einfachere Anwendungen erstellen können. Diese Erweiterung implementiert die JSON-RPC 2.0-Transport-Schnittstelle strikt und bietet Transport über HTTP-GET-, POST-Anfragen und auch Web-Sockets mit Sisk. Sie können die Erweiterung über Nuget mit dem folgenden Befehl installieren. Beachten Sie, dass Sie in experimentellen/Beta-Versionen die Option zum Suchen nach Vorabversionen in Visual Studio aktivieren müssen. dotnet add package Sisk.JsonRpc Transport-Schnittstelle JSON-RPC ist ein Zustandsloses, asynchrones Remote-Verfahren-Ausführungsprotokoll (RDP), das JSON für einseitige Datenkommunikation verwendet. Eine JSON-RPC-Anfrage wird normalerweise durch eine ID identifiziert, und eine Antwort wird durch die gleiche ID geliefert, die in der Anfrage gesendet wurde. Nicht alle Anfragen erfordern eine Antwort, die als \"Benachrichtigungen\" bezeichnet werden. Die JSON-RPC 2.0-Spezifikation erklärt im Detail, wie der Transport funktioniert. Dieser Transport ist unabhängig davon, wo er verwendet wird. Sisk implementiert dieses Protokoll über HTTP, indem es die Konformitäten von JSON-RPC über HTTP befolgt, die teilweise GET-Anfragen unterstützt, aber vollständig POST-Anfragen unterstützt. Web-Sockets werden auch unterstützt, wodurch asynchrone Nachrichtenkommunikation ermöglicht wird. Eine JSON-RPC-Anfrage sieht ähnlich aus wie: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } Und eine erfolgreiche Antwort sieht ähnlich aus wie: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC-Methoden Das folgende Beispiel zeigt, wie Sie eine JSON-RPC-API mit Sisk erstellen können. Eine mathematische Operationenklasse führt die Remote-Operationen aus und liefert die serialisierte Antwort an den Client. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // fügt alle Methoden mit dem Attribut WebMethod zum JSON-RPC-Handler hinzu args.Handler.Methods.AddMethodsFromType(new MathOperations()); // ordnet die Route /service zum JSON-RPC-Handler für POST- und GET-Anfragen zu args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // erstellt einen WebSocket-Handler für GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } Das obige Beispiel ordnet die Methoden Sum und Sqrt dem JSON-RPC-Handler zu und macht diese Methoden über GET /service, POST /service und GET /ws verfügbar. Methodennamen sind nicht case-sensitiv. Methodeparameter werden automatisch in ihre spezifischen Typen deserialisiert. Die Verwendung von Anfragen mit benannten Parametern wird auch unterstützt. Die JSON-Serialisierung wird von der LightJson-Bibliothek durchgeführt. Wenn ein Typ nicht korrekt deserialisiert wird, können Sie einen spezifischen JSON-Konverter für diesen Typ erstellen und ihn mit Ihren JsonSerializerOptions verknüpfen. Sie können auch das $.params-Objekt direkt aus der JSON-RPC-Anfrage in Ihrer Methode abrufen. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Damit dies geschieht, muss @params der einzige Parameter in Ihrer Methode sein, mit genau dem Namen params (in C# ist das @ erforderlich, um diesen Parameter-Namen zu entkommen). Die Deserialisierung von Parametern erfolgt sowohl für benannte Objekte als auch für positionale Arrays. Zum Beispiel kann die folgende Methode durch beide Anfragen aufgerufen werden: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Für ein Array muss die Reihenfolge der Parameter befolgt werden. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Anpassen des Serialisierungsprogramms Sie können den JSON-Serialisierer in der JsonRpcHandler.JsonSerializerOptions-Eigenschaft anpassen. In dieser Eigenschaft können Sie die Verwendung von JSON5 für die Deserialisierung von Nachrichten aktivieren. Obwohl dies nicht konform mit JSON-RPC 2.0 ist, ist JSON5 eine Erweiterung von JSON, die ein menschenlesbareres und lesbareres Schreiben ermöglicht. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // verwendet einen gereinigten Namen-Vergleicher. Dieser Vergleicher vergleicht nur Buchstaben // und Ziffern in einem Namen und ignoriert andere Symbole. Zum Beispiel: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // aktiviert JSON5 für den JSON-Interpreter. Selbst wenn dies aktiviert ist, ist Plain-JSON immer noch erlaubt e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // ordnet die POST /service-Route zum JSON-RPC-Handler zu e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/de/extensions/service-providers.html": {
    "href": "docs/de/extensions/service-providers.html",
    "title": "Diensteanbieter | Sisk",
    "keywords": "Diensteanbieter Diensteanbieter sind eine Möglichkeit, Ihre Sisk-Anwendung auf verschiedene Umgebungen mit einer portablen Konfigurationsdatei zu übertragen. Diese Funktion ermöglicht es Ihnen, den Serverport, Parameter und andere Optionen ohne Änderung des Anwendungscode für jede Umgebung zu ändern. Dieses Modul hängt von der Sisk-Konstruktionsyntax ab und kann über die Methode UsePortableConfiguration konfiguriert werden. Ein Konfigurationsanbieter wird mit IConfigurationProvider implementiert, der einen Konfigurationsleser bereitstellt und jede Implementierung erhalten kann. Standardmäßig bietet Sisk einen JSON-Konfigurationsleser, aber es gibt auch ein Paket für INI-Dateien. Sie können auch Ihren eigenen Konfigurationsanbieter erstellen und ihn mit: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Wie bereits erwähnt, ist der Standardanbieter eine JSON-Datei. Standardmäßig wird nach einer Datei mit dem Namen service-config.json gesucht, und diese wird im aktuellen Verzeichnis des laufenden Prozesses und nicht im Verzeichnis der ausführbaren Datei gesucht. Sie können den Dateinamen sowie das Verzeichnis, in dem Sisk nach der Konfigurationsdatei suchen soll, mit: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); Der obige Code sucht nach der Datei config.toml im aktuellen Verzeichnis des laufenden Prozesses. Wenn sie nicht gefunden wird, sucht er dann im Verzeichnis, in dem die ausführbare Datei liegt. Wenn die Datei nicht existiert, wird der Parameter createIfDontExists beachtet, und die Datei wird ohne Inhalt im letzten getesteten Pfad (basierend auf lookupDirectories) erstellt, und ein Fehler wird in der Konsole ausgegeben, was die Anwendung verhindert, sich zu initialisieren. Tip Sie können den Quellcode des INI-Konfigurationslesers und des JSON-Konfigurationslesers betrachten, um zu verstehen, wie ein IConfigurationProvider implementiert wird. Lesen von Konfigurationen aus einer JSON-Datei Standardmäßig bietet Sisk einen Konfigurationsanbieter, der Konfigurationen aus einer JSON-Datei liest. Diese Datei folgt einer festen Struktur und besteht aus den folgenden Parametern: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"Meine Sisk-Anwendung\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Konfigurationsdateien unterstützen auch Kommentare ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // neu in 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Die aus einer Konfigurationsdatei erstellten Parameter können im Serverkonstruktor abgerufen werden: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Jeder Konfigurationsleser bietet eine Möglichkeit, die Serverinitialisierungsparameter zu lesen. Einige Eigenschaften sind so konzipiert, dass sie in der Prozessumgebung anstelle der Konfigurationsdatei definiert werden, wie z. B. sensible API-Daten, API-Schlüssel usw. Konfigurationsdateistruktur Die JSON-Konfigurationsdatei besteht aus den folgenden Eigenschaften: Eigenschaft Pflichtfeld Beschreibung Server Erforderlich Stellt den Server selbst mit seinen Einstellungen dar. Server.AccessLogsStream Optional Standardmäßig console. Gibt den Ausgabestream für die Zugriffsprotokolle an. Kann eine Dateiname, null oder console sein. Server.ErrorsLogsStream Optional Standardmäßig null. Gibt den Ausgabestream für die Fehlerprotokolle an. Kann eine Dateiname, null oder console sein. Server.MaximumContentLength Optional Server.MaximumContentLength Optional Standardmäßig 0. Gibt die maximale Inhaltslänge in Bytes an. Null bedeutet unendlich. Server.IncludeRequestIdHeader Optional Standardmäßig false. Gibt an, ob der HTTP-Server den X-Request-Id-Header senden soll. Server.ThrowExceptions Optional Standardmäßig true. Gibt an, ob unbehandelte Ausnahmen ausgelöst werden sollen. Auf false setzen, wenn die Anwendung in Produktion ist, und auf true, wenn die Anwendung debuggt wird. ListeningHost Erforderlich Stellt den Server-Host dar, der zugehört. ListeningHost.Label Optional Stellt die Anwendungsbezeichnung dar. ListeningHost.Ports Erforderlich Stellt ein Array von Zeichenfolgen dar, die der Syntax von ListeningPort entsprechen. ListeningHost.CrossOriginResourceSharingPolicy Optional Konfiguriert die CORS-Header für die Anwendung. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Optional Standardmäßig false. Gibt den Allow-Credentials-Header an. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Optional Standardmäßig null. Erwartet ein Array von Zeichenfolgen. Gibt den Expose-Headers-Header an. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Optional Standardmäßig null. Erwartet eine Zeichenfolge. Gibt den Allow-Origin-Header an. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Optional Standardmäßig null. Erwartet ein Array von Zeichenfolgen. Gibt mehrere Allow-Origin-Header an. Siehe AllowOrigins für weitere Informationen. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Optional Standardmäßig null. Erwartet ein Array von Zeichenfolgen. Gibt den Allow-Methods-Header an. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Optional Standardmäßig null. Erwartet ein Array von Zeichenfolgen. Gibt den Allow-Headers-Header an. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Optional Standardmäßig null. Erwartet eine Ganzzahl. Gibt den Max-Age-Header in Sekunden an. ListeningHost.Parameters Optional Gibt die Eigenschaften an, die der Anwendungskonfigurationsmethode bereitgestellt werden."
  },
  "docs/de/extensions/ssl-proxy.html": {
    "href": "docs/de/extensions/ssl-proxy.html",
    "title": "SSL-Proxy | Sisk",
    "keywords": "SSL-Proxy Warning Diese Funktion ist experimentell und sollte nicht in der Produktion verwendet werden. Bitte beachten Sie dieses Dokument, wenn Sie Sisk mit SSL verwenden möchten. Der Sisk SSL-Proxy ist ein Modul, das eine HTTPS-Verbindung für einen ListeningHost in Sisk bereitstellt und HTTPS-Nachrichten an einen unsicheren HTTP-Kontext weiterleitet. Das Modul wurde entwickelt, um eine SSL-Verbindung für einen Dienst bereitzustellen, der HttpListener verwendet, um zu laufen, was keine SSL-Unterstützung bietet. Der Proxy läuft innerhalb der gleichen Anwendung und hört auf HTTP/1.1-Nachrichten, die im gleichen Protokoll an Sisk weitergeleitet werden. Derzeit ist diese Funktion sehr experimentell und möglicherweise instabil genug, um nicht in der Produktion verwendet zu werden. Derzeit unterstützt der SslProxy fast alle HTTP/1.1-Features, wie z.B. Keep-Alive, Chunked-Encoding, WebSockets usw. Für eine offene Verbindung zum SSL-Proxy wird eine TCP-Verbindung zum Zielserver erstellt und der Proxy wird an die etablierte Verbindung weitergeleitet. Der SslProxy kann mit HttpServer.CreateBuilder wie folgt verwendet werden: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hallo, Welt!\"); }); }) // SSL zum Projekt hinzufügen .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Sie müssen ein gültiges SSL-Zertifikat für den Proxy bereitstellen. Um sicherzustellen, dass das Zertifikat von Browsern akzeptiert wird, importieren Sie es in das Betriebssystem, damit es ordnungsgemäß funktioniert."
  },
  "docs/de/faq.html": {
    "href": "docs/de/faq.html",
    "title": "Häufig gestellte Fragen | Sisk",
    "keywords": "Häufig gestellte Fragen Häufig gestellte Fragen über Sisk. Ist Sisk Open-Source? Vollkommen. Alle Quellcode, die von Sisk verwendet werden, sind veröffentlicht und werden häufig auf GitHub aktualisiert. Werden Beiträge akzeptiert? Solange sie mit der Sisk-Philosophie kompatibel sind, sind alle Beiträge sehr willkommen! Beiträge müssen nicht nur Code sein! Sie können auch bei der Dokumentation, Tests, Übersetzungen, Spenden und Beiträgen helfen, zum Beispiel. Wird Sisk finanziell unterstützt? Nein. Keine Organisation oder Projekt unterstützt Sisk derzeit finanziell. Kann ich Sisk in der Produktion verwenden? Absolut. Das Projekt ist seit über drei Jahren in Entwicklung und wurde in kommerziellen Anwendungen intensiv getestet, die seitdem in Produktion sind. Sisk wird in wichtigen kommerziellen Projekten als Hauptinfrastruktur verwendet. Ein Leitfaden zur Bereitstellung in verschiedenen Systemen und Umgebungen wurde geschrieben und ist verfügbar. Hat Sisk Authentifizierung, Überwachung und Datenbankdienste? Nein. Sisk hat keine davon. Es ist ein Framework für die Entwicklung von HTTP-Webanwendungen, aber es ist immer noch ein minimales Framework, das nur das Nötigste für Ihre Anwendung liefert. Sie können alle Dienste, die Sie benötigen, mit jeder beliebigen Bibliothek implementieren, die Sie bevorzugen. Sisk wurde so konzipiert, dass es agnostisch, flexibel und mit allem kompatibel ist. Warum sollte ich Sisk anstelle von verwenden? Ich weiß nicht. Sie sagen es mir. Sisk wurde erstellt, um ein generisches Szenario für HTTP-Webanwendungen in .NET zu erfüllen. Etablierte Projekte wie ASP.NET lösen verschiedene Probleme, aber mit unterschiedlichen Vorurteilen. Im Gegensatz zu größeren Frameworks erfordert Sisk, dass der Benutzer weiß, was er tut und baut. Grundlegende Kenntnisse der Webentwicklung und des HTTP-Protokolls sind für die Arbeit mit Sisk unerlässlich. Sisk ist eher mit Express von Node.js als mit ASP.NET Core vergleichbar. Es ist eine hohe Abstraktion, die es Ihnen ermöglicht, Anwendungen mit der HTTP-Logik zu erstellen, die Sie wollen. Was muss ich lernen, um Sisk zu verwenden? Sie benötigen die Grundlagen von: Webentwicklung (HTTP, Restful usw.) .NET Das ist alles. Wenn Sie eine Vorstellung von diesen beiden Themen haben, können Sie sich einige Stunden widmen, um eine fortschrittliche Anwendung mit Sisk zu entwickeln. Kann ich kommerzielle Anwendungen mit Sisk entwickeln? Absolut. Sisk wurde unter der MIT-Lizenz erstellt, was bedeutet, dass Sie Sisk in jedem kommerziellen Projekt, kommerziell oder nicht-kommerziell, ohne die Notwendigkeit einer proprietären Lizenz verwenden können. Was wir bitten, ist, dass Sie irgendwo in Ihrer Anwendung einen Hinweis auf die verwendeten Open-Source-Projekte haben und dass Sisk dabei ist."
  },
  "docs/de/features/content-streaming.html": {
    "href": "docs/de/features/content-streaming.html",
    "title": "Streaming-Inhalt | Sisk",
    "keywords": "Streaming-Inhalt Das Sisk unterstützt das Lesen und Senden von Inhalten als Streams zwischen Client und Server. Diese Funktion ist nützlich, um den Speicherüberkopft für die Serialisierung und Deserialisierung von Inhalten während der Lebensdauer einer Anfrage zu reduzieren. Anfrage-Inhalt-Stream Kleine Inhalte werden automatisch in den HTTP-Verbindungspuffer-Speicher geladen, sodass dieser Inhalt schnell in HttpRequest.Body und HttpRequest.RawBody geladen wird. Für größere Inhalte kann die HttpRequest.GetRequestStream-Methode verwendet werden, um den Anfrage-Inhalt-Stream zu erhalten. Es ist wichtig zu beachten, dass die HttpRequest.GetMultipartFormContent-Methode den gesamten Anfrage-Inhalt in den Speicher lädt, sodass sie für das Lesen großer Inhalte nicht geeignet ist. Betrachten Sie das folgende Beispiel: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // Anfrage hat keinen Inhalt return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"Datei erfolgreich gesendet.\" } ) }; } In dem obigen Beispiel liest die UploadDocument-Methode den Anfrage-Inhalt und speichert den Inhalt in einer Datei. Es wird keine zusätzliche Speicherzuweisung vorgenommen, außer für den Lese-Puffer, der von Stream.CopyToAsync verwendet wird. Das obige Beispiel reduziert den Druck der Speicherzuweisung für sehr große Dateien, was die Anwendungsleistung optimieren kann. Eine gute Praxis ist es, immer ein CancellationToken in einer Operation zu verwenden, die zeitaufwändig sein kann, wie z.B. das Senden von Dateien, da es von der Netzwerkgeschwindigkeit zwischen Client und Server abhängt. Die Anpassung mit einem CancellationToken kann wie folgt vorgenommen werden: Controller/UploadDocument.cs C# // Der CancellationToken unten wird eine Ausnahme auslösen, wenn die 30-Sekunden-Frist erreicht ist. CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"Der Upload hat die maximale Upload-Zeit (30 Sekunden) überschritten.\" } ) }; } Antwort-Inhalt-Stream Das Senden von Antwort-Inhalten ist auch möglich. Derzeit gibt es zwei Möglichkeiten, dies zu tun: über die HttpRequest.GetResponseStream-Methode und mit einem Inhalt vom Typ StreamContent. Betrachten Sie ein Szenario, in dem wir ein Bild senden müssen. Dazu können wir den folgenden Code verwenden: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // Beispiel-Methode, um ein Profilbild zu erhalten var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } Die obige Methode führt eine Speicherzuweisung durch, wenn sie den Bild-Inhalt liest. Wenn das Bild groß ist, kann dies ein Leistungsproblem verursachen und in Spitzenzeiten sogar einen Speicherüberlauf und einen Server-Absturz verursachen. In diesen Situationen kann Caching nützlich sein, aber es wird das Problem nicht eliminieren, da Speicher immer noch für diese Datei reserviert wird. Caching kann den Druck der Speicherzuweisung für jede Anfrage lindern, aber für große Dateien wird es nicht ausreichen. Das Senden des Bildes über einen Stream kann eine Lösung für das Problem sein. Anstatt den gesamten Bild-Inhalt zu lesen, wird ein Lese-Stream auf der Datei erstellt und mit einem kleinen Puffer an den Client kopiert. Senden über die GetResponseStream-Methode Die HttpRequest.GetResponseStream-Methode erstellt ein Objekt, das das Senden von Teilen der HTTP-Antwort ermöglicht, während der Inhalt-Fluss vorbereitet wird. Diese Methode ist manuell und erfordert, dass Sie den Status, die Header und die Inhaltsgröße vor dem Senden des Inhalts definieren. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // in dieser Form des Sendens müssen der Status und der Header definiert werden // bevor der Inhalt gesendet wird var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // in dieser Form des Sendens muss auch die Inhaltsgröße definiert werden // bevor sie gesendet wird. requestStreamManager.SetContentLength ( fs.Length ); // wenn Sie die Inhaltsgröße nicht kennen, können Sie chunked-encoding // verwenden, um den Inhalt zu senden requestStreamManager.SendChunked = true; // und dann schreiben Sie in den Ausgabe-Stream await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } Senden von Inhalten über einen StreamContent Die StreamContent-Klasse ermöglicht das Senden von Inhalten aus einer Datenquelle als Byte-Stream. Diese Form des Sendens ist einfacher und entfernt die vorherigen Anforderungen und ermöglicht sogar die Verwendung von Komprimierungs-Codierung, um die Inhaltsgröße zu reduzieren. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } [!WICHTIG] Bei dieser Art von Inhalten sollten Sie den Stream nicht in einem using-Block einwickeln. Der Inhalt wird automatisch vom HTTP-Server verworfen, wenn der Inhalts-Fluss abgeschlossen ist, mit oder ohne Fehler."
  },
  "docs/de/features/cors.html": {
    "href": "docs/de/features/cors.html",
    "title": "Aktivierung von CORS (Cross-Origin Resource Sharing) in Sisk | Sisk",
    "keywords": "Aktivierung von CORS (Cross-Origin Resource Sharing) in Sisk Sisk verfügt über ein Tool, das bei der Veröffentlichung Ihres Dienstes öffentlich nützlich für die Verwaltung von Cross-Origin Resource Sharing (CORS) sein kann. Diese Funktion ist nicht Teil des HTTP-Protokolls, sondern eine spezifische Funktion von Webbrowsern, die von der W3C definiert wird. Dieser Sicherheitsmechanismus verhindert, dass eine Webseite Anfragen an einen anderen Domain als diejenige sendet, die die Webseite bereitgestellt hat. Ein Dienstanbieter kann bestimmten Domains den Zugriff auf seine Ressourcen erlauben oder nur einer. Same Origin Damit eine Ressource als \"same origin\" identifiziert wird, muss eine Anfrage den Origin-Header in ihrer Anfrage enthalten: GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... Und der Remote-Server muss mit einem Access-Control-Allow-Origin-Header antworten, der den gleichen Wert wie die angeforderte Ursprung hat: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... Diese Überprüfung ist explizit: Der Host, Port und Protokoll müssen identisch mit dem Angeforderten sein. Überprüfen Sie das Beispiel: Ein Server antwortet, dass sein Access-Control-Allow-Origin https://example.com ist: https://example.net - die Domäne ist unterschiedlich. http://example.com - das Schema ist unterschiedlich. http://example.com:5555 - der Port ist unterschiedlich. https://www.example.com - der Host ist unterschiedlich. In der Spezifikation ist nur die Syntax für beide Header zulässig, sowohl für Anfragen als auch für Antworten. Der URL-Pfad wird ignoriert. Der Port wird auch weggelassen, wenn es sich um einen Standardport (80 für HTTP und 443 für HTTPS) handelt. Origin: null Origin: <schema>://<hostname> Origin: <schema>://<hostname>:<port> Aktivierung von CORS Natürlich haben Sie das CrossOriginResourceSharingHeaders-Objekt innerhalb Ihres ListeningHost. Sie können CORS beim Initialisieren des Servers konfigurieren: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } Der obige Code sendet die folgenden Header für alle Antworten: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type Diese Header müssen für alle Antworten an einen Web-Client gesendet werden, einschließlich Fehler und Umleitungen. Sie können feststellen, dass die CrossOriginResourceSharingHeaders-Klasse zwei ähnliche Eigenschaften hat: AllowOrigin und AllowOrigins. Beachten Sie, dass eine plural und die andere singular ist. Die AllowOrigin-Eigenschaft ist statisch: Nur die Ursprung, die Sie angeben, wird für alle Antworten gesendet. Die AllowOrigins-Eigenschaft ist dynamisch: Der Server überprüft, ob die Ursprung der Anfrage in dieser Liste enthalten ist. Wenn sie gefunden wird, wird sie für die Antwort dieser Ursprung gesendet. Wildcard in Origin Alternativ können Sie ein Wildcard (*) in der Antwort-Ursprung verwenden, um anzugeben, dass jede Ursprung auf die Ressource zugreifen darf. Allerdings ist dieser Wert nicht für Anfragen zulässig, die Anmeldeinformationen (Autorisierungsheader) enthalten, und dieser Vorgang wird zu einem Fehler führen. Sie können dieses Problem umgehen, indem Sie explizit auflisten, welche Ursprünge über die AllowOrigins-Eigenschaft zugelassen werden sollen, oder auch die AutoAllowOrigin-Konstante im Wert von AllowOrigin verwenden. Diese magische Eigenschaft wird den Access-Control-Allow-Origin-Header für den gleichen Wert wie den Origin-Header der Anfrage definieren. Andere Möglichkeiten, CORS anzuwenden Wenn Sie mit Dienstanbietern arbeiten, können Sie Werte überschreiben, die in der Konfigurationsdatei definiert sind: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // Überschreibt die Ursprung, die in der Konfigurationsdatei definiert ist. cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } Deaktivierung von CORS auf bestimmten Routen Die UseCors-Eigenschaft ist sowohl für Routen als auch für alle Routenattribute verfügbar und kann wie folgt deaktiviert werden: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Grüne Widget\", \"Rote Widget\" }; } } Ersetzen von Werten in der Antwort Sie können Werte explizit in einer Router-Aktion ersetzen oder entfernen: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Entfernt den Access-Control-Allow-Credentials-Header request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Ersetzt den Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Grüne Widget\", \"Rote Widget\" }; } } Preflight-Anfragen Eine Preflight-Anfrage ist eine OPTIONS-Methode-Anfrage, die der Client vor der eigentlichen Anfrage sendet. Der Sisk-Server antwortet immer mit einem 200 OK und den anwendbaren CORS-Headern, und dann kann der Client mit der eigentlichen Anfrage fortfahren. Diese Bedingung gilt nicht, wenn eine Route für die Anfrage mit der RouteMethod explizit für Options konfiguriert ist. Deaktivierung von CORS global Dies ist nicht möglich. Um CORS nicht zu verwenden, konfigurieren Sie es einfach nicht."
  },
  "docs/de/features/discard-syntax.html": {
    "href": "docs/de/features/discard-syntax.html",
    "title": "Discard-Syntax | Sisk",
    "keywords": "Discard-Syntax Der HTTP-Server kann verwendet werden, um auf eine Callback-Anfrage von einer Aktion, wie z.B. OAuth-Authentifizierung, zu hören und kann nach Erhalt dieser Anfrage verworfen werden. Dies kann in Fällen nützlich sein, in denen Sie eine Hintergrundaktion benötigen, aber keine gesamte HTTP-Anwendung dafür einrichten möchten. Das folgende Beispiel zeigt, wie man einen lauschenden HTTP-Server auf Port 5555 mit CreateListener erstellt und auf den nächsten Kontext wartet: using (var server = HttpServer.CreateListener(5555)) { // warte auf die nächste HTTP-Anfrage var context = await server.WaitNextAsync(); Console.WriteLine($\"Angeforderter Pfad: {context.Request.Path}\"); } Die WaitNext-Funktion wartet auf den nächsten Kontext einer abgeschlossenen Anfrageverarbeitung. Sobald das Ergebnis dieser Operation erhalten ist, hat der Server die Anfrage bereits vollständig bearbeitet und die Antwort an den Client gesendet."
  },
  "docs/de/features/instancing.html": {
    "href": "docs/de/features/instancing.html",
    "title": "Abhängigkeitsinjektion | Sisk",
    "keywords": "Abhängigkeitsinjektion Es ist üblich, Mitglieder und Instanzen zu widmen, die für die gesamte Lebensdauer eines Anfrages gültig sind, wie z.B. eine Datenbankverbindung, einen authentifizierten Benutzer oder ein Sitzungstoken. Eine der Möglichkeiten besteht darin, den HttpContext.RequestBag zu verwenden, der ein Dictionary erstellt, das für die gesamte Lebensdauer eines Anfrages gültig ist. Dieses Dictionary kann von Anfragebehandlern zugreifen und Variablen während der gesamten Anfrage definieren. Zum Beispiel kann ein Anfragebehandler, der einen Benutzer authentifiziert, diesen Benutzer im HttpContext.RequestBag setzen, und innerhalb der Anfrage-Logik kann dieser Benutzer mit HttpContext.RequestBag.Get<User>() abgerufen werden. Hier ist ein Beispiel: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hallo {authenticatedUser.Name}!\") }; } Dies ist ein vorläufiges Beispiel für diese Operation. Die Instanz von User wurde innerhalb des Anfragebehandlers für die Authentifizierung erstellt, und alle Routen, die diesen Anfragebehandler verwenden, haben die Garantie, dass es eine User-Instanz in ihrem HttpContext.RequestBag gibt. Es ist möglich, Logik zu definieren, um Instanzen zu erhalten, wenn sie nicht zuvor im RequestBag definiert wurden, durch Methoden wie GetOrAdd oder GetOrAddAsync. Seit Version 1.3 wurde die statische Eigenschaft HttpContext.Current eingeführt, die den Zugriff auf den aktuellen HttpContext des Anfragekontexts ermöglicht. Dies ermöglicht es, Mitglieder des HttpContext außerhalb der aktuellen Anfrage zu exponieren und Instanzen in Routen-Objekten zu definieren. Das folgende Beispiel definiert einen Controller, der Mitglieder enthält, die häufig im Kontext einer Anfrage zugegriffen werden. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // erstelle einen DbContext oder hole den bestehenden return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // die folgende Zeile wird einen Fehler werfen, wenn die Eigenschaft zugegriffen wird, wenn der Benutzer nicht // im RequestBag definiert ist public User AuthentifizierterBenutzer { get => HttpContext.Current.RequestBag.Get<User>(); } // der Zugriff auf die HttpRequest-Instanz wird auch unterstützt public HttpRequest Request { get => HttpContext.Current.Request; } } Und definiere Typen, die von diesem Controller erben: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthentifizierterBenutzer.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthentifizierterBenutzer.Id); return post ?? new HttpResponse(404); } } Für das obige Beispiel müssen Sie einen Wert-Handler in Ihrem Router konfigurieren, damit die von Ihrem Router zurückgegebenen Objekte in ein gültiges HttpResponse umgewandelt werden. Beachten Sie, dass die Methoden kein HttpRequest request-Argument haben, wie es in anderen Methoden der Fall ist. Dies liegt daran, dass der Router seit Version 1.3 zwei Arten von Delegaten für Routing-Antworten unterstützt: RouteAction, der standardmäßig ein HttpRequest-Argument erhält, und ParameterlessRouteAction. Das HttpRequest-Objekt kann immer noch über die Request-Eigenschaft des statischen HttpContext auf dem Thread zugegriffen werden. Im obigen Beispiel haben wir ein disposable-Objekt, den DbContext, definiert, und wir müssen sicherstellen, dass alle im DbContext erstellten Instanzen verworfen werden, wenn die HTTP-Sitzung endet. Dazu können wir zwei Methoden verwenden. Eine Möglichkeit besteht darin, einen Anfragebehandler zu erstellen, der nach der Aktion des Routers ausgeführt wird, und die andere Möglichkeit besteht darin, einen benutzerdefinierten Server-Handler zu verwenden. Für die erste Methode können wir den Anfragebehandler inline direkt im OnSetup-Methoden des RouterModule erstellen: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { // ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // hole einen im Request-Handler-Kontext definierten DbContext und // verwerfe ihn ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Seit Sisk-Version 1.4 ist die Eigenschaft HttpServerConfiguration.DisposeDisposableContextValues eingeführt und standardmäßig aktiviert, die bestimmt, ob der HTTP-Server alle IDisposable-Werte im Kontext-Beutel verwerfen soll, wenn eine HTTP-Sitzung geschlossen wird. Die obige Methode stellt sicher, dass der DbContext verworfen wird, wenn die HTTP-Sitzung abgeschlossen ist. Sie können dies für weitere Mitglieder tun, die am Ende einer Antwort verworfen werden müssen. Für die zweite Methode können Sie einen benutzerdefinierten Server-Handler erstellen, der den DbContext verwerfen wird, wenn die HTTP-Sitzung abgeschlossen ist. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } Und verwenden Sie ihn in Ihrem App-Builder: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Dies ist eine Möglichkeit, Code-Reinigung und Abhängigkeitsinjektion zu handhaben und die Abhängigkeiten einer Anfrage getrennt von der Art des Moduls zu halten, das verwendet wird, um die Menge an dupliziertem Code innerhalb jeder Aktion eines Routers zu reduzieren. Es ist eine Praxis, die ähnlich ist wie die, die in Frameworks wie ASP.NET verwendet wird."
  },
  "docs/de/features/logging.html": {
    "href": "docs/de/features/logging.html",
    "title": "Protokollierung | Sisk",
    "keywords": "Protokollierung Sie können Sisk so konfigurieren, dass es Zugriffs- und Fehlerprotokolle automatisch schreibt. Es ist möglich, Protokollrotation, Erweiterungen und Häufigkeit zu definieren. Die LogStream-Klasse bietet eine asynchrone Möglichkeit, Protokolle zu schreiben und sie in einer wartbaren Warteschlange zu halten. In diesem Artikel zeigen wir Ihnen, wie Sie die Protokollierung für Ihre Anwendung konfigurieren. Dateibasierte Zugriffsprotokolle Protokolle in Dateien öffnen die Datei, schreiben den Text und schließen die Datei für jede Zeile, die geschrieben wird. Dieses Verfahren wurde zur Aufrechterhaltung der Schreibreaktion in den Protokollen übernommen. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } Der obige Code schreibt alle eingehenden Anfragen in die Datei logs/access.log. Beachten Sie, dass die Datei automatisch erstellt wird, wenn sie nicht existiert, jedoch nicht das Verzeichnis davor. Es ist nicht notwendig, das Verzeichnis logs/ zu erstellen, da die LogStream-Klasse es automatisch erstellt. Stream-basierte Protokollierung Sie können Protokolldateien an TextWriter-Objekte wie Console.Out schreiben, indem Sie ein TextWriter-Objekt im Konstruktor übergeben: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); Für jede in der stream-basierten Protokollierung geschriebene Nachricht wird die TextWriter.Flush()-Methode aufgerufen. Zugriffsprotokoll-Formatierung Sie können das Zugriffsprotokoll-Format durch vordefinierte Variablen anpassen. Betrachten Sie die folgende Zeile: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; Sie schreibt eine Nachricht wie: 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] Sie können Ihre Protokolldatei durch das Format beschreiben, das in der folgenden Tabelle angegeben ist: Wert Was es darstellt Beispiel %dd Tag des Monats (als zwei Ziffern formatiert) 05 %dmmm Vollständiger Name des Monats Juli %dmm Abgekürzter Name des Monats (drei Buchstaben) Jul %dm Monatsnummer (als zwei Ziffern formatiert) 07 %dy Jahr (als vier Ziffern formatiert) 2023 %th Stunde im 12-Stunden-Format 03 %tH Stunde im 24-Stunden-Format (HH) 15 %ti Minuten (als zwei Ziffern formatiert) 30 %ts Sekunden (als zwei Ziffern formatiert) 45 %tm Millisekunden (als drei Ziffern formatiert) 123 %tz Zeitzone (gesamte Stunden in UTC) +03:00 %ri Client-IP-Adresse des Remote-Computers 192.168.1.100 %rm HTTP-Methode (in Großbuchstaben) GET %rs URI-Schema (http/https) https %ra URI-Autorität (Domain) example.com %rh Host der Anfrage www.example.com %rp Port der Anfrage 443 %rz Pfad der Anfrage /path/to/resource %rq Abfragezeichenfolge6355 ?key=value&another=123 %sc HTTP-Antwort-Statuscode 200 %sd HTTP-Antwort-Statusbeschreibung OK %lin Menschlich lesbare Größe der Anfrage 1.2 KB %linr Rohgröße der Anfrage (Bytes) 1234 %lou Menschlich lesbare Größe der Antwort 2.5 KB %lour Rohgröße der Antwort (Bytes) 2560 %lms Verstrichene Zeit in Millisekunden 120 %ls Ausführungsstatus Executed Rotierende Protokolle Tip In Sisk 0.15 und älter ist diese Funktion nur mit dem Sisk.ServiceProvider-Paket verfügbar. In Sisk 0.16 und höher ist diese Funktion im Core-Paket implementiert. Sie können den HTTP-Server so konfigurieren, dass er die Protokolldateien in eine komprimierte .gz-Datei umwandelt, wenn sie eine bestimmte Größe erreichen. Die Größe wird periodisch durch den von Ihnen definierten Schwellenwert überprüft. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); Der obige Code überprüft alle sechs Stunden, ob die Datei des LogStreams die 1-MB-Grenze erreicht hat. Wenn ja, wird die Datei in eine .gz-Datei komprimiert und die access.log-Datei wird gelöscht. Während dieses Prozesses wird das Schreiben in die Datei gesperrt, bis die Datei komprimiert und gelöscht ist. Alle Zeilen, die in diesem Zeitraum geschrieben werden sollen, werden in einer Warteschlange gespeichert, bis die Komprimierung abgeschlossen ist. Diese Funktion funktioniert nur mit dateibasierten LogStreams. Fehlerprotokollierung Wenn ein Server keine Fehler an den Debugger weiterleitet, leitet er Fehler an die Protokollierung weiter, wenn Fehler auftreten. Sie können die Fehlerprotokollierung mit: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Diese Eigenschaft schreibt nur dann etwas in das Protokoll, wenn der Fehler nicht von der Rückruf-Funktion oder der Router.CallbackErrorHandler-Eigenschaft abgefangen wird. Der Fehler, der vom Server geschrieben wird, schreibt immer das Datum und die Uhrzeit, die Anfrage-Header (nicht den Text), die Fehlerverfolgung und die innere Ausnahme-Verfolgung, wenn vorhanden. Andere Protokollierungsinstanzen Ihre Anwendung kann null oder mehrere LogStreams haben, es gibt keine Grenze für die Anzahl der Protokollkanäle, die sie haben kann. Es ist daher möglich, die Protokollierung Ihrer Anwendung in eine Datei umzuleiten, die sich von der Standard-Zugriffsprotokollierung oder Fehlerprotokollierung unterscheidet. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Anwendung gestartet am {0}\", DateTime.Now); Erweiterung von LogStream Sie können die LogStream-Klasse erweitern, um benutzerdefinierte Formate zu schreiben, die mit dem aktuellen Sisk-Protokollmotor kompatibel sind. Das folgende Beispiel ermöglicht es, farbige Nachrichten über die Spectre.Console-Bibliothek in die Konsole zu schreiben: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Eine weitere Möglichkeit, automatisch benutzerdefinierte Protokolle für jede Anfrage/Antwort zu schreiben, besteht darin, einen HttpServerHandler zu erstellen. Das folgende Beispiel ist ein wenig umfassender. Es schreibt den Text der Anfrage und Antwort im JSON-Format in die Konsole. Es kann nützlich sein, Anfragen im Allgemeinen zu debuggen. Dieses Beispiel verwendet ContextBag und HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // Zu diesem Zeitpunkt ist die Verbindung geöffnet und der Client hat den Header gesendet, der angibt, // dass der Inhalt JSON ist. Die folgende Zeile liest den Inhalt und speichert ihn im Anfrage-Objekt. // // Wenn der Inhalt nicht im Anfrage-Objekt gelesen wird, ist es wahrscheinlich, dass der GC den Inhalt // nach dem Senden der Antwort an den Client sammelt, sodass der Inhalt möglicherweise nicht nach dem Schließen // der Antwort verfügbar ist. // _ = request.RawBody; // Fügen Sie einen Hinweis im Kontext hinzu, um anzugeben, dass diese Anfrage einen JSON-Textkörper enthält request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // Reformuliert den JSON mithilfe der CypherPotato.LightJson-Bibliothek var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // Überprüfen, ob die Antwort JSON ist httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // Ruft den internen Server-Verarbeitungsstatus ab responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/de/features/server-sent-events.html": {
    "href": "docs/de/features/server-sent-events.html",
    "title": "Server Sent Events | Sisk",
    "keywords": "Server Sent Events Sisk unterstützt das Senden von Nachrichten über Server Sent Events out of the box. Sie können disposible und persistente Verbindungen erstellen, die Verbindungen während der Laufzeit abrufen und verwenden. Diese Funktion hat einige Einschränkungen, die von Browsern auferlegt werden, wie z.B. das Senden von nur Textnachrichten und das Nicht-Schließen einer Verbindung dauerhaft. Eine serverseitig geschlossene Verbindung wird von einem Client alle 5 Sekunden (3 für einige Browser) versuchen, erneut zu verbinden. Diese Verbindungen sind nützlich, um Ereignisse vom Server an den Client zu senden, ohne dass der Client die Informationen jedes Mal anfordern muss. Erstellen einer SSE-Verbindung Eine SSE-Verbindung funktioniert wie eine reguläre HTTP-Anfrage, aber anstatt eine Antwort zu senden und die Verbindung sofort zu schließen, wird die Verbindung offen gehalten, um Nachrichten zu senden. Durch Aufrufen der HttpRequest.GetEventSource()-Methode wird die Anfrage in einen Wartezustand versetzt, während die SSE-Instanz erstellt wird. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Hallo, Welt!\"); return sse.Close(); }); Im obigen Code erstellen wir eine SSE-Verbindung und senden eine \"Hallo, Welt!\"-Nachricht, dann schließen wir die SSE-Verbindung von der Serverseite. Note Wenn eine serverseitige Verbindung geschlossen wird, versucht der Client standardmäßig, die Verbindung erneut herzustellen, und die Verbindung wird neu gestartet, die Methode wird erneut ausgeführt, für immer. Es ist üblich, eine Terminationsnachricht vom Server zu senden, wenn die Verbindung vom Server geschlossen wird, um zu verhindern, dass der Client versucht, erneut zu verbinden. Anhängen von Headern Wenn Sie Header senden müssen, können Sie die HttpRequestEventSource.AppendHeader-Methode verwenden, bevor Sie Nachrichten senden. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Schlüssel\", \"Header-Wert\"); sse.Send(\"Hallo!\"); return sse.Close(); }); Beachten Sie, dass es notwendig ist, die Header zu senden, bevor Sie Nachrichten senden. Wait-For-Fail-Verbindungen Verbindungen werden normalerweise beendet, wenn der Server nicht mehr in der Lage ist, Nachrichten zu senden, aufgrund einer möglichen clientseitigen Trennung. Damit wird die Verbindung automatisch beendet und die Instanz der Klasse verworfen. Selbst bei einer erneuten Verbindung funktioniert die Instanz der Klasse nicht, da sie an die vorherige Verbindung gekoppelt ist. In einigen Situationen benötigen Sie diese Verbindung später und möchten sie nicht über die Callback-Methode der Route verwalten. Dafür können wir die SSE-Verbindungen mit einer Kennung identifizieren und sie später mithilfe dieser Kennung abrufen, auch außerhalb des Callbacks der Route. Darüber hinaus markieren wir die Verbindung mit WaitForFail, um die Route nicht zu beenden und die Verbindung automatisch zu beenden. Eine SSE-Verbindung in KeepAlive wartet auf einen Sendefehler (verursacht durch Trennung), um die Methoden Ausführung fortzusetzen. Es ist auch möglich, ein Timeout für dies festzulegen. Nach Ablauf der Zeit wird die Verbindung beendet, wenn keine Nachricht gesendet wurde, und die Ausführung wird fortgesetzt. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"meine-index-verbindung\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // warten Sie 15 Sekunden ohne Nachrichten, bevor Sie die Verbindung beenden return sse.Close(); }); Die obige Methode erstellt die Verbindung, behandelt sie und wartet auf eine Trennung oder einen Fehler. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"meine-index-verbindung\"); if (evs != null) { // die Verbindung ist noch aktiv evs.Send(\"Hallo wieder!\"); } Und das obige Code-Snippet versucht, die neu erstellte Verbindung zu suchen, und wenn sie existiert, sendet es eine Nachricht an sie. Alle aktiven Serververbindungen, die identifiziert werden, stehen in der Sammlung HttpServer.EventSources zur Verfügung. Diese Sammlung speichert nur aktive und identifizierte Verbindungen. Geschlossene Verbindungen werden aus der Sammlung entfernt. Note Es ist wichtig zu beachten, dass Keep-Alive eine Grenze hat, die von Komponenten festgelegt wird, die möglicherweise auf unkontrollierbare Weise mit Sisk verbunden sind, wie z.B. ein Web-Proxy, ein HTTP-Kernel oder ein Netzwerktreiber, und diese schließen inaktive Verbindungen nach einer bestimmten Zeit. Daher ist es wichtig, die Verbindung offen zu halten, indem Sie periodische Pings senden oder die maximale Zeit verlängern, bevor die Verbindung geschlossen wird. Lesen Sie den nächsten Abschnitt, um besser zu verstehen, wie periodische Pings gesendet werden. Einrichtung von Ping-Richtlinien für Verbindungen Ping-Richtlinien sind eine automatisierte Möglichkeit, periodische Nachrichten an Ihren Client zu senden. Diese Funktion ermöglicht es dem Server, zu verstehen, wann der Client die Verbindung getrennt hat, ohne die Verbindung auf unbestimmte Zeit offen halten zu müssen. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"Ping-Nachricht\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } Im obigen Code wird alle 5 Sekunden eine neue Ping-Nachricht an den Client gesendet. Dies hält die TCP-Verbindung aktiv und verhindert, dass sie aufgrund von Inaktivität geschlossen wird. Wenn eine Nachricht nicht gesendet werden kann, wird die Verbindung automatisch geschlossen, wodurch die von der Verbindung verwendeten Ressourcen freigegeben werden. Abfragen von Verbindungen Sie können aktive Verbindungen mithilfe eines Prädikats für die Verbindungs-ID suchen, um beispielsweise zu broadcasten. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"meine-verbindung-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcast an alle Ereignisquellen, die mit 'meine-verbindung-' beginnen\"); } Sie können auch die All-Methode verwenden, um alle aktiven SSE-Verbindungen zu erhalten."
  },
  "docs/de/features/websockets.html": {
    "href": "docs/de/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk unterstützt auch Web Sockets, sowohl beim Empfangen als auch beim Senden von Nachrichten an den Client. Diese Funktion funktioniert in den meisten Browsern einwandfrei, ist aber in Sisk noch experimentell. Bitte melden Sie etwaige Fehler auf GitHub. Asynchrones Akzeptieren und Empfangen von Nachrichten Das folgende Beispiel zeigt, wie WebSocket in der Praxis funktioniert, mit einem Beispiel für das Öffnen einer Verbindung, das Empfangen einer Nachricht und das Anzeigen im Konsolenfenster. Alle von WebSocket empfangenen Nachrichten werden in Bytes empfangen, daher müssen Sie diese bei Empfang dekodieren. Standardmäßig werden Nachrichten in Pakete aufgeteilt und das letzte Stück wird als letztes Paket der Nachricht gesendet. Sie können die Paketgröße mit dem WebSocketBufferSize-Flag konfigurieren. Diese Pufferung gilt sowohl für das Senden als auch für das Empfangen von Nachrichten. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Nachricht empfangen: \" + msgText); // erhält den HttpWebSocket-Kontext, der die Nachricht empfangen hat HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Antwort!\"); }; ws.WaitForClose(); return ws.Close(); }); Note Verwenden Sie keine asynchronen Ereignisse auf diese Weise. Sie können Ausnahmen außerhalb des HTTP-Server-Bereichs auslösen und Ihre Anwendung zum Absturz bringen. Wenn Sie asynchrone Code-Handler verwenden und mit mehreren Nachrichten gleichzeitig umgehen müssen, können Sie die Nachrichten-Schleife verwenden: router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Nachricht empfangen: {messageText}\"); await ws.SendAsync(\"Hallo vom Server!\"); } return ws.Close(); }); Synchrones Akzeptieren und Empfangen von Nachrichten Das folgende Beispiel enthält eine Möglichkeit, einen synchronen WebSocket zu verwenden, ohne einen asynchronen Kontext, in dem Sie die Nachrichten empfangen, verarbeiten und dann den Socket schließen. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"Wie heißt du?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Bitte gib deinen Namen ein!\"); goto askName; } askAge: ws.Send(\"Und wie alt bist du?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Bitte gib eine gültige Zahl ein\"); goto askAge; } ws.Send($\"Du bist {name} und {age} Jahre alt.\"); return ws.Close(); }); Senden von Nachrichten Die Send-Methode hat drei Überlastungen, die es ermöglichen, Text, ein Byte-Array oder einen Byte-Span zu senden. Alle von ihnen werden in Pakete aufgeteilt, wenn die WebSocketBufferSize-Flagge des Servers größer ist als die Gesamtgröße der Payload. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hallo, Welt\"); // wird als UTF-8-Byte-Array kodiert ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Warten auf WebSocket-Schließung Die Methode WaitForClose() blockiert den aktuellen Aufrufstack, bis die Verbindung entweder vom Client oder vom Server beendet wird. Dadurch wird die Ausführung des Rückrufs der Anfrage blockiert, bis der Client oder der Server die Verbindung trennt. Sie können die Verbindung auch manuell mit der Close()-Methode schließen. Diese Methode gibt ein leeres HttpResponse-Objekt zurück, das nicht an den Client gesendet wird, aber als Rückgabe aus der Funktion fungiert, in der die HTTP-Anfrage empfangen wurde. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // warten Sie, bis der Client die Verbindung schließt ws.WaitForClose(); // warten Sie, bis 60 Sekunden lang keine Nachrichten mehr ausgetauscht werden // oder bis eine Partei die Verbindung schließt ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Ping-Richtlinie Ähnlich wie bei der Ping-Richtlinie in Server Side Events können Sie auch eine Ping-Richtlinie konfigurieren, um die TCP-Verbindung offen zu halten, wenn es Inaktivität gibt. ws.WithPing(ping => { ping.DataMessage = \"Ping-Nachricht\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/de/fundamentals/request-handlers.html": {
    "href": "docs/de/fundamentals/request-handlers.html",
    "title": "Anfragebehandlung | Sisk",
    "keywords": "Anfragebehandlung Anfragebehandler, auch bekannt als \"Middleware\", sind Funktionen, die vor oder nach der Ausführung einer Anfrage auf dem Router ausgeführt werden. Sie können pro Route oder pro Router definiert werden. Es gibt zwei Arten von Anfragebehandlern: BeforeResponse: definiert, dass der Anfragebehandler vor dem Aufruf der Router-Aktion ausgeführt wird. AfterResponse: definiert, dass der Anfragebehandler nach dem Aufruf der Router-Aktion ausgeführt wird. Das Senden einer HTTP-Antwort in diesem Kontext überschreibt die Router-Aktionsantwort. Beide Anfragebehandler können die tatsächliche Router-Rückruf-Funktion überschreiben. Darüber hinaus können Anfragebehandler nützlich sein, um eine Anfrage zu validieren, wie z.B. Authentifizierung, Inhalt oder andere Informationen, wie z.B. das Speichern von Informationen, Protokollen oder anderen Schritten, die vor oder nach einer Antwort ausgeführt werden können. Auf diese Weise kann ein Anfragebehandler die gesamte Ausführung unterbrechen und eine Antwort zurückgeben, bevor der Zyklus beendet ist, und alles andere im Prozess verwerfen. Beispiel: Nehmen wir an, dass ein Benutzer-Authentifizierungsanfragebehandler den Benutzer nicht authentifiziert. Er wird den Anfragelebenszyklus nicht fortsetzen und hängen bleiben. Wenn dies im Anfragebehandler an Position zwei passiert, werden die dritte und folgenden nicht ausgewertet. Erstellen eines Anfragebehandlers Um einen Anfragebehandler zu erstellen, können wir eine Klasse erstellen, die die IRequestHandler-Schnittstelle erbt, in diesem Format: Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Rückgabe von null bedeutet, dass der Anfragezyklus fortgesetzt werden kann return null; } else { // Rückgabe eines HttpResponse-Objekts bedeutet, dass diese Antwort die benachbarten Antworten überschreibt. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } Im obigen Beispiel haben wir angegeben, dass, wenn die Authorization-Header in der Anfrage vorhanden ist, sie fortgesetzt werden sollte und der nächste Anfragebehandler oder die Router-Rückruf-Funktion aufgerufen werden sollte, je nachdem, was zuerst kommt. Wenn ein Anfragebehandler nach der Antwort durch ihre Eigenschaft ExecutionMode ausgeführt wird und einen nicht-leeren Wert zurückgibt, wird er die Router-Antwort überschreiben. Wenn ein Anfragebehandler null zurückgibt, bedeutet dies, dass die Anfrage fortgesetzt werden muss und das nächste Objekt aufgerufen werden muss oder der Zyklus mit der Router-Antwort enden muss. Zuordnen eines Anfragebehandlers zu einer einzelnen Route Sie können einen oder mehrere Anfragebehandler für eine Route definieren. Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // vorheriger Anfragebehandler new ValidateJsonContentRequestHandler(), // vorheriger Anfragebehandler // -- Methode IndexPage wird hier ausgeführt new WriteToLogRequestHandler() // nachfolgender Anfragebehandler }); Oder durch Erstellen eines Route-Objekts: Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Zuordnen eines Anfragebehandlers zu einem Router Sie können einen globalen Anfragebehandler definieren, der auf allen Routen auf einem Router ausgeführt wird. Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Zuordnen eines Anfragebehandlers zu einem Attribut Sie können einen Anfragebehandler auf einem Methoden-Attribut zusammen mit einem Route-Attribut definieren. Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hallo Welt!\") }; } } Beachten Sie, dass es notwendig ist, den gewünschten Anfragebehandlertyp und nicht eine Objektinstanz zu übergeben. Auf diese Weise wird der Anfragebehandler vom Router-Parser instanziert. Sie können Argumente im Klassenkonstruktor mit der ConstructorArguments-Eigenschaft übergeben. Beispiel: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hallo Welt!\") }; } Sie können auch Ihr eigenes Attribut erstellen, das RequestHandler implementiert: Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } Und es wie folgt verwenden: Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hallo Welt!\") }; } Umgehen eines globalen Anfragebehandlers Nachdem Sie einen globalen Anfragebehandler auf einer Route definiert haben, können Sie diesen Anfragebehandler auf bestimmten Routen ignorieren. Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"Meine Route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: dieselbe Instanz wie in den globalen Anfragebehandlern new AuthenticateUserRequestHandler() // falsch: wird den globalen Anfragebehandler nicht überspringen } }); [!HINWEIS] Wenn Sie einen Anfragebehandler umgehen, müssen Sie dieselbe Referenz verwenden, die Sie zuvor instanziert haben, um den globalen Anfragebehandler zu überspringen. Das Erstellen einer anderen Anfragebehandler-Instanz wird den globalen Anfragebehandler nicht überspringen, da die Referenz geändert wird. Beachten Sie, dass Sie dieselbe Anfragebehandler-Referenz verwenden müssen, die in beiden GlobalRequestHandlers und BypassGlobalRequestHandlers verwendet wird."
  },
  "docs/de/fundamentals/requests.html": {
    "href": "docs/de/fundamentals/requests.html",
    "title": "Anfragen | Sisk",
    "keywords": "Anfragen Anfragen sind Strukturen, die eine HTTP-Anfrage-Nachricht darstellen. Das HttpRequest-Objekt enthält nützliche Funktionen für die Verarbeitung von HTTP-Nachrichten in Ihrer Anwendung. Eine HTTP-Anfrage besteht aus der Methode, dem Pfad, der Version, den Headern und dem Body. In diesem Dokument werden wir Ihnen zeigen, wie Sie jedes dieser Elemente erhalten. Abrufen der Anfragemethode Um die Methode der empfangenen Anfrage zu erhalten, können Sie die Methode-Eigenschaft verwenden: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Diese Eigenschaft gibt die Anfragemethode als HttpMethod-Objekt zurück. Note Im Gegensatz zu Routenmethoden dient diese Eigenschaft nicht dem RouteMethod.Any-Element. Stattdessen gibt sie die tatsächliche Anfragemethode zurück. Abrufen von URL-Komponenten Sie können verschiedene Komponenten aus einer URL über bestimmte Eigenschaften einer Anfrage abrufen. Für dieses Beispiel betrachten wir die URL: http://localhost:5000/user/login?email=foo@bar.com Komponentenname Beschreibung Komponentenwert Path Ruft den Anfragepfad ab. /user/login FullPath Ruft den Anfragepfad und die Abfragezeichenfolge ab. /user/login?email=foo@bar.com FullUrl Ruft die gesamte URL-Anfragezeichenfolge ab. http://localhost:5000/user/login?email=foo@bar.com Host Ruft den Anfragehost ab. localhost Authority Ruft den Anfragehost und den Port ab. localhost:5000 QueryString Ruft die Anfrageabfrage ab. ?email=foo@bar.com Query Ruft die Anfrageabfrage als benannte Wertesammlung ab. {StringValueCollection-Objekt} IsSecure Bestimmt, ob die Anfrage SSL verwendet (true) oder nicht (false). false Sie können auch die HttpRequest.Uri-Eigenschaft verwenden, die alles oben Genannte in einem Objekt enthält. Abrufen des Anfragebodies Einige Anfragen enthalten einen Body, wie z. B. Formulare, Dateien oder API-Transaktionen. Sie können den Body einer Anfrage aus der Eigenschaft abrufen: // Ruft den Anfragebody als Zeichenfolge ab, wobei die Anfragecodierung als Codierer verwendet wird string body = request.Body; // oder ruft ihn als Byte-Array ab byte[] bodyBytes = request.RawBody; // oder Sie können ihn streamen Stream requestStream = request.GetRequestStream(); Es ist auch möglich, zu bestimmen, ob ein Body in der Anfrage vorhanden ist und ob er geladen ist, mit den Eigenschaften HasContents, die bestimmt, ob die Anfrage Inhalte enthält, und IsContentAvailable, die angibt, dass der HTTP-Server den Inhalt vom Remote-Punkt vollständig empfangen hat. Es ist nicht möglich, den Anfrageinhalt über GetRequestStream mehr als einmal zu lesen. Wenn Sie mit dieser Methode lesen, sind die Werte in RawBody und Body nicht mehr verfügbar. Es ist nicht notwendig, den Anfragestream im Kontext der Anfrage zu entsorgen, da er am Ende der HTTP-Sitzung, in der er erstellt wird, entsorgt wird. Sie können auch die HttpRequest.RequestEncoding-Eigenschaft verwenden, um die beste Codierung zu erhalten, um die Anfrage manuell zu decodieren. Der Server hat Grenzen für das Lesen des Anfrageinhalts, die sowohl für HttpRequest.Body als auch für HttpRequest.RawBody gelten. Diese Eigenschaften kopieren den gesamten Eingabestream in einen lokalen Puffer der gleichen Größe wie HttpRequest.ContentLength. Eine Antwort mit dem Status 413 Inhalt zu groß wird an den Client zurückgegeben, wenn der gesendete Inhalt größer ist als HttpServerConfiguration.MaximumContentLength, wie in der Benutzerkonfiguration definiert. Zusätzlich wird, wenn es keine konfigurierte Grenze gibt oder wenn sie zu groß ist, der Server eine OutOfMemoryException auslösen, wenn der vom Client gesendete Inhalt Int32.MaxValue (2 GB) überschreitet und wenn der Inhalt über eine der oben genannten Eigenschaften abgerufen wird. Sie können den Inhalt immer noch über Streaming verarbeiten. Note Obwohl Sisk dies zulässt, ist es immer eine gute Idee, HTTP-Semantik zu befolgen, um Ihre Anwendung zu erstellen und nicht Inhalte in Methoden zu erhalten oder bereitzustellen, die dies nicht zulassen. Lesen Sie über RFC 9110 \"HTTP-Semantik\". Abrufen des Anfragekontexts Der HTTP-Kontext ist ein exklusives Sisk-Objekt, das Informationen über den HTTP-Server, die Route, den Router und den Anfragehandler enthält. Sie können es verwenden, um sich in einer Umgebung zu organisieren, in der diese Objekte schwer zu organisieren sind. Das RequestBag-Objekt enthält gespeicherte Informationen, die von einem Anfragehandler an einen anderen Punkt übergeben werden und am Endziel verbraucht werden können. Dieses Objekt kann auch von Anfragehandlern verwendet werden, die nach dem Routenrückruf ausgeführt werden. Tip Diese Eigenschaft ist auch über die HttpRequest.Bag-Eigenschaft zugänglich. Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } Der obige Anfragehandler wird AuthenticatedUser im Anfragebeutel definieren und kann später im Endrückruf verbraucht werden: Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hallo, {authUser.Name}!\") }; } } Sie können auch die Bag.Set()- und Bag.Get()-Hilfsmethoden verwenden, um Objekte nach ihrem Typ zu erhalten oder zu setzen. Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } Abrufen von Formulardaten Sie können die Werte von Formulardaten in einer NameValueCollection mit dem folgenden Beispiel abrufen: Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } Abrufen von Multipart-Formulardaten Sisks HTTP-Anfrage ermöglicht es Ihnen, hochgeladene Multipart-Inhalte wie Dateien, Formularfelder oder beliebige Binärinhalte abzurufen. Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // Die folgende Methode liest die gesamte Anfrageeingabe in ein // Array von MultipartObjecten var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // Der Name der Datei, die durch die Multipart-Formulardaten bereitgestellt wird. // Null wird zurückgegeben, wenn das Objekt keine Datei ist. Console.WriteLine(\"Dateiname : \" + uploadedObject.Filename); // Der Name des Multipart-Formulardatenfelds. Console.WriteLine(\"Feldname : \" + uploadedObject.Name); // Die Länge des Multipart-Formulardateninhalts. Console.WriteLine(\"Inhaltslänge : \" + uploadedObject.ContentLength); // Bestimmt das Dateiformat basierend auf dem Dateikopf für jeden // bekannten Inhaltstyp. Wenn der Inhalt kein erkanntes gängiges Dateiformat ist, // gibt diese Methode MultipartObjectCommonFormat.Unknown zurück Console.WriteLine(\"Gängiges Format : \" + uploadedObject.GetCommonFileFormat()); } } Sie können mehr über Sisks Multipart-Formulardatenobjekte und ihre Methoden, Eigenschaften und Funktionen erfahren. Server-sent-Events-Unterstützung Sisk unterstützt Server-sent-Events, die es ermöglichen, Chunks als Stream zu senden und die Verbindung zwischen Server und Client aufrechtzuerhalten. Durch den Aufruf der HttpRequest.GetEventSource-Methode wird die HttpRequest in ihren Zuhörerzustand versetzt. Von diesem Zeitpunkt an erwartet der Kontext dieser HTTP-Anfrage keine HttpResponse, da sie die von der Server-Seite gesendeten Pakete überlagert. Nach dem Senden aller Pakete muss die Rückrufmethode die Close-Methode zurückgeben, die die endgültige Antwort an den Server sendet und anzeigt, dass der Streamingvorgang beendet wurde. Es ist nicht möglich, die Gesamtlänge aller Pakete vorherzusagen, die gesendet werden, daher ist es nicht möglich, das Ende der Verbindung mit dem Content-Length-Header zu bestimmen. Die meisten Browser unterstützen standardmäßig keine Server-sent-Events, die HTTP-Header oder Methoden anderen als der GET-Methode senden. Daher sollten Sie vorsichtig sein, wenn Sie Anfragehandler mit Event-Quellen-Anfragen verwenden, die bestimmte Header in der Anfrage erfordern, da sie wahrscheinlich nicht vorhanden sind. Außerdem starten die meisten Browser Streams erneut, wenn die EventSource.close-Methode auf der Client-Seite nach dem Empfang aller Pakete nicht aufgerufen wird, was zu endlosem zusätzlichem Verarbeitung auf der Server-Seite führt. Um dieses Problem zu vermeiden, ist es üblich, ein letztes Paket zu senden, das anzeigt, dass die Event-Quelle alle Pakete gesendet hat. Das folgende Beispiel zeigt, wie der Browser mit einem Server kommunizieren kann, der Server-sent-Events unterstützt. sse-example.html HTML <html> <body> <b>Früchte:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `Nachricht: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomate\") { evtSource.close(); } } </script> </html> Und sendet die Nachrichten schrittweise an den Client: Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] fruechte = new[] { \"Apfel\", \"Banane\", \"Wassermelone\", \"Tomate\" }; foreach (string frucht in fruechte) { await serverEvents.SendAsync(frucht); await Task.Delay(1500); } return serverEvents.Close(); } } Wenn wir diesen Code ausführen, erwarten wir ein Ergebnis, das diesem ähnelt: Auflösen von proxied IPs und Hosts Sisk kann mit Proxys verwendet werden, und daher können IP-Adressen durch den Proxy-Endpunkt im Transaktionsverlauf von einem Client zum Proxy ersetzt werden. Sie können Ihre eigenen Auflöser in Sisk mit Forwarding-Resolvery definieren. Header-Codierung Header-Codierung kann ein Problem für einige Implementierungen darstellen. Unter Windows werden UTF-8-Header nicht unterstützt, daher wird ASCII verwendet. Sisk verfügt über einen integrierten Codierungskonverter, der für die Decodierung von falsch codierten Headern nützlich sein kann. Dieser Vorgang ist kostspielig und standardmäßig deaktiviert, kann aber unter der NormalizeHeadersEncodings-Flag aktiviert werden."
  },
  "docs/de/fundamentals/responses.html": {
    "href": "docs/de/fundamentals/responses.html",
    "title": "Antworten | Sisk",
    "keywords": "Antworten Antworten stellen Objekte dar, die HTTP-Antworten auf HTTP-Anfragen sind. Sie werden vom Server an den Client gesendet, um die Anfrage nach einer Ressource, Seite, Dokument, Datei oder einem anderen Objekt anzuzeigen. Eine HTTP-Antwort besteht aus Status, Headern und Inhalt. In diesem Dokument erfahren Sie, wie Sie HTTP-Antworten mit Sisk entwerfen. Festlegen eines HTTP-Status Die Liste der HTTP-Statuscodes ist seit HTTP/1.0 gleich und Sisk unterstützt alle davon. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 Oder mit Fluent-Syntax: new HttpResponse() .WithStatus(200) // oder .WithStatus(HttpStatusCode.Ok) // oder .WithStatus(HttpStatusInformation.Ok); Sie können die vollständige Liste der verfügbaren HttpStatusCode hier sehen. Sie können auch Ihren eigenen Statuscode mithilfe der HttpStatusInformation-Struktur bereitstellen. Body und Content-Type Sisk unterstützt .NET-Inhalte Objekte, um den Body in Antworten zu senden. Sie können die StringContent-Klasse verwenden, um beispielsweise eine JSON-Antwort zu senden: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); Der Server versucht immer, die Content-Length aus dem zu definieren, was Sie im Inhalt definiert haben, wenn Sie es nicht explizit in einem Header definiert haben. Wenn der Server den Content-Length-Header nicht implizit aus dem Antwortinhalt abrufen kann, wird die Antwort mit Chunked-Encoding gesendet. Sie können die Antwort auch streamen, indem Sie einen StreamContent senden oder die Methode GetResponseStream verwenden. Antwort-Header Sie können Header hinzufügen, bearbeiten oder entfernen, die Sie in der Antwort senden. Das folgende Beispiel zeigt, wie Sie eine Umleitungsantwort an den Client senden. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Oder mit Fluent-Syntax: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Wenn Sie die Add-Methode von HttpHeaderCollection verwenden, fügen Sie einen Header zur Anfrage hinzu, ohne die bereits gesendeten zu ändern. Die Set-Methode ersetzt die Header mit demselben Namen durch den angegebenen Wert. Der Index von HttpHeaderCollection ruft intern die Set-Methode auf, um die Header zu ersetzen. Senden von Cookies Sisk verfügt über Methoden, die die Definition von Cookies auf dem Client erleichtern. Cookies, die mit dieser Methode gesetzt werden, sind bereits URL-kodiert und entsprechen dem RFC-6265-Standard. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Oder mit Fluent-Syntax: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Es gibt andere vollständigere Versionen derselben Methode. Chunked-Antworten Sie können die Übertragungskodierung auf chunked setzen, um große Antworten zu senden. HttpResponse res = new HttpResponse(); res.SendChunked = true; Bei Verwendung von Chunked- Encoding wird der Content-Length-Header automatisch weggelassen. Antwortstrom Antwortströme sind eine verwaltete Möglichkeit, die es Ihnen ermöglicht, Antworten auf eine segmentierte Weise zu senden. Es handelt sich um eine Ebene tiefer als die Verwendung von HttpResponse-Objekten, da sie erfordern, dass Sie die Header und Inhalte manuell senden und dann die Verbindung schließen. Dieses Beispiel öffnet einen schreibgeschützten Strom für die Datei, kopiert den Strom in den Antwortausgabestrom und lädt die gesamte Datei nicht in den Speicher. Dies kann nützlich sein, um mittelgroße oder große Dateien zu bedienen. // erhält den Antwortausgabestrom using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // setzt die Antwortkodierung auf chunked-encoding // auch sollten Sie den Content-Length-Header nicht senden, wenn Sie chunked-encoding verwenden responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // kopiert den Dateistream in den Antwortausgabestrom fileStream.CopyTo(responseStream.ResponseStream); // schließt den Strom return responseStream.Close(); GZip-, Deflate- und Brotli-Komprimierung Sie können Antworten mit komprimierten Inhalten in Sisk senden, indem Sie HTTP-Inhalte komprimieren. Zuerst kapseln Sie Ihr HttpContent-Objekt in eines der untenstehenden Kompressoren, um die komprimierte Antwort an den Client zu senden. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // oder Content = new BrotliContent(new HtmlContent(myHtml)), // oder Content = new DeflateContent(new HtmlContent(myHtml)), }; }); Sie können diese komprimierten Inhalte auch mit Strömen verwenden. router.MapGet(\"/archive.zip\", request => { // verwenden Sie hier nicht \"using\". Der HttpServer verwirft Ihren Inhalt // nachdem er die Antwort gesendet hat. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Die Content-Encoding-Header werden automatisch gesetzt, wenn diese Inhalte verwendet werden. Automatische Komprimierung Es ist möglich, HTTP-Antworten mit der EnableAutomaticResponseCompression-Eigenschaft automatisch zu komprimieren. Diese Eigenschaft kapselt den Antwortinhalt vom Router automatisch in einen komprimierbaren Inhalt, der von der Anfrage akzeptiert wird, vorausgesetzt, die Antwort wird nicht von einem CompressedContent geerbt. Nur ein komprimierbarer Inhalt wird für eine Anfrage ausgewählt, die gemäß der Accept-Encoding-Header, die der Reihe nach folgt: BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) Wenn die Anfrage angibt, dass sie eine dieser Komprimierungsmethoden akzeptiert, wird die Antwort automatisch komprimiert. Implizite Antworttypen Sie können andere Rückgabetypen als HttpResponse verwenden, aber es ist notwendig, den Router zu konfigurieren, wie er jeden Objekttyp behandelt. Das Konzept besteht darin, immer einen Referenztyp zurückzugeben und ihn in ein gültiges HttpResponse-Objekt umzuwandeln. Routen, die HttpResponse zurückgeben, unterliegen keiner Umwandlung. Wertetypen (Strukturen) können nicht als Rückgabetyp verwendet werden, da sie nicht mit dem RouterCallback kompatibel sind. Daher müssen sie in ein ValueResult gekapselt werden, um in Handhabern verwendet werden zu können. Betrachten Sie das folgende Beispiel eines Router-Moduls, das nicht HttpResponse im Rückgabetyp verwendet: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } Damit muss nun im Router definiert werden, wie er mit jedem Objekttyp umgeht. Objekte sind immer das erste Argument des Handlers und der Ausgabetyp muss ein gültiges HttpResponse sein. Außerdem sollten die Ausgabeobjekte einer Route niemals null sein. Für ValueResult-Typen ist es nicht notwendig, anzugeben, dass das Eingabeobjekt ein ValueResult ist und nur T, da ValueResult ein Objekt ist, das von seiner ursprünglichen Komponente reflektiert wird. Die Zuordnung von Typen vergleicht nicht, was registriert wurde, mit dem Typ des Objekts, das vom Router-Callback zurückgegeben wird. Stattdessen prüft es, ob der Typ des Router-Ergebnisses dem registrierten Typ zuweisbar ist. Das Registrieren eines Handlers vom Typ Object wird auf alle zuvor nicht validierten Typen zurückgeführt. Die Einfügereihenfolge der Wert-Handler spielt auch eine Rolle, daher sollten Sie zuerst bestimmte Wert-Handler registrieren, um die Reihenfolge sicherzustellen. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // das Registrieren eines Wert-Handlers vom Typ Object muss das letzte sein // Wert-Handler, der als Fallback verwendet wird r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); Hinweis zu enumerable Objekten und Arrays Implizite Antwortobjekte, die IEnumerable implementieren, werden durch die ToArray()-Methode in den Speicher gelesen, bevor sie durch einen definierten Wert-Handler umgewandelt werden. Damit dies geschieht, wird das IEnumerable-Objekt in ein Array von Objekten umgewandelt, und der Antwortkonverter empfängt immer ein Object[] anstelle des ursprünglichen Typs. Betrachten Sie das folgende Szenario: using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"String-Array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Objekt-Array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); Im obigen Beispiel wird der IEnumerable<string>-Konverter nie aufgerufen, da das Eingabeobjekt immer ein Object[] ist und nicht in ein IEnumerable<string> umgewandelt werden kann. Der Konverter unten, der ein IEnumerable<object> empfängt, empfängt jedoch seine Eingabe, da sein Wert kompatibel ist. Wenn Sie den Typ des Objekts, das enumeriert wird, tatsächlich verarbeiten müssen, müssen Sie die Reflexion verwenden, um den Typ des SammlungsElements zu erhalten. Alle enumerable Objekte (Listen, Arrays und Sammlungen) werden durch den HTTP-Antwortkonverter in ein Array von Objekten umgewandelt. Werte, die IAsyncEnumerable implementieren, werden automatisch vom Server behandelt, wenn die ConvertIAsyncEnumerableIntoEnumerable-Eigenschaft aktiviert ist, ähnlich wie bei IEnumerable. Eine asynchrone Enumeration wird in einen blockierenden Enumerator umgewandelt und dann in ein synchrones Array von Objekten umgewandelt."
  },
  "docs/de/fundamentals/routing.html": {
    "href": "docs/de/fundamentals/routing.html",
    "title": "Routing | Sisk",
    "keywords": "Routing Der Router ist der erste Schritt beim Aufbau des Servers. Er ist verantwortlich für die Unterbringung von Route-Objekten, die Endpunkte sind, die URLs und ihre Methoden mit Aktionen verknüpfen, die vom Server ausgeführt werden. Jede Aktion ist verantwortlich für das Empfangen einer Anfrage und das Liefern einer Antwort an den Client. Die Routen sind Paare von Pfad-Ausdrücken (\"Pfadmuster\") und der HTTP-Methode, auf die sie hören können. Wenn eine Anfrage an den Server gestellt wird, versucht er, eine Route zu finden, die der erhaltenen Anfrage entspricht, und ruft dann die Aktion dieser Route auf und liefert die resultierende Antwort an den Client. Es gibt mehrere Möglichkeiten, Routen in Sisk zu definieren: Sie können statisch, dynamisch oder auto-gescannt, durch Attribute definiert oder direkt im Router-Objekt definiert werden. Router mainRouter = new Router(); // ordnet die GET /-Route der folgenden Aktion zu mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hallo, Welt!\"); }); Um zu verstehen, was eine Route tun kann, müssen wir verstehen, was eine Anfrage tun kann. Ein HttpRequest enthält alles, was Sie benötigen. Sisk enthält auch einige zusätzliche Funktionen, die die Gesamtentwicklung beschleunigen. Für jede vom Server empfangene Aktion wird ein Delegat vom Typ RouteAction aufgerufen. Dieser Delegat enthält ein Parameter, das ein HttpRequest mit allen notwendigen Informationen über die vom Server empfangene Anfrage enthält. Das resultierende Objekt aus diesem Delegaten muss ein HttpResponse oder ein Objekt sein, das durch implizite Antworttypen darauf abgebildet werden kann. Übereinstimmende Routen Wenn eine Anfrage an den HTTP-Server gestellt wird, sucht Sisk nach einer Route, die den Ausdruck des empfangenen Pfads erfüllt. Der Ausdruck wird immer zwischen der Route und dem Anfragepfad getestet, ohne die Abfragezeichenfolge zu berücksichtigen. Dieser Test hat keine Priorität und ist exklusiv für eine einzelne Route. Wenn keine Route mit dieser Anfrage übereinstimmt, wird die Router.NotFoundErrorHandler-Antwort an den Client zurückgegeben. Wenn der Pfad-Ausdruck übereinstimmt, aber die HTTP-Methode nicht übereinstimmt, wird die Router.MethodNotAllowedErrorHandler-Antwort an den Client zurückgegeben. Sisk überprüft die Möglichkeit von Routen-Kollisionen, um diese Probleme zu vermeiden. Wenn Routen definiert werden, sucht Sisk nach möglichen Routen, die mit der definierten Route kollidieren könnten. Dieser Test umfasst die Überprüfung des Pfads und der Methode, die die Route akzeptieren soll. Erstellen von Routen mit Pfadmustern Sie können Routen mit verschiedenen SetRoute-Methoden definieren. // SetRoute-Methode mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hallo, {name}\"); }); // Map*-Methode mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // leerer 200-OK }); // Route.*-Hilfsmethoden mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // der StreamContent-Inner // stream wird nach dem Senden // der Antwort verworfen. Content = new StreamContent(imageStream) }; }); // mehrere Parameter mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hallo, {name} {surname}!\"); }); Die RouteParameters-Eigenschaft von HttpResponse enthält alle Informationen über die Pfadvariablen der empfangenen Anfrage. Jeder vom Server empfangene Pfad wird vor dem Pfad-Ausdruck-Test normalisiert, indem die folgenden Regeln angewendet werden: Alle leeren Segmente werden aus dem Pfad entfernt, z. B. ////foo//bar wird zu /foo/bar. Der Pfad-Test ist groß-/kleinschreibungsabhängig, es sei denn, Router.MatchRoutesIgnoreCase ist auf true gesetzt. Die Query und RouteParameters Eigenschaften von HttpRequest geben ein StringValueCollection-Objekt zurück, bei dem jedes indizierte Eigenschaft ein nicht-Null-StringValue zurückgibt, das als Option/Monad verwendet werden kann, um seinen Rohwert in ein verwaltetes Objekt umzuwandeln. Das folgende Beispiel liest den Routen-Parameter \"id\" und erhält ein Guid daraus. Wenn der Parameter kein gültiges Guid ist, wird eine Ausnahme ausgelöst und ein 500-Fehler an den Client zurückgegeben, wenn der Server Router.CallbackErrorHandler nicht behandelt. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); [!HINWEIS] Pfade haben ihre abschließenden / ignoriert, sowohl in der Anfrage als auch in der Routen-Pfad, d. h., wenn Sie versuchen, auf eine Route zuzugreifen, die als /index/page definiert ist, können Sie auch auf /index/page/ zugreifen. Sie können auch URLs zwingen, mit / zu enden, indem Sie die ForceTrailingSlash-Flag setzen. Erstellen von Routen mit Klasseninstanzen Sie können auch Routen dynamisch mit Reflexion und dem RouteAttribute definieren. Auf diese Weise werden die Instanzen einer Klasse, deren Methoden dieses Attribut implementieren, ihre Routen im Ziel-Router definiert. Für eine Methode, die als Route definiert werden soll, muss sie mit einem RouteAttribute markiert werden, wie z. B. dem Attribut selbst oder einem RouteGetAttribute. Die Methode kann statisch, instanziell, öffentlich oder privat sein. Wenn die Methode SetObject(type) oder SetObject<TType>() verwendet wird, werden Instanzmethoden ignoriert. Controller/MyController.cs C# public class MyController { // wird mit GET / übereinstimmen [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // statische Methoden funktionieren auch [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hallo Welt!\"); return res; } } Die folgende Zeile wird beide Methoden Index und Hello von MyController als Routen definieren, da beide als Routen markiert sind und eine Instanz der Klasse bereitgestellt wurde, nicht deren Typ. Wenn deren Typ stattdessen bereitgestellt worden wäre, würden nur die statischen Methoden definiert. var myController = new MyController(); mainRouter.SetObject(myController); Seit Sisk-Version 0.16 ist es möglich, AutoScan zu aktivieren, das nach benutzerdefinierten Klassen sucht, die RouterModule implementieren, und diese automatisch mit dem Router verknüpft. Dies wird nicht mit AOT-Kompilierung unterstützt. mainRouter.AutoScanModules<ApiController>(); Der obige Befehl sucht nach allen Typen, die ApiController implementieren, aber nicht den Typ selbst. Die beiden optionalen Parameter geben an, wie die Methoden nach diesen Typen suchen. Der erste Argument impliziert die Assembly, in der die Typen gesucht werden, und der zweite gibt an, wie die Typen definiert werden. Regex-Routen Anstelle der Verwendung der Standard-HTTP-Pfad-Übereinstimmungsmethode können Sie eine Route markieren, um sie mit Regex zu interpretieren. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Oder mit der RegexRoute-Klasse: mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hallo, Welt\"); })); Sie können auch Gruppen aus dem Regex-Muster in die HttpRequest.RouteParameters-Inhalte erfassen: Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Zugriff auf Datei {filename}\"); } } Routen-Präfixe Sie können alle Routen in einer Klasse oder einem Modul mit dem RoutePrefix-Attribut vordefinieren und den Präfix als Zeichenfolge setzen. Siehe das folgende Beispiel mit der BREAD-Architektur (Browse, Read, Edit, Add und Delete): Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } Im obigen Beispiel wird der HttpResponse-Parameter weggelassen, um durch den globalen Kontext HttpContext.Current verwendet zu werden. Weitere Informationen finden Sie im folgenden Abschnitt. Routen ohne Anfrageparameter Routen können ohne den HttpRequest-Parameter definiert werden und es ist dennoch möglich, die Anfrage und ihre Komponenten im Anfragekontext zu erhalten. Betrachten wir eine Abstraktion ControllerBase, die als Grundlage für alle Controller einer API dient und die Request-Eigenschaft bereitstellt, um die HttpRequest zu erhalten, die derzeit im Kontext ist. Controller/ControllerBase.cs C# public abstract class ControllerBase { // erhält die Anfrage aus dem aktuellen Thread public HttpRequest Request { get => HttpContext.Current.Request; } // die folgende Zeile erhält die Datenbank aus der aktuellen HTTP-Sitzung, // oder erstellt eine neue, wenn sie nicht existiert public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } Und für alle seine Nachkommen, um die Routen-Syntax ohne den Anfrageparameter zu verwenden: Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // liest die JSON-Daten aus der aktuellen Anfrage UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } Weitere Details zum aktuellen Kontext und zur Abhängigkeitsinjektion finden Sie im Abhängigkeitsinjektion-Tutorial. Routen für jede Methode Sie können eine Route definieren, die nur nach ihrem Pfad übereinstimmt und die HTTP-Methode ignoriert. Dies kann nützlich sein, um die Methode innerhalb der Routen-Aktion zu validieren. // wird mit / auf jede HTTP-Methode übereinstimmen mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Routen für jeden Pfad Routen für jeden Pfad testen jeden Pfad, der vom HTTP-Server empfangen wird, unter Vorbehalt der Route-Methode, die getestet wird. Wenn die Route-Methode RouteMethod.Any ist und die Route Route.AnyPath in ihrem Pfad-Ausdruck verwendet, wird diese Route auf alle Anfragen vom HTTP-Server hören, und keine anderen Routen können definiert werden. // die folgende Route wird mit allen POST-Anfragen übereinstimmen mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Groß-/Kleinschreibung ignorierende Routen-Übereinstimmung Standardmäßig ist die Interpretation von Routen mit Anfragen groß-/kleinschreibungsabhängig. Um dies zu ignorieren, aktivieren Sie diese Option: mainRouter.MatchRoutesIgnoreCase = true; Dies aktiviert auch die Option RegexOptions.IgnoreCase für Routen, bei denen es sich um Regex-Übereinstimmung handelt. Nicht gefunden (404)-Rückruf-Handler Sie können einen benutzerdefinierten Rückruf für den Fall erstellen, dass eine Anfrage keine bekannte Route entspricht. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Seit v0.14 Content = new HtmlContent(\"<h1>Nicht gefunden</h1>\") // ältere Versionen Content = new StringContent(\"<h1>Nicht gefunden</h1>\", Encoding.UTF8, \"text/html\") }; }; Methode nicht zulässig (405)-Rückruf-Handler Sie können auch einen benutzerdefinierten Rückruf für den Fall erstellen, dass eine Anfrage ihren Pfad entspricht, aber nicht die Methode. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Methode nicht zulässig für diese Route.\") }; }; Interne Fehlerbehandlung Routen-Rückrufe können während der Serverausführung Fehler auslösen. Wenn diese nicht richtig behandelt werden, kann die Gesamtfunktion des HTTP-Servers unterbrochen werden. Der Router hat einen Rückruf für den Fall, dass ein Routen-Rückruf fehlschlägt und die Serviceunterbrechung verhindert. Diese Methode ist nur erreichbar, wenn ThrowExceptions auf false gesetzt ist. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Fehler: {ex.Message}\") }; };"
  },
  "docs/de/getting-started.html": {
    "href": "docs/de/getting-started.html",
    "title": "Erste Schritte | Sisk",
    "keywords": "Erste Schritte Willkommen in der Sisk-Dokumentation! Schließlich, was ist das Sisk-Framework? Es ist eine Open-Source-Bibliothek, die mit .NET erstellt wurde, und minimalistisch, flexibel und abstrakt konzipiert ist. Sie ermöglicht es Entwicklern, Internetdienste schnell zu erstellen, mit wenig oder keiner notwendigen Konfiguration. Sisk ermöglicht es Ihrer bestehenden Anwendung, ein verwaltetes HTTP-Modul zu haben, das vollständig und entsorgbar ist. Die Werte von Sisk umfassen Code-Transparenz, Modularität, Leistung und Skalierbarkeit und können verschiedene Arten von Anwendungen verarbeiten, wie z.B. Restful, JSON-RPC, Web-Sockets und mehr. Die wichtigsten Funktionen umfassen: Ressource Beschreibung Routing Ein Pfad-Router, der Präfixe, benutzerdefinierte Methoden, Pfadvariablen, Wertkonverter und mehr unterstützt. Request-Handler Auch bekannt als Middleware, bietet eine Schnittstelle, um eigene Request-Handler zu erstellen, die mit der Anfrage vor oder nach einer Aktion arbeiten. Komprimierung Komprimieren Sie den Inhalt Ihrer Antwort einfach mit Sisk. Web-Sockets Bietet Routen, die vollständige Web-Sockets akzeptieren, für das Lesen und Schreiben an den Client. Server-sent Events Bietet das Senden von Server-Ereignissen an Clients, die das SSE-Protokoll unterstützen. Protokollierung Vereinfachte Protokollierung. Protokollieren Sie Fehler, Zugriffe, definieren Sie rotierende Protokolle nach Größe, mehrere Ausgabeströme für das gleiche Protokoll und mehr. Multi-Host Haben Sie einen HTTP-Server für mehrere Ports, und jeden Port mit seinem eigenen Router, und jeden Router mit seiner eigenen Anwendung. Server-Handler Erweitern Sie Ihre eigene Implementierung des HTTP-Servers. Anpassen Sie mit Erweiterungen, Verbesserungen und neuen Funktionen. Erste Schritte Sisk kann in jeder .NET-Umgebung ausgeführt werden. In diesem Leitfaden werden wir Ihnen zeigen, wie Sie eine Sisk-Anwendung mit .NET erstellen. Wenn Sie es noch nicht installiert haben, laden Sie bitte das SDK von hier herunter. In diesem Tutorial werden wir zeigen, wie Sie eine Projektstruktur erstellen, eine Anfrage empfangen, einen URL-Parameter abrufen und eine Antwort senden. Dieser Leitfaden konzentriert sich auf den Aufbau eines einfachen Servers mit C#. Sie können auch Ihre bevorzugte Programmiersprache verwenden. Note Sie könnten an einem Quickstart-Projekt interessiert sein. Überprüfen Sie dieses Repository für weitere Informationen. Projekt erstellen Nennen wir unser Projekt \"Meine Sisk-Anwendung\". Sobald Sie .NET eingerichtet haben, können Sie Ihr Projekt mit dem folgenden Befehl erstellen: dotnet new console -n meine-sisk-anwendung Navigieren Sie als Nächstes zu Ihrem Projektverzeichnis und installieren Sie Sisk mit dem .NET-Utility-Tool: cd meine-sisk-anwendung dotnet add package Sisk.HttpServer Sie können weitere Möglichkeiten finden, Sisk in Ihrem Projekt zu installieren, hier. Lassen Sie uns nun eine Instanz unseres HTTP-Servers erstellen. Für dieses Beispiel werden wir es so konfigurieren, dass es auf Port 5000 hört. HTTP-Server erstellen Sisk ermöglicht es Ihnen, Ihre Anwendung Schritt für Schritt manuell aufzubauen, da es Routen zum HttpServer-Objekt ermöglicht. Dies kann jedoch für die meisten Projekte nicht sehr praktisch sein. Daher können wir die Builder-Methode verwenden, die es einfacher macht, unsere Anwendung in Betrieb zu nehmen. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hallo, Welt!\") }; }); await app.StartAsync(); } } Es ist wichtig, jedes wichtige Komponente von Sisk zu verstehen. Später in diesem Dokument werden Sie mehr über die Funktionsweise von Sisk erfahren. Manuelles (erweitertes) Setup Sie können erfahren, wie jedes Sisk-Mechanismus funktioniert, in diesem Abschnitt der Dokumentation, der das Verhalten und die Beziehungen zwischen dem HttpServer, Router, ListeningPort und anderen Komponenten erklärt."
  },
  "docs/de/installing.html": {
    "href": "docs/de/installing.html",
    "title": "Installation | Sisk",
    "keywords": "Installation Sie können Sisk über Nuget, dotnet cli oder andere Optionen installieren. Sie können Ihre Sisk-Umgebung leicht einrichten, indem Sie diesen Befehl in Ihrer Entwicklerkonsole ausführen: dotnet add package Sisk.HttpServer Dieser Befehl installiert die neueste Version von Sisk in Ihrem Projekt."
  },
  "docs/de/native-aot.html": {
    "href": "docs/de/native-aot.html",
    "title": "Native AOT-Unterstützung | Sisk",
    "keywords": "Native AOT-Unterstützung .NET Native AOT ermöglicht die Veröffentlichung von nativen .NET-Anwendungen, die selbstständig sind und nicht die .NET-Laufzeit auf dem Zielhost benötigen. Zusätzlich bietet Native AOT Vorteile wie: Erheblich kleinere Anwendungen Wesentlich schnellere Initialisierung Geringeren Speicherbedarf Das Sisk Framework ermöglicht aufgrund seiner expliziten Natur die Verwendung von Native AOT für fast alle seine Funktionen, ohne dass eine Überarbeitung des Quellcodes erforderlich ist, um es an Native AOT anzupassen. Nicht unterstützte Funktionen Allerdings verwendet Sisk Reflexion, wenn auch minimal, für einige Funktionen. Die nachfolgend genannten Funktionen sind möglicherweise teilweise verfügbar oder während der nativen Codeausführung ganz nicht verfügbar: Automatisches Scannen von Modulen des Routers: Diese Ressource scannet die im ausführenden Assembly eingebetteten Typen und registriert die Typen, die Router-Module sind. Diese Ressource benötigt Typen, die während des Assembly-Trimming ausgeschlossen werden können. Alle anderen Funktionen sind mit AOT in Sisk kompatibel. Es ist üblich, eine oder andere Methode zu finden, die eine AOT-Warnung ausgibt, aber dieselbe, wenn sie nicht hier erwähnt wird, hat eine Überladung, die das Übergeben eines Typs, Parameters oder Typinformationen anzeigt, die dem AOT-Compiler helfen, das Objekt zu kompilieren."
  },
  "docs/de/registering-namespace.html": {
    "href": "docs/de/registering-namespace.html",
    "title": "Konfiguration von Namensraumreservierungen auf Windows | Sisk",
    "keywords": "Konfiguration von Namensraumreservierungen auf Windows Sisk arbeitet mit der HttpListener-Netzwerkschnittstelle, die einen virtuellen Host an das System bindet, um Anfragen zu empfangen. Unter Windows ist diese Bindung ein bisschen restriktiv und erlaubt nur localhost als gültigen Host. Wenn man versucht, auf einen anderen Host zuzugreifen, wird auf dem Server ein Zugriffsverweigerungsfehler ausgelöst. Dieses Tutorial erklärt, wie man die Autorisierung erteilt, um auf jeden Host auf dem System zuzuhören, den man möchte. Namespace Setup.bat BATCH @echo off :: Präfix hier einfügen, ohne Leerzeichen oder Anführungszeichen SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Wo PREFIX das Präfix (\"Zuhör-Host->Port\") ist, auf das der Server hört. Es muss im URL-Schema, Host, Port und einem Schrägstrich am Ende formatiert sein, Beispiel: Namespace Setup.bat BATCH SET PREFIX=http://my-anwendung.example.test/ Damit Sie in Ihrer Anwendung über Folgendes zugehört werden können: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-anwendung.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hallo, Welt!\") }; }); await app.StartAsync(); } }"
  },
  "docs/de/ssl.html": {
    "href": "docs/de/ssl.html",
    "title": "Arbeiten mit SSL | Sisk",
    "keywords": "Arbeiten mit SSL Arbeiten mit SSL für die Entwicklung kann notwendig sein, wenn Sie in Kontexten arbeiten, die Sicherheit erfordern, wie z.B. die meisten Webentwicklungsszenarien. Sisk operiert auf Basis von HttpListener, der keine native HTTPS-Unterstützung bietet, sondern nur HTTP. Es gibt jedoch Workarounds, die es Ihnen ermöglichen, mit SSL in Sisk zu arbeiten. Siehe sie unten: Über IIS auf Windows Verfügbar auf: Windows Aufwand: mittel Wenn Sie auf Windows sind, können Sie IIS verwenden, um SSL auf Ihrem HTTP-Server zu aktivieren. Damit dies funktioniert, ist es ratsam, dass Sie diesem Tutorial vorher folgen, wenn Sie möchten, dass Ihre Anwendung auf einem anderen Host als \"localhost\" hört. Damit dies funktioniert, müssen Sie IIS über die Windows-Features installieren. IIS ist für Windows- und Windows-Server-Benutzer kostenlos verfügbar. Um SSL in Ihrer Anwendung zu konfigurieren, müssen Sie das SSL-Zertifikat bereit haben, auch wenn es selbstsigniert ist. Als Nächstes können Sie sehen, wie Sie SSL auf IIS 7 oder höher einrichten. Über mitmproxy Verfügbar auf: Linux, macOS, Windows Aufwand: einfach mitmproxy ist ein Interceptions-Proxy-Tool, das es Entwicklern und Sicherheitstestern ermöglicht, HTTP- und HTTPS-Verkehr zwischen einem Client (wie einem Webbrowser) und einem Server zu überwachen, zu modifizieren und aufzuzeichnen. Sie können die mitmdump-Utility verwenden, um einen Reverse-SSL-Proxy zwischen Ihrem Client und Ihrer Sisk-Anwendung zu starten. Zuerst installieren Sie mitmproxy auf Ihrem Computer. Starten Sie Ihre Sisk-Anwendung. In diesem Beispiel verwenden wir den Port 8000 als unsicheren HTTP-Port. Starten Sie den mitmproxy-Server, um den sicheren Port 8001 zu hören: mitmdump --mode reverse:http://localhost:8000/ -p 8001 Und Sie sind bereit! Sie können Ihre Anwendung bereits über https://localhost:8001/ aufrufen. Ihre Anwendung muss nicht laufen, damit Sie mitmdump starten können. Alternativ können Sie einen Verweis auf die mitmproxy-Hilfe in Ihrem Projekt hinzufügen. Dies erfordert jedoch, dass mitmproxy auf Ihrem Computer installiert ist. Über Sisk.SslProxy-Paket Verfügbar auf: Linux, macOS, Windows Aufwand: einfach Das Sisk.SslProxy-Paket ist eine einfache Möglichkeit, SSL auf Ihrer Sisk-Anwendung zu aktivieren. Es ist jedoch ein extrem experimentelles Paket. Es kann instabil sein, mit diesem Paket zu arbeiten, aber Sie können Teil des kleinen Prozentsatzes von Menschen sein, die dazu beitragen, dieses Paket verwendbar und stabil zu machen. Um loszulegen, können Sie das Sisk.SslProxy-Paket mit installieren: dotnet add package Sisk.SslProxy Note Sie müssen \"Vorabversionen von Paketen aktivieren\" im Visual Studio-Paket-Manager aktivieren, um Sisk.SslProxy zu installieren. Wiederum ist es ein experimentelles Projekt, also sollten Sie nicht einmal daran denken, es in die Produktion zu übernehmen. Im Moment kann Sisk.SslProxy die meisten HTTP/1.1-Features verarbeiten, einschließlich HTTP-Continue, Chunked-Encoding, WebSockets und SSE. Lesen Sie mehr über SslProxy hier."
  },
  "docs/deploying.html": {
    "href": "docs/deploying.html",
    "title": "Deploying your Sisk Application | Sisk",
    "keywords": "Deploying your Sisk Application The process of deploying a Sisk application consists of publishing your project into production. Although the process is relatively simple, it is worth noting details that can be lethal to the security and stability of the deployment's infrastructure. Ideally, you should be ready to deploy your application to the cloud, after carrying out all possible tests to have your application ready. Publishing your app Publishing your Sisk application or service is generating binaries ready and optimized for production. In this example, we will compile the binaries for production to run on a machine that has the .NET Runtime installed on the machine. You will need .NET SDK installed in your machine in order to build your app, and .NET Runtime installed on the target server to run your app. You can learn how to install .NET Runtime in your Linux server here, Windows and Mac OS. In the folder where your project is located, open a terminal and use the .NET publish command: $ dotnet publish -r linux-x64 -c Release This will generate your binaries inside bin/Release/publish/linux-x64. Note If your app is running using Sisk.ServiceProvider package, you should copy your service-config.json into your host server along all binaries generated by dotnet publish. You can leave the file preconfigured, with environment variables, listening ports and hosts, and additional server configurations. The next step is to take these files to the server where your application will be hosted. After that, give execution permissions to your binary file. In this case, let's consider that our project name is \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app After running your application, check to see if it produces any error messages. If it didn't produce, it's because your application is running. At this point, it will probably not be possible to access your application by external net ouside your server, as access rules such as Firewall have not been configured. We will consider this in the next steps. You should have the address of the virtual host where your application is listening to. This is set manually in the application, and depends on how you are instantiating your Sisk service. If you're not using the Sisk.ServiceProvider package, you should find it where you defined your HttpServer instance: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk should listen on http://localhost:5000/ Associating an ListeningHost manually: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Or if you're using the Sisk.ServiceProvider package, in your service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } From this, we can create a reverse proxy to listen to your service and make the traffic available over the open network. Proxying your application Proxying your service means not directly exposing your Sisk service to an external network. This practice is very common for server deployments because: Allows you to associate an SSL certificate in your application; Create access rules before accessing the service and avoid overloads; Control bandwidth and request limits; Separate load-balancers for your application; Prevent security damage to failing infrastructure. You can serve your application through a reverse proxy like Nginx or Apache, or you can use an http-over-dns tunnel like Cloudflared. Also, remember to correctly resolve your proxy's forwarding headers to obtain your client's information, such as IP address and host, through forwarding resolvers. The next step after creating your tunnel, firewall configuration and having your application running, is to create a service for your application. Note Using SSL certificates directly in the Sisk service on non-Windows systems is not possible. This is a point of the implementation of HttpListener, which is the central module for how HTTP queue management is done in Sisk, and this implementation varies from operating system to operating system. You can use SSL in your Sisk service if you associate a certificate with the virtual host with IIS. For other systems, using a reverse proxy is highly recommended. Creating an service Creating a service will make your application always available, even after restarting your server instance or a non-recoverable crash. In this simple tutorial, we will use the content from the previous tutorial as a showcase to keep your service always active. Access the folder where the service configuration files are located: cd /etc/systemd/system Create your my-app.service file and include the contents: my-app.service INI [Unit] Description=<description about your app> [Service] # set the user which will launch the service on User=<user which will launch the service> # the ExecStart path is not relative to WorkingDirectory. # set it as the full path to the executeable file WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # set the service to always restart on crash Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Restart your service manager module: $ sudo systemctl daemon-reload Start your new created service from the name of the file you set and check if they are running: $ sudo systemctl start my-app $ sudo systemctl status my-app Now if your app is running (\"Active: active\"), enable your service to keep run after an system reboot: $ sudo systemctl enable my-app Now you're ready to go and present your Sisk application to everyone."
  },
  "docs/es/advanced/forwarding-resolvers.html": {
    "href": "docs/es/advanced/forwarding-resolvers.html",
    "title": "Resolutores de Reenvío | Sisk",
    "keywords": "Resolutores de Reenvío Un Resolutor de Reenvío es un ayudante que ayuda a decodificar la información que identifica al cliente a través de una solicitud, proxy, CDN o balanceadores de carga. Cuando su servicio Sisk se ejecuta a través de un proxy inverso o directo, la dirección IP del cliente, el host y el protocolo pueden ser diferentes de la solicitud original, ya que es un reenvío de un servicio a otro. Esta funcionalidad de Sisk le permite controlar y resolver esta información antes de trabajar con la solicitud. Estos proxies suelen proporcionar encabezados útiles para identificar a su cliente. Actualmente, con la clase ForwardingResolver, es posible resolver la dirección IP del cliente, el host y el protocolo HTTP utilizado. Después de la versión 1.0 de Sisk, el servidor ya no tiene una implementación estándar para decodificar estos encabezados por razones de seguridad que varían de servicio a servicio. Por ejemplo, el encabezado X-Forwarded-For incluye información sobre las direcciones IP que reenviaron la solicitud. Este encabezado es utilizado por los proxies para transportar una cadena de información al servicio final e incluye la dirección IP de todos los proxies utilizados, incluyendo la dirección real del cliente. El problema es: a veces es difícil identificar la dirección IP remota del cliente y no hay una regla específica para identificar este encabezado. Se recomienda encarecidamente leer la documentación de los encabezados que se van a implementar a continuación: Lea sobre el encabezado X-Forwarded-For aquí. Lea sobre el encabezado X-Forwarded-Host aquí. Lea sobre el encabezado X-Forwarded-Proto aquí. La clase ForwardingResolver Esta clase tiene tres métodos virtuales que permiten la implementación más adecuada para cada servicio. Cada método es responsable de resolver la información de la solicitud a través de un proxy: la dirección IP del cliente, el host de la solicitud y el protocolo de seguridad utilizado. Por defecto, Sisk siempre utilizará la información de la solicitud original, sin resolver ningún encabezado. El ejemplo a continuación muestra cómo se puede utilizar esta implementación. Este ejemplo resuelve la dirección IP del cliente a través del encabezado X-Forwarded-For y lanza un error cuando se reenvían más de una dirección IP en la solicitud. Important No utilice este ejemplo en código de producción. Siempre verifique si la implementación es adecuada para su uso. Lea la documentación del encabezado antes de implementarlo. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"El encabezado X-Forwarded-For está ausente.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Demasiadas direcciones en el encabezado X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/es/advanced/http-server-handlers.html": {
    "href": "docs/es/advanced/http-server-handlers.html",
    "title": "Controladores de servidor HTTP | Sisk",
    "keywords": "Controladores de servidor HTTP En la versión 0.16 de Sisk, se ha introducido la clase HttpServerHandler, que tiene como objetivo ampliar el comportamiento general de Sisk y proporcionar controladores de eventos adicionales a Sisk, como el manejo de solicitudes HTTP, enrutadores, bolsas de contexto y más. La clase concentra los eventos que ocurren durante la vida útil de todo el servidor HTTP y también de una solicitud. El protocolo HTTP no tiene sesiones, y por lo tanto no es posible conservar información de una solicitud a otra. Sisk proporciona por ahora una forma de implementar sesiones, contextos, conexiones de base de datos y otros proveedores útiles para ayudar en su trabajo. Consulte esta página para leer dónde se desencadena cada evento y cuál es su propósito. También puede ver el ciclo de vida de una solicitud HTTP para entender qué sucede con una solicitud y dónde se disparan los eventos. El servidor HTTP permite utilizar varios controladores al mismo tiempo. Cada llamada a un evento es síncrona, es decir, bloqueará el subproceso actual para cada solicitud o contexto hasta que todos los controladores asociados con esa función se ejecuten y completen. A diferencia de los controladores de solicitudes, no se pueden aplicar a grupos de rutas o rutas específicas. En su lugar, se aplican a todo el servidor HTTP. Puede aplicar condiciones dentro de su controlador de servidor HTTP. Además, se definen singletones de cada HttpServerHandler para cada aplicación Sisk, por lo que solo se define una instancia por HttpServerHandler. Un ejemplo práctico de uso de HttpServerHandler es para desechar automáticamente una conexión de base de datos al final de la solicitud. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // comprueba si la solicitud ha definido un DbContext // en su bolsa de contexto if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // permite al usuario crear un contexto de base de datos a partir de una solicitud HTTP // y almacenarlo en su bolsa de contexto public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } Con el código anterior, la extensión GetDbContext permite crear un contexto de conexión directamente desde el objeto HttpRequest. Una conexión no desechar puede causar problemas al ejecutar con la base de datos, por lo que se termina en OnHttpRequestClose. Puede registrar un controlador en un servidor HTTP en su constructor o directamente con HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } Con esto, la clase UsersController puede utilizar el contexto de base de datos como: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Usuario agregado.\"); } } El código anterior utiliza métodos como JsonOk y JsonMessage que están integrados en ApiController, que hereda de RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Los desarrolladores pueden implementar sesiones, contextos y conexiones de base de datos utilizando esta clase. El código proporcionado muestra un ejemplo práctico con el DatabaseConnectionHandler, automatizando el descarte de la conexión de base de datos al final de cada solicitud. La integración es sencilla, con controladores registrados durante la configuración del servidor. La clase HttpServerHandler ofrece un conjunto de herramientas poderosas para administrar recursos y ampliar el comportamiento de Sisk en aplicaciones HTTP."
  },
  "docs/es/advanced/manual-setup.html": {
    "href": "docs/es/advanced/manual-setup.html",
    "title": "Configuración manual (avanzada) | Sisk",
    "keywords": "Configuración manual (avanzada) En esta sección, crearemos nuestro servidor HTTP sin ningún estándar predefinido, de una manera completamente abstracta. Aquí, puedes construir manualmente cómo funcionará tu servidor HTTP. Cada ListeningHost tiene un enrutador, y un servidor HTTP puede tener varios ListeningHosts, cada uno apuntando a un host diferente en un puerto diferente. Primero, necesitamos entender el concepto de solicitud/respuesta. Es bastante simple: para cada solicitud, debe haber una respuesta. Sisk sigue este principio también. Creemos un método que responda con un mensaje \"Hola, mundo!\" en HTML, especificando el código de estado y los encabezados. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hola, mundo!</h1> </body> </html> \") }; return indexResponse; } El siguiente paso es asociar este método con una ruta HTTP. Enrutadores Los enrutadores son abstracciones de rutas de solicitud y sirven como el puente entre solicitudes y respuestas para el servicio. Los enrutadores gestionan las rutas del servicio, las funciones y los errores. Un enrutador puede tener varias rutas, y cada ruta puede realizar diferentes operaciones en esa ruta, como ejecutar una función, servir una página o proporcionar un recurso desde el servidor. Creemos nuestro primer enrutador y asociemos nuestro método IndexPage con la ruta de índice. Router mainRouter = new Router(); // SetRoute asociará todas las rutas de índice con nuestro método. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Ahora nuestro enrutador puede recibir solicitudes y enviar respuestas. Sin embargo, mainRouter no está vinculado a un host o un servidor, por lo que no funcionará por sí solo. El siguiente paso es crear nuestro ListeningHost. Hosts y puertos de escucha Un ListeningHost puede hospedar un enrutador y varios puertos de escucha para el mismo enrutador. Un ListeningPort es un prefijo donde el servidor HTTP escuchará. Aquí, podemos crear un ListeningHost que apunte a dos puntos finales para nuestro enrutador: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Ahora nuestro servidor HTTP escuchará en los puntos finales especificados y redirigirá sus solicitudes a nuestro enrutador. Configuración del servidor La configuración del servidor es responsable de la mayoría del comportamiento del servidor HTTP en sí. En esta configuración, podemos asociar ListeningHosts con nuestro servidor. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Agregue nuestro ListeningHost a esta configuración del servidor A continuación, podemos crear nuestro servidor HTTP: HttpServer server = new HttpServer(config); server.Start(); // Inicia el servidor Console.ReadKey(); // Evita que la aplicación se cierre Ahora podemos compilar nuestro ejecutable y ejecutar nuestro servidor HTTP con el comando: dotnet watch En tiempo de ejecución, abra su navegador y navegue hasta la ruta del servidor, y debería ver:"
  },
  "docs/es/advanced/multi-host-setup.html": {
    "href": "docs/es/advanced/multi-host-setup.html",
    "title": "Varios hosts de escucha por servidor | Sisk",
    "keywords": "Varios hosts de escucha por servidor El Framework Sisk siempre ha soportado el uso de más de un host por servidor, es decir, un solo servidor HTTP puede escuchar en varios puertos y cada puerto tiene su propio enrutador y su propio servicio ejecutándose en él. De esta manera, es fácil separar responsabilidades y gestionar servicios en un solo servidor HTTP con Sisk. El ejemplo a continuación muestra la creación de dos ListeningHosts, cada uno escuchando en un puerto diferente, con diferentes enrutadores y acciones. Lea creación manual de su aplicación para entender los detalles sobre esta abstracción. static void Main(string[] args) { // crea dos hosts de escucha, cada uno con su propio enrutador y // escuchando en su propio puerto // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hola desde el host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hola desde el host B!\")); // crea una configuración de servidor y agrega ambos // hosts de escucha en ella // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // crea un servidor HTTP que utiliza la configuración // especificada // HttpServer server = new HttpServer(configuration); // inicia el servidor server.Start(); Console.WriteLine(\"Intente llegar al host A en {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Intente llegar al host B en {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/es/advanced/request-lifecycle.html": {
    "href": "docs/es/advanced/request-lifecycle.html",
    "title": "Ciclo de vida de la solicitud | Sisk",
    "keywords": "Ciclo de vida de la solicitud A continuación se explica todo el ciclo de vida de una solicitud a través de un ejemplo de una solicitud HTTP. Recepción de la solicitud: cada solicitud crea un contexto HTTP entre la solicitud en sí y la respuesta que se entregará al cliente. Este contexto proviene del listener integrado en Sisk, que puede ser el HttpListener, Kestrel, o Cadente. Validación de solicitud externa: se valida la HttpServerConfiguration.RemoteRequestsAction para la solicitud. Si la solicitud es externa y la propiedad es Drop, la conexión se cierra sin una respuesta al cliente con un HttpServerExecutionStatus = RemoteRequestDropped. Configuración del resolutor de reenvío: si un ForwardingResolver está configurado, se llama al método OnResolveRequestHost en el host original de la solicitud. Coincidencia de DNS: con el host resuelto y con más de un ListeningHost configurado, el servidor busca el host correspondiente para la solicitud. Si no hay un ListeningHost que coincida, se devuelve una respuesta 400 Bad Request al cliente y un estado HttpServerExecutionStatus = DnsUnknownHost se devuelve al contexto HTTP. Si un ListeningHost coincide, pero su Router no está inicializado, se devuelve una respuesta 503 Service Unavailable al cliente y un estado HttpServerExecutionStatus = ListeningHostNotReady se devuelve al contexto HTTP. Enlace del router: el router del ListeningHost correspondiente se asocia con el servidor HTTP recibido. Si el router ya está asociado con otro servidor HTTP, lo que no está permitido porque el router utiliza activamente los recursos de configuración del servidor, se lanza una excepción InvalidOperationException. Esto solo ocurre durante la inicialización del servidor HTTP, no durante la creación del contexto HTTP. Predefinición de encabezados: Predefine el encabezado X-Request-Id en la respuesta si está configurado para hacerlo. Predefine el encabezado X-Powered-By en la respuesta si está configurado para hacerlo. Validación del tamaño del contenido: valida si el contenido de la solicitud es menor que HttpServerConfiguration.MaximumContentLength solo si es mayor que cero. Si la solicitud envía un Content-Length mayor que el configurado, se devuelve una respuesta 413 Payload Too Large al cliente y un estado HttpServerExecutionStatus = ContentTooLarge se devuelve al contexto HTTP. El evento OnHttpRequestOpen se invoca para todos los controladores de servidor HTTP configurados. Enrutamiento de la acción: el servidor invoca el router para la solicitud recibida. Si el router no encuentra una ruta que coincida con la solicitud: Si la propiedad Router.NotFoundErrorHandler está configurada, se invoca la acción y la respuesta de la acción se reenvía al cliente HTTP. Si la propiedad anterior es nula, se devuelve una respuesta 404 Not Found por defecto al cliente. Si el router encuentra una ruta coincidente, pero el método de la ruta no coincide con el método de la solicitud: Si la propiedad Router.MethodNotAllowedErrorHandler está configurada, se invoca la acción y la respuesta de la acción se reenvía al cliente HTTP. Si la propiedad anterior es nula, se devuelve una respuesta 405 Method Not Allowed por defecto al cliente. Si la solicitud es del método OPTIONS: El router devuelve una respuesta 200 Ok al cliente solo si no hay una ruta que coincida con el método de la solicitud (el método de la ruta no es explícitamente RouteMethod.Options). Si la propiedad HttpServerConfiguration.ForceTrailingSlash está habilitada, la ruta coincidente no es una expresión regular, la ruta de la solicitud no termina con / y el método de la solicitud es GET: Se devuelve una respuesta HTTP 307 Temporary Redirect con el encabezado Location con la ruta y la consulta a la misma ubicación con un / al final al cliente. El evento OnContextBagCreated se invoca para todos los controladores de servidor HTTP configurados. Se ejecutan todas las instancias globales de IRequestHandler con la bandera BeforeResponse. Si algún controlador devuelve una respuesta no nula, esa respuesta se reenvía al cliente HTTP y el contexto se cierra. Si se lanza un error en este paso y HttpServerConfiguration.ThrowExceptions está deshabilitado: Si la propiedad Router.CallbackErrorHandler está habilitada, se invoca y la respuesta resultante se devuelve al cliente. Si la propiedad anterior no está definida, se devuelve una respuesta vacía al servidor, que reenvía una respuesta según el tipo de excepción lanzada, que generalmente es 500 Internal Server Error. Se ejecutan todas las instancias de IRequestHandler definidas en la ruta y con la bandera BeforeResponse. Si algún controlador devuelve una respuesta no nula, esa respuesta se reenvía al cliente HTTP y el contexto se cierra. Si se lanza un error en este paso y HttpServerConfiguration.ThrowExceptions está deshabilitado: Si la propiedad Router.CallbackErrorHandler está habilitada, se invoca y la respuesta resultante se devuelve al cliente. Si la propiedad anterior no está definida, se devuelve una respuesta vacía al servidor, que reenvía una respuesta según el tipo de excepción lanzada, que generalmente es 500 Internal Server Error. Se invoca la acción del router y se convierte en una respuesta HTTP. Si se lanza un error en este paso y HttpServerConfiguration.ThrowExceptions está deshabilitado: Si la propiedad Router.CallbackErrorHandler está habilitada, se invoca y la respuesta resultante se devuelve al cliente. Si la propiedad anterior no está definida, se devuelve una respuesta vacía al servidor, que reenvía una respuesta según el tipo de excepción lanzada, que generalmente es 500 Internal Server Error. Se ejecutan todas las instancias globales de IRequestHandler con la bandera AfterResponse. Si algún controlador devuelve una respuesta no nula, la respuesta del controlador reemplaza la respuesta anterior y se reenvía inmediatamente al cliente HTTP. Si se lanza un error en este paso y HttpServerConfiguration.ThrowExceptions está deshabilitado: Si la propiedad Router.CallbackErrorHandler está habilitada, se invoca y la respuesta resultante se devuelve al cliente. Si la propiedad anterior no está definida, se devuelve una respuesta vacía al servidor, que reenvía una respuesta según el tipo de excepción lanzada, que generalmente es 500 Internal Server Error. Se ejecutan todas las instancias de IRequestHandler definidas en la ruta y con la bandera AfterResponse. Si algún controlador devuelve una respuesta no nula, la respuesta del controlador reemplaza la respuesta anterior y se reenvía inmediatamente al cliente HTTP. Si se lanza un error en este paso y HttpServerConfiguration.ThrowExceptions está deshabilitado: Si la propiedad Router.CallbackErrorHandler está habilitada, se invoca y la respuesta resultante se devuelve al cliente. Si la propiedad anterior no está definida, se devuelve una respuesta vacía al servidor, que reenvía una respuesta según el tipo de excepción lanzada, que generalmente es 500 Internal Server Error. Procesamiento de la respuesta: con la respuesta lista, el servidor la prepara para enviarla al cliente. Se definen los encabezados de la política de recursos compartidos de origen cruzado (CORS) en la respuesta según lo configurado en el ListeningHost.CrossOriginResourceSharingPolicy actual. Se envían el código de estado y los encabezados de la respuesta al cliente. Se envía el contenido de la respuesta al cliente: Si el contenido de la respuesta es un descendiente de ByteArrayContent, los bytes de la respuesta se copian directamente en el flujo de salida de la respuesta. Si la condición anterior no se cumple, la respuesta se serializa en un flujo y se copia en el flujo de salida de la respuesta. Se cierran los flujos y se descarta el contenido de la respuesta. Si HttpServerConfiguration.DisposeDisposableContextValues está habilitado, se descartan todos los objetos definidos en el contexto de la solicitud que heredan de IDisposable. El evento OnHttpRequestClose se invoca para todos los controladores de servidor HTTP configurados. Si se lanzó una excepción en el servidor, el evento OnException se invoca para todos los controladores de servidor HTTP configurados. Si la ruta permite el registro de acceso y HttpServerConfiguration.AccessLogsStream no es nulo, se escribe una línea de registro en el flujo de registro. Si la ruta permite el registro de errores, hay una excepción y HttpServerConfiguration.ErrorsLogsStream no es nulo, se escribe una línea de registro en el flujo de registro de errores. Si el servidor está esperando una solicitud a través de HttpServer.WaitNext, se libera el mutex y el contexto se vuelve disponible para el usuario."
  },
  "docs/es/changelogs.html": {
    "href": "docs/es/changelogs.html",
    "title": "Registros de cambios | Sisk",
    "keywords": "Registros de cambios Cada cambio realizado en Sisk se registra a través del registro de cambios. Puedes ver los registros de cambios para todas las versiones de Sisk aquí."
  },
  "docs/es/deploying.html": {
    "href": "docs/es/deploying.html",
    "title": "Desplegando tu Aplicación Sisk | Sisk",
    "keywords": "Desplegando tu Aplicación Sisk El proceso de desplegar una aplicación Sisk consiste en publicar tu proyecto en producción. Aunque el proceso es relativamente simple, es importante tener en cuenta detalles que pueden ser letales para la seguridad y la estabilidad de la infraestructura de despliegue. Idealmente, debes estar listo para desplegar tu aplicación en la nube, después de realizar todas las pruebas posibles para tener tu aplicación lista. Publicando tu aplicación Publicar tu aplicación o servicio Sisk es generar binarios listos y optimizados para producción. En este ejemplo, compilaremos los binarios para producción para ejecutarlos en una máquina que tenga el tiempo de ejecución de .NET instalado. Necesitarás tener el SDK de .NET instalado en tu máquina para compilar tu aplicación, y el tiempo de ejecución de .NET instalado en el servidor objetivo para ejecutar tu aplicación. Puedes aprender a instalar el tiempo de ejecución de .NET en tu servidor Linux aquí, Windows y Mac OS. En la carpeta donde se encuentra tu proyecto, abre una terminal y utiliza el comando de publicación de .NET: $ dotnet publish -r linux-x64 -c Release Esto generará tus binarios dentro de bin/Release/publish/linux-x64. Note Si tu aplicación se ejecuta utilizando el paquete Sisk.ServiceProvider, debes copiar tu archivo service-config.json en tu servidor de host junto con todos los binarios generados por dotnet publish. Puedes dejar el archivo preconfigurado, con variables de entorno, puertos y hosts de escucha, y configuraciones de servidor adicionales. El siguiente paso es trasladar estos archivos al servidor donde se hospedará tu aplicación. Después de eso, da permisos de ejecución a tu archivo binario. En este caso, consideremos que el nombre de nuestro proyecto es \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app Después de ejecutar tu aplicación, verifica si produce algún mensaje de error. Si no produce ninguno, es porque tu aplicación se está ejecutando. En este punto, es probable que no sea posible acceder a tu aplicación desde la red externa fuera de tu servidor, ya que no se han configurado las reglas de acceso como el Firewall. Consideraremos esto en los siguientes pasos. Debes tener la dirección del host virtual donde tu aplicación está escuchando. Esto se establece manualmente en la aplicación y depende de cómo estás instanciando tu servicio Sisk. Si no estás utilizando el paquete Sisk.ServiceProvider, debes encontrarla donde definiste tu instancia de HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk debe escuchar en http://localhost:5000/ Asociando un ListeningHost manualmente: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); O si estás utilizando el paquete Sisk.ServiceProvider, en tu archivo service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } A partir de esto, podemos crear un proxy inverso para escuchar a tu servicio y hacer que el tráfico esté disponible en la red abierta. Proxyando tu aplicación Proxyar tu servicio significa no exponer directamente tu servicio Sisk a una red externa. Esta práctica es muy común para despliegues de servidor porque: Permite asociar un certificado SSL en tu aplicación; Crea reglas de acceso antes de acceder al servicio y evita sobrecargas; Controla el ancho de banda y los límites de solicitudes; Separa los equilibradores de carga para tu aplicación; Evita daños de seguridad a la infraestructura fallida. Puedes servir tu aplicación a través de un proxy inverso como Nginx o Apache, o puedes utilizar un túnel http-over-dns como Cloudflared. También recuerda resolver correctamente los encabezados de reenvío de tu proxy para obtener la información del cliente, como la dirección IP y el host, a través de resolutores de reenvío. El siguiente paso después de crear tu túnel, configurar el firewall y tener tu aplicación en ejecución, es crear un servicio para tu aplicación. Note Utilizar certificados SSL directamente en el servicio Sisk en sistemas no Windows no es posible. Esto es un punto de la implementación de HttpListener, que es el módulo central para la gestión de la cola de HTTP en Sisk, y esta implementación varía de un sistema operativo a otro. Puedes utilizar SSL en tu servicio Sisk si asocias un certificado con el host virtual con IIS. Para otros sistemas, se recomienda altamente utilizar un proxy inverso. Creando un servicio Crear un servicio hará que tu aplicación esté siempre disponible, incluso después de reiniciar tu instancia de servidor o un bloqueo no recuperable. En este tutorial simple, utilizaremos el contenido del tutorial anterior como una demostración para mantener tu servicio siempre activo. Accede a la carpeta donde se encuentran los archivos de configuración del servicio: cd /etc/systemd/system Crea tu archivo my-app.service e incluye el contenido: my-app.service INI [Unit] Description=<descripción sobre tu aplicación> [Service] # establece el usuario que lanzará el servicio User=<usuario que lanzará el servicio> # la ruta de ExecStart no es relativa a WorkingDirectory. # establecela como la ruta completa al archivo ejecutable WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # establece el servicio para que siempre se reinicie en caso de bloqueo Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Reinicia el módulo de administración de servicios: $ sudo systemctl daemon-reload Inicia tu servicio recién creado desde el nombre del archivo que estableciste y verifica si se está ejecutando: $ sudo systemctl start my-app $ sudo systemctl status my-app Ahora, si tu aplicación se está ejecutando (\"Active: active\"), habilita tu servicio para que se mantenga en ejecución después de un reinicio del sistema: $ sudo systemctl enable my-app Ahora estás listo para presentar tu aplicación Sisk a todos."
  },
  "docs/es/extensions/basic-auth.html": {
    "href": "docs/es/extensions/basic-auth.html",
    "title": "Autenticación Básica | Sisk",
    "keywords": "Autenticación Básica El paquete de Autenticación Básica agrega un controlador de solicitudes capaz de manejar el esquema de autenticación básica en su aplicación Sisk con muy poca configuración y esfuerzo. La autenticación HTTP básica es una forma minimalista de autenticar solicitudes mediante un identificador de usuario y una contraseña, donde la sesión es controlada exclusivamente por el cliente y no hay tokens de autenticación o acceso. Lea más sobre el esquema de autenticación básica en la especificación de MDN. Instalación Para empezar, instale el paquete Sisk.BasicAuth en su proyecto: > dotnet add package Sisk.BasicAuth Puede ver más formas de instalarlo en su proyecto en el repositorio de Nuget. Creación de su controlador de autenticación Puede controlar el esquema de autenticación para un módulo completo o para rutas individuales. Para ello, primero escribamos nuestro primer controlador de autenticación básica. En el ejemplo a continuación, se establece una conexión con la base de datos, se verifica si el usuario existe y si la contraseña es válida, y después de eso, se almacena el usuario en la bolsa de contexto. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Para entrar en esta página, por favor, informe sus credenciales.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // en este caso, estamos utilizando el correo electrónico como el campo de identificador de usuario, así que // vamos a buscar un usuario utilizando su correo electrónico. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Lo sentimos, no se encontró ningún usuario con este correo electrónico.\"); } // valida que la contraseña de las credenciales sea válida para este usuario. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Credenciales inválidas.\"); } // agrega el usuario conectado a la bolsa de contexto // y continúa la ejecución context.Bag.Add(\"loggedUser\", user); return null; } } Así que solo asocie este controlador de solicitudes con nuestra ruta o clase. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hola, \" + loggedUser.Name + \"!\"; } } O utilizando la clase RouterModule: public class UsersController : RouterModule { public ClientModule() { // ahora todas las rutas dentro de esta clase serán manejadas por // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hola, \" + loggedUser.Name + \"!\"; } } Observaciones La responsabilidad principal de la autenticación básica se lleva a cabo en el lado del cliente. El almacenamiento, el control de caché, y el cifrado se manejan localmente en el cliente. El servidor solo recibe las credenciales y valida si se permite o no el acceso. Tenga en cuenta que este método no es uno de los más seguros porque coloca una gran responsabilidad en el cliente, lo que puede ser difícil de rastrear y mantener la seguridad de sus credenciales. Además, es fundamental que las contraseñas se transmitan en un contexto de conexión segura (SSL), ya que no tienen cifrado inherente. Una breve intercepción en los encabezados de una solicitud puede exponer las credenciales de acceso de su usuario. Opte por soluciones de autenticación más robustas para aplicaciones en producción y evite utilizar demasiados componentes prefabricados, ya que pueden no adaptarse a las necesidades de su proyecto y terminar exponiéndolo a riesgos de seguridad."
  },
  "docs/es/extensions/ini-configuration.html": {
    "href": "docs/es/extensions/ini-configuration.html",
    "title": "Proveedor de configuración INI | Sisk",
    "keywords": "Proveedor de configuración INI Sisk tiene un método para obtener configuraciones de inicio diferentes a JSON. De hecho, cualquier canal que implemente IConfigurationReader se puede utilizar con PortableConfigurationBuilder.WithConfigurationPipeline, leyendo la configuración del servidor desde cualquier tipo de archivo. El paquete Sisk.IniConfiguration proporciona un lector de archivos INI basado en flujo que no lanza excepciones por errores de sintaxis comunes y tiene una sintaxis de configuración simple. Este paquete se puede utilizar fuera del marco de Sisk, ofreciendo flexibilidad para proyectos que requieren un lector de documentos INI eficiente. Instalación Para instalar el paquete, puede comenzar con: $ dotnet add package Sisk.IniConfiguration También puede instalar el paquete principal, que no incluye el lector de configuración INI IConfigurationReader, ni la dependencia de Sisk, solo los serializadores INI: $ dotnet add package Sisk.IniConfiguration.Core Con el paquete principal, puede utilizarlo en su código como se muestra en el ejemplo a continuación: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // utiliza el lector de configuración IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } El código anterior buscará un archivo app.ini en el directorio actual del proceso (CurrentDirectory). El archivo INI se ve así: [Server] # Se admiten varias direcciones de escucha Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Sabor y sintaxis INI Implementación actual del sabor: Los nombres de propiedades y secciones son insensibles a mayúsculas y minúsculas. Los nombres de propiedades y valores son recortados, a menos que los valores estén entre comillas. Los valores pueden estar entre comillas simples o dobles. Las comillas pueden tener saltos de línea dentro de ellas. Se admiten comentarios con # y ;. También se admiten comentarios al final. Las propiedades pueden tener varios valores. En detalle, la documentación para el \"sabor\" del analizador INI utilizado en Sisk está disponible en este documento. Utilizando el siguiente código INI como ejemplo: One = 1 Value = this is an value Another value = \"this value has an line break on it\" ; el código a continuación tiene algunos colores [some section] Color = Red Color = Blue Color = Yellow ; no use yellow Analícelo con: // analice el texto INI desde la cadena IniDocument doc = IniDocument.FromString(iniText); // obtenga un valor string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // obtenga varios valores string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Parámetros de configuración Sección y nombre Admite varios valores Descripción Server.Listen Sí Las direcciones/puertos de escucha del servidor. Server.Encoding No La codificación predeterminada del servidor. Server.MaximumContentLength No El tamaño máximo de contenido en bytes del servidor. Server.IncludeRequestIdHeader No Especifica si el servidor HTTP debe enviar el encabezado X-Request-Id. Server.ThrowExceptions No Especifica si las excepciones no controladas deben lanzarse. Server.AccessLogsStream No Especifica la secuencia de salida de registros de acceso. Server.ErrorsLogsStream No Especifica la secuencia de salida de registros de errores. Cors.AllowMethods No Especifica el valor del encabezado CORS Allow-Methods. Cors.AllowHeaders No Especifica el valor del encabezado CORS Allow-Headers. Cors.AllowOrigins No Especifica varios encabezados Allow-Origin, separados por comas. AllowOrigins para más información. Cors.AllowOrigin No Especifica un encabezado Allow-Origin. Cors.ExposeHeaders No Especifica el valor del encabezado CORS Expose-Headers. Cors.AllowCredentials No Especifica el valor del encabezado CORS Allow-Credentials. Cors.MaxAge No Especifica el valor del encabezado CORS Max-Age."
  },
  "docs/es/extensions/json-rpc.html": {
    "href": "docs/es/extensions/json-rpc.html",
    "title": "Extensión JSON-RPC | Sisk",
    "keywords": "Extensión JSON-RPC Sisk tiene un módulo experimental para una API JSON-RPC 2.0, que te permite crear aplicaciones aún más simples. Esta extensión implementa estrictamente la interfaz de transporte JSON-RPC 2.0 y ofrece transporte a través de HTTP GET, solicitudes POST y también web-sockets con Sisk. Puedes instalar la extensión a través de Nuget con el comando siguiente. Ten en cuenta que, en versiones experimentales/beta, debes habilitar la opción para buscar paquetes prelanzamiento en Visual Studio. dotnet add package Sisk.JsonRpc Interfaz de transporte JSON-RPC es un protocolo de ejecución remota de procedimientos (RDP) sin estado y asíncrono que utiliza JSON para la comunicación de datos unidireccional. Una solicitud JSON-RPC se identifica típicamente por un ID, y una respuesta se entrega con el mismo ID que se envió en la solicitud. No todas las solicitudes requieren una respuesta, que se llaman \"notificaciones\". La especificación JSON-RPC 2.0 explica en detalle cómo funciona el transporte. Este transporte es agnóstico de dónde se utilizará. Sisk implementa este protocolo a través de HTTP, siguiendo las conformidades de JSON-RPC sobre HTTP, que admite parcialmente las solicitudes GET, pero admite completamente las solicitudes POST. También se admiten los web-sockets, que proporcionan una comunicación de mensajes asíncrona. Una solicitud JSON-RPC se parece a: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } Y una respuesta exitosa se parece a: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Métodos JSON-RPC El siguiente ejemplo muestra cómo crear una API JSON-RPC utilizando Sisk. Una clase de operaciones matemáticas realiza las operaciones remotas y entrega la respuesta serializada al cliente. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // agregar todos los métodos con la etiqueta WebMethod al controlador JSON-RPC args.Handler.Methods.AddMethodsFromType(new MathOperations()); // asigna la ruta /service para manejar solicitudes JSON-RPC POST y GET args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // crea un controlador de web-sockets en GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } El ejemplo anterior asignará los métodos Sum y Sqrt al controlador JSON-RPC, y estos métodos estarán disponibles en GET /service, POST /service y GET /ws. Los nombres de los métodos son insensibles a mayúsculas y minúsculas. Los parámetros de los métodos se deserializan automáticamente en sus tipos específicos. También se admite el uso de parámetros con nombre en las solicitudes. La serialización JSON se realiza mediante la biblioteca LightJson. Cuando un tipo no se deserializa correctamente, puedes crear un convertidor JSON personalizado para ese tipo y asociarlo con tus opciones de serializador JSON más adelante. También puedes obtener el objeto $.params crudo de la solicitud JSON-RPC directamente en tu método. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Para que esto ocurra, @params debe ser el único parámetro en tu método, con exactamente el nombre params (en C#, el @ es necesario para escapar este nombre de parámetro). La deserialización de parámetros ocurre tanto para objetos con nombre como para matrices posicionales. Por ejemplo, el siguiente método se puede llamar de forma remota mediante ambas solicitudes: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Para una matriz, el orden de los parámetros debe seguirse. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Personalización del serializador Puedes personalizar el serializador JSON en la propiedad JsonRpcHandler.JsonSerializerOptions. En esta propiedad, puedes habilitar el uso de JSON5 para deserializar mensajes. Aunque no es una conformidad con JSON-RPC 2.0, JSON5 es una extensión de JSON que permite una escritura más legible y humana. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // utiliza un comparador de nombres sanitizado. este comparador compara solo letras // y dígitos en un nombre, y descarta otros símbolos. por ejemplo: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // habilita JSON5 para el intérprete JSON. incluso activando esto, el JSON plano todavía se admite e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // asigna la ruta POST /service al controlador JSON-RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/es/extensions/service-providers.html": {
    "href": "docs/es/extensions/service-providers.html",
    "title": "Proveedores de Servicios | Sisk",
    "keywords": "Proveedores de Servicios Los Proveedores de Servicios son una forma de portar su aplicación Sisk a diferentes entornos con un archivo de configuración portátil. Esta característica permite cambiar el puerto del servidor, parámetros y otras opciones sin tener que modificar el código de la aplicación para cada entorno. Este módulo depende de la sintaxis de construcción de Sisk y se puede configurar a través del método UsePortableConfiguration. Un proveedor de configuración se implementa con IConfigurationProvider, que proporciona un lector de configuración y puede recibir cualquier implementación. Por defecto, Sisk proporciona un lector de configuración JSON, pero también hay un paquete para archivos INI. También puede crear su propio proveedor de configuración y registrararlo con: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Como se mencionó anteriormente, el proveedor predeterminado es un archivo JSON. Por defecto, el nombre del archivo que se busca es service-config.json, y se busca en el directorio actual del proceso en ejecución, no en el directorio del ejecutable. Puede elegir cambiar el nombre del archivo, así como dónde Sisk debe buscar el archivo de configuración, con: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); El código anterior buscará el archivo config.toml en el directorio actual del proceso en ejecución. Si no se encuentra, luego buscará en el directorio donde se encuentra el ejecutable. Si el archivo no existe, el parámetro createIfDontExists se honra, creando el archivo, sin contenido, en la última ruta de acceso probada (basada en lookupDirectories), y se lanza un error en la consola, evitando que la aplicación se inicialice. Tip Puede ver el código fuente del lector de configuración INI y el lector de configuración JSON para entender cómo se implementa un IConfigurationProvider. Lectura de configuraciones desde un archivo JSON Por defecto, Sisk proporciona un proveedor de configuración que lee configuraciones desde un archivo JSON. Este archivo sigue una estructura fija y está compuesto por los siguientes parámetros: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"Mi aplicación Sisk\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Los archivos de configuración también admiten comentarios ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // Nuevo en 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Los parámetros creados a partir de un archivo de configuración se pueden acceder en el constructor del servidor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Cada lector de configuración proporciona una forma de leer los parámetros de inicialización del servidor. Algunas propiedades se indican que deben estar en el entorno del proceso en lugar de estar definidas en el archivo de configuración, como datos de API sensibles, claves de API, etc. Estructura del archivo de configuración El archivo de configuración JSON está compuesto por las siguientes propiedades: Propiedad Obligatorio Descripción Server Requerido Representa el servidor en sí con sus configuraciones. Server.AccessLogsStream Opcional Por defecto, es console. Especifica la secuencia de salida de los registros de acceso. Puede ser un nombre de archivo, null o console. Server.ErrorsLogsStream Opcional Por defecto, es null. Especifica la secuencia de salida de los registros de errores. Puede ser un nombre de archivo, null o console. Server.MaximumContentLength Opcional Server.MaximumContentLength Opcional Por defecto, es 0. Especifica la longitud máxima de contenido en bytes. Cero significa infinito. Server.IncludeRequestIdHeader Opcional Por defecto, es false. Especifica si el servidor HTTP debe enviar el encabezado X-Request-Id. Server.ThrowExceptions Opcional Por defecto, es true. Especifica si las excepciones no controladas deben lanzarse. Establezca en false cuando esté en producción y true cuando esté depurando. ListeningHost Requerido Representa el host de escucha del servidor. ListeningHost.Label Opcional Representa la etiqueta de la aplicación. ListeningHost.Ports Requerido Representa una matriz de cadenas, que coincide con la sintaxis de ListeningPort. ListeningHost.CrossOriginResourceSharingPolicy Opcional Configura los encabezados CORS para la aplicación. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Opcional Por defecto, es false. Especifica el encabezado Allow-Credentials. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Expose-Headers. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Opcional Por defecto, es null. Esta propiedad espera una cadena. Especifica el encabezado Allow-Origin. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica múltiples encabezados Allow-Origin. Consulte AllowOrigins para obtener más información. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Allow-Methods. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Allow-Headers. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Opcional Por defecto, es null. Esta propiedad espera un entero. Especifica el encabezado Max-Age en segundos. ListeningHost.Parameters Opcional Especifica las propiedades proporcionadas al método de configuración de la aplicación."
  },
  "docs/es/extensions/ssl-proxy.html": {
    "href": "docs/es/extensions/ssl-proxy.html",
    "title": "Proxy SSL | Sisk",
    "keywords": "Proxy SSL Warning Esta característica es experimental y no debe usarse en producción. Por favor, consulte este documento si desea hacer que Sisk funcione con SSL. El Proxy SSL de Sisk es un módulo que proporciona una conexión HTTPS para un ListeningHost en Sisk y enruta los mensajes HTTPS a un contexto HTTP inseguro. El módulo se creó para proporcionar una conexión SSL para un servicio que utiliza HttpListener para ejecutarse, que no admite SSL. El proxy se ejecuta dentro de la misma aplicación y escucha los mensajes HTTP/1.1, reenviándolos en el mismo protocolo a Sisk. Actualmente, esta característica es muy experimental y puede ser lo suficientemente inestable como para no usarse en producción. En la actualidad, el SslProxy admite casi todas las características de HTTP/1.1, como keep-alive, codificación chunked, websockets, etc. Para una conexión abierta al proxy SSL, se crea una conexión TCP al servidor de destino y el proxy se reenvía a la conexión establecida. El SslProxy se puede utilizar con HttpServer.CreateBuilder de la siguiente manera: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hola, mundo!\"); }); }) // agregar SSL al proyecto .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Debes proporcionar un certificado SSL válido para el proxy. Para asegurarte de que el certificado sea aceptado por los navegadores, recuerda importarlo en el sistema operativo para que funcione correctamente."
  },
  "docs/es/faq.html": {
    "href": "docs/es/faq.html",
    "title": "Preguntas Frecuentes | Sisk",
    "keywords": "Preguntas Frecuentes Preguntas frecuentes sobre Sisk. ¿Es Sisk de código abierto? Totalmente. Todo el código fuente utilizado por Sisk se publica y se actualiza con frecuencia en GitHub. ¿Se aceptan contribuciones? Siempre y cuando sean compatibles con la filosofía de Sisk, todas las contribuciones son muy bienvenidas. Las contribuciones no tienen que ser solo código. Puedes contribuir con documentación, pruebas, traducciones, donaciones y publicaciones, por ejemplo. ¿Está financiado Sisk? No. Ninguna organización o proyecto patrocina actualmente a Sisk. ¿Puedo usar Sisk en producción? Absolutamente. El proyecto lleva en desarrollo más de tres años y ha tenido una intensa prueba en aplicaciones comerciales que han estado en producción desde entonces. Sisk se utiliza en proyectos comerciales importantes como infraestructura principal. Una guía sobre cómo implementar en diferentes sistemas y entornos se ha escrito y está disponible. ¿Tiene Sisk autenticación, monitoreo y servicios de base de datos? No. Sisk no tiene ninguno de estos. Es un framework para desarrollar aplicaciones web HTTP, pero es un framework minimalista que entrega lo necesario para que tu aplicación funcione. Puedes implementar todos los servicios que desees utilizando cualquier biblioteca de terceros que prefieras. Sisk fue diseñado para ser agnóstico, flexible y funcionar con cualquier cosa. ¿Por qué debería usar Sisk en lugar de ? No lo sé. Tú me lo dices. Sisk se creó para llenar un escenario genérico para aplicaciones web HTTP en .NET. Proyectos establecidos, como ASP.NET, resuelven varios problemas, pero con diferentes sesgos. A diferencia de los frameworks más grandes, Sisk requiere que el usuario sepa lo que está haciendo y construyendo. Los conceptos básicos de desarrollo web y el protocolo HTTP son esenciales para trabajar con Sisk. Sisk se parece más a Express de Node.js que a ASP.NET Core. Es una abstracción de alto nivel que te permite crear aplicaciones con lógica HTTP que tú quieras. ¿Qué necesito para aprender Sisk? Necesitas los conceptos básicos de: Desarrollo web (HTTP, Restful, etc.) .NET Eso es todo. Teniendo una noción de estos dos temas, puedes dedicar unas horas a desarrollar una aplicación avanzada con Sisk. ¿Puedo desarrollar aplicaciones comerciales con Sisk? Absolutamente. Sisk se creó bajo la licencia MIT, lo que significa que puedes usar Sisk en cualquier proyecto comercial, comercial o no comercial, sin necesidad de una licencia propietaria. Lo que pedimos es que en algún lugar de tu aplicación, tengas un aviso de los proyectos de código abierto utilizados en tu proyecto, y que Sisk esté allí."
  },
  "docs/es/features/content-streaming.html": {
    "href": "docs/es/features/content-streaming.html",
    "title": "Transmisión de contenido | Sisk",
    "keywords": "Transmisión de contenido El Sisk admite la lectura y el envío de flujos de contenido desde y hacia el cliente. Esta característica es útil para eliminar la sobrecarga de memoria para serializar y deserializar contenido durante la vida útil de una solicitud. Flujo de contenido de la solicitud Los contenidos pequeños se cargan automáticamente en la memoria del búfer de la conexión HTTP, cargando rápidamente este contenido en HttpRequest.Body y HttpRequest.RawBody. Para contenidos más grandes, se puede utilizar el método HttpRequest.GetRequestStream para obtener el flujo de lectura del contenido de la solicitud. Es importante destacar que el método HttpRequest.GetMultipartFormContent lee todo el contenido de la solicitud en la memoria, por lo que puede no ser útil para leer contenidos grandes. Consideremos el siguiente ejemplo: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // la solicitud no tiene contenido return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"Archivo enviado con éxito.\" } ) }; } En el ejemplo anterior, el método UploadDocument lee el contenido de la solicitud y lo guarda en un archivo. No se realiza ninguna asignación de memoria adicional, excepto por el búfer de lectura utilizado por Stream.CopyToAsync. El ejemplo anterior elimina la presión de asignación de memoria para un archivo muy grande, lo que puede optimizar el rendimiento de la aplicación. Es una buena práctica utilizar siempre un CancellationToken en una operación que pueda ser larga, como enviar archivos, ya que depende de la velocidad de la red entre el cliente y el servidor. El ajuste con un CancellationToken se puede realizar de la siguiente manera: Controller/UploadDocument.cs C# // el token de cancelación a continuación lanzará una excepción si se alcanza el tiempo de espera de 30 segundos. CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"La carga superó el tiempo de carga máximo (30 segundos).\" } ) }; } Flujo de contenido de la respuesta Enviar contenido de respuesta también es posible. Actualmente, hay dos formas de hacerlo: a través del método HttpRequest.GetResponseStream y utilizando un contenido de tipo StreamContent. Consideremos un escenario en el que necesitamos servir un archivo de imagen. Para hacer esto, podemos utilizar el siguiente código: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // método de ejemplo para obtener una imagen de perfil var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } El método anterior realiza una asignación de memoria cada vez que se lee el contenido de la imagen. Si la imagen es grande, esto puede causar un problema de rendimiento, y en situaciones de pico, incluso una sobrecarga de memoria y caída del servidor. En estas situaciones, la caché puede ser útil, pero no eliminará el problema, ya que la memoria seguirá reservada para ese archivo. La caché aliviará la presión de tener que asignar memoria para cada solicitud, pero para archivos grandes, no será suficiente. Enviar la imagen a través de un flujo puede ser una solución al problema. En lugar de leer todo el contenido de la imagen, se crea un flujo de lectura en el archivo y se copia al cliente utilizando un búfer pequeño. Enviar a través del método GetResponseStream El método HttpRequest.GetResponseStream crea un objeto que permite enviar fragmentos de la respuesta HTTP a medida que se prepara el flujo de contenido. Este método es más manual, requiriendo que se defina el estado, los encabezados y el tamaño del contenido antes de enviar el contenido. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // en esta forma de envío, el estado y el encabezado deben definirse // antes de enviar el contenido var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // en esta forma de envío, también es necesario definir el tamaño del contenido // antes de enviarlo. requestStreamManager.SetContentLength ( fs.Length ); // si no se conoce el tamaño del contenido, se puede utilizar codificación por fragmentos // para enviar el contenido requestStreamManager.SendChunked = true; // y luego, escribir en el flujo de salida await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } Enviar contenido a través de un StreamContent La clase StreamContent permite enviar contenido desde una fuente de datos como un flujo de bytes. Esta forma de envío es más fácil, eliminando los requisitos anteriores, y incluso permitiendo el uso de codificación de compresión para reducir el tamaño del contenido. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important En este tipo de contenido, no encapsule el flujo en un bloque using. El contenido se descartará automáticamente por el servidor HTTP cuando se finalice el flujo de contenido, con o sin errores."
  },
  "docs/es/features/cors.html": {
    "href": "docs/es/features/cors.html",
    "title": "Habilitar CORS (Compartir recursos de origen cruzado) en Sisk | Sisk",
    "keywords": "Habilitar CORS (Compartir recursos de origen cruzado) en Sisk Sisk tiene una herramienta que puede ser útil para manejar Compartir recursos de origen cruzado (CORS) cuando se expone su servicio públicamente. Esta característica no es parte del protocolo HTTP, sino una característica específica de los navegadores web definida por la W3C. Este mecanismo de seguridad evita que una página web realice solicitudes a un dominio diferente al que proporcionó la página web. Un proveedor de servicios puede permitir que ciertos dominios accedan a sus recursos, o solo uno. Same Origin Para que un recurso sea identificado como \"same origin\", una solicitud debe identificar el encabezado Origin en su solicitud: GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... Y el servidor remoto debe responder con un encabezado Access-Control-Allow-Origin con el mismo valor que el origen solicitado: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... Esta verificación es explícita: el host, el puerto y el protocolo deben ser los mismos que los solicitados. Verifique el ejemplo: Un servidor responde que su Access-Control-Allow-Origin es https://example.com: https://example.net - el dominio es diferente. http://example.com - el esquema es diferente. http://example.com:5555 - el puerto es diferente. https://www.example.com - el host es diferente. En la especificación, solo se permite la sintaxis para ambos encabezados, tanto para solicitudes como para respuestas. La ruta URL se ignora. El puerto también se omite si es un puerto predeterminado (80 para HTTP y 443 para HTTPS). Origin: null Origin: <scheme>://<hostname> Origin: <scheme>://<hostname>:<port> Habilitar CORS Nativamente, tiene el objeto CrossOriginResourceSharingHeaders dentro de su ListeningHost. Puede configurar CORS al inicializar el servidor: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } El código anterior enviará los siguientes encabezados para todas las respuestas: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type Estos encabezados deben enviarse para todas las respuestas a un cliente web, incluidos errores y redirecciones. Puede notar que la clase CrossOriginResourceSharingHeaders tiene dos propiedades similares: AllowOrigin y AllowOrigins. Note que una es plural, mientras que la otra es singular. La propiedad AllowOrigin es estática: solo el origen que especifique se enviará para todas las respuestas. La propiedad AllowOrigins es dinámica: el servidor verifica si el origen de la solicitud está contenido en esta lista. Si se encuentra, se envía para la respuesta de ese origen. Comodín en Origen Alternativamente, puede usar un comodín (*) en el origen de la respuesta para especificar que cualquier origen puede acceder al recurso. Sin embargo, este valor no está permitido para solicitudes que tienen credenciales (encabezados de autorización) y esta operación resultará en un error. Puede solucionar este problema enumerando explícitamente qué orígenes se permitirán a través de la propiedad AllowOrigins o también usar la constante AutoAllowOrigin en el valor de AllowOrigin. Esta propiedad mágica definirá el encabezado Access-Control-Allow-Origin para el mismo valor que el encabezado Origin de la solicitud. Otras formas de aplicar CORS Si está tratando con proveedores de servicios, puede anular los valores definidos en el archivo de configuración: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // Anulará el origen definido en el archivo de configuración. cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } Deshabilitar CORS en rutas específicas La propiedad UseCors está disponible para rutas y todos los atributos de ruta y se puede deshabilitar con el siguiente ejemplo: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } Reemplazar valores en la respuesta Puede reemplazar o eliminar valores explícitamente en una acción de enrutador: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Elimina el encabezado Access-Control-Allow-Credentials request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Reemplaza el Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } Solicitudes preflight Una solicitud preflight es un método OPTIONS que el cliente envía antes de la solicitud real. El servidor Sisk siempre responderá a la solicitud con un 200 OK y los encabezados CORS aplicables, y luego el cliente puede proceder con la solicitud real. Esta condición solo no se aplica cuando existe una ruta para la solicitud con el RouteMethod configurado explícitamente para Options. Deshabilitar CORS globalmente No es posible hacerlo. Para no usar CORS, no configurelo."
  },
  "docs/es/features/discard-syntax.html": {
    "href": "docs/es/features/discard-syntax.html",
    "title": "Sintaxis de descarte | Sisk",
    "keywords": "Sintaxis de descarte El servidor HTTP se puede utilizar para escuchar una solicitud de devolución de llamada desde una acción, como la autenticación OAuth, y se puede descartar después de recibir esa solicitud. Esto puede ser útil en casos donde necesite una acción en segundo plano pero no desee configurar una aplicación HTTP completa para ello. El siguiente ejemplo muestra cómo crear un servidor HTTP de escucha en el puerto 5555 con CreateListener y esperar el siguiente contexto: using (var server = HttpServer.CreateListener(5555)) { // espera la próxima solicitud HTTP var context = await server.WaitNextAsync(); Console.WriteLine($\"Ruta solicitada: {context.Request.Path}\"); } La función WaitNext espera el próximo contexto de un procesamiento de solicitud completado. Una vez que se obtiene el resultado de esta operación, el servidor ya ha procesado completamente la solicitud y ha enviado la respuesta al cliente."
  },
  "docs/es/features/instancing.html": {
    "href": "docs/es/features/instancing.html",
    "title": "Inyección de dependencias | Sisk",
    "keywords": "Inyección de dependencias Es común dedicar miembros e instancias que duran toda la vida de una solicitud, como una conexión a una base de datos, un usuario autenticado o un token de sesión. Una de las posibilidades es a través de HttpContext.RequestBag, que crea un diccionario que dura toda la vida de una solicitud. Este diccionario se puede acceder desde manejadores de solicitudes y definir variables a lo largo de esa solicitud. Por ejemplo, un manejador de solicitudes que autentica a un usuario establece este usuario dentro de HttpContext.RequestBag, y dentro de la lógica de la solicitud, este usuario se puede recuperar con HttpContext.RequestBag.Get<User>(). Aquí hay un ejemplo: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // avanzar a la siguiente solicitud de manejo o lógica de solicitud } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hola {authenticatedUser.Name}!\") }; } Este es un ejemplo preliminar de esta operación. La instancia de User se creó dentro del manejador de solicitudes dedicado a la autenticación, y todas las rutas que utilizan este manejador de solicitudes tendrán la garantía de que habrá un User en su instancia de HttpContext.RequestBag. Es posible definir lógica para obtener instancias cuando no se han definido previamente en RequestBag a través de métodos como GetOrAdd o GetOrAddAsync. Desde la versión 1.3, se introdujo la propiedad estática HttpContext.Current, que permite acceder al HttpContext actualmente en ejecución del contexto de la solicitud. Esto permite exponer miembros del HttpContext fuera de la solicitud actual y definir instancias en objetos de rutas. El ejemplo siguiente define un controlador que tiene miembros comúnmente accedidos por el contexto de una solicitud. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // crear un DbContext o obtener el existente return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // la siguiente línea lanzará una excepción si la propiedad se accede cuando el Usuario no // está definido en la bolsa de solicitudes public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // También se admite la exposición de la instancia de HttpRequest public HttpRequest Request { get => HttpContext.Current.Request; } } Y define tipos que heredan del controlador: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Para el ejemplo anterior, necesitarás configurar un manejador de valores en tu enrutador para que los objetos devueltos por el enrutador se transformen en un HttpResponse válido. Tenga en cuenta que los métodos no tienen un argumento HttpRequest request como está presente en otros métodos. Esto se debe a que, desde la versión 1.3, el enrutador admite dos tipos de delegados para respuestas de enrutamiento: RouteAction, que es el delegado predeterminado que recibe un argumento HttpRequest, y ParameterlessRouteAction. El objeto HttpRequest aún se puede acceder desde ambos delegados a través de la propiedad Request del HttpContext estático en el subproceso. En el ejemplo anterior, definimos un objeto desechable, el DbContext, y necesitamos asegurarnos de que todas las instancias creadas en un DbContext se desechen cuando la sesión HTTP finalice. Para ello, podemos utilizar dos formas de lograrlo. Una es crear un manejador de solicitudes que se ejecute después de la acción del enrutador, y la otra forma es a través de un manejador de servidor personalizado. Para el primer método, podemos crear el manejador de solicitudes directamente en el método OnSetup heredado de RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // obtener un DbContext definido en el contexto del manejador de solicitudes y // desecharlo ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Desde Sisk versión 1.4, la propiedad HttpServerConfiguration.DisposeDisposableContextValues se introdujo y se habilitó de forma predeterminada, lo que define si el servidor HTTP debe desechar todos los valores IDisposable en la bolsa de contexto cuando se cierra una sesión HTTP. El método anterior garantizará que el DbContext se deseché cuando la sesión HTTP se finalice. Puedes hacer esto para más miembros que necesitan desecharse al final de una respuesta. Para el segundo método, puedes crear un manejador de servidor personalizado que desechará el DbContext cuando la sesión HTTP se finalice. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } Y usarlo en tu constructor de aplicaciones: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Esta es una forma de manejar la limpieza de código y mantener las dependencias de una solicitud separadas por el tipo de módulo que se utilizará, reduciendo la cantidad de código duplicado dentro de cada acción de un enrutador. Es una práctica similar a la que se utiliza la inyección de dependencias en frameworks como ASP.NET."
  },
  "docs/es/features/logging.html": {
    "href": "docs/es/features/logging.html",
    "title": "Registro | Sisk",
    "keywords": "Registro Puedes configurar Sisk para que escriba automáticamente los registros de acceso y error. Es posible definir la rotación de registros, extensiones y frecuencia. La clase LogStream proporciona una forma asíncrona de escribir registros y mantenerlos en una cola de escritura esperable. En este artículo te mostraremos cómo configurar el registro para tu aplicación. Registros de acceso basados en archivos Los registros en archivos abren el archivo, escriben el texto de la línea y luego cierran el archivo para cada línea escrita. Este procedimiento se adoptó para mantener la respuesta de escritura en los registros. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } El código anterior escribirá todas las solicitudes entrantes en el archivo logs/access.log. Ten en cuenta que, si el archivo no existe, se crea automáticamente, sin embargo, la carpeta anterior no. No es necesario crear el directorio logs/ ya que la clase LogStream lo crea automáticamente. Registro basado en flujo Puedes escribir archivos de registro en objetos TextWriter, como Console.Out, pasando un objeto TextWriter en el constructor: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); Para cada mensaje escrito en el registro basado en flujo, se llama al método TextWriter.Flush(). Formato de registro de acceso Puedes personalizar el formato de registro de acceso mediante variables predefinidas. Considera la siguiente línea: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou en %lmsms [%{user-agent}]\"; Escribirá un mensaje como: 29/mar./2023 15:21:47 -0300 Ejecutado ::1 http://localhost:5555/ [200 OK] 689B -> 707B en 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] Puedes formatear tu archivo de registro según el formato descrito en la tabla: Valor Lo que representa Ejemplo %dd Día del mes (formateado como dos dígitos) 05 %dmmm Nombre completo del mes Julio %dmm Nombre abreviado del mes (tres letras) Jul %dm Número de mes (formateado como dos dígitos) 07 %dy Año (formateado como cuatro dígitos) 2023 %th Hora en formato de 12 horas 03 %tH Hora en formato de 24 horas (HH) 15 %ti Minutos (formateados como dos dígitos) 30 %ts Segundos (formateados como dos dígitos) 45 %tm Milisegundos (formateados como tres dígitos) 123 %tz Desplazamiento de zona horaria (total de horas en UTC) +03:00 %ri Dirección IP remota del cliente 192.168.1.100 %rm Método HTTP (en mayúsculas) GET %rs Esquema de URI (http/https) https %ra Autoridad de URI (dominio) example.com %rh Host de la solicitud www.example.com %rp Puerto de la solicitud 443 %rz Ruta de la solicitud /path/to/resource %rq Cadena de consulta ?key=value&another=123 %sc Código de estado de respuesta HTTP 200 %sd Descripción de estado de respuesta HTTP OK %lin Tamaño legible de la solicitud 1.2 KB %linr Tamaño bruto de la solicitud (bytes) 1234 %lou Tamaño legible de la respuesta 2.5 KB %lour Tamaño bruto de la respuesta (bytes) 2560 %lms Tiempo transcurrido en milisegundos 120 %ls Estado de ejecución Ejecutado Registros rotativos Tip En Sisk 0.15 y versiones anteriores, esta función solo está disponible con el paquete Sisk.ServiceProvider. En Sisk 0.16 y superior, esta función se implementa en el paquete principal. Puedes configurar el servidor HTTP para que gire los archivos de registro a un archivo comprimido .gz cuando alcancen un tamaño determinado. El tamaño se comprueba periódicamente por el límite que defines. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); El código anterior comprueba cada seis horas si el archivo de LogStream ha alcanzado su límite de 1MB. Si es así, el archivo se comprime a un archivo .gz y luego se limpia el archivo access.log. Durante este proceso, la escritura en el archivo está bloqueada hasta que el archivo se comprima y limpie. Todas las líneas que entren para ser escritas en este período esperarán hasta el final de la compresión. Esta función solo funciona con LogStreams basados en archivos. Registro de errores Cuando un servidor no está lanzando errores al depurador, los reenvía a la escritura de registros cuando hay alguno. Puedes configurar la escritura de errores con: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Esta propiedad solo escribirá algo en el registro si el error no es capturado por la devolución de llamada o la propiedad Router.CallbackErrorHandler. El error escrito por el servidor siempre escribe la fecha y hora, los encabezados de la solicitud (no el cuerpo), la traza del error y la traza de la excepción interna, si la hay. Otras instancias de registro Tu aplicación puede tener cero o varias instancias de LogStream, no hay límite en la cantidad de canales de registro que puede tener. Por lo tanto, es posible dirigir el registro de tu aplicación a un archivo diferente al registro de acceso o error predeterminado. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Aplicación iniciada en {0}\", DateTime.Now); Extensión de LogStream Puedes extender la clase LogStream para escribir formatos personalizados, compatibles con el motor de registro actual de Sisk. El ejemplo siguiente permite escribir mensajes con colores en la consola a través de la biblioteca Spectre.Console: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Otra forma de escribir automáticamente registros personalizados para cada solicitud/respuesta es crear un HttpServerHandler. El ejemplo siguiente es un poco más completo. Escribe el cuerpo de la solicitud y la respuesta en JSON en la consola. Puede ser útil para depurar solicitudes en general. Este ejemplo utiliza ContextBag y HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // En este punto, la conexión está abierta y el cliente ha enviado el encabezado que especifica // que el contenido es JSON. La línea siguiente lee el contenido y lo deja almacenado en la solicitud. // // Si el contenido no se lee en la acción de la solicitud, es probable que el GC lo recolecte // después de enviar la respuesta al cliente, por lo que el contenido puede no estar disponible después de cerrar la respuesta. // _ = request.RawBody; // agregar una pista en el contexto para indicar que esta solicitud tiene un cuerpo JSON request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformatea el JSON utilizando la biblioteca CypherPotato.LightJson var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // verificar si la respuesta es JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // obtener el estado de manejo interno del servidor responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/es/features/server-sent-events.html": {
    "href": "docs/es/features/server-sent-events.html",
    "title": "Eventos Enviados por Servidor | Sisk",
    "keywords": "Eventos Enviados por Servidor Sisk admite el envío de mensajes a través de Eventos Enviados por Servidor de forma predeterminada. Puedes crear conexiones desechables y persistentes, obtener las conexiones durante el tiempo de ejecución y utilizarlas. Esta característica tiene algunas limitaciones impuestas por los navegadores, como el envío de solo mensajes de texto y no poder cerrar permanentemente una conexión. Una conexión cerrada en el lado del servidor hará que un cliente intente reconectar periódicamente cada 5 segundos (3 para algunos navegadores). Estas conexiones son útiles para enviar eventos desde el servidor al cliente sin que el cliente solicite la información cada vez. Creando una conexión SSE Una conexión SSE funciona como una solicitud HTTP regular, pero en lugar de enviar una respuesta y cerrar inmediatamente la conexión, la conexión se mantiene abierta para enviar mensajes. Al llamar al método HttpRequest.GetEventSource(), la solicitud se pone en un estado de espera mientras se crea la instancia de SSE. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Hola, mundo!\"); return sse.Close(); }); En el código anterior, creamos una conexión SSE y enviamos un mensaje \"Hola, mundo\", luego cerramos la conexión SSE desde el lado del servidor. Note Al cerrar una conexión en el lado del servidor, por defecto el cliente intentará conectarse de nuevo en ese extremo y la conexión se reiniciará, ejecutando el método de nuevo, por siempre. Es común reenviar un mensaje de terminación desde el servidor cada vez que la conexión se cierra desde el servidor para evitar que el cliente intente reconectar de nuevo. Agregando encabezados Si necesitas enviar encabezados, puedes utilizar el método HttpRequestEventSource.AppendHeader antes de enviar cualquier mensaje. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Clave-Encabezado\", \"Valor-Encabezado\"); sse.Send(\"Hola!\"); return sse.Close(); }); Ten en cuenta que es necesario enviar los encabezados antes de enviar cualquier mensaje. Conexiones Wait-For-Fail Las conexiones normalmente se terminan cuando el servidor ya no puede enviar mensajes debido a una posible desconexión en el lado del cliente. De esta manera, la conexión se termina automáticamente y la instancia de la clase se descarta. Incluso con una reconexión, la instancia de la clase no funcionará, ya que está vinculada a la conexión anterior. En algunas situaciones, es posible que necesites esta conexión más adelante y no quieras administrarla a través del método de devolución de llamada de la ruta. Para esto, podemos identificar las conexiones SSE con un identificador y obtenerlas utilizando más tarde, incluso fuera de la devolución de llamada de la ruta. Además, marcamos la conexión con WaitForFail para no terminar la ruta y terminar la conexión automáticamente. Una conexión SSE en KeepAlive esperará un error de envío (causado por la desconexión) para reanudar la ejecución del método. También es posible establecer un tiempo de espera para esto. Después del tiempo, si no se ha enviado ningún mensaje, la conexión se termina y la ejecución se reanuda. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"mi-indice-conexion\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // esperar 15 segundos sin ningún mensaje antes de terminar la conexión return sse.Close(); }); El método anterior creará la conexión, la manejará y esperará una desconexión o error. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"mi-indice-conexion\"); if (evs != null) { // la conexión todavía está viva evs.Send(\"Hola de nuevo!\"); } Y el fragmento de código anterior intentará buscar la conexión recién creada y, si existe, enviará un mensaje a ella. Todas las conexiones activas del servidor que estén identificadas estarán disponibles en la colección HttpServer.EventSources. Esta colección solo almacena conexiones activas e identificadas. Las conexiones cerradas se eliminan de la colección. Note Es importante tener en cuenta que Keep Alive tiene un límite establecido por componentes que pueden estar conectados a Sisk de una manera incontrolable, como un proxy web, un kernel HTTP o un controlador de red, y cierran las conexiones inactivas después de un período determinado de tiempo. Por lo tanto, es importante mantener la conexión abierta enviando pings periódicos o extendiendo el tiempo máximo antes de que se cierre la conexión. Lee la siguiente sección para comprender mejor el envío de pings periódicos. Configurar política de pings de conexión La política de pings es una forma automatizada de enviar mensajes periódicos a tu cliente. Esta función permite al servidor comprender cuándo el cliente se ha desconectado de esa conexión sin tener que mantener la conexión abierta indefinidamente. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"mensaje-ping\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } En el código anterior, cada 5 segundos, se enviará un nuevo mensaje de ping al cliente. Esto mantendrá viva la conexión TCP y evitará que se cierre debido a la inactividad. Además, cuando un mensaje falla al enviarse, la conexión se cierra automáticamente, liberando los recursos utilizados por la conexión. Consultar conexiones Puedes buscar conexiones activas utilizando un predicado en el identificador de conexión, para poder transmitir, por ejemplo. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"mi-conexion-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Transmisión a todas las fuentes de eventos que comienzan con 'mi-conexion-'\"); } También puedes utilizar el método All para obtener todas las conexiones SSE activas."
  },
  "docs/es/features/websockets.html": {
    "href": "docs/es/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk también admite web sockets, como recibir y enviar mensajes a sus clientes. Esta característica funciona bien en la mayoría de los navegadores, pero en Sisk todavía es experimental. Por favor, si encuentras algún error, repórtalo en github. Aceptar y recibir mensajes de forma asíncrona El ejemplo siguiente muestra cómo funciona websocket en la práctica, con un ejemplo de abrir una conexión, recibir un mensaje y mostrarlo en la consola. Todos los mensajes recibidos por WebSocket se reciben en bytes, por lo que deberá decodificarlos al recibirlos. De forma predeterminada, los mensajes se fragmentan en fragmentos y el último fragmento se envía como el paquete final del mensaje. Puede configurar el tamaño del paquete con la bandera WebSocketBufferSize. Este almacenamiento en búfer es el mismo para enviar y recibir mensajes. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Mensaje recibido: \" + msgText); // obtiene el contexto de HttpWebSocket que recibió el mensaje HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Respuesta!\"); }; ws.WaitForClose(); return ws.Close(); }); Note No utilice eventos asíncronos de esta manera. Puede tener excepciones lanzadas fuera del dominio del servidor HTTP y pueden hacer que su aplicación se bloquee. Si necesita manejar código asíncrono y tratar con varios mensajes al mismo tiempo, puede utilizar el bucle de mensajes: router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Mensaje recibido: {messageText}\"); await ws.SendAsync(\"Hola desde el servidor!\"); } return ws.Close(); }); Aceptar y recibir mensajes de forma síncrona El ejemplo siguiente contiene una forma de utilizar un websocket síncrono, sin un contexto asíncrono, donde recibe los mensajes, los trata y termina utilizando el socket. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"¿Cuál es tu nombre?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Por favor, introduce tu nombre!\"); goto askName; } askAge: ws.Send(\"¿Y tu edad?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Por favor, introduce un número válido\"); goto askAge; } ws.Send($\"Eres {name} y tienes {age} años.\"); return ws.Close(); }); Enviar mensajes El método Send tiene tres sobrecargas, que permiten enviar texto, una matriz de bytes o un lapso de bytes. Todos ellos se fragmentan si el tamaño del paquete del servidor WebSocketBufferSize es mayor que el tamaño total de la carga. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hola, mundo\"); // se codificará como una matriz de bytes UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Esperar a que se cierre el websocket El método WaitForClose() bloquea la pila de llamadas actual hasta que la conexión sea terminada por el cliente o el servidor. Con esto, la ejecución de la devolución de llamada de la solicitud se bloqueará hasta que el cliente o el servidor se desconecten. También puede cerrar la conexión manualmente con el método Close(). Este método devuelve un objeto HttpResponse vacío, que no se envía al cliente, pero funciona como una devolución de la función donde se recibió la solicitud HTTP. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // esperar a que el cliente cierre la conexión ws.WaitForClose(); // espera hasta que no se intercambien mensajes en 60 segundos // o hasta que alguna parte cierre la conexión ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Política de ping Al igual que funciona la política de ping en Server Side Events, también puede configurar una política de ping para mantener la conexión TCP abierta si hay inactividad en ella. ws.WithPing(ping => { ping.DataMessage = \"mensaje-ping\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/es/fundamentals/request-handlers.html": {
    "href": "docs/es/fundamentals/request-handlers.html",
    "title": "Manejo de solicitudes | Sisk",
    "keywords": "Manejo de solicitudes Los controladores de solicitudes, también conocidos como \"middlewares\", son funciones que se ejecutan antes o después de que se ejecute una solicitud en el enrutador. Pueden definirse por ruta o por enrutador. Existen dos tipos de controladores de solicitudes: BeforeResponse: define que el controlador de solicitudes se ejecutará antes de llamar a la acción del enrutador. AfterResponse: define que el controlador de solicitudes se ejecutará después de llamar a la acción del enrutador. Enviar una respuesta HTTP en este contexto sobrescribirá la respuesta de la acción del enrutador. Ambos controladores de solicitudes pueden anular la respuesta real de la función de devolución de llamada del enrutador. Además, los controladores de solicitudes pueden ser útiles para validar una solicitud, como la autenticación, el contenido o cualquier otra información, como almacenar información, registros o otros pasos que se pueden realizar antes o después de una respuesta. De esta manera, un controlador de solicitudes puede interrumpir toda esta ejecución y devolver una respuesta antes de terminar el ciclo, descartando todo lo demás en el proceso. Ejemplo: supongamos que un controlador de solicitudes de autenticación de usuario no autentica al usuario. Evitará que el ciclo de solicitud continúe y se suspenderá. Si esto sucede en el controlador de solicitudes en la posición dos, el tercero y siguientes no se evaluarán. Creación de un controlador de solicitudes Para crear un controlador de solicitudes, podemos crear una clase que herede de la interfaz IRequestHandler, en este formato: Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Devolver null indica que el ciclo de solicitud puede continuar return null; } else { // Devolver un objeto HttpResponse indica que esta respuesta sobrescribirá las respuestas adyacentes. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } En el ejemplo anterior, indicamos que si el encabezado Authorization está presente en la solicitud, debe continuar y la siguiente solicitud de controlador o la devolución de llamada del enrutador debe ser llamada, lo que sea que venga a continuación. Si es un controlador de solicitudes que se ejecuta después de la respuesta por su propiedad ExecutionMode y devuelve un valor no nulo, sobrescribirá la respuesta del enrutador. Siempre que un controlador de solicitudes devuelva null, indica que la solicitud debe continuar y el siguiente objeto debe ser llamado o el ciclo debe terminar con la respuesta del enrutador. Asociación de un controlador de solicitudes con una sola ruta Puedes definir uno o más controladores de solicitudes para una ruta. Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // antes de la solicitud new ValidateJsonContentRequestHandler(), // antes de la solicitud // -- el método IndexPage se ejecutará aquí new WriteToLogRequestHandler() // después de la solicitud }); O creando un objeto Route: Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Asociación de un controlador de solicitudes con un enrutador Puedes definir un controlador de solicitudes global que se ejecutará en todas las rutas del enrutador. Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Asociación de un controlador de solicitudes con un atributo Puedes definir un controlador de solicitudes en un atributo junto con un atributo de ruta. Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hola mundo!\") }; } } Ten en cuenta que es necesario pasar el tipo de controlador de solicitudes deseado y no una instancia del objeto. De esta manera, el controlador de solicitudes será instanciado por el analizador del enrutador. Puedes pasar argumentos en el constructor de la clase con la propiedad ConstructorArguments. Ejemplo: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hola mundo!\") }; } También puedes crear tu propio atributo que implemente RequestHandler: Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } Y usarlo como: Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hola mundo!\") }; } Omisión de un controlador de solicitudes global Después de definir un controlador de solicitudes global en una ruta, puedes ignorar este controlador de solicitudes en rutas específicas. Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"Mi ruta\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: la misma instancia de lo que está en los controladores de solicitudes globales new AuthenticateUserRequestHandler() // incorrecto: no saltará el controlador de solicitudes global } }); Note Si estás omitiendo un controlador de solicitudes, debes usar la misma referencia de lo que instanciaste antes para saltar. Crear otra instancia de controlador de solicitudes no saltará el controlador de solicitudes global, ya que su referencia cambiará. Recuerda usar la misma referencia de controlador de solicitudes utilizada en ambos GlobalRequestHandlers y BypassGlobalRequestHandlers."
  },
  "docs/es/fundamentals/requests.html": {
    "href": "docs/es/fundamentals/requests.html",
    "title": "Solicitudes | Sisk",
    "keywords": "Solicitudes Las solicitudes son estructuras que representan un mensaje de solicitud HTTP. El objeto HttpRequest contiene funciones útiles para manejar mensajes HTTP en toda su aplicación. Una solicitud HTTP se forma por el método, ruta, versión, encabezados y cuerpo. En este documento, le enseñaremos cómo obtener cada uno de estos elementos. Obtener el método de la solicitud Para obtener el método de la solicitud recibida, puede utilizar la propiedad Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Esta propiedad devuelve el método de la solicitud representado por un objeto HttpMethod. Note A diferencia de los métodos de ruta, esta propiedad no sirve el elemento RouteMethod.Any. En su lugar, devuelve el método de solicitud real. Obtener componentes de la URL de la solicitud Puede obtener varios componentes de una URL a través de ciertas propiedades de una solicitud. Para este ejemplo, consideremos la URL: http://localhost:5000/user/login?email=foo@bar.com Nombre del componente Descripción Valor del componente Path Obtiene la ruta de la solicitud. /user/login FullPath Obtiene la ruta de la solicitud y la cadena de consulta. /user/login?email=foo@bar.com FullUrl Obtiene la cadena de solicitud de URL completa. http://localhost:5000/user/login?email=foo@bar.com Host Obtiene el host de la solicitud. localhost Authority Obtiene el host y el puerto de la solicitud. localhost:5000 QueryString Obtiene la consulta de la solicitud. ?email=foo@bar.com Query Obtiene la consulta de la solicitud en una colección de valores con nombre. {StringValueCollection object} IsSecure Determina si la solicitud está utilizando SSL (true) o no (false). false También puede optar por utilizar la propiedad HttpRequest.Uri, que incluye todo lo anterior en un solo objeto. Obtener el cuerpo de la solicitud Algunas solicitudes incluyen un cuerpo, como formularios, archivos o transacciones de API. Puede obtener el cuerpo de una solicitud desde la propiedad: // obtiene el cuerpo de la solicitud como una cadena, utilizando la codificación de la solicitud como codificador string body = request.Body; // o lo obtiene en un arreglo de bytes byte[] bodyBytes = request.RawBody; // o también, puede transmitirlo. Stream requestStream = request.GetRequestStream(); También es posible determinar si hay un cuerpo en la solicitud y si está cargado con las propiedades HasContents, que determina si la solicitud tiene contenido y IsContentAvailable que indica que el servidor HTTP recibió completamente el contenido del punto remoto. No es posible leer el contenido de la solicitud a través de GetRequestStream más de una vez. Si lee con este método, los valores en RawBody y Body no estarán disponibles. No es necesario desechar el flujo de solicitud en el contexto de la solicitud, ya que se desecha al final de la sesión HTTP en la que se crea. También puede utilizar la propiedad HttpRequest.RequestEncoding para obtener la mejor codificación para decodificar la solicitud manualmente. El servidor tiene límites para leer el contenido de la solicitud, que se aplica tanto a HttpRequest.Body como a HttpRequest.RawBody. Estas propiedades copian el flujo de entrada completo en un búfer local del mismo tamaño que HttpRequest.ContentLength. Una respuesta con estado 413 Contenido demasiado grande se devuelve al cliente si el contenido enviado es más grande que HttpServerConfiguration.MaximumContentLength definido en la configuración del usuario. Además, si no hay un límite configurado o si es demasiado grande, el servidor lanzará una OutOfMemoryException cuando el contenido enviado por el cliente exceda Int32.MaxValue (2 GB) y si el contenido se intenta acceder a través de una de las propiedades mencionadas anteriormente. Todavía puede tratar con el contenido a través de transmisión. Note Aunque Sisk lo permite, siempre es una buena idea seguir la semántica HTTP para crear su aplicación y no obtener o servir contenido en métodos que no lo permitan. Lea sobre RFC 9110 \"HTTP Semantics\". Obtener el contexto de la solicitud El contexto HTTP es un objeto exclusivo de Sisk que almacena información del servidor HTTP, ruta, enrutador y controlador de solicitudes. Puede utilizarlo para organizarse en un entorno donde estos objetos son difíciles de organizar. El objeto RequestBag contiene información almacenada que se pasa de un controlador de solicitudes a otro punto y se puede consumir en el destino final. Este objeto también se puede utilizar por controladores de solicitudes que se ejecutan después de la devolución de llamada de la ruta. Tip Esta propiedad también es accesible a través de la propiedad HttpRequest.Bag. Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } El controlador de solicitudes anterior definirá AuthenticatedUser en la bolsa de solicitudes y se puede consumir más adelante en la devolución de llamada final: Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } También puede utilizar los métodos auxiliares Bag.Set() y Bag.Get() para obtener o establecer objetos por sus singleton de tipo. Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } Obtener datos de formulario Puede obtener los valores de los datos de formulario en una NameValueCollection con el ejemplo siguiente: Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } Obtener datos de formulario multipart La solicitud HTTP de Sisk le permite obtener contenidos multipart, como archivos, campos de formulario o contenido binario. Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // el siguiente método lee la entrada de solicitud completa en un // arreglo de objetos Multipart var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // El nombre del archivo proporcionado por los datos de formulario multipart. // Se devuelve null si el objeto no es un archivo. Console.WriteLine(\"Nombre del archivo : \" + uploadedObject.Filename); // El nombre del campo de los datos de formulario multipart. Console.WriteLine(\"Nombre del campo : \" + uploadedObject.Name); // La longitud del contenido de los datos de formulario multipart. Console.WriteLine(\"Longitud del contenido : \" + uploadedObject.ContentLength); // Determina el formato de archivo común en función del encabezado del archivo para cada // tipo de contenido conocido. Si el contenido no es un formato de archivo común reconocido, // el método a continuación devolverá MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Formato común : \" + uploadedObject.GetCommonFileFormat()); } } Puede leer más sobre los objetos Multipart form de Sisk y sus métodos, propiedades y funcionalidades. Soporte para eventos enviados por el servidor Sisk admite eventos enviados por el servidor, que permite enviar fragmentos como un flujo y mantener la conexión entre el servidor y el cliente viva. Llamando al método HttpRequest.GetEventSource se pondrá la solicitud HTTP en su estado de escucha. A partir de esto, el contexto de esta solicitud HTTP no esperará una respuesta HttpResponse, ya que se superpondrá a los paquetes enviados por eventos del servidor. Después de enviar todos los paquetes, la devolución de llamada debe devolver el método Close, que enviará la respuesta final al servidor e indicará que la transmisión ha terminado. No es posible predecir la longitud total de todos los paquetes que se enviarán, por lo que no es posible determinar el final de la conexión con el encabezado Content-Length. La mayoría de los navegadores no admiten la transmisión de encabezados HTTP o métodos diferentes al GET. Por lo tanto, tenga cuidado al utilizar controladores de solicitudes con solicitudes de evento de origen que requieren encabezados específicos en la solicitud, ya que es probable que no los tengan. Además, la mayoría de los navegadores reinician las transmisiones si el método EventSource.close no se llama en el lado del cliente después de recibir todos los paquetes, lo que causa un procesamiento adicional infinito en el lado del servidor. Para evitar este tipo de problema, es común enviar un paquete final que indique que el evento de origen ha terminado de enviar todos los paquetes. El ejemplo siguiente muestra cómo el navegador puede comunicarse con el servidor que admite eventos enviados por el servidor. sse-example.html HTML <html> <body> <b>Frutas:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `mensaje: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomate\") { evtSource.close(); } } </script> </html> Y envíe los mensajes al cliente de forma progresiva: Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] frutas = new[] { \"Manzana\", \"Plátano\", \"Sandía\", \"Tomate\" }; foreach (string fruta in frutas) { await serverEvents.SendAsync(fruta); await Task.Delay(1500); } return serverEvents.Close(); } } Al ejecutar este código, esperamos un resultado similar a este: Resolución de direcciones IP y hosts proxy Sisk se puede utilizar con proxies, y por lo tanto, las direcciones IP pueden reemplazarse por el punto final del proxy en la transacción desde un cliente hasta el proxy. Puede definir sus propios resolutores en Sisk con resolutores de reenvío. Codificación de encabezados La codificación de encabezados puede ser un problema para algunas implementaciones. En Windows, los encabezados UTF-8 no son compatibles, por lo que se utiliza ASCII. Sisk tiene un convertidor de codificación incorporado, que puede ser útil para decodificar encabezados codificados incorrectamente. Esta operación es costosa y está deshabilitada de forma predeterminada, pero se puede habilitar bajo la bandera NormalizeHeadersEncodings."
  },
  "docs/es/fundamentals/responses.html": {
    "href": "docs/es/fundamentals/responses.html",
    "title": "Respuestas | Sisk",
    "keywords": "Respuestas Las respuestas representan objetos que son respuestas HTTP a solicitudes HTTP. Son enviadas por el servidor al cliente como una indicación de la solicitud de un recurso, página, documento, archivo u otro objeto. Una respuesta HTTP se compone de estado, encabezados y contenido. En este documento, te enseñaremos a arquitecturar respuestas HTTP con Sisk. Establecer un estado HTTP La lista de estados HTTP es la misma desde HTTP/1.0, y Sisk los admite todos. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 O con sintaxis fluida: new HttpResponse() .WithStatus(200) // o .WithStatus(HttpStatusCode.Ok) // o .WithStatus(HttpStatusInformation.Ok); Puedes ver la lista completa de HttpStatusCode disponibles aquí. También puedes proporcionar tu propio código de estado utilizando la estructura HttpStatusInformation. Cuerpo y tipo de contenido Sisk admite objetos de contenido .NET nativos para enviar el cuerpo en las respuestas. Puedes utilizar la clase StringContent para enviar una respuesta JSON, por ejemplo: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); El servidor siempre intentará calcular el Content-Length a partir de lo que has definido en el contenido si no lo has definido explícitamente en un encabezado. Si el servidor no puede obtener implícitamente el encabezado Content-Length del contenido de la respuesta, la respuesta se enviará con Chunked-Encoding. También puedes transmitir la respuesta enviando un StreamContent o utilizando el método GetResponseStream. Encabezados de respuesta Puedes agregar, editar o eliminar encabezados que estás enviando en la respuesta. El ejemplo siguiente muestra cómo enviar una respuesta de redirección al cliente. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); O con sintaxis fluida: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Cuando utilices el método Add de HttpHeaderCollection, estás agregando un encabezado a la solicitud sin alterar los que ya se han enviado. El método Set reemplaza los encabezados con el mismo nombre con el valor indicado. El indexador de HttpHeaderCollection llama internamente al método Set para reemplazar los encabezados. Enviar cookies Sisk tiene métodos que facilitan la definición de cookies en el cliente. Las cookies establecidas por este método ya están codificadas en URL y se ajustan al estándar RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); O con sintaxis fluida: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Hay otras versiones más completas del mismo método. Respuestas fragmentadas Puedes establecer la codificación de transferencia en fragmentada para enviar respuestas grandes. HttpResponse res = new HttpResponse(); res.SendChunked = true; Cuando utilices codificación fragmentada, el encabezado Content-Length se omite automáticamente. Flujo de respuesta Los flujos de respuesta son una forma administrada que te permiten enviar respuestas de manera segmentada. Es una operación de nivel inferior que utilizar objetos HttpResponse, ya que requieren que envíes los encabezados y el contenido manualmente, y luego cierres la conexión. Este ejemplo abre un flujo de lectura solo para el archivo, copia el flujo en el flujo de salida de la respuesta y no carga todo el archivo en la memoria. Esto puede ser útil para servir archivos medianos o grandes. // obtiene el flujo de salida de la respuesta using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // establece la codificación de la respuesta para utilizar codificación fragmentada // también no deberías enviar el encabezado content-length cuando utilices // codificación fragmentada responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copia el flujo del archivo en el flujo de salida de la respuesta fileStream.CopyTo(responseStream.ResponseStream); // cierra el flujo return responseStream.Close(); Compresión GZip, Deflate y Brotli Puedes enviar respuestas con contenido comprimido en Sisk con contenidos HTTP comprimidos. Primero, encapsula tu objeto HttpContent dentro de uno de los compresores siguientes para enviar la respuesta comprimida al cliente. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // o Content = new BrotliContent(new HtmlContent(myHtml)), // o Content = new DeflateContent(new HtmlContent(myHtml)), }; }); También puedes utilizar estos contenidos comprimidos con flujos. router.MapGet(\"/archive.zip\", request => { // no apliques \"using\" aquí. el HttpServer descartará tu contenido // después de enviar la respuesta. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Los encabezados Content-Encoding se establecen automáticamente cuando se utilizan estos contenidos. Compresión automática Es posible comprimir automáticamente las respuestas HTTP con la propiedad EnableAutomaticResponseCompression. Esta propiedad encapsula automáticamente el contenido de la respuesta del enrutador en un contenido compressible que es aceptado por la solicitud, siempre y cuando la respuesta no sea heredada de un CompressedContent. Solo se elige un contenido compressible para una solicitud, elegido según el encabezado Accept-Encoding, que sigue el orden: BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) Si la solicitud especifica que acepta cualquiera de estos métodos de compresión, la respuesta se comprimirá automáticamente. Tipos de respuesta implícitos Puedes utilizar otros tipos de retorno además de HttpResponse, pero es necesario configurar el enrutador para que sepa cómo manejará cada tipo de objeto. El concepto es siempre devolver un tipo de referencia y convertirlo en un objeto HttpResponse válido. Las rutas que devuelven HttpResponse no se someten a conversión. Los tipos de valor (estructuras) no se pueden utilizar como tipo de retorno porque no son compatibles con el RouterCallback, por lo que deben estar envueltos en un ValueResult para poder ser utilizados en controladores. Considera el siguiente ejemplo de un módulo de enrutador que no utiliza HttpResponse en el tipo de retorno: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } Con esto, ahora es necesario definir en el enrutador cómo manejará cada tipo de objeto. Los objetos siempre son el primer argumento del controlador y el tipo de salida debe ser un HttpResponse válido. Además, los objetos de salida de una ruta nunca deben ser nulos. Para tipos ValueResult no es necesario indicar que el objeto de entrada es un ValueResult y solo T, ya que ValueResult es un objeto reflejado de su componente original. La asociación de tipos no compara lo que se registró con el tipo del objeto devuelto del controlador de enrutador. En su lugar, verifica si el tipo del resultado del enrutador es asignable al tipo registrado. Registrar un controlador de tipo Object actuará como una reserva para todos los tipos no validados previamente. El orden de inserción de los controladores de valor también importa, por lo que registrar un controlador de Object ignorará todos los controladores específicos de tipo. Siempre registre controladores de valor específicos primero para asegurarse del orden. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // registrar un controlador de valor de objeto debe ser el último // controlador de valor que se utilizará como una reserva r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); Nota sobre objetos enumerables y matrices Los objetos de respuesta implícitos que implementan IEnumerable se leen en la memoria a través del método ToArray() antes de ser convertidos a través de un controlador de valor definido. Para que esto ocurra, el objeto IEnumerable se convierte en una matriz de objetos, y el convertidor de respuesta siempre recibirá un Object[] en lugar del tipo original. Considera el siguiente escenario: using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"Matriz de cadenas:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Matriz de objetos:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hola\", \"mundo\"]; }); }) .Build(); En el ejemplo anterior, el convertidor IEnumerable<string> nunca se llamará, porque el objeto de entrada siempre será un Object[] y no es convertible a un IEnumerable<string>. Sin embargo, el convertidor siguiente que recibe un IEnumerable<object> recibirá su entrada, ya que su valor es compatible. Si necesitas manejar realmente el tipo de objeto que se enumerará, necesitarás utilizar reflexión para obtener el tipo del elemento de la colección. Todos los objetos enumerables (listas, matrices y colecciones) se convierten en una matriz de objetos por el convertidor de respuesta HTTP. Los valores que implementan IAsyncEnumerable se manejan automáticamente por el servidor si la propiedad ConvertIAsyncEnumerableIntoEnumerable está habilitada, de manera similar a lo que sucede con IEnumerable. Una enumeración asincrónica se convierte en un enumerador bloqueante y luego se convierte en una matriz de objetos sincrónica."
  },
  "docs/es/fundamentals/routing.html": {
    "href": "docs/es/fundamentals/routing.html",
    "title": "Enrutamiento | Sisk",
    "keywords": "Enrutamiento El Router es el primer paso en la construcción del servidor. Es responsable de contener objetos Route, que son puntos de conexión que asignan URLs y sus métodos a acciones ejecutadas por el servidor. Cada acción es responsable de recibir una solicitud y entregar una respuesta al cliente. Las rutas son pares de expresiones de ruta (\"patrón de ruta\") y el método HTTP que pueden escuchar. Cuando se realiza una solicitud al servidor, intentará encontrar una ruta que coincida con la solicitud recibida, luego llamará a la acción de esa ruta y entregará la respuesta resultante al cliente. Hay varias formas de definir rutas en Sisk: pueden ser estáticas, dinámicas o auto-escaneadas, definidas por atributos o directamente en el objeto Router. Router mainRouter = new Router(); // asigna la ruta GET / a la siguiente acción mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hola, mundo!\"); }); Para entender qué es capaz de hacer una ruta, necesitamos entender qué es capaz de hacer una solicitud. Un HttpRequest contendrá todo lo que necesite. Sisk también incluye algunas características adicionales que aceleran el desarrollo en general. Para cada acción recibida por el servidor, se llamará a un delegado de tipo RouteAction. Este delegado contiene un parámetro que contiene un HttpRequest con toda la información necesaria sobre la solicitud recibida por el servidor. El objeto resultante de este delegado debe ser un HttpResponse o un objeto que se asigna a él a través de tipos de respuesta implícitos. Coincidencia de rutas Cuando se recibe una solicitud por el servidor HTTP, Sisk busca una ruta que satisfaga la expresión de la ruta recibida por la solicitud. La expresión siempre se prueba entre la ruta y la ruta de la solicitud, sin considerar la cadena de consulta. Esta prueba no tiene prioridad y es exclusiva de una sola ruta. Cuando no se encuentra una ruta que coincida con la solicitud, se devuelve la respuesta Router.NotFoundErrorHandler al cliente. Cuando se coincide con el patrón de ruta, pero el método HTTP no coincide, se envía la respuesta Router.MethodNotAllowedErrorHandler al cliente. Sisk verifica la posibilidad de colisiones de rutas para evitar estos problemas. Cuando se definen rutas, Sisk buscará rutas posibles que puedan colisionar con la ruta que se está definiendo. Esta prueba incluye la comprobación de la ruta y el método que la ruta está configurada para aceptar. Creación de rutas usando patrones de ruta Puedes definir rutas usando varios métodos SetRoute. // forma SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hola, {name}\"); }); // forma Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 200 ok vacío }); // métodos de ayuda Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // el StreamContent interno // se desecha después de enviar // la respuesta. Content = new StreamContent(imageStream) }; }); // varios parámetros mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hola, {name} {surname}!\"); }); La propiedad RouteParameters de HttpResponse contiene toda la información sobre las variables de ruta de la solicitud recibida. Cada ruta recibida por el servidor se normaliza antes de que se ejecute la prueba del patrón de ruta, siguiendo estas reglas: Todos los segmentos vacíos se eliminan de la ruta, por ejemplo: ////foo//bar se convierte en /foo/bar. La coincidencia de ruta es sensible a mayúsculas y minúsculas, a menos que Router.MatchRoutesIgnoreCase esté establecido en true. Las propiedades Query y RouteParameters de HttpRequest devuelven un objeto StringValueCollection, donde cada propiedad indexada devuelve un StringValue no nulo, que se puede usar como una opción/monada para convertir su valor raw en un objeto administrado. El ejemplo siguiente lee el parámetro de ruta \"id\" y obtiene un Guid de él. Si el parámetro no es un Guid válido, se lanza una excepción y se devuelve un error 500 al cliente si el servidor no está manejando Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); [!NOTA] Las rutas ignoran el / final en ambas rutas de solicitud y ruta, es decir, si intentas acceder a una ruta definida como /index/page podrás acceder usando /index/page/ también. También puedes forzar a las URLs a terminar con / habilitando la bandera ForceTrailingSlash. Creación de rutas usando instancias de clase También puedes definir rutas dinámicamente usando reflexión con el atributo RouteAttribute. De esta manera, la instancia de una clase en la que sus métodos implementan este atributo tendrá sus rutas definidas en el router de destino. Para que un método se defina como una ruta, debe estar marcado con un RouteAttribute, como el atributo en sí o un RouteGetAttribute. El método puede ser estático, de instancia, público o privado. Cuando se usa el método SetObject(type) o SetObject<TType>(), se ignoran los métodos de instancia. Controller/MyController.cs C# public class MyController { // coincide con GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // los métodos estáticos también funcionan [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hola mundo!\"); return res; } } La línea siguiente definirá tanto el método Index como el método Hello de MyController como rutas, ya que ambos están marcados como rutas y se ha proporcionado una instancia de la clase, no su tipo. Si se hubiera proporcionado su tipo en lugar de una instancia, solo se habrían definido los métodos estáticos. var myController = new MyController(); mainRouter.SetObject(myController); Desde la versión 0.16 de Sisk, es posible habilitar AutoScan, que buscará clases definidas por el usuario que implementen RouterModule y las asociará automáticamente con el router. Esto no es compatible con la compilación AOT. mainRouter.AutoScanModules<ApiController>(); La instrucción anterior buscará todos los tipos que implementan ApiController, pero no el tipo en sí. Los dos parámetros opcionales indican cómo se buscarán estos tipos. El primer argumento implica el ensamblado donde se buscarán los tipos y el segundo indica la forma en que se definirán los tipos. Rutas de regex En lugar de usar los métodos de coincidencia de ruta HTTP predeterminados, puedes marcar una ruta para que se interprete con Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"Mi ruta\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); O con la clase RegexRoute: mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hola, mundo\"); })); También puedes capturar grupos de la expresión regular en el contenido de HttpRequest.RouteParameters: Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Accediendo al archivo {filename}\"); } } Prefijo de rutas Puedes prefijar todas las rutas en una clase o módulo con el atributo RoutePrefix y establecer el prefijo como una cadena. Vea el ejemplo siguiente usando la arquitectura BREAD (Buscar, Leer, Editar, Agregar y Eliminar): Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } En el ejemplo anterior, el parámetro HttpResponse se omite a favor de ser utilizado a través del contexto global HttpContext.Current. Lea más en la sección que sigue. Rutas sin parámetro de solicitud Las rutas se pueden definir sin el parámetro HttpRequest y aún es posible obtener la solicitud y sus componentes en el contexto de la solicitud. Consideremos una abstracción ControllerBase que sirve como base para todos los controladores de una API y que proporciona la propiedad Request para obtener la HttpRequest actualmente. Controller/ControllerBase.cs C# public abstract class ControllerBase { // obtiene la solicitud del subproceso actual public HttpRequest Request { get => HttpContext.Current.Request; } // la línea siguiente, cuando se llama, obtiene la base de datos del subproceso HTTP actual, // o crea una nueva si no existe public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } Y para que todos sus descendientes puedan usar la sintaxis de ruta sin el parámetro de solicitud: Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // lee los datos JSON de la solicitud actual UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } Más detalles sobre el contexto actual y la inyección de dependencias se pueden encontrar en el tutorial de inyección de dependencias. Rutas de cualquier método Puedes definir una ruta para que coincida solo con su ruta y omitir el método HTTP. Esto puede ser útil para que valides el método dentro de la acción de la ruta. // coincide con / en cualquier método HTTP mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Rutas de cualquier ruta Las rutas de cualquier ruta prueban cualquier ruta recibida por el servidor HTTP, sujeta al método de ruta que se está probando. Si el método de ruta es RouteMethod.Any y la ruta usa Route.AnyPath en su expresión de ruta, esta ruta escuchará todas las solicitudes del servidor HTTP, y no se pueden definir otras rutas. // la siguiente ruta coincide con todas las solicitudes POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Coincidencia de ruta sin distinguir mayúsculas y minúsculas Por defecto, la interpretación de rutas con solicitudes es sensible a mayúsculas y minúsculas. Para hacer que ignore mayúsculas y minúsculas, habilita esta opción: mainRouter.MatchRoutesIgnoreCase = true; Esto también habilitará la opción RegexOptions.IgnoreCase para rutas que usan coincidencia de regex. Controlador de errores de no encontrado (404) Puedes crear un controlador de errores personalizado para cuando una solicitud no coincide con ninguna ruta conocida. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Desde la versión v0.14 Content = new HtmlContent(\"<h1>No encontrado</h1>\") // versiones anteriores Content = new StringContent(\"<h1>No encontrado</h1>\", Encoding.UTF8, \"text/html\") }; }; Controlador de errores de método no permitido (405) También puedes crear un controlador de errores personalizado para cuando una solicitud coincide con su ruta, pero no coincide con el método. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Método no permitido para esta ruta.\") }; }; Controlador de errores internos Las acciones de ruta pueden lanzar errores durante la ejecución del servidor. Si no se manejan correctamente, el funcionamiento general del servidor HTTP puede interrumpirse. El router tiene un controlador de errores para cuando una acción de ruta falla y evita la interrupción del servicio. Este método solo es accesible cuando ThrowExceptions está establecido en false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/es/getting-started.html": {
    "href": "docs/es/getting-started.html",
    "title": "Introducción | Sisk",
    "keywords": "Introducción Bienvenido a la documentación de Sisk. Finalmente, ¿qué es el Marco de Sisk? Es una biblioteca de código abierto y ligera construida con .NET, diseñada para ser minimalista, flexible y abstracta. Permite a los desarrolladores crear servicios de Internet rápidamente, con poca o ninguna configuración necesaria. Sisk permite que su aplicación existente tenga un módulo HTTP administrado, completo y desechable o completo. Los valores de Sisk incluyen la transparencia del código, la modularidad, el rendimiento y la escalabilidad, y pueden manejar varios tipos de aplicaciones, como Restful, JSON-RPC, Web-sockets y más. Sus características principales incluyen: Recurso Descripción Enrutamiento Un enrutador de rutas que admite prefijos, métodos personalizados, variables de ruta, convertidores de valores y más. Controladores de solicitudes También conocidos como middlewares, proporcionan una interfaz para crear sus propios controladores de solicitudes que funcionan con la solicitud antes o después de una acción. Compresión Comprima el contenido de sus respuestas fácilmente con Sisk. Web sockets Proporciona rutas que aceptan web sockets completos, para leer y escribir en el cliente. Eventos enviados por el servidor Proporciona el envío de eventos del servidor a los clientes que admiten el protocolo SSE. Registro Registro simplificado. Registre errores, acceso, defina registros rotativos por tamaño, varias secuencias de salida para el mismo registro y más. Multi-host Tener un servidor HTTP para varios puertos, y cada puerto con su propio enrutador, y cada enrutador con su propia aplicación. Controladores de servidor Amplíe su propia implementación del servidor HTTP. Personalice con extensiones, mejoras y nuevas características. Primeros pasos Sisk puede ejecutarse en cualquier entorno .NET. En esta guía, le enseñaremos cómo crear una aplicación Sisk utilizando .NET. Si aún no lo ha instalado, descargue el SDK desde aquí. En este tutorial, cubriremos cómo crear una estructura de proyecto, recibir una solicitud, obtener un parámetro de URL y enviar una respuesta. Esta guía se centrará en la creación de un servidor simple utilizando C#. También puede utilizar su lenguaje de programación favorito. Note Es posible que esté interesado en un proyecto de inicio rápido. Consulte este repositorio para obtener más información. Creación de un proyecto Llamemos a nuestro proyecto \"Mi aplicación Sisk\". Una vez que tenga configurado .NET, puede crear su proyecto con el siguiente comando: dotnet new console -n my-sisk-application A continuación, navegue hasta el directorio de su proyecto e instale Sisk utilizando la herramienta de utilidad .NET: cd my-sisk-application dotnet add package Sisk.HttpServer Puede encontrar formas adicionales de instalar Sisk en su proyecto aquí. Ahora, creemos una instancia de nuestro servidor HTTP. En este ejemplo, lo configuraremos para escuchar en el puerto 5000. Construcción del servidor HTTP Sisk le permite construir su aplicación paso a paso manualmente, ya que enruta al objeto HttpServer. Sin embargo, esto puede no ser muy conveniente para la mayoría de los proyectos. Por lo tanto, podemos utilizar el método del constructor, que facilita la ejecución de nuestra aplicación. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hola, mundo!\") }; }); await app.StartAsync(); } } Es importante comprender cada componente vital de Sisk. Más adelante en este documento, aprenderá más sobre cómo funciona Sisk. Configuración manual (avanzada) Puede aprender cómo funciona cada mecanismo de Sisk en esta sección de la documentación, que explica el comportamiento y las relaciones entre el HttpServer, Router, ListeningPort y otros componentes."
  },
  "docs/es/installing.html": {
    "href": "docs/es/installing.html",
    "title": "Instalación | Sisk",
    "keywords": "Instalación Puedes instalar Sisk a través de Nuget, dotnet cli o otras opciones. Puedes configurar fácilmente tu entorno de Sisk ejecutando este comando en tu consola de desarrollador: dotnet add package Sisk.HttpServer Este comando instalará la última versión de Sisk en tu proyecto."
  },
  "docs/es/native-aot.html": {
    "href": "docs/es/native-aot.html",
    "title": "Soporte de AOT Nativo | Sisk",
    "keywords": "Soporte de AOT Nativo .NET Native AOT permite la publicación de aplicaciones .NET nativas que son autosuficientes y no requieren que el tiempo de ejecución de .NET esté instalado en el host de destino. Además, Native AOT proporciona beneficios como: Aplicaciones mucho más pequeñas Inicialización significativamente más rápida Consumo de memoria más bajo Sisk Framework, por su naturaleza explícita, permite el uso de Native AOT para casi todas sus características sin requerir rework en el código fuente para adaptarlo a Native AOT. Características no soportadas Sin embargo, Sisk utiliza la reflexión, aunque mínima, para algunas características. Las características mencionadas a continuación pueden estar parcialmente disponibles o completamente no disponibles durante la ejecución de código nativo: Exploración automática de módulos del enrutador: este recurso escanea los tipos incrustados en el ensamblado en ejecución y registra los tipos que son módulos del enrutador. Este recurso requiere tipos que pueden ser excluidos durante el recorte del ensamblado. Todas las demás características son compatibles con AOT en Sisk. Es común encontrar uno o otro método que da una advertencia de AOT, pero el mismo, si no se menciona aquí, tiene una sobrecarga que indica el paso de un tipo, parámetro o información de tipo que ayuda al compilador de AOT a compilar el objeto."
  },
  "docs/es/registering-namespace.html": {
    "href": "docs/es/registering-namespace.html",
    "title": "Configuración de reservas de namespace en Windows | Sisk",
    "keywords": "Configuración de reservas de namespace en Windows Sisk funciona con la interfaz de red HttpListener, que enlaza un host virtual al sistema para escuchar solicitudes. En Windows, esta unión es un poco restrictiva, solo permitiendo que localhost se enlace como un host válido. Al intentar escuchar a otro host, se lanza un error de acceso denegado en el servidor. Este tutorial explica cómo conceder autorización para escuchar en cualquier host que desee en el sistema. Configuración de namespace.bat BATCH @echo off :: insertar prefijo aquí, sin espacios ni comillas SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Donde en PREFIX, es el prefijo (\"Host de escucha->Puerto\") que su servidor escuchará. Debe estar formateado con el esquema de URL, host, puerto y una barra al final, ejemplo: Configuración de namespace.bat BATCH SET PREFIX=http://mi-aplicación.example.test/ Para que pueda ser escuchado en su aplicación a través de: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://mi-aplicación.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hola, mundo!\") }; }); await app.StartAsync(); } }"
  },
  "docs/es/ssl.html": {
    "href": "docs/es/ssl.html",
    "title": "Trabajando con SSL | Sisk",
    "keywords": "Trabajando con SSL Trabajar con SSL para desarrollo puede ser necesario cuando se trabaja en contextos que requieren seguridad, como la mayoría de los escenarios de desarrollo web. Sisk opera sobre HttpListener, que no admite HTTPS de forma nativa, solo HTTP. Sin embargo, existen soluciones alternativas que te permiten trabajar con SSL en Sisk. Consulta a continuación: A través de IIS en Windows Disponible en: Windows Esfuerzo: medio Si estás en Windows, puedes utilizar IIS para habilitar SSL en tu servidor HTTP. Para que esto funcione, es recomendable que sigas este tutorial con anticipación si deseas que tu aplicación esté escuchando en un host diferente a \"localhost\". Para que esto funcione, debes instalar IIS a través de las características de Windows. IIS está disponible de forma gratuita para usuarios de Windows y Windows Server. Para configurar SSL en tu aplicación, debes tener el certificado SSL listo, incluso si es auto-firmado. A continuación, puedes ver cómo configurar SSL en IIS 7 o superior. A través de mitmproxy Disponible en: Linux, macOS, Windows Esfuerzo: fácil mitmproxy es una herramienta de proxy de interceptación que permite a los desarrolladores y testers de seguridad inspeccionar, modificar y grabar el tráfico HTTP y HTTPS entre un cliente (como un navegador web) y un servidor. Puedes utilizar la utilidad mitmdump para iniciar un proxy SSL inverso entre tu cliente y tu aplicación Sisk. Primero, instala mitmproxy en tu máquina. Inicia tu aplicación Sisk. En este ejemplo, utilizaremos el puerto 8000 como el puerto HTTP inseguro. Inicia el servidor mitmproxy para escuchar el puerto seguro en 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 Y listo! Ya puedes acceder a tu aplicación a través de https://localhost:8001/. Tu aplicación no necesita estar en ejecución para iniciar mitmdump. Alternativamente, puedes agregar una referencia a la herramienta de ayuda de mitmproxy en tu proyecto. Esto aún requiere que mitmproxy esté instalado en tu computadora. A través del paquete Sisk.SslProxy Disponible en: Linux, macOS, Windows Esfuerzo: fácil El paquete Sisk.SslProxy es una forma sencilla de habilitar SSL en tu aplicación Sisk. Sin embargo, es un paquete extremadamente experimental. Puede ser inestable trabajar con este paquete, pero puedes ser parte del pequeño porcentaje de personas que contribuirán a hacer que este paquete sea viable y estable. Para empezar, puedes instalar el paquete Sisk.SslProxy con: dotnet add package Sisk.SslProxy Note Debes habilitar \"Habilitar paquetes de pre-lanzamiento\" en el Administrador de paquetes de Visual Studio para instalar Sisk.SslProxy. Nuevamente, es un proyecto experimental, así que no pienses en ponerlo en producción. En este momento, Sisk.SslProxy puede manejar la mayoría de las características de HTTP/1.1, incluyendo HTTP Continue, Chunked-Encoding, WebSockets y SSE. Lee más sobre SslProxy aquí."
  },
  "docs/extensions/basic-auth.html": {
    "href": "docs/extensions/basic-auth.html",
    "title": "Basic Auth | Sisk",
    "keywords": "Basic Auth The Basic Auth package adds a request handler capable of handling basic authentication scheme in your Sisk application with very little configuration and effort. Basic HTTP authentication is a minimal input form of authenticating requests by an user id and password, where the session is controlled exclusively by the client and there are no authentication or access tokens. Read more about the Basic authentication scheme in the MDN specification. Installing To get started, install the Sisk.BasicAuth package in your project: > dotnet add package Sisk.BasicAuth You can view more ways to install it in your project in the Nuget repository. Creating your auth handler You can control the authentication scheme for an entire module or for individual routes. For that, let's first write our first basic authentication handler. In the example below, a connection is made to the database, it checks if the user exists and if the password is valid, and after that, stores the user in the context bag. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"To enter this page, please, inform your credentials.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // in this case, we're using the email as the user id field, so we're // going to search for an user using their email. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Sorry! No user was found by this email.\"); } // validates that the credentials password is valid for this user. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Invalid credentials.\"); } // adds the logged user to the http context // and continues the execution context.Bag.Add(\"loggedUser\", user); return null; } } So, just associate this request handler with our route or class. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hello, \" + loggedUser.Name + \"!\"; } } Or using RouterModule class: public class UsersController : RouterModule { public ClientModule() { // now all routes inside this class will be handled by // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hello, \" + loggedUser.Name + \"!\"; } } Remarks The primary responsibility of basic authentication is carried out on the client-side. Storage, cache control, and encryption are all handled locally on the client. The server only receives the credentials and validates whether access is allowed or not. Note that this method is not one of the most secure because it places a significant responsibility on the client, which can be difficult to trace and maintain the security of its credentials. Additionally, it is crucial for passwords to be transmitted in a secure connection context (SSL), as they do not have any inherent encryption. A brief interception in the headers of a request can expose the access credentials of your user. Opt for more robust authentication solutions for applications in production and avoid using too many off-the-shelf components, as they may not adapt to the needs of your project and end up exposing it to security risks."
  },
  "docs/extensions/ini-configuration.html": {
    "href": "docs/extensions/ini-configuration.html",
    "title": "INI configuration provider | Sisk",
    "keywords": "INI configuration provider Sisk has a method for obtaining startup configurations other than JSON. In fact, any pipeline that implements IConfigurationReader can be used with PortableConfigurationBuilder.WithConfigurationPipeline, reading the server configuration from any file type. The Sisk.IniConfiguration package provides a stream-based INI file reader that does not throw exceptions for common syntax errors and has a simple configuration syntax. This package can be used outside the Sisk framework, offering flexibility for projects that require an efficient INI document reader. Installing To install the package, you can start with: $ dotnet add package Sisk.IniConfiguration You can also install the core package, which doens't includes the INI IConfigurationReader, neither the Sisk dependency, just the INI serializers: $ dotnet add package Sisk.IniConfiguration.Core With the main package, you can use it in your code as shown in the example below: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // uses the IniConfigurationReader configuration reader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } The code above will look for an app.ini file in the process's current directory (CurrentDirectory). The INI file looks like this: [Server] # Multiple listen addresses are supported Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI flavor and syntax Current implementation flavor: Properties and section names are case-insensitive. Properties names and values are trimmed, unless values are quoted. Values can be quoted with single or double quotes. Quotes can have line-breaks inside them. Comments are supported with # and ;. Also, trailing comments are allowed. Properties can have multiple values. In detail, the documentation for the \"flavor\" of the INI parser used in Sisk is available in this document. Using the following ini code as example: One = 1 Value = this is an value Another value = \"this value has an line break on it\" ; the code below has some colors [some section] Color = Red Color = Blue Color = Yellow ; do not use yellow Parse it with: // parse the ini text from the string IniDocument doc = IniDocument.FromString(iniText); // get one value string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // get multiple values string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Configuration parameters Section and name Allow multiple values Description Server.Listen Yes The server listening addresses/ports. Server.Encoding No The server default encoding. Server.MaximumContentLength No The server max content-length size in bytes. Server.IncludeRequestIdHeader No Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions No Specifies if unhandled exceptions should be thrown. Server.AccessLogsStream No Specifies the access log output stream. Server.ErrorsLogsStream No Specifies the error log output stream. Cors.AllowMethods No Specifies the CORS Allow-Methods header value. Cors.AllowHeaders No Specifies the CORS Allow-Headers header value. Cors.AllowOrigins No Specifies multiples Allow-Origin headers, separated by commas. AllowOrigins for more information. Cors.AllowOrigin No Specifies one Allow-Origin header. Cors.ExposeHeaders No Specifies the CORS Expose-Headers header value. Cors.AllowCredentials No Specifies the CORS Allow-Credentials header value. Cors.MaxAge No Specifies the CORS Max-Age header value."
  },
  "docs/extensions/json-rpc.html": {
    "href": "docs/extensions/json-rpc.html",
    "title": "JSON-RPC Extension | Sisk",
    "keywords": "JSON-RPC Extension Sisk has an experimental module for a JSON-RPC 2.0 API, which allows you to create even simpler applications. This extension strictly implements the JSON-RPC 2.0 transport interface and offers transport via HTTP GET, POST requests, and also web-sockets with Sisk. You can install the extension via Nuget with the command below. Note that, in experimental/beta versions, you should enable the option to search for pre-release packages in Visual Studio. dotnet add package Sisk.JsonRpc Transport Interface JSON-RPC is a stateless, asynchronous remote procedure execution (RDP) protocol that uses JSON for unilateral data communication. A JSON-RPC request is typically identified by an ID, and a response is delivered by the same ID that was sent in the request. Not all requests require a response, which are called \"notifications\". The JSON-RPC 2.0 specification explains in detail how the transport works. This transport is agnostic of where it will be used. Sisk implements this protocol through HTTP, following the conformities of JSON-RPC over HTTP, which partially supports GET requests, but completely supports POST requests. Web-sockets are also supported, providing asynchronous message communication. A JSON-RPC request looks similar to: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } And a successful response looks similar to: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC Methods The following example shows how to create a JSON-RPC API using Sisk. A mathematical operations class performs the remote operations and delivers the serialized response to the client. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // add all methods tagged with WebMethod to the JSON-RPC handler args.Handler.Methods.AddMethodsFromType(new MathOperations()); // maps the /service route to handle JSON-RPC POST and GET requests args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // creates an websocket handler on GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } The above example will map the Sum and Sqrt methods to the JSON-RPC handler, and these methods will be available at GET /service, POST /service and GET /ws. Method names are case-insensitive. Method parameters are automatically deserialized to their specific types. Using a request with named parameters is also supported. JSON serialization is done by the LightJson library. When a type is not correctly deserialized, you can create a specific JSON converter for that type and associate it with your JsonSerializerOptions later. You can also get the $.params raw object from the JSON-RPC request directly in your method. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } For this to occur, @params must be the only parameter in your method, with exactly the name params (in C#, the @ is necessary to escape this parameter name). Parameter deserialization occurs for both named objects or positional arrays. For example, the following method can be called remotely by both requests: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } For an array, the order of the parameters must be followed. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Customizing the serializer You can customize the JSON serializer in the JsonRpcHandler.JsonSerializerOptions property. In this property, you can enable the use of JSON5 for deserializing messages. Although not a conformity with JSON-RPC 2.0, JSON5 is an extension of JSON that allows for more human-readable and legible writing. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // uses a sanitized name comparer. this comparer compares only letters // and digits in a name, and discards other symbols. ex: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // enables JSON5 for the JSON interpreter. even activating this, plain JSON is still allowed e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // maps the POST /service route to the JSON RPC handler e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/extensions/service-providers.html": {
    "href": "docs/extensions/service-providers.html",
    "title": "Service Providers | Sisk",
    "keywords": "Service Providers Service Providers is a way to port your Sisk application to different environments with a portable configuration file. This feature allows you to change the server's port, parameters, and other options without having to modify the application code for each environment. This module depends on the Sisk construction syntax and can be configured through the UsePortableConfiguration method. A configuration provider is implemented with IConfigurationProvider, which provides a configuration reader and can receive any implementation. By default, Sisk provides a JSON configuration reader, but there is also a package for INI files. You can also create your own configuration provider and register it with: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); As mentioned earlier, the default provider is a JSON file. By default, the file name searched for is service-config.json, and it is searched in the current directory of the running process, not the executable directory. You can choose to change the file name, as well as where Sisk should look for the configuration file, with: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); The code above will look for the config.toml file in the current directory of the running process. If not found, it will then search in the directory where the executable is located. If the file does not exist, the createIfDontExists parameter is honored, creating the file, without any content, in the last tested path (based on lookupDirectories), and an error is thrown in the console, preventing the application from initializing. Tip You can look at the source code of the INI configuration reader and the JSON configuration reader to understand how an IConfigurationProvider is implemented. Reading configurations from a JSON file By default, Sisk provides a configuration provider that reads configurations from a JSON file. This file follows a fixed structure and is composed of the following parameters: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Configuration files also support comments ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // new on 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } The parameters created from a configuration file can be accessed in the server constructor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Each configuration reader provides a way to read the server initialization parameters. Some properties are indicated to be in the process environment instead of being defined in the configuration file, such as sensitive API data, API keys, etc. Configuration file structure The JSON configuration file is composed of the following properties: Property Mandatory Description Server Required Represents the server itself with its settings. Server.AccessLogsStream Optional Default to console. Specifies the access log output stream. Can be a filename, null or console. Server.ErrorsLogsStream Optional Default to null. Specifies the error log output stream. Can be a filename, null or console. Server.MaximumContentLength Optional Server.MaximumContentLength Optional Default to 0. Specifies the maximum content length in bytes. Zero means infinite. Server.IncludeRequestIdHeader Optional Default to false. Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions Optional Default to true. Specifies if unhandled exceptions should be thrown. Set to false when production and true when debugging. ListeningHost Required Represents the server listening host. ListeningHost.Label Optional Represents the application label. ListeningHost.Ports Required Represents an array of strings, matching the ListeningPort syntax. ListeningHost.CrossOriginResourceSharingPolicy Optional Setup the CORS headers for the application. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Optional Defaults to false. Specifies the Allow-Credentials header. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Expose-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Optional Defaults to null. This property expects an string. Specifies the Allow-Origin header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Optional Defaults to null. This property expects an array of strings. Specifies multiples Allow-Origin headers. See AllowOrigins for more information. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Methods header. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Optional Defaults to null. This property expects an integer. Specifies the Max-Age header in seconds. ListeningHost.Parameters Optional Specifies the properties provided to the application setup method."
  },
  "docs/extensions/ssl-proxy.html": {
    "href": "docs/extensions/ssl-proxy.html",
    "title": "SSL Proxy | Sisk",
    "keywords": "SSL Proxy Warning This feature is experimental and should not be used in production. Please refer to this document if you want to make Sisk work with SSL. The Sisk SSL Proxy is a module that provides an HTTPS connection for a ListeningHost in Sisk and routes HTTPS messages to an insecure HTTP context. The module was built to provide SSL connection for a service that uses HttpListener to run, which does not support SSL. The proxy runs within the same application and listens for HTTP/1.1 messages, forwarding them in the same protocol to Sisk. Currently, this feature is highly experimental and may be unstable enough to not be used in production. At present, the SslProxy supports almost all HTTP/1.1 features, such as keep-alive, chunked encoding, websockets, etc. For an open connection to the SSL proxy, a TCP connection is created to the target server, and the proxy is forwarded to the established connection. The SslProxy can be used with HttpServer.CreateBuilder as follows: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // add SSL to the project .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); You must provide a valid SSL certificate for the proxy. To ensure that the certificate is accepted by browsers, remember to import it into the operating system so that it functions correctly."
  },
  "docs/faq.html": {
    "href": "docs/faq.html",
    "title": "Frequently Asked Questions | Sisk",
    "keywords": "Frequently Asked Questions Frequently asked questions about Sisk. Is Sisk open-source? Totally. All source code used by Sisk is published and frequently updated on GitHub. Are contributions accepted? As long as they are compatible with the Sisk philosophy, all contributions are very welcome! Contributions don't have to be just code! You can contribute with documentation, tests, translations, donations, and posts, for example. Is Sisk funded? No. No organization or project currently sponsors Sisk. Can I use Sisk in production? Absolutely. The project has been in development for more than three years and has had intense testing in commercial applications that have been in production since then. Sisk is used in important commercial projects as main infrastructure. A guide on how to deploy in different systems and environments has been written and is available. Does Sisk have authentication, monitoring, and database services? No. Sisk does not have any of these. It's a framework for developing HTTP web applications, but it's still a minimal framework that delivers what's needed for your application to work. You can implement all the services you want using any third-party library you prefer. Sisk was made to be agnostic, flexible, and work with anything. Why should I use Sisk instead of ? I don't know. You tell me. Sisk was created to fill a generic scenario for HTTP web applications in .NET. Established projects, such as ASP.NET, solve various problems, but with different biases. Unlike larger frameworks, Sisk requires the user to know what they're doing and building. Basic notions of web development and the HTTP protocol are essential for working with Sisk. Sisk is closer to the Express of Node.js than ASP.NET Core. It's a high-level abstraction that allows you to create applications with HTTP logic that you want. What do I need to learn Sisk? You need the basics of: Web development (HTTP, Restful, etc.) .NET That's it. Having a notion of what these two topics are, you can dedicate a few hours to developing an advanced application with Sisk. Can I develop commercial applications with Sisk? Absolutely. Sisk was created under the MIT license, which means you can use Sisk in any commercial project, commercially or non-commercially, without the need for a proprietary license. What we ask is that somewhere in your application, you have a notice of the open-source projects used in your project, and that Sisk is there."
  },
  "docs/features/content-streaming.html": {
    "href": "docs/features/content-streaming.html",
    "title": "Streaming Content | Sisk",
    "keywords": "Streaming Content The Sisk supports reading and sending streams of content to and from the client. This feature is useful for removing memory overhead for serializing and deserializing content during the lifetime of a request. Request content stream Small contents are automatically loaded into the HTTP connection buffer memory, quickly loading this content to HttpRequest.Body and HttpRequest.RawBody. For larger contents, the HttpRequest.GetRequestStream method can be used to obtain the request content read stream. It is worth noting that the HttpRequest.GetMultipartFormContent method reads the entire request content into memory, so it may not be useful for reading large contents. Consider the following example: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // request does not have content return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"File sent successfully.\" } ) }; } In the example above, the UploadDocument method reads the request content and saves the content to a file. No additional memory allocation is made except for the read buffer used by Stream.CopyToAsync. The example above removes the pressure of memory allocation for a very large file, which can optimize application performance. A good practice is to always use a CancellationToken in an operation that can be time-consuming, such as sending files, as it depends on the network speed between the client and the server. The adjustment with a CancellationToken can be made in the following way: Controller/UploadDocument.cs C# // the cancellation token below will throw an exception if the 30-second timeout is reached. CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"The upload exceeded the maximum upload time (30 seconds).\" } ) }; } Response content stream Sending response content is also possible. Currently, there are two ways to do this: through the HttpRequest.GetResponseStream method and using a content of type StreamContent. Consider a scenario where we need to serve an image file. To do this, we can use the following code: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // example method to obtain a profile picture var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } The method above makes a memory allocation every time it reads the image content. If the image is large, this can cause a performance problem, and in peak situations, even a memory overload and crash the server. In these situations, caching can be useful, but it will not eliminate the problem, since memory will still be reserved for that file. Caching will alleviate the pressure of having to allocate memory for every request, but for large files, it will not be enough. Sending the image through a stream can be a solution to the problem. Instead of reading the entire image content, a read stream is created on the file and copied to the client using a tiny buffer. Sending through the GetResponseStream method The HttpRequest.GetResponseStream method creates an object that allows sending chunks of the HTTP response as the content flow is prepared. This method is more manual, requiring you to define the status, headers, and content size before sending the content. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // in this form of sending, the status and header must be defined // before the content is sent var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // in this form of sending, it is also necessary to define the content size // before sending it. requestStreamManager.SetContentLength ( fs.Length ); // if you don't know the content size, you can use chunked-encoding // to send the content requestStreamManager.SendChunked = true; // and then, write to the output stream await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } Sending content through a StreamContent The StreamContent class allows sending content from a data source as a byte stream. This form of sending is easier, removing the previous requirements, and even allowing the use of compression encoding to reduce the content size. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important In this type of content, do not encapsulate the stream in a using block. The content will be automatically discarded by the HTTP server when the content flow is finalized, with or without errors."
  },
  "docs/features/cors.html": {
    "href": "docs/features/cors.html",
    "title": "Enabling CORS (Cross-Origin Resource Sharing) in Sisk | Sisk",
    "keywords": "Enabling CORS (Cross-Origin Resource Sharing) in Sisk Sisk has a tool that can be useful for handling Cross-Origin Resource Sharing (CORS) when exposing your service publicly. This feature is not part of the HTTP protocol but a specific feature of web browsers defined by the W3C. This security mechanism prevents a web page from making requests to a different domain than the one that provided the web page. A service provider can allow certain domains to access its resources, or just one. Same Origin For a resource to be identified as \"same origin\", a request must identify the Origin header in its request: GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... And the remote server must respond with an Access-Control-Allow-Origin header with the same value as the requested origin: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... This verification is explicit: the host, port, and protocol must be the same as requested. Check the example: A server responds that its Access-Control-Allow-Origin is https://example.com: https://example.net - the domain is different. http://example.com - the scheme is different. http://example.com:5555 - the port is different. https://www.example.com - the host is different. In the specification, only the syntax is allowed for both headers, whether for requests and responses. The URL path is ignored. The port is also omitted if it is a default port (80 for HTTP and 443 for HTTPS). Origin: null Origin: <scheme>://<hostname> Origin: <scheme>://<hostname>:<port> Enabling CORS Natively, you have the CrossOriginResourceSharingHeaders object within your ListeningHost. You can configure CORS when initializing the server: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } The code above will send the following headers for all responses: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type These headers need to be sent for all responses to a web client, including errors and redirects. You may notice that the CrossOriginResourceSharingHeaders class has two similar properties: AllowOrigin and AllowOrigins. Note that one is plural, while the other is singular. The AllowOrigin property is static: only the origin you specify will be sent for all responses. The AllowOrigins property is dynamic: the server checks if the request's origin is contained in this list. If it is found, it is sent for the response of that origin. Wildcard in Origin Alternatively, you can use a wildcard (*) in the response's origin to specify that any origin is allowed to access the resource. However, this value is not allowed for requests that have credentials (authorization headers) and this operation will result in an error. You can work around this problem by explicitly listing which origins will be allowed through the AllowOrigins property or also use the AutoAllowOrigin constant in the value of AllowOrigin. This magic property will define the Access-Control-Allow-Origin header for the same value as the Origin header of the request. Other Ways to Apply CORS If you are dealing with service providers, you can override values defined in the configuration file: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // Will override the origin defined in the configuration // file. cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } Disabling CORS on Specific Routes The UseCors property is available for both routes and all route attributes and can be disabled with the following example: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } Replacing Values in the Response You can replace or remove values explicitly in a router action: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Removes the Access-Control-Allow-Credentials header request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Replaces the Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } Preflight Requests A preflight request is an OPTIONS method request that the client sends before the actual request. The Sisk server will always respond to the request with a 200 OK and the applicable CORS headers, and then the client can proceed with the actual request. This condition is only not applied when a route exists for the request with the RouteMethod explicitly configured for Options. Disabling CORS Globally It is not possible to do this. To not use CORS, do not configure it."
  },
  "docs/features/discard-syntax.html": {
    "href": "docs/features/discard-syntax.html",
    "title": "Discard syntax | Sisk",
    "keywords": "Discard syntax The HTTP server can be used to listen for a callback request from an action, such as OAuth authentication, and can be discarded after receiving that request. This can be useful in cases where you need a background action but do not want to set up an entire HTTP application for it. The following example show us how to create an listening HTTP server at port 5555 with CreateListener and wait the next context: using (var server = HttpServer.CreateListener(5555)) { // wait for the next http request var context = await server.WaitNextAsync(); Console.WriteLine($\"Requested path: {context.Request.Path}\"); } The WaitNext function waits for the next context of a completed request processing. Once the result of this operation is obtained, the server has already fully handled the request and sent the response to the client."
  },
  "docs/features/instancing.html": {
    "href": "docs/features/instancing.html",
    "title": "Dependency injection | Sisk",
    "keywords": "Dependency injection It is common to dedicate members and instances that last for the lifetime of a request, such as a database connection, an authenticated user, or a session token. One of the possibilities is through the HttpContext.RequestBag, which creates a dictionary that lasts for the entire lifetime of a request. This dictionary can be accessed by request handlers and define variables throughout that request. For example, a request handler that authenticates a user sets this user within the HttpContext.RequestBag, and within the request logic, this user can be retrieved with HttpContext.RequestBag.Get<User>(). Here’s an example: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } This is a preliminary example of this operation. The instance of User was created within the request handler dedicated to authentication, and all routes that use this request handler will have the guarantee that there will be a User in their instance of HttpContext.RequestBag. It is possible to define logic to obtain instances when not previously defined in the RequestBag through methods like GetOrAdd or GetOrAddAsync. Since version 1.3, the static property HttpContext.Current was introduced, allowing access to the currently executing HttpContext of the request context. This enables exposing members of the HttpContext outside the current request and defining instances in route objects. The example below defines a controller that has members commonly accessed by the context of a request. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // create an DbContext or get the existing one return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // the following line will throw if the property is accessed when the User is not // defined in the request bag public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // Exposing the HttpRequest instance is supported too public HttpRequest Request { get => HttpContext.Current.Request; } } And define types that inherit from the controller: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } For the example above, you will need to configure a value handler in your router so that the objects returned by the router are transformed into a valid HttpResponse. Note that the methods do not have an HttpRequest request argument as present in other methods. This is because, since version 1.3, the router supports two types of delegates for routing responses: RouteAction, which is the default delegate that receives an HttpRequest argument, and ParameterlessRouteAction. The HttpRequest object can still be accessed by both delegates through the Request property of the static HttpContext on the thread. In the example above, we defined a disposable object, the DbContext, and we need to ensure that all instances created in a DbContext are disposed of when the HTTP session ends. For this, we can use two ways to achieve this. One is to create a request handler that is executed after the router's action, and the other way is through a custom server handler. For the first method, we can create the request handler inline directly in the OnSetup method inherited from RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // get one DbContext defined in the request handler context and // dispose it ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Since Sisk version 1.4, the property HttpServerConfiguration.DisposeDisposableContextValues is introduced and enabled by default, which defines whether the HTTP server should dispose all IDisposable values in the context bag when an HTTP session is closed. The method above will ensure that the DbContext is disposed of when the HTTP session is finalized. You can do this for more members that need to be disposed of at the end of a response. For the second method, you can create a custom server handler that will dispose of the DbContext when the HTTP session is finalized. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } And use it in your app builder: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); This is a way to handle code cleanup and keep the dependencies of a request separated by the type of module that will be used, reducing the amount of duplicated code within each action of a router. It is a practice similar to what dependency injection is used for in frameworks like ASP.NET."
  },
  "docs/features/logging.html": {
    "href": "docs/features/logging.html",
    "title": "Logging | Sisk",
    "keywords": "Logging You can configure Sisk to write access and error logs automatically. It is possible to define log rotation, extensions and frequency. The LogStream class provides an asynchronous way of writing logs and keeping them in an awaitable write queue. In this article we will show you how to configure logging for your application. File based access logs Logs to files open the file, write the line text, and then close the file for every line written. This procedure was adopted to maintain write responsiveness in the logs. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } The above code will write all incoming requests to the logs/access.log file. Note that, the file is created automatically if it does not exist, however the folder before it does not. It's not necessary to create the logs/ directory as the LogStream class automatically creates it. Stream based logging You can write log files to TextWriter objects instances, such as Console.Out, by passing an TextWriter object in the constructor: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); For every message written in the stream-based log, the TextWriter.Flush() method is called. Access log formatting You can customize the access log format by predefined variables. Consider the following line: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; It will write an message like: 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] You can format your log file by the format described by the table: Value What it represents Example %dd Day of the month (formatted as two digits) 05 %dmmm Full name of the month July %dmm Abbreviated name of the month (three letters) Jul %dm Month number (formatted as two digits) 07 %dy Year (formatted as four digits) 2023 %th Hour in 12-hour format 03 %tH Hour in 24-hour format (HH) 15 %ti Minutes (formatted as two digits) 30 %ts Seconds (formatted as two digits) 45 %tm Milliseconds (formatted as three digits) 123 %tz Time zone offset (total hours in UTC) +03:00 %ri Client's remote IP address 192.168.1.100 %rm HTTP method (uppercase) GET %rs URI scheme (http/https) https %ra URI authority (domain) example.com %rh Host of the request www.example.com %rp Port of the request 443 %rz Path of the request /path/to/resource %rq Query string ?key=value&another=123 %sc HTTP response status code 200 %sd HTTP response status description OK %lin Human-readable size of the request 1.2 KB %linr Raw size of the request (bytes) 1234 %lou Human-readable size of the response 2.5 KB %lour Raw size of the response (bytes) 2560 %lms Elapsed time in milliseconds 120 %ls Execution status Executed Rotating logs Tip In Sisk 0.15 and older, this function is only available with the Sisk.ServiceProvider package. In Sisk 0.16 and above, this function is implemented on it's core package. You can configure the HTTP server to rotate the log files to a compressed .gz file when they reach a certain size. The size is checked periodically by the limiar you define. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); The above code will check every six hours if the LogStream's file has reached it's 1MB limit. If so, the file is compressed to an .gz file and it then access.log is cleaned. During this process, writing to the file is locked until the file is compressed and cleaned. All lines that enter to be written in this period will be in a queue waiting for the end of compression. This function only works with file-based LogStreams. Error logging When a server is not throwing errors to the debugger, it forwards the errors to log writing when there are any. You can configure error writing with: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); This property will only write something to the log if the error is not captured by the callback or the Router.CallbackErrorHandler property. The error written by the server always writes the date and time, the request headers (not the body), the error trace, and the inner exception trace, if theres any. Other logging instances Your application can have zero or multiple LogStreams, there is no limit on how many log channels it can have. Therefore, it is possible to direct your application's log to a file other than the default AccessLog or ErrorLog. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Application started at {0}\", DateTime.Now); Extending LogStream You can extend the LogStream class to write custom formats, compatible with the current Sisk log engine. The example below allows to write colorful messages into the Console through Spectre.Console library: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Another way to automatically write custom logs for each request/response is to create an HttpServerHandler. The example below is a little more complete. It writes the body of the request and response in JSON to the Console. It can be useful for debugging requests in general. This example makes use of ContextBag and HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // At this point, the connection is open and the client has sent the header specifying // that the content is JSON.The line below reads the content and leaves it stored in the request. // // If the content is not read in the request action, the GC is likely to collect the content // after sending the response to the client, so the content may not be available after the response is closed. // _ = request.RawBody; // add hint in the context to tell that this request has an json body on it request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformats the JSON using the CypherPotato.LightJson library var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // check if the response is JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // gets the internal server handling status responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/features/server-sent-events.html": {
    "href": "docs/features/server-sent-events.html",
    "title": "Server Sent Events | Sisk",
    "keywords": "Server Sent Events Sisk supports sending messages through Server Sent Events out of the box. You can create disposable and persistent connections, get the connections during runtime and use them. This feature has some limitations imposed by browsers, such as sending only texts messages and not being able to permanently close a connection. A server-side closed connection will have a client periodically trying to reconnect every 5 seconds (3 for some browsers). These connections are useful for sending events from the server to the client without having the client request the information every time. Creating an SSE connection A SSE connection works like a regular HTTP request, but instead of sending a response and immediately closing the connection, the connection is kept open to send messages. Calling the HttpRequest.GetEventSource() method, the request is put in a waiting state while the SSE instance is created. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Hello, world!\"); return sse.Close(); }); In the above code, we create an SSE connection and send a \"Hello, world\" message, then we close the SSE connection from the server side. Note When closing a server-side connection, by default the client will try to connect again at that end and the connection will be restarted, executing the method again, forever. It's common to forward a termination message from the server whenever the connection is closed from the server to prevent the client from trying to reconnect again. Appending headers If you need to send headers, you can use the HttpRequestEventSource.AppendHeader method before sending any messages. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hello!\"); return sse.Close(); }); Note that it is necessary to send the headers before sending any messages. Wait-For-Fail connections Connections are normally terminated when the server is no longer able to send messages due to an possible client-side disconnection. With that, the connection is automatically terminated and the instance of the class is discarded. Even with a reconnection, the instance of the class will not work, as it is linked to the previous connection. In some situations, you may need this connection later and you don't want to manage it via the callback method of the route. For this, we can identify the SSE connections with an identifier and get them using it later, even outside the callback of the route. In addition, we mark the connection with WaitForFail so as not to terminate the route and terminate the connection automatically. An SSE connection in KeepAlive will wait for a send error (caused by disconnection) to resume method execution. It is also possible to set a Timeout for this. After the time, if no message has been sent, the connection is terminated and execution resumes. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // wait for 15 seconds without any message before terminating the connection return sse.Close(); }); The above method will create the connection, handle it and wait for a disconnection or error. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // the connection is still alive evs.Send(\"Hello again!\"); } And the snippet above will try to look for the newly created connection, and if it exists, it will send a message to it. All active server connections that are identified will be available in the collection HttpServer.EventSources. This collection only stores active and identified connections. Closed connections are removed from the collection. Note It is important to note that keep alive has a limit established by components that may be connected to Sisk in an uncontrollable way, such as an web proxy, an HTTP kernel or a network driver, and they close idle connections after a certain period of time. Therefore, it is important to keep the connection open by sending periodic pings or extending the maximum time before the connection is closed. Read the next section to better understand sending periodic pings. Setup connections ping policy Ping Policy is an automated way of sending periodic messages to your client. This function allows the server to understand when the client has disconnected from that connection without having to keep the connection open indefinitely. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } In the code above, every 5 seconds, a new ping message will be sent to the client. This will keep the TCP connection alive and prevent it from being closed due to inactivity. Also, when a message fails to be sent, the connection is automatically closed, freeing up the resources used by the connection. Querying connections You can search for active connections using a predicate on the connection identifier, to be able to broadcast, for example. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcasting to all event sources that starts with 'my-connection-'\"); } You can also use the All method to get all active SSE connections."
  },
  "docs/features/websockets.html": {
    "href": "docs/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk supports web sockets as well, such as receiving and sending messages to their client. This feature works fine in most browsers, but in Sisk it is still experimental. Please, if you find any bugs, report it on github. Accepting and receiving messages asynchronously The example below shows how websocket works in practice, with an example of opening a connection, receiving a message and displaying it in the console. All messages received by WebSocket are received in bytes, so you will have to decode them upon receipt. By default, messages are fragmented into chunks and the last piece is sent as the final packet of the message. You can configure the packet size with the WebSocketBufferSize flag. This buffering is the same for sending and receiving messages. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // gets the HttpWebSocket context which received the message HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); Note Do not use asynchronous events in this way. You can have exceptions thrown outside the HTTP server domain and they can crash your application. If you need to handle asynchronous code and deal with multiple messages at the same time, you can use the message loop: router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Received message: {messageText}\"); await ws.SendAsync(\"Hello from server!\"); } return ws.Close(); }); Accepting and receiving messages synchronously The example below contains a way for you to use a synchronous websocket, without an asynchronous context, where you receive the messages, deal with them, and finish using the socket. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); Sending messages The Send method has three overloads, which allow you to send text, a byte array, or a byte span. All of them is chunked if the server's WebSocketBufferSize flag is greater than the total payload size. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // will be encoded as an UTF-8 byte array ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Waiting for websocket close The method WaitForClose() blocks the current call stack until the connection is terminated by either the client or the server. With this, the execution of the callback of the request will be blocked until the client or the server disconnects. You can also manually close the connection with the Close() method. This method returns an empty HttpResponse object, which is not sent to the client, but works as a return from the function where the HTTP request was received. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // wait for client close connection ws.WaitForClose(); // waits until no messages are exchanged in the 60 seconds // or until some party closes the connection ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Ping Policy Similar to how ping policy in Server Side Events works, you can also configure a ping policy to keep the TCP connection open if there is inactivity in it. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/fundamentals/request-handlers.html": {
    "href": "docs/fundamentals/request-handlers.html",
    "title": "Request handling | Sisk",
    "keywords": "Request handling Request handlers, also known as \"middlewares\", are functions that run before or after a request is executed on the router. They can be defined per route or per router. There are two types of request handlers: BeforeResponse: defines that the request handler will be executed before calling the router action. AfterResponse: defines that the request handler will be executed after calling the router action. Sending an HTTP response in this context will overwrite the router's action response. Both requests handlers can override the actual router callback function response. By the way, request handlers can be useful for validating a request, such as authentication, content, or any other information, such as storing information, logs, or other steps that can be performed before or after a response. This way, a request handler can interrupt all this execution and return a response before finishing the cycle, discarding everything else in the process. Example: let's assume that a user authentication request handler does not authenticate him. It will prevent the request lifecycle from being continued and will hang. If this happens in the request handler at position two, the third and onwards will not be evaluated. Creating an request handler To create a request handler, we can create a class that inherits the IRequestHandler interface, in this format: Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Returning null indicates that the request cycle can be continued return null; } else { // Returning an HttpResponse object indicates that this response will overwrite adjacent responses. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } In the above example, we indicated that if the Authorization header is present in the request, it should continue and the next request handler or the router callback should be called, whichever comes next. If it's a request handler is executed after the response by their property ExecutionMode and return an non-null value, it will overwrite the router's response. Whenever a request handler returns null, it indicates that the request must continue and the next object must be called or the cycle must end with the router's response. Associating a request handler with a single route You can define one or more request handlers for a route. Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // before request handler new ValidateJsonContentRequestHandler(), // before request handler // -- method IndexPage will be executed here new WriteToLogRequestHandler() // after request handler }); Or creating an Route object: Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Associating a request handler with a router You can define a global request handler that will runned on all routes on a router. Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Associating a request handler with an attribute You can define a request handler on a method attribute along with a route attribute. Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } } Note that it is necessary to pass the desired request handler type and not an object instance. That way, the request handler will be instantiated by the router parser. You can pass arguments in the class constructor with the ConstructorArguments property. Example: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } You can also create your own attribute that implements RequestHandler: Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } And use it as: Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } Bypassing an global request handler After defining a global request handler on a route, you can ignore this request handler on specific routes. Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: the same instance of what is in the global request handlers new AuthenticateUserRequestHandler() // wrong: will not skip the global request handler } }); Note If you're bypassing a request handler you must use the same reference of what you instanced before to skip. Creating another request handler instance will not skip the global request handler since it's reference will change. Remember to use the same request handler reference used in both GlobalRequestHandlers and BypassGlobalRequestHandlers."
  },
  "docs/fundamentals/requests.html": {
    "href": "docs/fundamentals/requests.html",
    "title": "Requests | Sisk",
    "keywords": "Requests Requests are structures that represent an HTTP request message. The HttpRequest object contains useful functions for handling HTTP messages throughout your application. An HTTP request is formed by the method, path, version, headers and body. In this document, we will teach you how to obtain each of these elements. Getting the request method To obtain the method of the received request, you can use the Method property: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } This property returns the request's method represented by an HttpMethod object. Note Unlike route methods, this property does not serves the RouteMethod.Any item. Instead, it returns the real request method. Getting request url components You can get various component from a URL through certain properties of a request. For this example, let's consider the URL: http://localhost:5000/user/login?email=foo@bar.com Component name Description Component value Path Gets the request path. /user/login FullPath Gets the request path and the query string. /user/login?email=foo@bar.com FullUrl Gets the entire URL request string. http://localhost:5000/user/login?email=foo@bar.com Host Gets the request host. localhost Authority Gets the request host and port. localhost:5000 QueryString Gets the request query. ?email=foo@bar.com Query Gets the request query in a named value collection. {StringValueCollection object} IsSecure Determines if the request is using SSL (true) or not (false). false You can also opt by using the HttpRequest.Uri property, which includes everything above in one object. Getting the request body Some requests include body such as forms, files, or API transactions. You can get the body of a request from the property: // gets the request body as an string, using the request encoding as the encoder string body = request.Body; // or gets it in an byte array byte[] bodyBytes = request.RawBody; // or else, you can stream it. Stream requestStream = request.GetRequestStream(); It is also possible to determine if there is a body in the request and if it is loaded with the properties HasContents, which determines if the request has contents and IsContentAvailable which indicates that the HTTP server fully received the content from the remote point. It is not possible to read the request content through GetRequestStream more than once. If you read with this method, the values in RawBody and Body will also not be available. It's not necessary to dispose the request stream in the context of the request, as it is disposed at the end of the HTTP session in which it is created. Also, you can use HttpRequest.RequestEncoding property to get the best encoding to decode the request manually. The server has limits for reading the request content, which applies to both HttpRequest.Body and HttpRequest.RawBody. These properties copies the entire input stream to an local buffer of the same size of HttpRequest.ContentLength. A response with status 413 Content Too Large is returned to the client if the content sent is larger than HttpServerConfiguration.MaximumContentLength defined in the user configuration. Additionally, if there is no configured limit or if it is too large, the server will throw an OutOfMemoryException when the content sent by the client exceeds Int32.MaxValue (2 GB) and if the content is attempted to be accessed through one of the properties mentioned above. You can still deal with the content through streaming. Note Although Sisk allows it, it is always a good idea to follow HTTP Semantics to create your application and not obtain or serve content in methods that do not allow it. Read about RFC 9110 \"HTTP Semantics\". Getting the request context The HTTP Context is an exclusive Sisk object that stores HTTP server, route, router and request handler information. You can use it to be able to organize yourself in an environment where these objects are difficult to organize. The RequestBag object contains stored information that is passed from an request handler to another point, and can be consumed at the final destination. This object can also be used by request handlers that run after the route callback. Tip This property is also acessible by HttpRequest.Bag property. Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } The above request handler will define AuthenticatedUser in the request bag, and can be consumed later in the final callback: Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } You can also use the Bag.Set() and Bag.Get() helper methods to get or set objects by their type singletons. Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } Getting form data You can get the values of a form data in an NameValueCollection with the example below: Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } Getting multipart form data Sisk's HTTP request lets you get uploaded multipart contents, such as a files, form fields, or any binary content. Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // the following method reads the entire request input into an // array of MultipartObjects var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // The name of the file provided by Multipart form data. // Null is returned if the object is not a file. Console.WriteLine(\"File name : \" + uploadedObject.Filename); // The multipart form data object field name. Console.WriteLine(\"Field name : \" + uploadedObject.Name); // The multipart form data content length. Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // Determine the image format based in the file header for each // known content type. If the content ins't an recognized common file // format, this method below will return MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } You can read more about Sisk Multipart form objects and it's methods, properties and functionalities. Server-sent events support Sisk supports Server-sent events, which allows sending chunks as an stream and keeping the connection between the server and the client alive. Calling the HttpRequest.GetEventSource method will put the HttpRequest in it's listener state. From this, the context of this HTTP request will not expect an HttpResponse as it will overlap the packets sent by server side events. After sending all packets, the callback must return the Close method, which will send the final response to the server and indicate that the streaming has ended. It's not possible to predict what the total length of all packets that will be sent, so it is not possible to determine the end of the connection with Content-Length header. By most browsers defaults, server-side events does not support sending HTTP headers or methods other than the GET method. Therefore, be careful when using request handlers with event-source requests that require specific headers in the request, as it probably they ins't going to have them. Also, most browsers restart streams if the EventSource.close method ins't called on the client side after receiving all the packets, causing infinite additional processing on the server side. To avoid this kind of problem, it's common to send an final packet indicating that the event source has finished sending all packets. The example below shows how the browser can communicate with the server that supports Server-side events. sse-example.html HTML <html> <body> <b>Fruits:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> And progressively send the messages to the client: Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { await serverEvents.SendAsync(fruit); await Task.Delay(1500); } return serverEvents.Close(); } } When running this code, we expect a result similar to this: Resolving proxied IPs and hosts Sisk can be used with proxies, and therefore IP addresses can be replaced by the proxy endpoint in the transaction from a client to the proxy. You can define your own resolvers in Sisk with forwarding resolvers. Headers encoding Header encoding can be a problem for some implementations. On Windows, UTF-8 headers are not supported, so ASCII is used. Sisk has a built-in encoding converter, which can be useful for decoding incorrectly encoded headers. This operation is costly and disabled by default, but can be enabled under the NormalizeHeadersEncodings flag."
  },
  "docs/fundamentals/responses.html": {
    "href": "docs/fundamentals/responses.html",
    "title": "Responses | Sisk",
    "keywords": "Responses Responses represent objects that are HTTP responses to HTTP requests. They are sent by the server to the client as an indication of the request for a resource, page, document, file or other object. An HTTP response is formed up of status, headers and content. In this document, we will teach you how to architect HTTP responses with Sisk. Setting an HTTP status The HTTP status list is the same since HTTP/1.0, and Sisk supports all of them. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 Or with Fluent Syntax: new HttpResponse() .WithStatus(200) // or .WithStatus(HttpStatusCode.Ok) // or .WithStatus(HttpStatusInformation.Ok); You can see the full list of available HttpStatusCode here. You can also provide your own status code by using the HttpStatusInformation structure. Body and content-type Sisk supports native .NET content objects to send body in responses. You can use the StringContent class to send a JSON response for example: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); The server will always attempt to calculate the Content-Length from what you have defined in the content if you haven't explicitly defined it in a header. If the server cannot implicitly obtain the Content-Length header from the response content, the response will be sent with Chunked-Encoding. You can also stream the response by sending a StreamContent or using the method GetResponseStream. Response headers You can add, edit or remove headers you're sending in the response. The example below shows how to send an redirect response to the client. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Or with Fluent Syntax: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); When you use the Add method of HttpHeaderCollection, you are adding a header to the request without altering the ones already sent. The Set method replaces the headers with the same name with the instructed value. The indexer of HttpHeaderCollection internally calls the Set method to replace the headers. Sending cookies Sisk has methods that facilitate the definition of cookies in the client. Cookies set by this method are already URL encoded and fit the RFC-6265 standard. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Or with Fluent Syntax: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); There are other more complete versions of the same method. Chunked responses You can set the transfer encoding to chunked to send large responses. HttpResponse res = new HttpResponse(); res.SendChunked = true; When using chunked-encoding, the Content-Length header is automatically omitted. Response stream Response streams are an managed way that allow you to send responses in a segmented way. It's a lower level operation than using HttpResponse objects, as they require you to send the headers and content manually, and then close the connection. This example opens an read-only stream for the file, copies the stream to the response output stream and doens't loads the entire file in the memory. This can be useful to serving medium or big files. // gets the response output stream using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // sets the response encoding to use chunked-encoding // also you shouldn't send content-length header when using // chunked encoding responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copies the file stream to the response output stream fileStream.CopyTo(responseStream.ResponseStream); // closes the stream return responseStream.Close(); GZip, Deflate and Brotli compression You can send responses with compressed content in Sisk with compressing HTTP contents. Firstly, encapsulate your HttpContent object within one of the compressors below to send the compressed response to the client. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // or Content = new BrotliContent(new HtmlContent(myHtml)), // or Content = new DeflateContent(new HtmlContent(myHtml)), }; }); You can also use these compressed contents with streams. router.MapGet(\"/archive.zip\", request => { // do not apply \"using\" here. the HttpServer will discard your content // after sending the response. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); The Content-Encoding headers are automatically set when using these contents. Automatic compression It is possible to automatically compress HTTP responses with the EnableAutomaticResponseCompression property. This property automatically encapsulates the response content from the router in a compressible content that is accepted by the request, provided the response is not inherited from a CompressedContent. Only one compressible content is chosen for a request, chosen according to the Accept-Encoding header, which follows the order: BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) If the request specifies that it accepts any of these compression methods, the response will be automatically compressed. Implicit response types You can use other return types besides HttpResponse, but it is necessary to configure the router how it will handle each type of object. The concept is to always return a reference type and turn it into a valid HttpResponse object. Routes that return HttpResponse do not undergo any conversion. Value types (structures) cannot be used as a return type because they are not compatible with the RouterCallback, so they must be wrapped in a ValueResult to be able to be used in handlers. Consider the following example from a router module not using HttpResponse in the return type: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } With that, now it is necessary to define in the router how it will deal with each type of object. Objects are always the first argument of the handler and the output type must be a valid HttpResponse. Also, the output objects of a route should never be null. For ValueResult types it is not necessary to indicate that the input object is a ValueResult and only T, since ValueResult is an object reflected from its original component. The association of types does not compare what was registered with the type of the object returned from the router callback. Instead, it checks whether the type of the router result is assignable to the registered type. Registering a handler of type Object will fallback to all previously unvalidated types. The inserting order of the value handlers also matters, so registering an Object handler will ignore all other type-specific handlers. Always register specific value handlers first to ensure order. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // registering an value handler of object must be the last // value handler which will be used as an fallback r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); Note on enumerable objects and arrays Implicit response objects that implement IEnumerable are read into memory through the ToArray() method before being converted through a defined value handler. For this to occur, the IEnumerable object is converted to an array of objects, and the response converter will always receive an Object[] instead of the original type. Consider the following scenario: using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"String array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Object array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); In the above example, the IEnumerable<string> converter will never be called, because the input object will always be an Object[] and it is not convertible to an IEnumerable<string>. However, the converter below that receives an IEnumerable<object> will receive its input, since its value is compatible. If you need to actually handle the type of the object that will be enumerated, you will need to use reflection to get the type of the collection element. All enumerable objects (lists, arrays, and collections) are converted to an array of objects by the HTTP response converter. Values that implements IAsyncEnumerable are handled automatically by the server if the ConvertIAsyncEnumerableIntoEnumerable property is enabled, similar to what happens with IEnumerable. An asynchronous enumeration is converted to a blocking enumerator, and then converted to a synchronous array of objects."
  },
  "docs/fundamentals/routing.html": {
    "href": "docs/fundamentals/routing.html",
    "title": "Routing | Sisk",
    "keywords": "Routing The Router is the first step in building the server. It is responsible for housing Route objects, which are endpoints that map URLs and their methods to actions executed by the server. Each action is responsible for receiving a request and delivering a response to the client. The routes are pairs of path expressions (\"path pattern\") and the HTTP method that they can listen to. When a request is made to the server, it will attempt to find a route that matches the received request, then it will call the action of that route and deliver the resulting response to the client. There are multiple ways to define routes in Sisk: they can be static, dynamic or auto-scanned, defined by attributes, or directly in the Router object. Router mainRouter = new Router(); // maps the GET / route into the following action mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); To understand what a route is capable of doing, we need to understand what a request is capable of doing. An HttpRequest will contain everything you need. Sisk also includes some extra features that speed up the overral development. For every action received by the server, a delegate of type RouteAction will be called. This delegate contains an parameter holding an HttpRequest with all the necessary information about the request received by the server. The resulting object from this delegate must be an HttpResponse or an object that maps to it through implicit response types. Matching routes When a request is received by the HTTP server, Sisk searches for a route that satisfies the expression of the path received by the request. The expression is always tested between the route and the request path, without considering the query string. This test does not have priority and is exclusive to a single route. When no route is matched with that request, the Router.NotFoundErrorHandler response is returned to the client. When the path pattern is matched, but the HTTP method is mismatched, the Router.MethodNotAllowedErrorHandler response is sent back to the client. Sisk checks for the possibility of route collisions to avoid these problems. When defining routes, Sisk will look for possible routes that might collide with the route being defined. This test includes checking the path and the method that the route is set to accept. Creating routes using path patterns You can define routes using various SetRoute methods. // SetRoute way mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // Map* way mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // empty 200 ok }); // Route.* helper methods mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // the StreamContent inner // stream is disposed after sending // the response. Content = new StreamContent(imageStream) }; }); // multiple parameters mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); The RouteParameters property of HttpResponse contains all the information about the path variables of the received request. Every path received by the server is normalized before the path pattern test is executed, following these rules: All empty segments are removed from the path, eg: ////foo//bar becomes /foo/bar. Path matching is case-sensitive, unless Router.MatchRoutesIgnoreCase is set to true. The Query and RouteParameters properties of HttpRequest return a StringValueCollection object, where each indexed property returns a non-null StringValue, which can be used as an option/monad to convert its raw value into a managed object. The example below reads the route parameter \"id\" and obtains a Guid from it. If the parameter is not a valid Guid, an exception is thrown, and a 500 error is returned to the client if the server is not handling Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note Paths have their trailing / ignored in both request and route path, that is, if you try to access a route defined as /index/page you'll be able to access using /index/page/ too. You can also force URLs to terminate with / enabling the ForceTrailingSlash flag. Creating routes using class instances You can also define routes dynamically using reflection with the attribute RouteAttribute. This way, the instance of a class in which its methods implement this attribute will have their routes defined in the target router. For a method to be defined as a route, it must be marked with a RouteAttribute, such as the attribute itself or a RouteGetAttribute. The method can be static, instance, public, or private. When the method SetObject(type) or SetObject<TType>() is used, instance methods are ignored. Controller/MyController.cs C# public class MyController { // will match GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // static methods works too [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } The line below will define both the Index and Hello methods of MyController as routes, as both are marked as routes, and an instance of the class has been provided, not its type. If its type had been provided instead of an instance, only the static methods would be defined. var myController = new MyController(); mainRouter.SetObject(myController); Since Sisk version 0.16, it is possible to enable AutoScan, which will search for user-defined classes that implement RouterModule and will automatically associate it with the router. This is not supported with AOT compilation. mainRouter.AutoScanModules<ApiController>(); The above instruction will search for all types which implements ApiController but not the type itself. The two optional parameters indicate how the method will search for these types. The first argument implies the Assembly where the types will be searched and the second indicates the way in which the types will be defined. Regex routes Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Or with RegexRoute class: mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); })); You can also capture groups from the regex pattern into the HttpRequest.RouteParameters contents: Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } } Prefixing routes You can prefix all routes in a class or module with the RoutePrefix attribute and set the prefix as a string. See the example below using the BREAD architecture (Browse, Read, Edit, Add and Delete): Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } In the above example, the HttpResponse parameter is omitted in favor of being used through the global context HttpContext.Current. Read more in the section that follows. Routes without request parameter Routes can be defined without the HttpRequest parameter and still be possible to obtain the request and its components in the request context. Let's consider an abstraction ControllerBase that serves as a foundation for all controllers of an API, and that abstraction provides the Request property to obtain the HttpRequest currently. Controller/ControllerBase.cs C# public abstract class ControllerBase { // gets the request from the current thread public HttpRequest Request { get => HttpContext.Current.Request; } // the line below, when called, gets the database from the current HTTP session, // or creates a new one if it doesn't exist public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } And for all it's descendants to be able to use the route syntax without the request parameter: Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // reads the JSON data from the current request UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } More details about the current context and dependency injection can be found in the dependency injection tutorial. Any method routes You can define a route to be matched only by its path and skip the HTTP method. This can be useful for you to do method validation inside the route callback. // will match / on any HTTP method mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Any path routes Any path routes test for any path received by the HTTP server, subject to the route method being tested. If the route method is RouteMethod.Any and the route uses Route.AnyPath in its path expression, this route will listen to all requests from the HTTP server, and no other routes can be defined. // the following route will match all POST requests mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Ignore case route matching By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable this option: mainRouter.MatchRoutesIgnoreCase = true; This will also enable the option RegexOptions.IgnoreCase for routes where it's regex-matching. Not Found (404) callback handler You can create a custom callback for when a request doesn't match any known routes. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Since v0.14 Content = new HtmlContent(\"<h1>Not found</h1>\") // older versions Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; Method not allowed (405) callback handler You can also create a custom callback for when a request matches it's path, but doens't match the method. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; Internal error handler Route callbacks can throw errors during server execution. If not handled correctly, the overall functioning of the HTTP server can be terminated. The router has a callback for when a route callback fails and prevents service interruption. This method is only reacheable when ThrowExceptions is set to false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting started | Sisk",
    "keywords": "Getting started Welcome to the Sisk documentation! Finally, what is the Sisk Framework? It is an open-source lightweight library built with .NET, designed to be minimalist, flexible, and abstract. It allows developers to create internet services quickly, with little or no necessary configuration. Sisk makes it possible for your existing application to have a managed HTTP module, complete and disposable or complete. Sisk's values include code transparency, modularity, performance, and scalability, and can handle various types of applications, such as Restful, JSON-RPC, Web-sockets, and more. It's main features includes: Resource Description Routing A path router that supports prefixes, custom methods, path variables, value converters and more. Request Handlers Also known as middlewares, provides an interface to build your own request-handlers that work with the request before or after an action. Compression Compress your response contents easily with Sisk. Web sockets Provides routes that accept complete web-sockets, for reading and writing to the client. Server-sent events Provides the sending of server events to clients that support the SSE protocol. Logging Simplified logging. Log errors, access, define rotating logs by size, multiple output streams for the same log, and more. Multi-host Have an HTTP server for multiple ports, and each port with its own router, and each router with its own application. Server handlers Extend your own implementation of the HTTP server. Customize with extensions, improvements, and new features. First steps Sisk can run in any .NET environment. In this guide, we will teach you how to create a Sisk application using .NET. If you haven't installed it yet, please download the SDK from here. In this tutorial, we will cover how to create a project structure, receive a request, obtain a URL parameter, and send a response. This guide will focus on building a simple server using C#. You can also use your favorite programming language. Note You may be interested in a quickstart project. Check this repository for more information. Creating a Project Let's name our project \"My Sisk Application.\" Once you have .NET set up, you can create your project with the following command: dotnet new console -n my-sisk-application Next, navigate to your project directory and install Sisk using the .NET utility tool: cd my-sisk-application dotnet add package Sisk.HttpServer You can find additional ways to install Sisk in your project here. Now, let's create an instance of our HTTP server. For this example, we will configure it to listen on port 5000. Building the HTTP Server Sisk allows you to build your application step by step manually, as it routes to the HttpServer object. However, this may not be very convenient for most projects. Therefore, we can use the builder method, which makes it easier to get our app up and running. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } It's important to understand each vital component of Sisk. Later in this document, you will learn more about how Sisk works. Manual (advanced) setup You can learn how each Sisk mechanism works in this section of the documentation, which explains the behavior and relationships between the HttpServer, Router, ListeningPort, and other components."
  },
  "docs/installing.html": {
    "href": "docs/installing.html",
    "title": "Installing | Sisk",
    "keywords": "Installing You can install Sisk through Nuget, dotnet cli or another options. You can easily setup your Sisk environment by running this command in your developer console: dotnet add package Sisk.HttpServer This command will install the latest version of Sisk in your project."
  },
  "docs/jp/advanced/forwarding-resolvers.html": {
    "href": "docs/jp/advanced/forwarding-resolvers.html",
    "title": "フォワーディング リゾルバー | Sisk",
    "keywords": "フォワーディング リゾルバー フォワーディング リゾルバーは、クライアントを識別する情報をデコードするヘルパーです。リクエスト、プロキシ、CDN、またはロード バランサーを介して。Sisk サービスがリバース プロキシまたはフォワード プロキシを介して実行される場合、クライアントの IP アドレス、ホスト、およびプロトコルは、元のリクエストとは異なる場合があります。これは、サービス間のフォワーディングであるためです。この Sisk 機能により、リクエストを処理する前にこの情報を解決して制御できます。これらのプロキシは、クライアントを識別するために役立つヘッダーを提供します。 現在、ForwardingResolver クラスを使用すると、クライアントの IP アドレス、ホスト、および使用される HTTP プロトコルを解決できます。Sisk のバージョン 1.0 以降、サーバーにはこれらのヘッダーをデコードするための標準実装がなくなりました。これは、サービスごとに異なるセキュリティ上の理由があるためです。 たとえば、X-Forwarded-For ヘッダーには、リクエストをフォワードした IP アドレスに関する情報が含まれます。このヘッダーは、プロキシによって使用され、最終的なサービスに情報のチェーンを運ぶために使用され、クライアントの実際のアドレスを含むすべてのプロキシの IP アドレスが含まれます。問題は、クライアントのリモート IP を識別するのが難しい場合があり、ヘッダーを識別するための特定のルールがないことです。以下のヘッダーを実装する前に、ドキュメントを読むことを強くお勧めします。 X-Forwarded-For ヘッダー について読む。 X-Forwarded-Host ヘッダー について読む。 X-Forwarded-Proto ヘッダー について読む。 ForwardingResolver クラス このクラスには、各サービスに最も適した実装を可能にする 3 つの仮想メソッドがあります。各メソッドは、プロキシを介したリクエストから情報を解決する責任があります。クライアントの IP アドレス、リクエストのホスト、および使用されるセキュリティ プロトコルです。デフォルトでは、Sisk は常に元のリクエストの情報を使用し、ヘッダーを解決しません。 以下の例は、この実装を使用する方法を示しています。この例では、X-Forwarded-For ヘッダーを介してクライアントの IP を解決し、リクエストで複数の IP がフォワードされた場合にエラーをスローします。 Important この例を生産コードで使用しないでください。実装が使用するために適切であることを常に確認してください。ヘッダーを実装する前にドキュメントを読んでください。 class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"The X-Forwarded-For header is missing.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Too many addresses in the X-Forwarded-For header.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/jp/advanced/http-server-handlers.html": {
    "href": "docs/jp/advanced/http-server-handlers.html",
    "title": "Http サーバー ハンドラー | Sisk",
    "keywords": "Http サーバー ハンドラー Sisk バージョン 0.16 では、HttpServerHandler クラスが導入され、Sisk の全体的な動作を拡張し、Http リクエスト、ルーター、コンテキスト バッグなどへの追加のイベント ハンドラーを提供します。 このクラスは、HTTP サーバーのライフタイムとリクエストのイベントを集中管理します。Http プロトコルにはセッションがないため、1 つのリクエストから別のリクエストへの情報を保持することはできません。Sisk では、セッション、コンテキスト、データベース接続などの有用なプロバイダーを実装する方法を提供します。 各イベントが発生するタイミングと目的については、このページ を参照してください。また、HTTP リクエストのライフサイクル を確認して、リクエストに対して何が起こるかと、イベントがどこで発生するかを理解することもできます。HTTP サーバーでは、同時に複数のハンドラーを使用できます。各イベント呼び出しは同期的であり、関連付けられたすべてのハンドラーが実行され完了するまで、現在のスレッドがブロックされます。 RequestHandlers と異なり、特定のルート グループまたはルートに適用することはできません。代わりに、全体の HTTP サーバーに適用されます。Http サーバー ハンドラー内で条件を適用することもできます。さらに、各 Sisk アプリケーションに対して、各 HttpServerHandler のシングルトンが定義されます。つまり、各 HttpServerHandler には 1 つのインスタンスのみが定義されます。 HttpServerHandler を使用する実用的な例は、リクエストの終了時に自動的にデータベース接続を破棄することです。 // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // リクエストがコンテキスト バッグに DbContext を定義しているかどうかを確認します if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // ユーザーが HttpRequest から DbContext を作成し、それをリクエスト バッグに保存できるようにします public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } 上記のコードでは、GetDbContext 拡張メソッドにより、HttpRequest オブジェクトから直接接続コンテキストを作成し、それをリクエスト バッグに保存できます。破棄されていない接続はデータベースを実行する際に問題を引き起こす可能性があるため、OnHttpRequestClose で終了されます。 ハンドラーを Http サーバーに登録するには、ビルダーまたは HttpServer.RegisterHandler を使用できます。 // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } これにより、UsersController クラスはデータベース コンテキストを使用できます。 // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } 上記のコードでは、JsonOk と JsonMessage などのメソッドを使用しています。これらは ApiController に組み込まれており、RouterController から継承されています。 // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } 開発者は、このクラスを使用してセッション、コンテキスト、データベース接続を実装できます。提供されたコードは、DatabaseConnectionHandler を使用した実用的な例を示しており、各リクエストの終了時に自動的にデータベース接続を破棄します。 統合は簡単であり、ハンドラーはサーバー設定中に登録されます。HttpServerHandler クラスは、HTTP アプリケーションでリソースを管理し、Sisk の動作を拡張するための強力なツールセットを提供します。"
  },
  "docs/jp/advanced/manual-setup.html": {
    "href": "docs/jp/advanced/manual-setup.html",
    "title": "Manual (advanced) setup | Sisk",
    "keywords": "Manual (advanced) setup このセクションでは、事前に定義された標準なしで、完全に抽象的な方法でHTTPサーバーを作成します。ここでは、HTTPサーバーがどのように機能するかを手動で構築できます。各ListeningHostにはルーターがあり、HTTPサーバーには複数のListeningHostsを持ち、それぞれが異なるホストと異なるポートを指すことができます。 まず、リクエスト/レスポンスの概念を理解する必要があります。非常にシンプルです。各リクエストに対して、レスポンスが必要です。Siskもこの原則に従います。\"Hello, World!\"メッセージをHTMLで返すメソッドを作成しましょう。ステータスコードとヘッダーを指定します。 // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hello, world!</h1> </body> </html> \") }; return indexResponse; } 次のステップは、このメソッドをHTTPルートに関連付けることです。 Routers ルーターは、リクエストルートの抽象化であり、サービスに対するリクエストとレスポンスの橋渡しとなります。ルーターはサービスルート、関数、エラーを管理します。 ルーターには複数のルートを持ち、それぞれのルートは異なる操作を実行できます。たとえば、関数の実行、ページの提供、サーバーからのリソースの提供などです。 最初のルーターを作成し、IndexPageメソッドをインデックスパスに関連付けましょう。 Router mainRouter = new Router(); // SetRouteはすべてのインデックスルートをメソッドに関連付けます。 mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); 今、ルーターはリクエストを受け取り、レスポンスを送信できます。ただし、mainRouterはホストまたはサーバーに結び付けられていないため、単独では機能しません。次のステップは、ListeningHostを作成することです。 Listening HostsとPorts ListeningHostはルーターをホストし、同じルーターの複数のリスニングポートを持ちます。ListeningPortは、HTTPサーバーがリスニングするプレフィックスです。 ここで、ルーターを指す2つのエンドポイントを持つListeningHostを作成できます。 ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; 今、HTTPサーバーは指定されたエンドポイントをリスニングし、リクエストをルーターに転送します。 サーバー設定 サーバー設定は、HTTPサーバー自身の動作のほとんどを担当します。この設定では、ListeningHostsをサーバーに関連付けることができます。 HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // ListeningHostをサーバー設定に追加 次に、HTTPサーバーを作成できます。 HttpServer server = new HttpServer(config); server.Start(); // サーバーを起動 Console.ReadKey(); // アプリケーションが終了しないようにする 今、実行可能ファイルをコンパイルし、次のコマンドでHTTPサーバーを実行できます。 dotnet watch 実行時に、ブラウザを開き、サーバーパスに移動すると、次のようになります。"
  },
  "docs/jp/advanced/multi-host-setup.html": {
    "href": "docs/jp/advanced/multi-host-setup.html",
    "title": "複数のリスニングホストをサーバーごとに設定 | Sisk",
    "keywords": "複数のリスニングホストをサーバーごとに設定 Sisk Frameworkは、常に1つのサーバーに複数のホストを使用することをサポートしています。つまり、単一のHTTPサーバーは複数のポートでリスニングできます。各ポートには独自のルーターとサービスが実行されています。 この方法により、責任を簡単に分離し、Siskを使用した単一のHTTPサーバーでサービスを管理できます。以下の例は、2つのリスニングホストの作成を示しています。各リスニングホストは異なるポートでリスニングし、異なるルーターとアクションを実行しています。 アプリの手動作成を読んで、この抽象化の詳細を理解してください。 static void Main(string[] args) { // 2つのリスニングホストを作成します。各ホストには独自のルーターとポートがあります // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"ホストAからこんにちは！\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"ホストBからこんにちは！\")); // サーバー設定を作成し、両方のリスニングホストを追加します // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // 指定された設定を使用するHTTPサーバーを作成します // HttpServer server = new HttpServer(configuration); // サーバーを起動します server.Start(); Console.WriteLine(\"ホストAに{0}でアクセスしてみてください\", server.ListeningPrefixes[0]); Console.WriteLine(\"ホストBに{0}でアクセスしてみてください\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/jp/advanced/request-lifecycle.html": {
    "href": "docs/jp/advanced/request-lifecycle.html",
    "title": "リクエストライフサイクル | Sisk",
    "keywords": "リクエストライフサイクル 以下は、HTTP リクエストの例を通じて、リクエストの全ライフサイクルを説明します。 リクエストの受信: 各リクエストは、リクエスト自体とクライアントに配信されるレスポンスの間で HTTP コンテキストを作成します。このコンテキストは、Sisk に組み込まれたリスナーから来ます。これは、HttpListener、Kestrel、または Cadente になります。 外部リクエストの検証: HttpServerConfiguration.RemoteRequestsAction の検証がリクエストに対して行われます。 リクエストが外部で、プロパティが Drop の場合、クライアントにレスポンスを返さずに接続が閉じられ、HttpServerExecutionStatus = RemoteRequestDropped になります。 フォワーディング リゾルバーの構成: フォワーディング リゾルバーが構成されている場合、リクエストの元のホストに対して OnResolveRequestHost メソッドが呼び出されます。 DNS の一致: ホストが解決され、複数の ListeningHost が構成されている場合、サーバーはリクエストに対応するホストを探します。 対応する ListeningHost が見つからない場合、クライアントに 400 Bad Request レスポンスが返され、HTTP コンテキストに HttpServerExecutionStatus = DnsUnknownHost ステータスが返されます。 ListeningHost が見つかるが、その Router が初期化されていない場合、クライアントに 503 Service Unavailable レスポンスが返され、HTTP コンテキストに HttpServerExecutionStatus = ListeningHostNotReady ステータスが返されます。 ルーターのバインディング: 対応する ListeningHost のルーターが受信した HTTP サーバーに結び付けられます。 ルーターがすでに別の HTTP サーバーに結び付けられている場合、サーバーの構成リソースをアクティブに使用しているため、InvalidOperationException がスローされます。これは、HTTP サーバーの初期化中にのみ発生し、HTTP コンテキストの作成中に発生しません。 ヘッダーの事前定義: X-Request-Id ヘッダーがレスポンスに事前定義されます (構成されている場合)。 X-Powered-By ヘッダーがレスポンスに事前定義されます (構成されている場合)。 コンテンツ サイズの検証: リクエスト コンテンツが HttpServerConfiguration.MaximumContentLength 未満であることを検証します (これが 0 より大きい場合)。 リクエストが構成されたものより大きい Content-Length を送信した場合、クライアントに 413 Payload Too Large レスポンスが返され、HTTP コンテキストに HttpServerExecutionStatus = ContentTooLarge ステータスが返されます。 すべての構成された HTTP サーバー ハンドラーに対して OnHttpRequestOpen イベントが呼び出されます。 アクションのルーティング: サーバーは受信したリクエストに対してルーターを呼び出します。 ルーターがリクエストに一致するルートを見つけることができない場合: Router.NotFoundErrorHandler プロパティが構成されている場合、アクションが呼び出され、クライアントにアクションのレスポンスが転送されます。 前述のプロパティが null の場合、デフォルトの 404 Not Found レスポンスがクライアントに返されます。 ルーターがリクエストに一致するルートを見つけるが、ルートのメソッドがリクエストのメソッドと一致しない場合: Router.MethodNotAllowedErrorHandler プロパティが構成されている場合、アクションが呼び出され、クライアントにアクションのレスポンスが転送されます。 前述のプロパティが null の場合、デフォルトの 405 Method Not Allowed レスポンスがクライアントに返されます。 リクエストが OPTIONS メソッドの場合: ルーターは、リクエスト メソッドに一致するルートが見つからない場合 (ルートのメソッドが明示的に RouteMethod.Options ではない場合) に、クライアントに 200 Ok レスポンスを返します。 HttpServerConfiguration.ForceTrailingSlash プロパティが有効で、ルートが正規表現ではなく、リクエスト パスが / で終わらず、リクエスト メソッドが GET の場合: クライアントに、パスとクエリを同じ場所に / を付けてリダイレクトする 307 Temporary Redirect HTTP レスポンスが返されます。 すべての構成された HTTP サーバー ハンドラーに対して OnContextBagCreated イベントが呼び出されます。 BeforeResponse フラグを持つすべてのグローバル IRequestHandler インスタンスが実行されます。 どのハンドラーも null 以外のレスポンスを返した場合、そのレスポンスはクライアントに転送され、コンテキストは閉じられます。 このステップでエラーが発生し、HttpServerConfiguration.ThrowExceptions が無効になっている場合: Router.CallbackErrorHandler プロパティが有効になっている場合、それが呼び出され、結果のレスポンスがクライアントに返されます。 前述のプロパティが定義されていない場合、空のレスポンスがサーバーに返され、通常は 500 Internal Server Error になります。 BeforeResponse フラグを持つルートで定義されたすべての IRequestHandler インスタンスが実行されます。 どのハンドラーも null 以外のレスポンスを返した場合、そのレスポンスはクライアントに転送され、コンテキストは閉じられます。 このステップでエラーが発生し、HttpServerConfiguration.ThrowExceptions が無効になっている場合: Router.CallbackErrorHandler プロパティが有効になっている場合、それが呼び出され、結果のレスポンスがクライアントに返されます。 前述のプロパティが定義されていない場合、空のレスポンスがサーバーに返され、通常は 500 Internal Server Error になります。 ルーターのアクションが呼び出され、HTTP レスポンスに変換されます。 このステップでエラーが発生し、HttpServerConfiguration.ThrowExceptions が無効になっている場合: Router.CallbackErrorHandler プロパティが有効になっている場合、それが呼び出され、結果のレスポンスがクライアントに返されます。 前述のプロパティが定義されていない場合、空のレスポンスがサーバーに返され、通常は 500 Internal Server Error になります。 AfterResponse フラグを持つすべてのグローバル IRequestHandler インスタンスが実行されます。 どのハンドラーも null 以外のレスポンスを返した場合、そのハンドラーのレスポンスが前のレスポンスに置き換わり、すぐにクライアントに転送されます。 このステップでエラーが発生し、HttpServerConfiguration.ThrowExceptions が無効になっている場合: Router.CallbackErrorHandler プロパティが有効になっている場合、それが呼び出され、結果のレスポンスがクライアントに返されます。 前述のプロパティが定義されていない場合、空のレスポンスがサーバーに返され、通常は 500 Internal Server Error になります。 AfterResponse フラグを持つルートで定義されたすべての IRequestHandler インスタンスが実行されます。 どのハンドラーも null 以外のレスポンスを返した場合、そのハンドラーのレスポンスが前のレスポンスに置き換わり、すぐにクライアントに転送されます。 このステップでエラーが発生し、HttpServerConfiguration.ThrowExceptions が無効になっている場合: Router.CallbackErrorHandler プロパティが有効になっている場合、それが呼び出され、結果のレスポンスがクライアントに返されます。 前述のプロパティが定義されていない場合、空のレスポンスがサーバーに返され、通常は 500 Internal Server Error になります。 レスポンスの処理: レスポンスが準備できたら、サーバーはそれをクライアントに送信するために準備します。 Cross-Origin Resource Sharing Policy (CORS) ヘッダーが、現在の ListeningHost.CrossOriginResourceSharingPolicy に基づいてレスポンスに定義されます。 レスポンスのステータス コードとヘッダーがクライアントに送信されます。 レスポンス コンテンツがクライアントに送信されます: レスポンス コンテンツが ByteArrayContent の派生クラスの場合、レスポンス バイトが直接レスポンス出力ストリームにコピーされます。 前述の条件が満たされない場合、レスポンスはストリームにシリアル化され、レスポンス出力ストリームにコピーされます。 ストリームが閉じられ、レスポンス コンテンツが破棄されます。 HttpServerConfiguration.DisposeDisposableContextValues が有効になっている場合、リクエスト コンテキストで定義されたすべての IDisposable を継承するオブジェクトが破棄されます。 すべての構成された HTTP サーバー ハンドラーに対して OnHttpRequestClose イベントが呼び出されます。 サーバーで例外が発生した場合、すべての構成された HTTP サーバー ハンドラーに対して OnException イベントが呼び出されます。 ルートがアクセス ロギングを許可し、HttpServerConfiguration.AccessLogsStream が null でない場合、ログ出力にログ行が書き込まれます。 ルートがエラー ロギングを許可し、例外が発生し、HttpServerConfiguration.ErrorsLogsStream が null でない場合、エラー ログ出力にログ行が書き込まれます。 サーバーが HttpServer.WaitNext を通じてリクエストを待っている場合、ミューテックスが解放され、コンテキストがユーザーに利用可能になります。"
  },
  "docs/jp/changelogs.html": {
    "href": "docs/jp/changelogs.html",
    "title": "Changelogs | Sisk",
    "keywords": "Changelogs Sisk に行われたすべての変更は、変更ログを通じて記録されます。すべての Sisk バージョンの変更ログは ここ で確認できます。"
  },
  "docs/jp/deploying.html": {
    "href": "docs/jp/deploying.html",
    "title": "アプリケーションのデプロイ | Sisk",
    "keywords": "アプリケーションのデプロイ Sisk アプリケーションのデプロイ プロセスは、プロジェクトを本番環境に公開することです。プロセスは比較的単純ですが、デプロイのインフラストラクチャのセキュリティと安定性に致命的な影響を与える可能性のある詳細に注意する価値があります。 理想的には、アプリケーションをテストして準備し、クラウドにデプロイする準備ができているはずです。 アプリの公開 Sisk アプリケーションまたはサービスを公開するには、生成されたバイナリを本番環境で実行できるように最適化する必要があります。この例では、.NET Runtime がインストールされたマシンで実行するために、バイナリを本番環境用にコンパイルします。 アプリをビルドするには、.NET SDK をインストールし、ターゲット サーバーに .NET Runtime をインストールする必要があります。Linux サーバー、Windows、Mac OS に .NET Runtime をインストールする方法については、ここ、ここ、ここを参照してください。 プロジェクトが配置されているフォルダーで、ターミナルを開き、.NET 公開コマンドを使用します。 $ dotnet publish -r linux-x64 -c Release これにより、bin/Release/publish/linux-x64 内にバイナリが生成されます。 Note Sisk.ServiceProvider パッケージを使用してアプリを実行している場合、service-config.json ファイルをホスト サーバーにコピーし、dotnet publish で生成されたすべてのバイナリとともに配置する必要があります。 ファイルを事前に構成しておくことができます。環境変数、リスニング ポート、ホスト、および追加のサーバー構成が含まれます。 次のステップは、これらのファイルをアプリケーションをホストするサーバーに移動することです。 次に、バイナリ ファイルに実行権限を付与します。この場合、プロジェクト名は \"my-app\" です。 $ cd /home/htdocs $ chmod +x my-app $ ./my-app アプリケーションを実行すると、エラー メッセージが表示されない場合は、アプリケーションが実行中であることを意味します。 この時点では、ファイアウォールなどのアクセス ルールが構成されていないため、アプリケーションに外部ネットワークからアクセスすることはできない可能性があります。次のステップでこれを考慮します。 アプリケーションがリスニングしている仮想ホストのアドレスを持っている必要があります。これは、アプリケーション内で手動で設定され、Sisk サービスをインスタンス化する方法によって異なります。 Sisk.ServiceProvider パッケージを使用していない場合、HttpServer インスタンスを定義した場所でこれを見つける必要があります。 HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk は http://localhost:5000/ でリスニングする必要があります リスニング ホストを手動で関連付ける: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); または、Sisk.ServiceProvider パッケージを使用している場合、service-config.json 内で: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } これから、サービスをリスニングし、トラフィックをオープン ネットワークで利用できるようにするために、リバース プロキシを作成できます。 アプリケーションのプロキシ サービスをプロキシすることは、Sisk サービスを直接外部ネットワークに公開しないことを意味します。この方法は、サーバー デプロイで非常に一般的です。 アプリケーションに SSL 証明書を関連付けることができます。 サービスにアクセスする前にアクセス ルールを作成し、過負荷を回避できます。 バンド幅とリクエストの制限を制御できます。 アプリケーションの負荷分散を分離できます。 インフラストラクチャのセキュリティを損なうのを防ぐことができます。 Nginx または Apache のようなリバース プロキシを使用してアプリケーションを提供するか、Cloudflared のような HTTP-over-DNS トンネルを使用することができます。 また、クライアントの情報 (IP アドレスやホストなど) を取得するために、プロキシの転送ヘッダーを正しく解決することを忘れないでください。転送ヘッダー解決を参照してください。 トンネルを作成し、ファイアウォールを構成し、アプリケーションを実行した後、サービスを作成する必要があります。 Note 非 Windows システムでは、Sisk サービスで直接 SSL 証明書を使用することはできません。これは、Sisk の HTTP キュー管理の中心となるモジュールである HttpListener の実装によるものであり、オペレーティング システムによって異なります。IIS で仮想ホストに証明書を関連付けることで、Sisk サービスで SSL を使用できます。ここを参照してください。その他のシステムでは、リバース プロキシを使用することを強くお勧めします。 サービスの作成 サービスを作成すると、アプリケーションはサーバー インスタンスの再起動やクラッシュ後も常に利用可能になります。 この簡単なチュートリアルでは、前のチュートリアルからのコンテンツを使用して、サービスを常にアクティブに保つ方法を示します。 サービス構成ファイルが配置されているフォルダーにアクセスします。 cd /etc/systemd/system my-app.service ファイルを作成し、次の内容を含めます。 my-app.service INI [Unit] Description=<アプリの説明> [Service] # サービスを起動するユーザーを設定 User=<サービスを起動するユーザー> # ExecStart パスは WorkingDirectory に相対的ではありません。 # 実行可能ファイルへの完全パスとして設定します WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # サービスを常に再起動するように設定 Restart=always RestartSec=3 [Install] WantedBy=multi-user.target サービス マネージャー モジュールを再起動します。 $ sudo systemctl daemon-reload ファイル名に基づいて新しく作成したサービスを開始し、実行中であることを確認します。 $ sudo systemctl start my-app $ sudo systemctl status my-app アプリが実行中 (\"Active: active\") である場合、サービスをシステムの再起動後に実行するように有効にします。 $ sudo systemctl enable my-app これで、Sisk アプリケーションを公開する準備ができました。"
  },
  "docs/jp/extensions/basic-auth.html": {
    "href": "docs/jp/extensions/basic-auth.html",
    "title": "Basic Auth | Sisk",
    "keywords": "Basic Auth Basic Auth パッケージは、非常に少ない設定と労力で、Sisk アプリケーションで基本認証スキームを処理できるリクエスト ハンドラーを追加します。 Basic HTTP 認証は、ユーザー ID とパスワードでリクエストを認証する最小限の入力形式であり、セッションはクライアントによって完全に制御され、認証またはアクセス トークンはありません。 Basic 認証スキームについては、MDN の仕様を参照してください。 インストール 開始するには、プロジェクトに Sisk.BasicAuth パッケージをインストールします: > dotnet add package Sisk.BasicAuth プロジェクトにインストールする他の方法については、Nuget リポジトリを参照してください。 認証ハンドラーの作成 認証スキームをモジュール全体または個々のルートに対して制御できます。まず、基本認証ハンドラーを作成しましょう。 以下の例では、データベースに接続して、ユーザーが存在し、パスワードが有効であるかどうかを確認し、次にユーザーをコンテキスト バッグに保存します。 public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"このページにアクセスするには、資格情報を入力してください。\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // この場合、ユーザー ID フィールドとして電子メールを使用しているため、電子メールでユーザーを検索します。 User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"ユーザーが見つかりませんでした。\"); } // 資格情報のパスワードがこのユーザーに対して有効であることを確認します。 if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"資格情報が無効です。\"); } // ログインしたユーザーを HTTP コンテキストに追加し、実行を続行します。 context.Bag.Add(\"loggedUser\", user); return null; } } これで、このリクエスト ハンドラーをルートまたはクラスに関連付けるだけです。 public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"こんにちは、\" + loggedUser.Name + \"!\"; } } または、RouterModule クラスを使用することもできます: public class UsersController : RouterModule { public ClientModule() { // このクラス内のすべてのルートは、UserAuthHandler によって処理されます。 base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"こんにちは、\" + loggedUser.Name + \"!\"; } } 備考 基本認証の主な責任はクライアント側で実行されます。ストレージ、キャッシュ制御、暗号化はすべてクライアント側でローカルに処理され、サーバーは資格情報を受け取り、許可されたアクセスかどうかを検証するだけです。 この方法は、クライアントに大きな責任を負わせるため、セキュリティの面で最も安全な方法ではありません。さらに、パスワードは SSL のようなセキュアな接続コンテキストで送信される必要があります。なぜなら、パスワードには固有の暗号化がないからです。リクエストのヘッダーを一時的に傍受するだけで、ユーザーのアクセス資格情報が公開される可能性があります。 本番環境のアプリケーションでは、より堅牢な認証ソリューションを選択し、オフザシェルフのコンポーネントを使用しすぎないようにしてください。そうしないと、プロジェクトがセキュリティ リスクにさらされる可能性があります。"
  },
  "docs/jp/extensions/ini-configuration.html": {
    "href": "docs/jp/extensions/ini-configuration.html",
    "title": "INI 構成プロバイダー | Sisk",
    "keywords": "INI 構成プロバイダー Sisk には、JSON 以外の起動構成を取得する方法があります。実際には、IConfigurationReader を実装する任意のパイプラインを使用して、PortableConfigurationBuilder.WithConfigurationPipeline でサーバー構成を任意のファイル タイプから読み取ることができます。 Sisk.IniConfiguration パッケージでは、共通の構文エラーに対して例外をスローしないストリームベースの INI ファイル リーダーと、シンプルな構成構文が提供されます。このパッケージは、Sisk フレームワークの外部で使用でき、効率的な INI ドキュメント リーダーが必要なプロジェクトに柔軟性を提供します。 インストール パッケージをインストールするには、次のコマンドから始めることができます。 $ dotnet add package Sisk.IniConfiguration また、INI IConfigurationReader や Sisk 依存関係を含まないコア パッケージもインストールできます。 $ dotnet add package Sisk.IniConfiguration.Core メイン パッケージを使用すると、次の例のようにコードで使用できます。 class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // IniConfigurationReader 構成リーダーを使用 config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } 上記のコードは、プロセスの現在のディレクトリ (CurrentDirectory) にある app.ini ファイルを探します。INI ファイルの内容は次のようになります。 [Server] # 複数のリスニング アドレスがサポートされます Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI フレーバーと構文 現在の実装フレーバー: プロパティとセクション名は 大文字小文字を区別しません。 プロパティ名と値は トリミングされます、ただし値が引用符で囲まれている場合は除きます。 値は単一引用符または二重引用符で囲むことができます。引用符内には改行を含めることができます。 コメントは # と ; でサポートされます。末尾のコメントも許可されます。 プロパティには複数の値を指定できます。 詳細については、Sisk で使用されている INI パーサーの \"フレーバー\" のドキュメントが こちら にあります。 次の INI コードを例として使用します。 One = 1 Value = this is an value Another value = \"this value has an line break on it\" ; 次のコードにはいくつかの色があります [some section] Color = Red Color = Blue Color = Yellow ; 黄色は使用しないでください これを解析するには: // 文字列から INI テキストを解析 IniDocument doc = IniDocument.FromString(iniText); // 1 つの値を取得 string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // 複数の値を取得 string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); 構成パラメーター セクションと名前 複数の値を許可 説明 Server.Listen はい サーバーのリスニング アドレス/ポート。 Server.Encoding いいえ サーバーの既定のエンコード。 Server.MaximumContentLength いいえ サーバーの最大コンテンツ長 (バイト単位)。 Server.IncludeRequestIdHeader いいえ HTTP サーバーが X-Request-Id ヘッダーを送信するかどうかを指定します。 Server.ThrowExceptions いいえ 処理されていない例外をスローするかどうかを指定します。 Server.AccessLogsStream いいえ アクセス ログの出力ストリームを指定します。 Server.ErrorsLogsStream いいえ エラー ログの出力ストリームを指定します。 Cors.AllowMethods いいえ CORS Allow-Methods ヘッダー値を指定します。 Cors.AllowHeaders いいえ CORS Allow-Headers ヘッダー値を指定します。 Cors.AllowOrigins いいえ 複数の Allow-Origin ヘッダー、コンマで区切られた値を指定します。 AllowOrigins に関する詳細情報。 Cors.AllowOrigin いいえ 1 つの Allow-Origin ヘッダーを指定します。 Cors.ExposeHeaders いいえ CORS Expose-Headers ヘッダー値を指定します。 Cors.AllowCredentials いいえ CORS Allow-Credentials ヘッダー値を指定します。 Cors.MaxAge いいえ CORS Max-Age ヘッダー値を指定します。"
  },
  "docs/jp/extensions/json-rpc.html": {
    "href": "docs/jp/extensions/json-rpc.html",
    "title": "JSON-RPC 拡張 | Sisk",
    "keywords": "JSON-RPC 拡張 Sisk には、よりシンプルなアプリケーションを作成できる実験的な JSON-RPC 2.0 API 用のモジュールがあります。この拡張機能は、JSON-RPC 2.0 トランスポート インターフェイスを厳密に実装し、HTTP GET、POST リクエスト、以及 Sisk での Web ソケットを介したトランスポートを提供します。 以下のコマンドを使用して、Nuget を介して拡張機能をインストールできます。実験/ベータ バージョンの場合は、Visual Studio でプレリリース パッケージの検索を有効にする必要があります。 dotnet add package Sisk.JsonRpc トランスポート インターフェイス JSON-RPC は、状態を保持しない非同期リモート手続き呼び出し (RDP) プロトコルで、JSON を使用して一方向のデータ通信を行います。JSON-RPC リクエストは、通常、ID で識別され、レスポンスはリクエストで送信された同じ ID で配信されます。すべてのリクエストがレスポンスを必要とするわけではありません。これらは「通知」と呼ばれます。 JSON-RPC 2.0仕様 では、トランスポートの詳細について説明しています。このトランスポートは、使用される場所に依存しません。Sisk は、このプロトコルを HTTP を介して実装し、JSON-RPC over HTTP に準拠しています。これは、GET リクエストを部分的にサポートし、POST リクエストを完全にサポートします。Web ソケットもサポートされており、非同期メッセージ通信を提供します。 JSON-RPC リクエストは次のようになります。 { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } そして、成功したレスポンスは次のようになります: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC メソッド 以下の例は、Sisk を使用して JSON-RPC API を作成する方法を示しています。数学演算クラスはリモート演算を実行し、シリアライズされたレスポンスをクライアントに配信します。 Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // WebMethod 属性が付いたすべてのメソッドを JSON-RPC ハンドラーに追加します args.Handler.Methods.AddMethodsFromType(new MathOperations()); // /service ルートを JSON-RPC の POST および GET リクエストのハンドラーにマップします args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // GET /ws に WebSocket ハンドラーを作成します args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } 上記の例では、Sum と Sqrt メソッドを JSON-RPC ハンドラーにマップし、これらのメソッドは GET /service、POST /service、および GET /ws で利用可能になります。メソッド名は大文字と小文字を区別しません。 メソッドのパラメーターは自動的に特定の型にデシリアライズされます。名前付きパラメーターを使用したリクエストもサポートされています。JSON シリアライズは、LightJson ライブラリによって実行されます。型が正しくデシリアライズされない場合は、その型用に特定の JSON コンバーター を作成し、後でそれを JsonSerializerOptions に関連付けることができます。 また、JSON-RPC リクエストから直接 $.params の生のオブジェクトをメソッドで取得することもできます。 MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } これが発生するには、@params がメソッドの唯一のパラメーターで、正確に params (C# では @ でエスケープする必要があります) という名前でなければなりません。 パラメーターのデシリアライズは、名前付きオブジェクトまたは位置指定配列の両方で発生します。たとえば、次のメソッドは、両方のリクエストでリモートで呼び出されることができます。 [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } 配列の場合、パラメーターの順序に従う必要があります。 { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } シリアライザーのカスタマイズ JsonRpcHandler.JsonSerializerOptions プロパティで JSON シリアライザーをカスタマイズできます。このプロパティでは、メッセージのデシリアライズに JSON5 を使用できるようにすることができます。JSON-RPC 2.0 との準拠ではありませんが、JSON5 は、人間が読み書きしやすい JSON の拡張です。 Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // 名前比較子を使用して、名前の比較を実行します。 // この比較子では、名前の文字と数字のみを比較し、他のシンボルは無視されます。 // 例: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // JSON5 を JSON インタープリターで有効にします。 // これを有効にした場合でも、プレーン JSON はまだ許可されます。 e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // POST /service ルートを JSON-RPC ハンドラーにマップします e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/jp/extensions/service-providers.html": {
    "href": "docs/jp/extensions/service-providers.html",
    "title": "サービス プロバイダー | Sisk",
    "keywords": "サービス プロバイダー サービス プロバイダーは、Sisk アプリケーションをさまざまな環境に移植するための方法です。ポータブルな構成ファイルを使用して、サーバーのポート、パラメーター、他のオプションを変更できます。各環境ごとにアプリケーション コードを変更する必要はありません。このモジュールは、Sisk の構築構文に依存し、UsePortableConfiguration メソッドを使用して構成できます。 構成プロバイダーは、IConfigurationProvider を実装して構成リーダーを提供し、任意の実装を受け取ることができます。デフォルトでは、Sisk では JSON 構成リーダーが提供されますが、INI ファイル用のパッケージもあります。独自の構成プロバイダーを作成し、次のように登録することもできます。 using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); 前述のように、デフォルトのプロバイダーは JSON ファイルです。デフォルトでは、service-config.json という名前のファイルが検索され、実行中のプロセスのカレント ディレクトリで検索されますが、実行可能ファイルのディレクトリではありません。 ファイル名を変更したり、Sisk が構成ファイルを検索する場所を指定したりすることもできます。 using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); 上記のコードは、実行中のプロセスのカレント ディレクトリで config.toml ファイルを検索します。如果見つからない場合は、実行可能ファイルのディレクトリで検索します。如果ファイルが存在しない場合、createIfDontExists パラメーターが尊重され、最後にテストされたパス（lookupDirectories に基づく）にファイルが作成され、エラーがコンソールに出力され、アプリケーションの初期化が阻止されます。 Tip INI 構成リーダーと JSON 構成リーダーのソース コードを参照して、IConfigurationProvider がどのように実装されるかを理解することができます。 JSON ファイルからの構成の読み取り デフォルトでは、Sisk では JSON ファイルから構成を読み取る構成プロバイダーが提供されます。このファイルは固定構造を持ち、次のパラメーターで構成されます。 { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // 構成ファイルもコメントをサポートします ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // 0.14 で新しく追加されました \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } 構成ファイルから作成されたパラメーターは、サーバーのコンストラクターでアクセスできます。 using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); 各構成リーダーは、サーバーの初期化パラメーターを読み取る方法を提供します。プロセス環境で定義する必要がある一部のプロパティ (機密性の高い API データ、API キーなど) は、構成ファイルに定義するのではなく、プロセス環境で定義する必要があります。 構成ファイルの構造 JSON 構成ファイルは、次のプロパティで構成されます。 プロパティ 必須 説明 Server 必須 サーバー自身とその設定を表します。 Server.AccessLogsStream 省略可能 デフォルトは console。アクセス ログの出力ストリームを指定します。ファイル名、null、または console のいずれかになります。 Server.ErrorsLogsStream 省略可能 デフォルトは null。エラー ログの出力ストリームを指定します。ファイル名、null、または console のいずれかになります。 Server.MaximumContentLength 省略可能 Server.MaximumContentLength 省略可能 デフォルトは 0。コンテンツの最大長をバイト単位で指定します。0 は無制限を意味します。 Server.IncludeRequestIdHeader 省略可能 デフォルトは false。HTTP サーバーが X-Request-Id ヘッダーを送信するかどうかを指定します。 Server.ThrowExceptions 省略可能 デフォルトは true。未処理の例外をスローするかどうかを指定します。プロダクション環境では false、デバッグ環境では true に設定します。 ListeningHost 必須 サーバーのリスニング ホストを表します。 ListeningHost.Label 省略可能 アプリケーションのラベルを表します。 ListeningHost.Ports 必須 ListeningPort 構文に一致する文字列の配列を表します。 ListeningHost.CrossOriginResourceSharingPolicy 省略可能 アプリケーションの CORS ヘッダーを設定します。 ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials 省略可能 デフォルトは false。Allow-Credentials ヘッダーを指定します。 ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders 省略可能 デフォルトは null。文字列の配列を期待します。Expose-Headers ヘッダーを指定します。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin 省略可能 デフォルトは null。文字列を期待します。Allow-Origin ヘッダーを指定します。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins 省略可能 デフォルトは null。文字列の配列を期待します。複数の Allow-Origin ヘッダーを指定します。詳細については、AllowOrigins を参照してください。 ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods 省略可能 デフォルトは null。文字列の配列を期待します。Allow-Methods ヘッダーを指定します。 ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders 省略可能 デフォルトは null。文字列の配列を期待します。Allow-Headers ヘッダーを指定します。 ListeningHost.CrossOriginResourceSharingPolicy.MaxAge 省略可能 デフォルトは null。整数を期待します。Max-Age ヘッダーを秒単位で指定します。 ListeningHost.Parameters 省略可能 アプリケーションの設定メソッドに提供されるプロパティを指定します。"
  },
  "docs/jp/extensions/ssl-proxy.html": {
    "href": "docs/jp/extensions/ssl-proxy.html",
    "title": "SSL Proxy | Sisk",
    "keywords": "SSL Proxy Warning この機能は実験的であり、運用環境では使用しないでください。Sisk を SSL で動作させる方法については、このドキュメント を参照してください。 Sisk SSL Proxy は、Sisk の ListeningHost に HTTPS 接続を提供し、HTTPS メッセージを非安全な HTTP コンテキストにルーティングするモジュールです。このモジュールは、SSL をサポートしない HttpListener を使用して実行されるサービスに SSL 接続を提供するために構築されました。 プロキシは同じアプリケーション内で実行され、HTTP/1.1 メッセージをリッスンし、同じプロトコルで Sisk に転送します。現在、この機能は非常に実験的であり、運用環境で使用するには不安定すぎる可能性があります。 現在、SslProxy は、キープアライブ、チャンク化されたエンコード、WebSockets など、ほとんどの HTTP/1.1 機能をサポートしています。SSL プロキシへのオープン接続の場合、ターゲット サーバーに TCP 接続が作成され、プロキシは確立された接続に転送されます。 SslProxy は、次のように HttpServer.CreateBuilder と共に使用できます。 using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // プロジェクトに SSL を追加 .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); プロキシに有効な SSL 証明書を提供する必要があります。ブラウザによって証明書が受け入れられるようにするには、オペレーティング システムに証明書をインポートして、正しく機能するようにします。"
  },
  "docs/jp/faq.html": {
    "href": "docs/jp/faq.html",
    "title": "Frequently Asked Questions | Sisk",
    "keywords": "Frequently Asked Questions Sisk に関するよくある質問。 Sisk はオープンソースですか？ 完全に。Sisk で使用されるすべてのソースコードは、GitHub で公開され、頻繁に更新されています。 貢献は受け付けますか？ Sisk の哲学 と互換性がある限り、すべての貢献は大歓迎です！貢献はコードに限りません。ドキュメント、テスト、翻訳、寄付、投稿など、さまざまな形で貢献できます。 Sisk は資金提供されていますか？ いいえ。現在、Sisk はどの組織やプロジェクトからも資金提供を受けておりません。 Sisk を本番環境で使用できますか？ 絶対に。プロジェクトは 3 年以上開発されており、商用アプリケーションでのテストが行われてきました。Sisk は、重要な商用プロジェクトの主要インフラストラクチャとして使用されています。 さまざまなシステムや環境での デプロイ 方法についてのガイドが書かれており、利用可能です。 Sisk には認証、監視、データベースサービスがありますか？ いいえ。Sisk にはこれらのサービスはありません。Sisk は HTTP Web アプリケーションの開発フレームワークですが、まだ最小限のフレームワークであり、アプリケーションが動作するために必要なものだけを提供します。 好みの任意のサードパーティライブラリを使用して、必要なサービスをすべて実装できます。Sisk は、汎用的なシナリオを埋めるために作成され、柔軟性と、他のすべてとの互換性を保っています。 なぜ Sisk を <フレームワーク> よりも使用するべきですか？ わかりません。你が教えてください。 Sisk は、.NET の HTTP Web アプリケーションの汎用的なシナリオを埋めるために作成されました。既存のプロジェクト、たとえば ASP.NET は、さまざまな問題を解決しますが、異なる偏見で解決します。大きいフレームワークとは異なり、Sisk では、ユーザーが何をしているのか、そして何を構築しているのかを知っている必要があります。Web 開発と HTTP プロトコルの基本的な概念は、Sisk を使用するために不可欠です。 Sisk は、Node.js の Express よりも ASP.NET Core に近いです。HTTP ロジックが必要なアプリケーションを作成できる、高レベルの抽象化を提供します。 Sisk を学ぶために何が必要ですか？ 以下の基本的な知識が必要です： Web 開発 (HTTP、Restful など) .NET これら 2 つのトピックについての基本的な知識があると、Sisk で高度なアプリケーションを開発するのに数時間を費やすことができます。 Sisk を使用して商用アプリケーションを開発できますか？ 絶対に。 Sisk は MIT ライセンスの下で作成されており、Sisk を使用して商用プロジェクトや非商用プロジェクトを作成できます。ただし、プロジェクトで使用されているオープンソースプロジェクトについての通知をどこかに表示し、Sisk も使用されていることを示す必要があります。"
  },
  "docs/jp/features/content-streaming.html": {
    "href": "docs/jp/features/content-streaming.html",
    "title": "コンテンツのストリーミング | Sisk",
    "keywords": "コンテンツのストリーミング Sisk では、クライアントとサーバー間でコンテンツのストリーミングを読み書きすることができます。この機能は、リクエストの生存期間中にコンテンツのシリアル化とデシリアル化のメモリ負荷を削減するために役立ちます。 リクエストコンテンツストリーム 小さなコンテンツは自動的に HTTP 接続バッファメモリに読み込まれ、HttpRequest.Body と HttpRequest.RawBody に迅速に読み込まれます。より大きなコンテンツの場合は、HttpRequest.GetRequestStream メソッドを使用してリクエストコンテンツ読み取りストリームを取得できます。 HttpRequest.GetMultipartFormContent メソッドは、リクエスト全体のコンテンツをメモリに読み込むため、大きなコンテンツを読み取るには適していないことに注意してください。 以下の例を考えてみましょう: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // リクエストにコンテンツがありません return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"ファイルが正常に送信されました。\" } ) }; } 上記の例では、UploadDocument メソッドはリクエストコンテンツを読み取り、コンテンツをファイルに保存します。Stream.CopyToAsync で使用される読み取りバッファ以外に、追加のメモリ割り当ては行われません。上記の例は、非常に大きなファイルの場合にメモリ割り当ての負担を削減し、アプリケーションのパフォーマンスを最適化するのに役立ちます。 良い実践は、ファイルの送信などの時間のかかる操作では、常に CancellationToken を使用することです。これは、クライアントとサーバーの間のネットワーク速度に依存するためです。 CancellationToken での調整は、以下のように行うことができます: Controller/UploadDocument.cs C# // 30 秒のタイムアウトに達した場合、以下のキャンセルトークンは例外をスローします。 CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"アップロードが最大アップロード時間 (30 秒) を超えました。\" } ) }; } レスポンスコンテンツストリーム レスポンスコンテンツを送信することも可能です。現在、HttpRequest.GetResponseStream メソッドと StreamContent タイプのコンテンツを使用するという 2 つの方法があります。 画像ファイルを提供するシナリオを考えてみましょう。以下のコードを使用できます: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // プロファイル画像を取得するための例メソッド var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } 上記のメソッドは、画像コンテンツを読み取るたびにメモリ割り当てを行います。画像が大きい場合、これによりパフォーマンスの問題が発生し、ピーク時にはメモリオーバーロードによりサーバーがクラッシュする可能性があります。このような状況では、キャッシングは役立ちますが、ファイルのためにメモリが依然として予約されるため、問題を完全に解決することはできません。キャッシングは、毎回メモリを割り当てる必要性の圧力を軽減するのに役立ちますが、大きなファイルの場合は十分ではありません。 画像をストリームで送信することが問題の解決策となります。画像コンテンツ全体を読み取るのではなく、ファイル上で読み取りストリームを作成し、クライアントに小さなバッファを使用してコピーします。 GetResponseStream メソッドを使用した送信 HttpRequest.GetResponseStream メソッドは、HTTP 応答のコンテンツフローが準備されるにつれて、HTTP 応答のチャンクを送信できるオブジェクトを作成します。このメソッドはより手動で、コンテンツを送信する前にステータス、ヘッダー、コンテンツサイズを定義する必要があります。 Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // この形式の送信では、ステータスとヘッダーを事前に定義する必要があります。 var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // この形式の送信では、コンテンツサイズも事前に定義する必要があります。 requestStreamManager.SetContentLength ( fs.Length ); // コンテンツサイズがわからない場合は、チャンク化されたエンコードを使用してコンテンツを送信できます。 requestStreamManager.SendChunked = true; // その後、出力ストリームに書き込みます。 await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } StreamContent を使用したコンテンツの送信 StreamContent クラスを使用すると、データソースからバイトストリームとしてコンテンツを送信できます。この形式の送信は、以前の要件を削除し、圧縮エンコード を使用してコンテンツサイズを削減することもできます。 Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important このタイプのコンテンツでは、ストリームを using ブロックで囲むことは避けてください。コンテンツフローが終了すると、HTTP サーバーによってコンテンツが自動的に破棄されます。"
  },
  "docs/jp/features/cors.html": {
    "href": "docs/jp/features/cors.html",
    "title": "CORS（クロスオリジンリソース共有）をSiskで有効にする | Sisk",
    "keywords": "CORS（クロスオリジンリソース共有）をSiskで有効にする Siskには、サービスを公開する際にCORS（クロスオリジンリソース共有）を処理するためのツールがあります。この機能はHTTPプロトコルの一部ではなく、W3Cによって定義されたWebブラウザーの特定の機能です。このセキュリティメカニズムにより、Webページは提供されたWebページと異なるドメインへのリクエストを送信することができません。サービスプロバイダーは、特定のドメインまたは1つのドメインにリソースへのアクセスを許可できます。 同一オリジン リソースが「同一オリジン」として識別されるためには、リクエストにはオリジンヘッダーが含まれている必要があります。 GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... そして、リモートサーバーは、リクエストされたオリジンと同じ値を持つAccess-Control-Allow-Originヘッダーで応答する必要があります。 HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... この検証は明示的です。ホスト、ポート、プロトコルは、リクエストされたものと同じでなければなりません。次の例を確認してください。 サーバーは、Access-Control-Allow-Originがhttps://example.comであることを応答します。 https://example.net - ドメインが異なります。 http://example.com - スキームが異なります。 http://example.com:5555 - ポートが異なります。 https://www.example.com - ホストが異なります。 仕様では、ヘッダーの構文は、リクエストとレスポンスの両方に許可されます。URLパスは無視されます。デフォルトのポート（HTTPの80、HTTPSの443）である場合は、ポートは省略されます。 Origin: null Origin: <scheme>://<hostname> Origin: <scheme>://<hostname>:<port> CORSを有効にする ネイティブに、CrossOriginResourceSharingHeadersオブジェクトがListeningHost内にあります。 サーバーを初期化するときにCORSを構成できます。 static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } 上記のコードは、すべてのレスポンスに対して次のヘッダーを送信します。 HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type これらのヘッダーは、エラーとリダイレクトを含むすべてのWebクライアントへのレスポンスに送信される必要があります。 CrossOriginResourceSharingHeadersクラスには、2つの似たプロパティがあります。AllowOriginとAllowOriginsです。1つは単数形、もう1つは複数形です。 AllowOriginプロパティは静的です。指定したオリジンだけがすべてのレスポンスに送信されます。 AllowOriginsプロパティは動的です。サーバーは、リクエストのオリジンがこのリストに含まれているかどうかを確認します。如果見つかった場合、そのオリジンのレスポンスに送信されます。 オリジンでのワイルドカード 代わりに、レスポンスのオリジンでワイルドカード(*)を使用して、任意のオリジンがリソースにアクセスできるように指定できます。ただし、この値は、資格情報（認証ヘッダー）を持つリクエストには許可されず、この操作はエラーになります。 この問題を回避するには、AllowOriginsプロパティを使用して、許可されるオリジンを明示的にリストするか、またはAllowOriginプロパティの値にAutoAllowOrigin定数を使用できます。このマジックプロパティは、Access-Control-Allow-OriginヘッダーをリクエストのOriginヘッダーの値と同じ値に定義します。 CORSを適用する他の方法 サービスプロバイダーを扱っている場合は、構成ファイルで定義された値をオーバーライドできます。 static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // 構成ファイルで定義されたオリジンをオーバーライドします。 cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } 特定のルートでのCORSの無効化 UseCorsプロパティは、ルートとすべてのルート属性で使用でき、次の例のように無効にできます。 [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } レスポンスの値の置き換え ルーター アクションで値を明示的に置き換えるまたは削除することができます。 [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Access-Control-Allow-Credentialsヘッダーを削除します。 request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Access-Control-Allow-Originを置き換えます。 request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } プリフライトリクエスト プリフライトリクエストは、クライアントが実際のリクエストを送信する前に送信するOPTIONSメソッドのリクエストです。 Siskサーバーは、適用可能なCORSヘッダーとともに200 OKでリクエストに応答し、クライアントは実際のリクエストを続行できます。この条件は、ルートがRouteMethodをOptionsに明示的に構成した場合を除き、適用されません。 CORSのグローバルな無効化 これは不可能です。CORSを使用しない場合は、構成しないでください。"
  },
  "docs/jp/features/discard-syntax.html": {
    "href": "docs/jp/features/discard-syntax.html",
    "title": "Discard syntax | Sisk",
    "keywords": "Discard syntax HTTPサーバーは、OAuth認証などのアクションからのコールバック要求を待ち受けるために使用でき、要求を受け取った後には破棄できます。これは、バックグラウンドアクションが必要だが、HTTPアプリケーションを設定したくない場合に便利です。 以下の例は、CreateListenerを使用してポート5555でリスニングHTTPサーバーを作成し、次のコンテキストを待つ方法を示しています。 using (var server = HttpServer.CreateListener(5555)) { // 次のHTTP要求を待つ var context = await server.WaitNextAsync(); Console.WriteLine($\"要求されたパス: {context.Request.Path}\"); } WaitNext関数は、完了した要求処理の次のコンテキストを待ちます。この操作の結果が取得されると、サーバーはすでに要求を完全に処理し、クライアントに応答を送信しています。"
  },
  "docs/jp/features/instancing.html": {
    "href": "docs/jp/features/instancing.html",
    "title": "依存性注入 | Sisk",
    "keywords": "依存性注入 リクエストの生存期間中に存在するメンバーとインスタンスを専用にすることは一般的です。たとえば、データベース接続、認証されたユーザー、またはセッション トークンなどです。可能性の 1 つは、HttpContext.RequestBag を使用することです。これは、リクエストの生存期間中に存在する辞書を作成します。 この辞書は、リクエスト ハンドラー によってアクセスされ、リクエスト全体で変数を定義できます。たとえば、ユーザーを認証するリクエスト ハンドラーは、HttpContext.RequestBag 内にユーザーを設定し、リクエスト ロジック内では、HttpContext.RequestBag.Get<User>() でユーザーを取得できます。 以下は例です。 RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } これは、この操作の初期的な例です。User のインスタンスは、認証用のリクエスト ハンドラー内で作成されました。AuthenticateUser リクエスト ハンドラーを使用するすべてのルートには、HttpContext.RequestBag 内に User が存在することが保証されます。 RequestBag 内に事前に定義されていないインスタンスを取得するロジックを定義するには、GetOrAdd または GetOrAddAsync のようなメソッドを使用できます。 バージョン 1.3 以降、静的プロパティ HttpContext.Current が導入され、現在実行中のリクエスト コンテキストの HttpContext にアクセスできるようになりました。これにより、リクエスト外部で HttpContext のメンバーにアクセスし、ルート オブジェクト内でインスタンスを定義できるようになりました。 以下の例では、リクエスト コンテキストで一般的にアクセスされるメンバーを持つコントローラーを定義します。 Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // DbContext を作成または既存のものを取得 return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // 次の行は、プロパティがリクエスト バッグ内に定義されていない場合に例外をスローします public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // HttpRequest インスタンスの公開もサポートされます public HttpRequest Request { get => HttpContext.Current.Request; } } コントローラーから継承するタイプを定義します。 Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } 上記の例では、ルーターに 値ハンドラー を構成する必要があります。ルーターによって返されるオブジェクトが有効な HttpResponse に変換されるようにします。 メソッドに HttpRequest request 引数がないことに注意してください。これは、バージョン 1.3 以降、ルーターがルーティング応答の 2 つの種類のデリゲートをサポートしているためです。1 つは、デフォルトのデリゲートである RouteAction で、HttpRequest 引数を受け取ります。もう 1 つは、ParameterlessRouteAction です。HttpRequest オブジェクトは、静的な HttpContext の Request プロパティを介して、両方のデリゲートからアクセスできます。 上記の例では、破棄可能なオブジェクトである DbContext を定義しました。HTTP セッションが終了するときに、DbContext のすべてのインスタンスが破棄されることを確認する必要があります。これを実現するには、2 つの方法があります。1 つは、ルーターのアクションの後に実行される リクエスト ハンドラー を作成することです。もう 1 つは、カスタム サーバー ハンドラー を使用することです。 最初の方法では、RouterModule から継承される OnSetup メソッド内に直接リクエスト ハンドラーをインラインで作成できます。 Controllers/PostsController.cs C# public abstract class Controller : RouterModule { // ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // リクエスト ハンドラー コンテキスト内に定義された DbContext を取得し、破棄します ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Sisk バージョン 1.4 以降、プロパティ HttpServerConfiguration.DisposeDisposableContextValues が導入され、デフォルトで有効になりました。これは、HTTP セッションが閉じられたときに、コンテキスト バッグ内のすべての IDisposable 値を破棄するかどうかを定義します。 上記の方法では、HTTP 応答が終了したときに DbContext が破棄されることを保証します。他のメンバーも破棄する必要がある場合は、同様の方法を使用できます。 2 番目の方法では、HTTP セッションが終了したときに DbContext を破棄するカスタム サーバー ハンドラー を作成できます。 Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } そして、アプリケーション ビルダーで使用します。 Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); これは、コードのクリーンアップを処理し、リクエストの依存関係を使用されるモジュールの種類によって分離する方法です。これは、ASP.NET のようなフレームワークで依存性注入が使用されるのと似た方法です。"
  },
  "docs/jp/features/logging.html": {
    "href": "docs/jp/features/logging.html",
    "title": "ロギング | Sisk",
    "keywords": "ロギング Sisk を設定して、アクセスログとエラーログを自動的に書き込むことができます。ログのローテーション、拡張子、頻度を定義することもできます。 LogStream クラスは、ログを書き込むための非同期的な方法と、待機可能な書き込みキューを提供します。 この記事では、アプリケーションのロギングを設定する方法について説明します。 ファイルベースのアクセスログ ファイルにログを書き込むと、ファイルを開き、テキストを書き込み、そしてファイルを閉じます。ログの書き込みレスポンスを維持するために、この手順が採用されています。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } 上記のコードは、すべての受信リクエストを logs/access.log ファイルに書き込みます。ファイルが存在しない場合は自動的に作成されますが、フォルダは自動的に作成されません。logs/ ディレクトリを作成する必要はありません。LogStream クラスが自動的に作成します。 ストリームベースのロギング TextWriter オブジェクトのインスタンス (例: Console.Out) をコンストラクタに渡すことで、ログファイルを TextWriter オブジェクトに書き込むことができます。 Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ストリームベースのログの各メッセージの書き込みで、TextWriter.Flush() メソッドが呼び出されます。 アクセスログのフォーマット 定義済みの変数を使用して、アクセスログのフォーマットをカスタマイズできます。次の行を考えてみましょう。 config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; 次のようなメッセージが書き込まれます。 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] 次の表に従って、ログファイルをフォーマットできます。 値 これは何を表します 例 %dd 月の日 (2 桁でフォーマット) 05 %dmmm 月の完全な名前 July %dmm 月の略称 (3 文字) Jul %dm 月の番号 (2 桁でフォーマット) 07 %dy 年 (4 桁でフォーマット) 2023 %th 12 時間形式の時間 03 %tH 24 時間形式の時間 (HH) 15 %ti 分 (2 桁でフォーマット) 30 %ts 秒 (2 桁でフォーマット) 45 %tm ミリ秒 (3 桁でフォーマット) 123 %tz タイムゾーンのオフセット (UTC での合計時間) +03:00 %ri クライアントのリモート IP アドレス 192.168.1.100 %rm HTTP メソッド (大文字) GET %rs URI スキーム (http/https) https %ra URI の権威 (ドメイン) example.com %rh リクエストのホスト www.example.com %rp リクエストのポート 443 %rz リクエストのパス /path/to/resource %rq クエリ文字列 ?key=value&another=123 %sc HTTP 応答ステータスコード 200 %sd HTTP 応答ステータス説明 OK %lin 人間が読みやすいリクエストサイズ 1.2 KB %linr リクエストの生サイズ (バイト) 1234 %lou 人間が読みやすい応答サイズ 2.5 KB %lour 応答の生サイズ (バイト) 2560 %lms 経過時間 (ミリ秒) 120 %ls 実行ステータス Executed ログのローテーション Tip Sisk 0.15 以前では、この機能は Sisk.ServiceProvider パッケージでのみ使用できます。Sisk 0.16 以降では、この機能はコアパッケージに実装されています。 ログファイルを特定のサイズに達したときに、圧縮された .gz ファイルにローテーションするように HTTP サーバーを設定できます。サイズは、定義したしきい値で周期的にチェックされます。 config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); 上記のコードは、6 時間ごとに LogStream のファイルが 1MB の制限に達したかどうかをチェックします。達した場合は、ファイルを圧縮して .gz ファイルに保存し、access.log ファイルをクリーンアップします。 このプロセス中、ファイルへの書き込みはロックされ、圧縮とクリーンアップが完了するまで待機します。書き込みキューに蓄積されたすべての行は、圧縮とクリーンアップが完了するまで待機します。 この機能は、ファイルベースの LogStreams のみで動作します。 エラーロギング サーバーがデバッガーにエラーをスローしない場合、エラーはログに書き込まれます。エラーロギングを設定するには、次のコードを使用します。 config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); このプロパティは、エラーがコールバックまたは Router.CallbackErrorHandler プロパティによってキャッチされていない場合にのみ、ログに何かを書き込みます。 サーバーによって書き込まれるエラーには、常に日付と時刻、リクエストヘッダー (ボディは除く)、エラートレース、および内部例外トレース (存在する場合) が含まれます。 その他のロギングインスタンス アプリケーションには、0 個以上の LogStreams が存在できます。LogStreams の数に制限はありません。したがって、デフォルトのアクセスログまたはエラーログ以外のファイルにアプリケーションのログを送信することができます。 LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Application started at {0}\", DateTime.Now); LogStream の拡張 LogStream クラスを拡張して、カスタムフォーマットを書き込むことができます。Sisk の現在のログエンジンと互換性があります。以下の例では、Spectre.Console ライブラリを使用して、コンソールにカラフルなメッセージを書き込みます。 CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } リクエスト/レスポンスごとにカスタムログを自動的に書き込む別の方法は、HttpServerHandler を作成することです。以下の例は、ContextBag と HttpServerHandler を使用して、リクエストとレスポンスのボディを JSON でコンソールに書き込む方法を示しています。 Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // この時点で、接続は開かれており、クライアントはヘッダーを送信してコンテンツが JSON であることを指定しています。 // 次の行では、コンテンツを読み取り、リクエストに保存します。 // // リクエストアクションでコンテンツを読み取らない場合、クライアントにレスポンスを送信した後、コンテンツは GC によって収集される可能性があります。 // したがって、レスポンスを閉じた後、コンテンツは使用できなくなる可能性があります。 // _ = request.RawBody; // リクエストにヒントを追加して、JSON ボディが含まれていることを示します。 request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // CypherPotato.LightJson ライブラリを使用して JSON を整形します。 var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // 応答が JSON であることを確認します。 httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // 内部サーバーハンドリングステータスを取得します。 responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/jp/features/server-sent-events.html": {
    "href": "docs/jp/features/server-sent-events.html",
    "title": "Server Sent Events | Sisk",
    "keywords": "Server Sent Events Siskは、Server Sent Eventsをサポートしており、簡単に実装できます。クライアントにメッセージを送信するための使い捨て接続や永続接続を作成し、実行時に接続を取得して使用することができます。 この機能には、ブラウザによって課されるいくつかの制限があります。たとえば、テキストメッセージのみを送信でき、接続を永久に閉じることはできません。サーバー側で接続が閉じられた場合、クライアントは5秒ごとに再接続を試みます（一部のブラウザでは3秒ごと）。 これらの接続は、クライアントが情報を要求するたびにサーバーからクライアントにイベントを送信するために役立ちます。 SSE接続の作成 SSE接続は通常のHTTPリクエストのように動作しますが、レスポンスを送信してすぐに接続を閉じるのではなく、メッセージを送信するために接続が開いたままになります。 HttpRequest.GetEventSource()メソッドを呼び出すと、リクエストは待機状態になり、SSEインスタンスが作成されます。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"こんにちは、世界!\"); return sse.Close(); }); 上記のコードでは、SSE接続を作成し、「こんにちは、世界！」というメッセージを送信し、サーバー側からSSE接続を閉じます。 Note サーバー側で接続を閉じると、クライアントはデフォルトで再接続を試み、その接続は再開され、メソッドが再度実行されます。 クライアントが再接続しないように、サーバーが接続を閉じたときに終了メッセージを転送することが一般的です。 ヘッダーの追加 ヘッダーを送信する必要がある場合は、メッセージを送信する前にHttpRequestEventSource.AppendHeaderメソッドを使用できます。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"ヘッダーキー\", \"ヘッダー値\"); sse.Send(\"こんにちは！\"); return sse.Close(); }); ヘッダーを送信する前にメッセージを送信しないことが必要です。 待機-失敗接続 接続は通常、クライアント側の切断によりメッセージを送信できなくなると終了します。そのため、接続は自動的に終了し、クラスのインスタンスは破棄されます。 再接続しても、クラスのインスタンスは機能しません。以前の接続にリンクしているからです。場合によっては、この接続を後で必要とし、ルートのコールバックメソッドを介して管理したくないことがあります。 このため、識別子でSSE接続を識別し、後でそれを使用して、ルートのコールバック外でも取得できます。さらに、WaitForFailで接続をマークして、ルートを終了せず、接続を自動的に終了させません。 KeepAliveのSSE接続は、切断による送信エラーが発生するまでメソッドの実行を待機します。タイムアウトを設定することもできます。一定時間内にメッセージが送信されなかった場合、接続は終了し、実行が再開されます。 r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"私のインデックス接続\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // 15秒間メッセージが送信されなかった場合に接続を終了 return sse.Close(); }); 上記のメソッドは、接続を作成し、処理し、切断またはエラーを待ちます。 HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"私のインデックス接続\"); if (evs != null) { // 接続はまだアクティブです evs.Send(\"もう一度こんにちは！\"); } 上記のコードは、新しく作成された接続を探し、存在する場合にメッセージを送信します。 識別されたアクティブなサーバー接続はすべてHttpServer.EventSourcesコレクションで利用できます。このコレクションには、アクティブで識別された接続のみが保存されます。閉じられた接続はコレクションから削除されます。 Note アイドル接続を一定期間後に閉じるコンポーネント（Webプロキシ、HTTPカーネル、ネットワークドライバーなど）によって、キープアライブには制限があることに注意することが重要です。 したがって、定期的なpingを送信するか、接続が閉じられるまでの最大時間を延長して、接続を開いたままにすることが重要です。次のセクションを読んで、定期的なpingの送信について理解を深めてください。 接続のpingポリシーの設定 Pingポリシーは、クライアントに定期的なメッセージを送信する自動化された方法です。この機能により、サーバーはクライアントが接続から切断したかどうかを理解できます。 [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"pingメッセージ\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } 上記のコードでは、5秒ごとに新しいpingメッセージがクライアントに送信されます。これにより、TCP接続がアクティブなままになり、非アクティブにより接続が閉じられることがなくなります。また、メッセージの送信に失敗した場合、接続は自動的に閉じられ、接続で使用されるリソースが解放されます。 接続のクエリ 識別子に基づく述語を使用してアクティブな接続を検索することができます。たとえば、ブロードキャストなどです。 HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"私の接続-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"'私の接続-'で始まるすべてのイベントソースへのブロードキャスト\"); } Allメソッドを使用して、すべてのアクティブなSSE接続を取得することもできます。"
  },
  "docs/jp/features/websockets.html": {
    "href": "docs/jp/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets SiskはWebソケットをサポートしており、クライアントへのメッセージの受信と送信が可能です。 この機能はほとんどのブラウザで正常に動作しますが、Siskではまだ実験的な段階です。バグを見つけた場合は、githubに報告してください。 非同期メッセージの受信と受け取り 以下の例は、WebSocketが実際にどのように動作するかを示しています。接続の開始、メッセージの受信、コンソールへの表示の例です。 WebSocketで受信されたすべてのメッセージはバイトとして受信されるため、受信時にデコードする必要があります。 デフォルトでは、メッセージはチャンクに分割され、最後の部分はメッセージの最終パケットとして送信されます。パケットサイズは、 WebSocketBufferSizeフラグで構成できます。このバッファリングは、メッセージの送信と受信の両方で同じです。 router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // メッセージを受信したHttpWebSocketコンテキストを取得します HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); Note このように非同期イベントを使用しないでください。HTTPサーバーのドメイン外で例外がスローされ、アプリケーションがクラッシュする可能性があります。 複数のメッセージを同時に処理し、非同期コードを処理する必要がある場合は、メッセージループを使用できます。 router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Received message: {messageText}\"); await ws.SendAsync(\"Hello from server!\"); } return ws.Close(); }); 同期メッセージの受信と受け取り 以下の例は、同期的なWebSocketの使用方法を示しています。非同期コンテキストを使用せずに、メッセージを受信し、処理し、ソケットの使用を終了します。 router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); メッセージの送信 Sendメソッドには、テキスト、バイト配列、またはバイトスパンを送信できる3つのオーバーロードがあります。サーバーの WebSocketBufferSizeフラグが総ペイロードサイズより大きい場合、すべてがチャンク化されます。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // UTF-8バイト配列としてエンコードされます ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } WebSocketのクローズを待つ メソッド WaitForClose() は、クライアントまたはサーバーによって接続が終了するまで、現在の呼び出しスタックをブロックします。 これにより、リクエストのコールバックの実行は、クライアントまたはサーバーが切断するまでブロックされます。 また、 Close()メソッドを使用して接続を手動で閉じることもできます。このメソッドは、クライアントに送信されない空の HttpResponseオブジェクトを返しますが、HTTPリクエストを受信した関数の戻り値として機能します。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // クライアントが接続を閉じるのを待つ ws.WaitForClose(); // 60秒間メッセージが交換されないか、またはいずれかのパーティが接続を閉じるまで待つ ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Pingポリシー サーバ側イベントのpingポリシーのように、TCP接続をアクティブに保つために、pingポリシーを構成することもできます。 ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/jp/fundamentals/request-handlers.html": {
    "href": "docs/jp/fundamentals/request-handlers.html",
    "title": "リクエストハンドリング | Sisk",
    "keywords": "リクエストハンドリング リクエストハンドラー、別名「ミドルウェア」と呼ばれるものは、リクエストがルーターで実行される前または後に実行される関数です。これらは、ルートごとまたはルーターごとに定義できます。 リクエストハンドラーには2つの種類があります。 BeforeResponse: リクエストハンドラーがルーターアクションを呼び出す前に実行されることを定義します。 AfterResponse: リクエストハンドラーがルーターアクションを呼び出した後に実行されることを定義します。このコンテキストでHTTPレスポンスを送信すると、ルーターアクションのレスポンスが上書きされます。 両方のリクエストハンドラーは、実際のルーターコールバック関数のレスポンスを上書きできます。さらに、リクエストハンドラーは、認証、コンテンツ、またはその他の情報の検証に役立ちます。また、情報を保存したり、ログを記録したり、レスポンスの前または後に実行できる他のステップもあります。 このように、リクエストハンドラーは実行を中断し、サイクルを終了する前にレスポンスを返すことができます。その他のプロセスは破棄されます。 例: ユーザー認証リクエストハンドラーがユーザーを認証しないとします。リクエストライフサイクルは続行されず、ハングします。リクエストハンドラーが2番目の位置にある場合、3番目以降のハンドラーは評価されません。 リクエストハンドラーの作成 リクエストハンドラーを作成するには、IRequestHandler インターフェイスを継承するクラスを作成できます。 Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // nullを返すと、リクエストサイクルが続行されます return null; } else { // HttpResponseオブジェクトを返すと、隣接するレスポンスが上書きされます return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 上記の例では、Authorizationヘッダーがリクエストに存在する場合、続行し、次のリクエストハンドラーまたはルーターコールバックが呼び出されるようにします。ExecutionModeプロパティによって、レスポンスの前または後に実行されるリクエストハンドラーを指定できます。非null値を返すと、ルーターのレスポンスが上書きされます。 リクエストハンドラーがnullを返すと、リクエストが続行され、次のオブジェクトが呼び出されるか、サイクルがルーターのレスポンスで終了します。 ルートへのリクエストハンドラーの関連付け ルートに1つまたは複数のリクエストハンドラーを定義できます。 Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // before request handler new ValidateJsonContentRequestHandler(), // before request handler // -- method IndexPage will be executed here new WriteToLogRequestHandler() // after request handler }); または、Route オブジェクトを作成できます。 Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); ルーターへのリクエストハンドラーの関連付け ルーター全体で実行されるグローバルリクエストハンドラーを定義できます。 Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; 属性へのリクエストハンドラーの関連付け ルート属性とともにメソッド属性にリクエストハンドラーを定義できます。 Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } } 注: リクエストハンドラータイプを渡す必要があります。インスタンスを渡すことはできません。そうすると、ルーターパーサーによってリクエストハンドラーがインスタンス化されます。コンストラクタ引数をConstructorArguments プロパティで渡すことができます。 例: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } 独自の属性を作成してRequestHandlerを実装することもできます。 Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } そして、次のように使用します。 Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } グローバルリクエストハンドラーのバイパス ルートにグローバルリクエストハンドラーを定義した後、特定のルートでそれを無視できます。 Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: グローバルリクエストハンドラーと同じインスタンス new AuthenticateUserRequestHandler() // wrong: グローバルリクエストハンドラーはスキップされません } }); Note リクエストハンドラーをバイパスする場合、同じ参照を使用してスキップする必要があります。別のリクエストハンドラーインスタンスを作成すると、グローバルリクエストハンドラーはスキップされません。グローバルリクエストハンドラーとバイパスグローバルリクエストハンドラーの両方で同じリクエストハンドラー参照を使用することを確認してください。"
  },
  "docs/jp/fundamentals/requests.html": {
    "href": "docs/jp/fundamentals/requests.html",
    "title": "リクエスト | Sisk",
    "keywords": "リクエスト リクエストは、HTTP リクエスト メッセージを表す構造体です。HttpRequest オブジェクトには、HTTP メッセージをアプリケーション全体で処理するための便利な関数が含まれています。 HTTP リクエストは、メソッド、パス、バージョン、ヘッダー、ボディで構成されます。 このドキュメントでは、これらの要素を取得する方法について説明します。 リクエスト メソッドの取得 受信したリクエストのメソッドを取得するには、Method プロパティを使用できます。 static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } このプロパティは、HttpMethod オブジェクトとして表されるリクエストのメソッドを返します。 Note ルート メソッドとは異なり、このプロパティは RouteMethod.Any アイテムを提供しません。代わりに、実際のリクエスト メソッドを返します。 リクエスト URL コンポーネントの取得 リクエストの特定のプロパティを使用して、URL からさまざまなコンポーネントを取得できます。次の例では、次の URL を考えてみましょう。 http://localhost:5000/user/login?email=foo@bar.com コンポーネント名 説明 コンポーネント値 Path リクエスト パスを取得します。 /user/login FullPath リクエスト パスとクエリ文字列を取得します。 /user/login?email=foo@bar.com FullUrl リクエストの完全な URL 文字列を取得します。 http://localhost:5000/user/login?email=foo@bar.com Host リクエストのホストを取得します。 localhost Authority リクエストのホストとポートを取得します。 localhost:5000 QueryString リクエストのクエリを取得します。 ?email=foo@bar.com Query リクエストのクエリを名前付き値コレクションとして取得します。 {StringValueCollection object} IsSecure リクエストが SSL (true) を使用しているかどうかを判断します。 false また、HttpRequest.Uri プロパティを使用して、上記のすべての情報を 1 つのオブジェクトで取得することもできます。 リクエスト ボディの取得 一部のリクエストには、フォーム、ファイル、または API トランザクションなどのボディが含まれています。リクエストのボディを取得するには、次のプロパティを使用できます。 // リクエストのボディを文字列として取得します (リクエストのエンコードを使用)。 string body = request.Body; // または、バイト配列として取得します。 byte[] bodyBytes = request.RawBody; // または、ストリームとして取得します。 Stream requestStream = request.GetRequestStream(); また、リクエストにボディが含まれているかどうか、およびボディが読み込まれているかどうかを判断するために、HasContents プロパティと IsContentAvailable プロパティを使用できます。 GetRequestStream メソッドでリクエスト コンテンツを読み取ることは 1 回のみ可能です。如果この方法で読み取ると、RawBody と Body の値は使用できなくなります。リクエストのコンテキストでは、リクエスト ストリームを破棄する必要はありません。HTTP セッションの終了時に自動的に破棄されます。また、HttpRequest.RequestEncoding プロパティを使用して、リクエストを手動でデコードするための最適なエンコードを取得することもできます。 サーバーには、HttpRequest.Body と HttpRequest.RawBody の両方に適用される、リクエスト コンテンツの読み取り制限があります。これらのプロパティは、入力ストリームのコンテンツを同じサイズのローカル バッファーにコピーします。HttpRequest.ContentLength。 クライアントが送信したコンテンツが HttpServerConfiguration.MaximumContentLength を超える場合、サーバーはクライアントにステータス 413 コンテンツが大きすぎるというレスポンスを返します。さらに、制限が設定されていない場合、または制限が大きすぎる場合、サーバーは OutOfMemoryException をスローします。ただし、コンテンツは依然としてストリーミングを介してアクセスできます。 Note Sisk では許可されていますが、HTTP セマンティクスに従ってアプリケーションを作成し、コンテンツを取得または提供するためにメソッドを使用しないことをお勧めします。RFC 9110 \"HTTP セマンティクス\" を参照してください。 リクエスト コンテキストの取得 HTTP コンテキストは、Sisk の独自オブジェクトであり、HTTP サーバー、ルート、ルーター、およびリクエスト ハンドラーの情報を格納します。これを使用して、これらのオブジェクトが難しい環境で自分自身を整理することができます。 RequestBag オブジェクトには、リクエスト ハンドラーから別のポイントに渡される情報が格納されています。このオブジェクトは、ルート コールバックの後に実行されるリクエスト ハンドラーによっても使用できます。 Tip このプロパティは、HttpRequest.Bag プロパティでもアクセスできます。 Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 上記のリクエスト ハンドラーは、リクエスト バッグに AuthenticatedUser を定義し、最終的なコールバックで使用できます。 Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } また、Bag.Set() および Bag.Get() ヘルパー メソッドを使用して、オブジェクトをそのタイプのシングルトンで取得または設定できます。 Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } フォーム データの取得 フォーム データの値を NameValueCollection で取得できます。 Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } マルチパート フォーム データの取得 Sisk の HTTP リクエストでは、ファイル、フォーム フィールド、またはバイナリ コンテンツなどのマルチパート コンテンツを取得できます。 Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // 次のメソッドは、リクエストの入力全体を MultipartObject の配列に読み取ります。 var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // マルチパート フォーム データで提供されたファイルの名前。 // ファイルでない場合は null が返されます。 Console.WriteLine(\"File name : \" + uploadedObject.Filename); // マルチパート フォーム データ オブジェクトのフィールド名。 Console.WriteLine(\"Field name : \" + uploadedObject.Name); // マルチパート フォーム データのコンテンツの長さ。 Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // 各認識された共通ファイル形式に基づいて、ファイル形式を決定します。 // ファイルが認識された共通ファイル形式でない場合は、MultipartObjectCommonFormat.Unknown が返されます。 Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } Sisk の Multipart form objects とそのメソッド、プロパティ、機能については、こちらを参照してください。 サーバー送信イベントのサポート Sisk では、サーバー送信イベントをサポートしており、チャンクをストリームとして送信し、サーバーとクライアントの間の接続を維持できます。 HttpRequest.GetEventSource メソッドを呼び出すと、HttpRequest がリッスン状態になります。この状態では、HTTP リクエストのコンテキストは、サーバー側イベントによって送信されるパケットと重複するため、HttpResponse は予想されません。 すべてのパケットを送信した後、コールバックは Close メソッドを返す必要があります。これにより、サーバーに最終的なレスポンスが送信され、ストリーミングが終了したことが示されます。 送信されるパケットの合計長は予測できないため、Content-Length ヘッダーで接続の終了を判断することはできません。 ほとんどのブラウザーの既定では、サーバー側イベントは GET メソッド以外の HTTP ヘッダーまたはメソッドをサポートしていないため、特定のヘッダーを要求するリクエスト ハンドラーを使用するイベント ソース リクエストに注意する必要があります。そうでない場合は、ヘッダーが存在しない可能性があります。 また、ほとんどのブラウザーは、クライアント側で EventSource.close メソッドが呼び出されない場合、ストリームを再開し、サーバー側で無限に追加の処理が行われる可能性があります。 この種の問題を避けるには、イベント ソースがすべてのパケットを送信したことを示す最終的なパケットを送信することが一般的です。 以下の例は、ブラウザーがサーバー側イベントをサポートするサーバーと通信する方法を示しています。 sse-example.html HTML <html> <body> <b>Fruits:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> そして、クライアントにメッセージを逐次的に送信します。 Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { await serverEvents.SendAsync(fruit); await Task.Delay(1500); } return serverEvents.Close(); } } このコードを実行すると、次の結果が期待されます。 プロキシされた IP とホストの解決 Sisk はプロキシと使用できます。したがって、クライアントとプロキシの間のトランザクションで、IP アドレスがプロキシ エンドポイントに置き換えられる可能性があります。 Sisk では、forwarding resolvers を使用して独自の解決策を定義できます。 ヘッダーのエンコード ヘッダーのエンコードは、一部の実装では問題になる可能性があります。Windows では、UTF-8 ヘッダーはサポートされていないため、ASCII が使用されます。Sisk には、不正にエンコードされたヘッダーをデコードするための組み込みエンコード コンバーターが含まれています。 この操作はコストがかかるため、デフォルトでは無効になっていますが、NormalizeHeadersEncodings フラグで有効にすることができます。"
  },
  "docs/jp/fundamentals/responses.html": {
    "href": "docs/jp/fundamentals/responses.html",
    "title": "レスポンス | Sisk",
    "keywords": "レスポンス レスポンスは、HTTP リクエストに対する HTTP レスポンスを表すオブジェクトです。これらは、サーバーからクライアントに、リソース、ページ、ドキュメント、ファイルまたはその他のオブジェクトのリクエストの完了を示すために送信されます。 HTTP レスポンスは、ステータス、ヘッダー、およびコンテンツで構成されます。 このドキュメントでは、Sisk を使用して HTTP レスポンスを構築する方法を説明します。 HTTP ステータスの設定 HTTP ステータス一覧は、HTTP/1.0 以降同じであり、Sisk はすべてをサポートしています。 HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 または、Fluent Syntax を使用して: new HttpResponse() .WithStatus(200) // または .WithStatus(HttpStatusCode.Ok) // または .WithStatus(HttpStatusInformation.Ok); 使用可能な HttpStatusCode の一覧は、こちら で確認できます。また、HttpStatusInformation 構造体を使用して独自のステータス コードを指定することもできます。 ボディとコンテンツタイプ Sisk は、レスポンスのボディを送信するために .NET ネイティブ コンテント オブジェクトをサポートしています。たとえば、StringContent クラスを使用して JSON レスポンスを送信できます。 HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); サーバーは、ヘッダーで明示的に定義されていない場合、コンテンツから Content-Length を計算しようとします。サーバーがレスポンス コンテンツから Content-Length ヘッダーを暗黙のうちに取得できない場合、レスポンスは Chunked-Encoding で送信されます。 StreamContent を送信するか、GetResponseStream メソッドを使用してレスポンスをストリーミングすることもできます。 レスポンスヘッダ レスポンスで送信するヘッダを追加、編集、または削除できます。以下の例は、クライアントへのリダイレクト レスポンスを送信する方法を示しています。 HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); または、Fluent Syntax を使用して: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); HttpHeaderCollection の Add メソッドを使用すると、すでに送信されたヘッダを変更せずにヘッダをリクエストに追加します。Set メソッドは、同じ名前のヘッダを指定された値に置き換えます。HttpHeaderCollection のインデクサーは、内部的に Set メソッドを呼び出してヘッダを置き換えます。 クッキーの送信 Sisk には、クライアントでのクッキーの定義を容易にするメソッドがあります。このメソッドで設定されたクッキーは、すでに URL エンコードされ、RFC-6265 標準に適合しています。 HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); または、Fluent Syntax を使用して: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); このメソッドのより完全なバージョンは、こちら にあります。 チャンクレスポンス 大きなレスポンスを送信するために、転送エンコードをチャンクに設定できます。 HttpResponse res = new HttpResponse(); res.SendChunked = true; チャンクエンコードを使用する場合、Content-Length ヘッダーは自動的に省略されます。 レスポンスストリーム レスポンス ストリームは、管理された方法で、セグメント化された方法でレスポンスを送信できるようにします。これは、HttpResponse オブジェクトを使用するよりも低レベルの操作であり、ヘッダーとコンテンツを手動で送信し、接続を閉じる必要があります。 この例では、ファイルの読み取り専用ストリームを開き、ストリームをレスポンス出力ストリームにコピーし、ファイルをメモリにロードしません。これは、大きなファイルまたは中程度のファイルをサーブする場合に便利です。 // レスポンス出力ストリームを取得します using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // チャンクエンコードを使用するようにレスポンスエンコードを設定します // チャンクエンコードを使用する場合、Content-Length ヘッダーを送信しないでください responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // ファイルストリームをレスポンス出力ストリームにコピーします fileStream.CopyTo(responseStream.ResponseStream); // ストリームを閉じます return responseStream.Close(); GZip、Deflate、および Brotli 圧縮 Sisk で圧縮されたコンテンツを使用してレスポンスを送信できます。まず、以下の圧縮ツールで HttpContent オブジェクトをカプセル化して、クライアントに圧縮されたレスポンスを送信します。 router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // または Content = new BrotliContent(new HtmlContent(myHtml)), // または Content = new DeflateContent(new HtmlContent(myHtml)), }; }); これらの圧縮コンテンツをストリーミングで使用することもできます。 router.MapGet(\"/archive.zip\", request => { // ここで \"using\" を適用しないでください。HttpServer はレスポンスを送信した後でコンテンツを破棄します。 var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); これらのコンテンツを使用する場合、Content-Encoding ヘッダーは自動的に設定されます。 自動圧縮 EnableAutomaticResponseCompression プロパティを使用して、HTTP レスポンスを自動的に圧縮することができます。このプロパティは、ルーターからのレスポンス コンテンツを圧縮可能なコンテンツで自動的にカプセル化し、リクエストで受け入れられている場合にのみ圧縮を行います。レスポンスが CompressedContent から継承されていない場合に限り、圧縮が行われます。 1 つのリクエストに対して、1 つの圧縮コンテンツのみが選択され、Accept-Encoding ヘッダーに従って、以下の順序で選択されます。 BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) リクエストがこれらの圧縮方法のいずれを受け入れることを指定した場合、レスポンスは自動的に圧縮されます。 暗黙のレスポンスタイプ HttpResponse 以外の戻り値タイプを使用できますが、ルーターが各タイプのオブジェクトを処理する方法を構成する必要があります。 概念は、常に参照型を返し、それを有効な HttpResponse オブジェクトに変換することです。HttpResponse を返すルートは、変換を経ません。 値タイプ (構造体) は、RouterCallback と互換性がないため、戻り値のタイプとして使用できません。そのため、ValueResult でラッピングしてハンドラーで使用できるようにする必要があります。 以下の例は、戻り値のタイプとして HttpResponse を使用しないルーター モジュールの例です。 [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } これにより、ルーターが各タイプのオブジェクトを処理する方法を定義する必要があります。オブジェクトは常にハンドラーの最初の議論であり、出力タイプは有効な HttpResponse でなければなりません。また、ルートの出力オブジェクトは、決して null になることはできません。 ValueResult タイプの場合、入力オブジェクトが ValueResult であることを示す必要はなく、T のみで十分です。ValueResult は、その元のコンポーネントから反映されたオブジェクトであるためです。 タイプの関連付けは、登録されたものとルーター コールバックから返されたオブジェクトのタイプを比較しません。代わりに、ルーター結果のタイプが登録されたタイプに割り当て可能かどうかを確認します。 Object ハンドラーの登録は、以前に検証されていないすべてのタイプのフォールバックになります。値ハンドラーの挿入順序も重要であり、Object ハンドラーの登録は、他のタイプ固有のハンドラーを無視します。常に特定の値ハンドラーを最初に登録して、順序を確保してください。 Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // オブジェクトの値ハンドラーの登録は最後に実行する必要があります // このハンドラーはフォールバックとして使用されます r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); 列挙オブジェクトと配列に関する注意 IEnumerable を実装する暗黙のレスポンス オブジェクトは、ToArray() メソッドによってメモリに読み込まれ、定義された値ハンドラーによって変換されます。これが発生するには、IEnumerable オブジェクトがオブジェクトの配列に変換され、レスポンス コンバーターは、元のタイプではなく常に Object[] を受け取ります。 以下のシナリオを考えてみましょう。 using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"String array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Object array:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); 上記の例では、IEnumerable<string> コンバーターは呼び出されません。入力オブジェクトは常に Object[] であり、IEnumerable<string> に変換できません。ただし、以下に示すように、コンバーターが IEnumerable<object> を受け取る場合は、入力を受け取ります。 IAsyncEnumerable を実装する値は、ConvertIAsyncEnumerableIntoEnumerable プロパティが有効になっている場合、サーバーによって自動的に処理されます。非同期列挙は、ブロック列挙に変換され、オブジェクトの同期配列に変換されます。"
  },
  "docs/jp/fundamentals/routing.html": {
    "href": "docs/jp/fundamentals/routing.html",
    "title": "ルーティング | Sisk",
    "keywords": "ルーティング Routerは、サーバーを構築するための最初のステップです。ルーティングは、URLとそのメソッドをサーバーが実行するアクションにマッピングするエンドポイントであるRouteオブジェクトを保持する責任があります。各アクションは、リクエストを受信し、クライアントにレスポンスを配信する責任があります。 ルーティングは、パス式(\"パスパターン\")とそれがリッスンできるHTTPメソッドのペアです。リクエストがサーバーに送信されると、ルーティングは受信したリクエストに一致するルーティングを検索し、そのルーティングのアクションを呼び出し、結果のレスポンスをクライアントに配信します。 Siskでは、ルーティングを定義する方法は複数あります。静的、動的、または自動スキャンで定義できます。属性によって定義されることもあり、直接Routerオブジェクトで定義することもできます。 Router mainRouter = new Router(); // GET / ルーティングを次のアクションにマップ mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); ルーティングが何をできるかを理解するには、リクエストが何をできるかを理解する必要があります。HttpRequestには、必要なすべての情報が含まれています。Siskには、開発全体を高速化するいくつかの追加機能も含まれています。 サーバーが受信するすべてのアクションに対して、RouteActionタイプのデリゲートが呼び出されます。このデリゲートには、サーバーが受信したリクエストに関するすべての必要な情報を含むHttpRequestを保持するパラメーターが含まれています。このデリゲートの結果のオブジェクトは、HttpResponseまたは暗黙的なレスポンスタイプを介してそれにマップされるオブジェクトでなければなりません。 ルーティングのマッチング HTTPサーバーがリクエストを受信すると、Siskはリクエストを受信したパスの式を満たすルーティングを検索します。式は、常にルーティングとリクエストパスの間でテストされ、クエリ文字列は考慮されません。 このテストには優先順位はありません。単一のルーティングに排他的です。ルーティングがリクエストと一致しない場合、Router.NotFoundErrorHandlerレスポンスがクライアントに返されます。パスパターンが一致するが、HTTPメソッドが一致しない場合、Router.MethodNotAllowedErrorHandlerレスポンスがクライアントに返されます。 Siskは、ルーティングの衝突の可能性をチェックしてこれらの問題を避けます。ルーティングを定義するとき、Siskは定義されているルーティングと衝突する可能性のあるルーティングを検索します。このテストには、ルーティングのパスと受信するメソッドのチェックが含まれます. パスパターンを使用したルーティングの作成 ルーティングを定義するには、さまざまなSetRouteメソッドを使用できます。 // SetRoute方式 mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // Map*方式 mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 空の200 OK }); // Route.*ヘルパーメソッド mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // StreamContent内の // ストリームは、レスポンスを送信した後、破棄されます。 Content = new StreamContent(imageStream) }; }); // 複数のパラメーター mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); RouteParametersプロパティのHttpResponseには、受信したリクエストのパス変数に関するすべての情報が含まれています. サーバーが受信するすべてのパスは、パスパターンのテストが実行される前に、次のルールに従って正規化されます。 パスからすべての空のセグメントが削除されます。たとえば、////foo//barは/foo/barになります。 パスのマッチングは大文字/小文字を区別します。ただし、Router.MatchRoutesIgnoreCaseがtrueに設定されている場合は、区別しません。 QueryとRouteParametersプロパティのHttpRequestは、StringValueCollectionオブジェクトを返します。ここで、各インデックス付きプロパティは、nullでないStringValueを返します。これは、オプション/モナドとして使用して、生の値を管理されたオブジェクトに変換できます。 以下の例では、ルーティングパラメーター「id」を読み取り、それからGuidを取得します。パラメーターが有効なGuidでない場合、例外がスローされ、サーバーがRouter.CallbackErrorHandlerを処理していない場合は、クライアントに500エラーが返されます。 mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note パスの末尾の/は、リクエストパスとルーティングパスの両方で無視されます。つまり、ルーティングが/index/pageとして定義されている場合、/index/page/を使用してアクセスすることもできます。 ForceTrailingSlashフラグを有効にすると、URLを/で終わらせることもできます。 クラスインスタンスを使用したルーティングの作成 ルーティングを動的に定義するには、RouteAttribute属性を使用して、クラスのインスタンスを使用できます。この方法では、ターゲットルーターにルーティングが定義されます。 メソッドがルーティングとして定義されるには、RouteAttributeまたはRouteGetAttributeなどの属性でマークする必要があります。メソッドは静的、インスタンス、パブリック、またはプライベートにすることができます。SetObject(type)またはSetObject<TType>()メソッドを使用する場合、インスタンスメソッドは無視されます。 Controller/MyController.cs C# public class MyController { // GET / にマッチ [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // 静的メソッドも機能します [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } 以下の行は、MyControllerのIndexとHelloメソッドの両方をルーティングとして定義します。両方のメソッドがルーティングとしてマークされており、クラスのインスタンスが提供されているためです。クラスの型がインスタンスの代わりに提供された場合、静的メソッドのみが定義されます。 var myController = new MyController(); mainRouter.SetObject(myController); Siskバージョン0.16以降、AutoScanを有効にすることができます。これにより、RouterModuleを実装するユーザー定義のクラスを検索し、ルーターに自動的に関連付けられます。これは、AOTコンパイルではサポートされません。 mainRouter.AutoScanModules<ApiController>(); 上記の命令は、ApiControllerを実装するすべての型を検索しますが、型自体は検索しません。2つのオプションパラメーターは、メソッドがこれらの型を検索する方法を示します。最初の引数は、型を検索するアセンブリを示し、2番目の引数は、型が定義される方法を示します。 正規表現ルーティング デフォルトのHTTPパスマッチング方法を使用する代わりに、ルーティングを正規表現で解釈するようにマークできます。 Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); または、RegexRouteクラスを使用することもできます。 mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); })); 正規表現パターンからグループをキャプチャして、HttpRequest.RouteParametersの内容に含めることもできます。 Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } } ルーティングのプレフィックス クラスまたはモジュールのすべてのルーティングにプレフィックスを付けるには、RoutePrefix属性を使用できます。 以下の例は、BREADアーキテクチャー（Browse、Read、Edit、Add、Delete）を使用しています。 Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } 上記の例では、HttpResponseパラメーターは省略され、代わりにグローバルコンテキストHttpContext.Currentを介して使用されます。詳細については、次のセクションを参照してください。 リクエストパラメーターなしのルーティング ルーティングは、HttpRequestパラメーターなしで定義でき、依然としてリクエストとそのコンポーネントをリクエストコンテキストで取得できます。すべてのコントローラーの基礎となるControllerBase抽象化を考えてみましょう。この抽象化は、Requestプロパティを提供して、現在のHttpRequestを取得します。 Controller/ControllerBase.cs C# public abstract class ControllerBase { // 現在のスレッドからリクエストを取得します。 public HttpRequest Request { get => HttpContext.Current.Request; } // 次の行は、現在のHTTPセッションからデータベースを取得します。存在しない場合は、新しいものを作成します。 public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } そして、すべての派生クラスがリクエストパラメーターなしでルーティング構文を使用できるようにします。 Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // 現在のリクエストからJSONデータを読み取ります。 UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } 現在のコンテキストと依存性の注入の詳細については、依存性の注入チュートリアルを参照してください。 どのメソッドでもマッチするルーティング ルーティングを定義して、パスのみに基づいてマッチさせ、HTTPメソッドをスキップすることができます。これは、ルーティングのコールバック内でメソッドの検証を行う場合に便利です。 // どのHTTPメソッドでも / にマッチ mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); どのパスでもマッチするルーティング どのパスでもマッチするルーティングは、ルーティングメソッドをテストするサーバーからのすべてのリクエストにマッチします。ルーティングメソッドがRouteMethod.Anyで、ルーティングがRoute.AnyPathをパス式として使用している場合、このルーティングはサーバーからのすべてのリクエストをリッスンし、他のルーティングは定義できません。 // すべてのPOSTリクエストにマッチ mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); 大文字/小文字を無視するルーティングのマッチング デフォルトでは、ルーティングの解釈は大文字/小文字を区別します。無視するには、次のオプションを有効にします。 mainRouter.MatchRoutesIgnoreCase = true; これにより、正規表現マッチングを使用するルーティングのRegexOptions.IgnoreCaseオプションも有効になります。 見つからない (404) コールバック ハンドラー ルーティングが見つからない場合のカスタムコールバックを作成できます。 mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // v0.14以降 Content = new HtmlContent(\"<h1>Not found</h1>\") // 以前のバージョン Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; メソッドが許可されていない (405) コールバック ハンドラー パスが一致するがメソッドが一致しない場合のカスタムコールバックを作成することもできます。 mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; 内部エラーハンドラー ルーティングのコールバックは、サーバーの実行中にエラーをスローする可能性があります。適切に処理されない場合、HTTPサーバーの全体的な機能が中断される可能性があります。ルーターには、ルーティングのコールバックが失敗したときに呼び出されるコールバックがあります。 このメソッドは、ThrowExceptionsがfalseに設定されている場合にのみ到達されます。 mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/jp/getting-started.html": {
    "href": "docs/jp/getting-started.html",
    "title": "はじめに | Sisk",
    "keywords": "はじめに Sisk ドキュメントへようこそ！ 最後に、Sisk フレームワークとは何か？Sisk フレームワークは、.NET で構築されたオープンソースの軽量ライブラリで、最小限、柔軟、抽象的であることを目指して設計されています。開発者が、迅速に、必要な設定が少ない、またはまったくないで、インターネットサービスを作成できるようにします。Sisk により、既存のアプリケーションに、管理された HTTP モジュール、完全に破棄可能または完全なものを実現できます。 Sisk の価値観には、コードの透明性、モジュラー性、パフォーマンス、スケーラビリティがあり、Restful、JSON-RPC、Web-sockets などのさまざまなタイプのアプリケーションを処理できます。 主な機能には以下のものがあります： リソース 説明 ルーティング プレフィックス、カスタム メソッド、パス変数、値コンバーターなどをサポートするパス ルーター。 リクエスト ハンドラー ミドルウェアとしても知られており、リクエストの前または後に動作する独自のリクエスト ハンドラーを構築するためのインターフェイスを提供します。 圧縮 Sisk を使用して、レスポンス コンテンツを簡単に圧縮します。 Web ソケット 完全な Web ソケットを受け入れるルートを提供し、クライアントへの読み取りと書き込みを行います。 サーバー送信イベント SSE プロトコルをサポートするクライアントにサーバー イベントを送信します。 ログ ログの簡素化。エラー、ログ、サイズによるローテーション ログ、同じログの複数の出力ストリームなどをログに記録します。 マルチ ホスト HTTP サーバーを複数のポートで実行し、各ポートに独自のルーターを持ち、各ルーターに独自のアプリケーションを実行します。 サーバー ハンドラー HTTP サーバーの独自の実装を拡張します。拡張機能、改善、ニューフィーチャーでカスタマイズします。 最初のステップ Sisk は、任意の .NET 環境で実行できます。このガイドでは、.NET を使用して Sisk アプリケーションを作成する方法を説明します。まだインストールしていない場合は、こちらから SDK をダウンロードしてください。 このチュートリアルでは、プロジェクト構造の作成、リクエストの受信、URL パラメータの取得、レスポンスの送信について説明します。このガイドでは、C# を使用してシンプルなサーバーを構築することに焦点を当てています。好みのプログラミング言語を使用することもできます。 Note クイックスタート プロジェクトに興味がある場合は、このリポジトリを参照してください。 プロジェクトの作成 プロジェクト名を \"My Sisk Application\" とします。.NET を設定したら、次のコマンドを使用してプロジェクトを作成できます。 dotnet new console -n my-sisk-application 次に、プロジェクト ディレクトリに移動し、.NET ユーティリティ ツールを使用して Sisk をインストールします。 cd my-sisk-application dotnet add package Sisk.HttpServer Sisk をプロジェクトにインストールする方法については、こちらを参照してください。 ここで、HTTP サーバーのインスタンスを作成します。この例では、ポート 5000 でリッスンするように構成します。 HTTP サーバーの構築 Sisk では、HttpServer オブジェクトにルーティングすることで、アプリケーションを手動で段階的に構築できます。ただし、ほとんどのプロジェクトではこれは便利ではありません。したがって、ビルダー メソッドを使用して、アプリケーションを簡単に起動できます。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } Sisk の各重要なコンポーネントを理解することが重要です。このドキュメントの後半では、Sisk のしくみについてさらに詳しく説明します。 手動 (高度な) 設定 Sisk の各メカニズムの動作と、HttpServer、Router、ListeningPort、他のコンポーネント間の関係については、このセクションのドキュメントを参照してください。"
  },
  "docs/jp/installing.html": {
    "href": "docs/jp/installing.html",
    "title": "インストール | Sisk",
    "keywords": "インストール Sisk を Nuget、dotnet cli、または 他のオプション を介してインストールできます。開発者コンソールで次のコマンドを実行することで、Sisk 環境を簡単に設定できます。 dotnet add package Sisk.HttpServer このコマンドは、プロジェクトに Sisk の最新バージョンをインストールします。"
  },
  "docs/jp/native-aot.html": {
    "href": "docs/jp/native-aot.html",
    "title": "ネイティブAOTサポート | Sisk",
    "keywords": "ネイティブAOTサポート .NET Native AOTを使用すると、.NETランタイムがターゲットホストにインストールされていない場合でも、自己完結型のネイティブ.NETアプリケーションを公開できます。さらに、ネイティブAOTでは以下のような利点があります： アプリケーションのサイズが大幅に小さくなる 初期化が大幅に高速化する メモリ消費量が低くなる Sisk Frameworkは、明示的な性質により、ほとんどの機能でネイティブAOTを使用できます。ソースコードをネイティブAOTに適応させるためのリワークは不要です。 サポートされていない機能 ただし、Siskは一部の機能で反射を使用しています。以下に記載されている機能は、ネイティブコード実行中に部分的に利用可能または完全に利用不可になる可能性があります： モジュールの自動スキャン of the router: このリソースは、実行中のアセンブリに埋め込まれた型をスキャンし、ルーターモジュールである型を登録します。このリソースでは、アセンブリトリミング中に除外される可能性のある型が必要です。 Siskの他のすべての機能はAOTと互換性があります。AOT警告を出すメソッドが見つかることがありますが、ここに記載されていない場合は、型、パラメーター、または型情報を渡すオーバーロードがあり、AOTコンパイラがオブジェクトをコンパイルするのを支援します。"
  },
  "docs/jp/registering-namespace.html": {
    "href": "docs/jp/registering-namespace.html",
    "title": "Windowsでの名前空間予約の設定 | Sisk",
    "keywords": "Windowsでの名前空間予約の設定 SiskはHttpListenerネットワークインターフェイスを使用しており、仮想ホストをシステムにバインドしてリクエストを待ち受けます。 Windowsでは、このバインドは少し制限があり、localhostのみが有効なホストとしてバインドされます。他のホストをリッスンしようとすると、サーバーでアクセスが拒否されたエラーが発生します。このチュートリアルでは、システムで任意のホストをリッスンするための認証を付与する方法について説明します。 Namespace Setup.bat BATCH @echo off :: ここにプレフィックスを入力してください (スペースや引用符なし) SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause ここで、PREFIXは、サーバーがリッスンするプレフィックス(\"リスニングホスト->ポート\")です。URLスキーム、ホスト、ポート、末尾のスラッシュで構成する必要があります。例: Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ これにより、アプリケーションを介してリッスンできるようになります: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/jp/ssl.html": {
    "href": "docs/jp/ssl.html",
    "title": "SSL を使用する | Sisk",
    "keywords": "SSL を使用する 開発の際に SSL を使用する必要がある場合があります。たとえば、ほとんどの Web 開発シナリオではセキュリティが必要です。Sisk は HttpListener 上で動作しますが、HttpListener ではネイティブの HTTPS はサポートされず、HTTP のみがサポートされます。ただし、Sisk で SSL を使用できるようにするための回避策があります。以下にそれらを示します。 Windows で IIS を使用する 使用可能: Windows 努力: 中 Windows を使用している場合、IIS を使用して HTTP サーバーで SSL を有効にすることができます。この方法を使用するには、\"localhost\" 以外のホストでアプリケーションをリッスンさせたい場合は、事前に このチュートリアル を参照することをお勧めします。 この方法を使用するには、Windows 機能を介して IIS をインストールする必要があります。IIS は、Windows と Windows Server ユーザー向けに無料で提供されています。アプリケーションで SSL を構成するには、セルフサイン証明書であっても SSL 証明書を用意する必要があります。次に、IIS 7 またはそれ以降で SSL を設定する方法 を参照できます。 mitmproxy を使用する 使用可能: Linux, macOS, Windows 努力: 簡単 mitmproxy は、開発者とセキュリティ テスターがクライアント (たとえば Web ブラウザ) とサーバー之间の HTTP および HTTPS トラフィックを検査、変更、および記録できるようにするためのインターセプション プロキシ ツールです。mitmdump ユーティリティを使用して、クライアントと Sisk アプリケーションの間にリバース SSL プロキシを開始できます。 まず、mitmproxy をマシンにインストールします。 Sisk アプリケーションを開始します。この例では、8000 ポートを非安全な HTTP ポートとして使用します。 mitmproxy サーバーを開始して、8001 ポートでセキュア ポートをリッスンします。 mitmdump --mode reverse:http://localhost:8000/ -p 8001 これで完了です! すでに https://localhost:8001/ でアプリケーションを使用できます。mitmdump を開始するには、アプリケーションが実行中である必要はありません。 代わりに、プロジェクトに mitmproxy ヘルパー の参照を追加できます。ただし、mitmproxy がコンピューターにインストールされている必要があります。 Sisk.SslProxy パッケージを使用する 使用可能: Linux, macOS, Windows 努力: 簡単 Sisk.SslProxy パッケージは、Sisk アプリケーションで SSL を有効にするための簡単な方法です。ただし、このパッケージは 非常に実験的 です。このパッケージで作業することは不安定になる可能性がありますが、このパッケージを実用的なものにするために貢献する少数の人々の一人になることができます。開始するには、次のように Sisk.SslProxy パッケージをインストールできます。 dotnet add package Sisk.SslProxy Note Visual Studio パッケージ マネージャーで \"プレビュー パッケージの有効化\" を有効にする必要があります。 再び言いますが、このプロジェクトは実験的ですので、生产環境で使用することを考えるべきではありません。 現在、Sisk.SslProxy は、HTTP Continue、チャンク化、WebSockets、SSE を含むほとんどの HTTP/1.1 機能を処理できます。SslProxy についてさらに詳しくは こちら を参照してください。"
  },
  "docs/native-aot.html": {
    "href": "docs/native-aot.html",
    "title": "Native AOT Support | Sisk",
    "keywords": "Native AOT Support .NET Native AOT allows the publication of native .NET applications that are self-sufficient and do not require the .NET runtime installed on the target host. Additionally, Native AOT provides benefits such as: Much smaller applications Significantly faster initialization Lower memory consumption Sisk Framework, by its explicit nature, allows the use of Native AOT for almost all it's features without requiring rework on the source code to adapt it to Native AOT. Not supported features However, Sisk does use reflection, albeit minimal, for some features. The features mentioned below may be partially available or entirely unavailable during native code execution: Auto-scanning of modules of the router: this resource scans the types embedded in the executing Assembly and registers the types that are router modules. This resource requires types that can be excluded during assembly trimming. All other features are compatible with AOT in Sisk. It is common to find one or another method that gives an AOT warning, but the same, if not mentioned here, has an overload that indicates the passing of a type, parameter, or type information that assists the AOT compiler in compiling the object."
  },
  "docs/pt-br/advanced/forwarding-resolvers.html": {
    "href": "docs/pt-br/advanced/forwarding-resolvers.html",
    "title": "Forwarding Resolvers | Sisk",
    "keywords": "Forwarding Resolvers Um Forwarding Resolver é um auxiliar que ajuda a decodificar informações que identificam o cliente por meio de uma solicitação, proxy, CDN ou balanceadores de carga. Quando seu serviço Sisk é executado por meio de um proxy inverso ou avançado, o endereço IP, o host e o protocolo do cliente podem ser diferentes da solicitação original, pois é um encaminhamento de um serviço para outro. Essa funcionalidade do Sisk permite que você controle e resolva essas informações antes de trabalhar com a solicitação. Esses proxies geralmente fornecem cabeçalhos úteis para identificar seu cliente. Atualmente, com a classe ForwardingResolver, é possível resolver o endereço IP do cliente, o host e o protocolo HTTP usado. Após a versão 1.0 do Sisk, o servidor não possui mais uma implementação padrão para decodificar esses cabeçalhos por motivos de segurança que variam de serviço para serviço. Por exemplo, o cabeçalho X-Forwarded-For inclui informações sobre os endereços IP que encaminharam a solicitação. Este cabeçalho é usado por proxies para transportar uma cadeia de informações para o serviço final e inclui o IP de todos os proxies usados, incluindo o endereço real do cliente. O problema é: às vezes é desafiador identificar o IP remoto do cliente e não há uma regra específica para identificar este cabeçalho. É altamente recomendável ler a documentação dos cabeçalhos que você está prestes a implementar abaixo: Leia sobre o cabeçalho X-Forwarded-For aqui. Leia sobre o cabeçalho X-Forwarded-Host aqui. Leia sobre o cabeçalho X-Forwarded-Proto aqui. A classe ForwardingResolver Esta classe possui três métodos virtuais que permitem a implementação mais adequada para cada serviço. Cada método é responsável por resolver informações da solicitação por meio de um proxy: o endereço IP do cliente, o host da solicitação e o protocolo de segurança usado. Por padrão, o Sisk sempre usará as informações da solicitação original, sem resolver nenhum cabeçalho. O exemplo abaixo mostra como essa implementação pode ser usada. Este exemplo resolve o endereço IP do cliente através do cabeçalho X-Forwarded-For e lança um erro quando mais de um IP foi encaminhado na solicitação. [!IMPORTANTE] Não use este exemplo em código de produção. Verifique sempre se a implementação é apropriada para uso. Leia a documentação do cabeçalho antes de implementá-lo. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"O cabeçalho X-Forwarded-For está faltando.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Número excessivo de endereços no cabeçalho X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/pt-br/advanced/http-server-handlers.html": {
    "href": "docs/pt-br/advanced/http-server-handlers.html",
    "title": "Handlers de servidor HTTP | Sisk",
    "keywords": "Handlers de servidor HTTP Na versão 0.16 do Sisk, introduzimos a classe HttpServerHandler, que visa estender o comportamento geral do Sisk e fornecer manipuladores de eventos adicionais ao Sisk, como lidar com solicitações HTTP, roteadores, bolsas de contexto e muito mais. A classe concentra eventos que ocorrem durante a vida útil do servidor HTTP inteiro e também de uma solicitação. O protocolo HTTP não possui sessões e, portanto, não é possível preservar informações de uma solicitação para outra. O Sisk, por enquanto, fornece uma maneira para você implementar sessões, contextos, conexões de banco de dados e outros provedores úteis para ajudar no seu trabalho. Consulte esta página para saber onde cada evento é acionado e qual é o seu propósito. Você também pode visualizar o ciclo de vida de uma solicitação HTTP para entender o que acontece com uma solicitação e onde os eventos são disparados. O servidor HTTP permite que você use vários manipuladores ao mesmo tempo. Cada chamada de evento é síncrona, ou seja, bloqueará a thread atual para cada solicitação ou contexto até que todos os manipuladores associados a essa função sejam executados e concluídos. Ao contrário dos RequestHandlers, eles não podem ser aplicados a alguns grupos de rotas ou rotas específicas. Em vez disso, eles são aplicados a todo o servidor HTTP. Você pode aplicar condições dentro do seu Http Server Handler. Além disso, singletons de cada HttpServerHandler são definidos para cada aplicativo Sisk, portanto, apenas uma instância por HttpServerHandler é definida. Um exemplo prático de uso do HttpServerHandler é descartar automaticamente uma conexão de banco de dados no final da solicitação. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // verifica se a solicitação definiu um DbContext // em sua bolsa de contexto if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // permite que o usuário crie um dbcontext a partir de uma solicitação HTTP // e armazene-o em sua bolsa de contexto public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } Com o código acima, a extensão GetDbContext permite que uma conexão de contexto seja criada diretamente do objeto HttpRequest. Uma conexão não descartada pode causar problemas ao executar com o banco de dados, portanto, é encerrada em OnHttpRequestClose. Você pode registrar um manipulador em um servidor HTTP em seu construtor ou diretamente com HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } Com isso, a classe UsersController pode usar o contexto do banco de dados como: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } O código acima usa métodos como JsonOk e JsonMessage que são integrados ao ApiController, que é herdado de um RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Os desenvolvedores podem implementar sessões, contextos e conexões de banco de dados usando esta classe. O código fornecido mostra um exemplo prático com o DatabaseConnectionHandler, automatizando o descarte da conexão do banco de dados no final de cada solicitação. A integração é simples, com manipuladores registrados durante a configuração do servidor. A classe HttpServerHandler oferece um conjunto poderoso de ferramentas para gerenciar recursos e estender o comportamento do Sisk em aplicações HTTP."
  },
  "docs/pt-br/advanced/manual-setup.html": {
    "href": "docs/pt-br/advanced/manual-setup.html",
    "title": "Configuração manual (avançado) | Sisk",
    "keywords": "Configuração manual (avançado) Nesta seção, vamos criar nosso servidor HTTP sem nenhum padrão predefinido, de uma maneira completamente abstrata. Aqui, você pode construir manualmente como seu servidor HTTP funcionará. Cada ListeningHost possui um roteador, e um servidor HTTP pode ter vários ListeningHosts, cada um apontando para um host diferente em uma porta diferente. Primeiro, precisamos entender o conceito de solicitação/resposta. É bastante simples: para cada solicitação, deve haver uma resposta. O Sisk segue esse princípio também. Vamos criar um método que responda com uma mensagem \"Olá, Mundo!\" em HTML, especificando o código de status e cabeçalhos. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Olá, mundo!</h1> </body> </html> \") }; return indexResponse; } O próximo passo é associar esse método a uma rota HTTP. Roteadores Roteadores são abstrações de rotas de solicitação e servem como a ponte entre solicitações e respostas para o serviço. Roteadores gerenciam rotas de serviço, funções e erros. Um roteador pode ter várias rotas, e cada rota pode realizar diferentes operações naquele caminho, como executar uma função, servir uma página ou fornecer um recurso do servidor. Vamos criar nosso primeiro roteador e associar nosso método IndexPage ao caminho index. Router mainRouter = new Router(); // SetRoute associará todas as rotas index às nossas funções. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Agora nosso roteador pode receber solicitações e enviar respostas. No entanto, mainRouter não está vinculado a um host ou servidor, então ele não funcionará sozinho. O próximo passo é criar nosso ListeningHost. Hosts de Escuta e Portas Um ListeningHost pode hospedar um roteador e várias portas de escuta para o mesmo roteador. Um ListeningPort é um prefixo onde o servidor HTTP irá escutar. Aqui, podemos criar um ListeningHost que aponta para dois endpoints para nosso roteador: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Agora nosso servidor HTTP irá escutar os endpoints especificados e redirecionar suas solicitações para nosso roteador. Configuração do Servidor A configuração do servidor é responsável por grande parte do comportamento do servidor HTTP em si. Nesta configuração, podemos associar ListeningHosts ao nosso servidor. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Adicione nosso ListeningHost a esta configuração do servidor Em seguida, podemos criar nosso servidor HTTP: HttpServer server = new HttpServer(config); server.Start(); // Inicia o servidor Console.ReadKey(); // Previne o encerramento da aplicação Agora podemos compilar nosso executável e executar nosso servidor HTTP com o comando: dotnet watch Em tempo de execução, abra seu navegador e navegue até o caminho do servidor, e você deve ver:"
  },
  "docs/pt-br/advanced/multi-host-setup.html": {
    "href": "docs/pt-br/advanced/multi-host-setup.html",
    "title": "Configuração de vários hosts | Sisk",
    "keywords": "Configuração de vários hosts O Sisk Framework sempre suportou o uso de mais de um host por servidor, ou seja, um único servidor HTTP pode escutar em múltiplos portas e cada porta possui seu próprio roteador e seu próprio serviço em execução nela. Isso facilita a separação de responsabilidades e a gestão de serviços em um único servidor HTTP com o Sisk. O exemplo abaixo mostra a criação de dois ListeningHosts, cada um escutando em uma porta diferente, com roteadores e ações diferentes. Leia criação manual do seu aplicativo para entender os detalhes sobre essa abstração. static void Main(string[] args) { // criar dois hosts de escuta, cada um com seu próprio roteador e // escutando em sua própria porta // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Olá do host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Olá do host B!\")); // criar uma configuração do servidor e adicionar ambos // os hosts de escuta nela // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // cria um servidor HTTP que usa a configuração especificada // HttpServer server = new HttpServer(configuration); // inicia o servidor server.Start(); Console.WriteLine(\"Tente acessar o host A em {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Tente acessar o host B em {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/pt-br/advanced/request-lifecycle.html": {
    "href": "docs/pt-br/advanced/request-lifecycle.html",
    "title": "Ciclo de vida da requisição | Sisk",
    "keywords": "Ciclo de vida da requisição Abaixo é explicado o ciclo de vida completo de uma requisição por meio de um exemplo de requisição HTTP. Recebendo a requisição: cada requisição cria um contexto HTTP entre a requisição em si e a resposta que será entregue ao cliente. Esse contexto vem do ouvinte embutido no Sisk, que pode ser o HttpListener, Kestrel ou Cadente. Validação de requisição externa: a validação de HttpServerConfiguration.RemoteRequestsAction é validada para a requisição. Se a requisição for externa e a propriedade for Drop, a conexão é fechada sem uma resposta ao cliente com um HttpServerExecutionStatus = RemoteRequestDropped. Configuração do resolvedor de encaminhamento: se um ForwardingResolver estiver configurado, ele chamará o método OnResolveRequestHost no host original da requisição. Combinação de DNS: com o host resolvido e com mais de um ListeningHost configurado, o servidor procurará pelo host correspondente para a requisição. Se nenhum ListeningHost corresponder, uma resposta 400 Bad Request será retornada ao cliente e um status HttpServerExecutionStatus = DnsUnknownHost será retornado ao contexto HTTP. Se um ListeningHost corresponder, mas seu Router não estiver inicializado, uma resposta 503 Service Unavailable será retornada ao cliente e um status HttpServerExecutionStatus = ListeningHostNotReady será retornado ao contexto HTTP. Associação do roteador: o roteador do ListeningHost correspondente é associado ao servidor HTTP recebido. Se o roteador já estiver associado a outro servidor HTTP, o que não é permitido porque o roteador usa ativamente os recursos de configuração do servidor, uma InvalidOperationException será lançada. Isso ocorre apenas durante a inicialização do servidor HTTP, não durante a criação do contexto HTTP. Pré-definição de cabeçalhos: Pré-definir o cabeçalho X-Request-Id na resposta se estiver configurado para fazê-lo. Pré-definir o cabeçalho X-Powered-By na resposta se estiver configurado para fazê-lo. Validação do tamanho do conteúdo: valida se o conteúdo da requisição é menor que HttpServerConfiguration.MaximumContentLength apenas se for maior que zero. Se a requisição enviar um Content-Length maior que o configurado, uma resposta 413 Payload Too Large será retornada ao cliente e um status HttpServerExecutionStatus = ContentTooLarge será retornado ao contexto HTTP. O evento OnHttpRequestOpen é invocado para todos os manipuladores de servidor HTTP configurados. Roteando a ação: o servidor invoca o roteador para a requisição recebida. Se o roteador não encontrar uma rota que corresponda à requisição: Se a propriedade Router.NotFoundErrorHandler estiver configurada, a ação será invocada e a resposta da ação será encaminhada ao cliente HTTP. Se a propriedade anterior for nula, uma resposta 404 Not Found padrão será retornada ao cliente. Se o roteador encontrar uma rota correspondente, mas o método da rota não corresponder ao método da requisição: Se a propriedade Router.MethodNotAllowedErrorHandler estiver configurada, a ação será invocada e a resposta da ação será encaminhada ao cliente HTTP. Se a propriedade anterior for nula, uma resposta 405 Method Not Allowed padrão será retornada ao cliente. Se a requisição for do método OPTIONS: O roteador retornará uma resposta 200 Ok ao cliente apenas se nenhuma rota corresponder ao método da requisição (o método da rota não é explicitamente RouteMethod.Options). Se a propriedade HttpServerConfiguration.ForceTrailingSlash estiver habilitada, a rota correspondente não for uma expressão regular, o caminho da requisição não terminar com / e o método da requisição for GET: Uma resposta 307 Temporary Redirect HTTP com o cabeçalho Location com o caminho e a consulta para o mesmo local com um / no final será retornada ao cliente. O evento OnContextBagCreated é invocado para todos os manipuladores de servidor HTTP configurados. Todas as instâncias globais de IRequestHandler com a flag BeforeResponse são executadas. Se algum manipulador retornar uma resposta não nula, a resposta do manipulador será encaminhada ao cliente HTTP e o contexto será fechado. Se um erro for lançado nessa etapa e HttpServerConfiguration.ThrowExceptions estiver desabilitado: Se a propriedade Router.CallbackErrorHandler estiver habilitada, ela será invocada e a resposta resultante será retornada ao cliente. Se a propriedade anterior não estiver definida, uma resposta vazia será retornada ao servidor, que encaminhará uma resposta de acordo com o tipo de exceção lançada, que geralmente é 500 Internal Server Error. Todas as instâncias de IRequestHandler definidas na rota e com a flag BeforeResponse são executadas. Se algum manipulador retornar uma resposta não nula, a resposta do manipulador será encaminhada ao cliente HTTP e o contexto será fechado. Se um erro for lançado nessa etapa e HttpServerConfiguration.ThrowExceptions estiver desabilitado: Se a propriedade Router.CallbackErrorHandler estiver habilitada, ela será invocada e a resposta resultante será retornada ao cliente. Se a propriedade anterior não estiver definida, uma resposta vazia será retornada ao servidor, que encaminhará uma resposta de acordo com o tipo de exceção lançada, que geralmente é 500 Internal Server Error. A ação do roteador é invocada e transformada em uma resposta HTTP. Se um erro for lançado nessa etapa e HttpServerConfiguration.ThrowExceptions estiver desabilitado: Se a propriedade Router.CallbackErrorHandler estiver habilitada, ela será invocada e a resposta resultante será retornada ao cliente. Se a propriedade anterior não estiver definida, uma resposta vazia será retornada ao servidor, que encaminhará uma resposta de acordo com o tipo de exceção lançada, que geralmente é 500 Internal Server Error. Todas as instâncias globais de IRequestHandler com a flag AfterResponse são executadas. Se algum manipulador retornar uma resposta não nula, a resposta do manipulador substituirá a resposta anterior e será imediatamente encaminhada ao cliente HTTP. Se um erro for lançado nessa etapa e HttpServerConfiguration.ThrowExceptions estiver desabilitado: Se a propriedade Router.CallbackErrorHandler estiver habilitada, ela será invocada e a resposta resultante será retornada ao cliente. Se a propriedade anterior não estiver definida, uma resposta vazia será retornada ao servidor, que encaminhará uma resposta de acordo com o tipo de exceção lançada, que geralmente é 500 Internal Server Error. Todas as instâncias de IRequestHandler definidas na rota e com a flag AfterResponse são executadas. Se algum manipulador retornar uma resposta não nula, a resposta do manipulador substituirá a resposta anterior e será imediatamente encaminhada ao cliente HTTP. Se um erro for lançado nessa etapa e HttpServerConfiguration.ThrowExceptions estiver desabilitado: Se a propriedade Router.CallbackErrorHandler estiver habilitada, ela será invocada e a resposta resultante será retornada ao cliente. Se a propriedade anterior não estiver definida, uma resposta vazia será retornada ao servidor, que encaminhará uma resposta de acordo com o tipo de exceção lançada, que geralmente é 500 Internal Server Error. Processando a resposta: com a resposta pronta, o servidor a prepara para envio ao cliente. Os cabeçalhos da Política de Compartilhamento de Recursos de Origem Cruzada (CORS) são definidos na resposta de acordo com o que foi configurado no ListeningHost.CrossOriginResourceSharingPolicy atual. O código de status e os cabeçalhos da resposta são enviados ao cliente. O conteúdo da resposta é enviado ao cliente: Se o conteúdo da resposta for um descendente de ByteArrayContent, os bytes da resposta são copiados diretamente para o fluxo de saída da resposta. Se a condição anterior não for atendida, a resposta é serializada para um fluxo e copiada para o fluxo de saída da resposta. Os fluxos são fechados e o conteúdo da resposta é descartado. Se HttpServerConfiguration.DisposeDisposableContextValues estiver habilitado, todos os objetos definidos no contexto da requisição que herdam de IDisposable são descartados. O evento OnHttpRequestClose é invocado para todos os manipuladores de servidor HTTP configurados. Se uma exceção for lançada no servidor, o evento OnException é invocado para todos os manipuladores de servidor HTTP configurados. Se a rota permitir logging de acesso e HttpServerConfiguration.AccessLogsStream não for nulo, uma linha de log é escrita no fluxo de log de saída. Se a rota permitir logging de erros, houver uma exceção e HttpServerConfiguration.ErrorsLogsStream não for nulo, uma linha de log é escrita no fluxo de log de erros de saída. Se o servidor estiver aguardando uma requisição por meio de HttpServer.WaitNext, o mutex é liberado e o contexto se torna disponível para o usuário."
  },
  "docs/pt-br/changelogs.html": {
    "href": "docs/pt-br/changelogs.html",
    "title": "Histórico de Versões | Sisk",
    "keywords": "Histórico de Versões Todas as alterações feitas no Sisk são registradas no histórico de versões. Você pode visualizar os históricos de versões para todas as versões do Sisk aqui."
  },
  "docs/pt-br/deploying.html": {
    "href": "docs/pt-br/deploying.html",
    "title": "Implantando sua Aplicação Sisk | Sisk",
    "keywords": "Implantando sua Aplicação Sisk O processo de implantar uma aplicação Sisk consiste em publicar seu projeto em produção. Embora o processo seja relativamente simples, é importante notar detalhes que podem ser letais para a segurança e estabilidade da infraestrutura de implantação. Idealmente, você deve estar pronto para implantar sua aplicação na nuvem, após realizar todos os testes possíveis para ter sua aplicação pronta. Publicando sua aplicação Publicar sua aplicação ou serviço Sisk é gerar binários prontos e otimizados para produção. Neste exemplo, vamos compilar os binários para produção para executar em uma máquina que tenha o .NET Runtime instalado. Você precisará ter o .NET SDK instalado em sua máquina para compilar sua aplicação, e o .NET Runtime instalado no servidor de destino para executar sua aplicação. Você pode aprender como instalar o .NET Runtime em seu servidor Linux aqui, Windows e Mac OS. No diretório onde seu projeto está localizado, abra um terminal e use o comando de publicação do .NET: $ dotnet publish -r linux-x64 -c Release Isso gerará seus binários dentro de bin/Release/publish/linux-x64. Note Se sua aplicação estiver executando usando o pacote Sisk.ServiceProvider, você deve copiar seu service-config.json para o servidor de hospedagem junto com todos os binários gerados pelo dotnet publish. Você pode deixar o arquivo pré-configurado, com variáveis de ambiente, portas e hosts de escuta e configurações adicionais do servidor. A próxima etapa é levar esses arquivos para o servidor onde sua aplicação será hospedada. Depois disso, dê permissões de execução para o arquivo binário. Neste caso, vamos considerar que o nome do nosso projeto é \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app Após executar sua aplicação, verifique se ela produz alguma mensagem de erro. Se não produzir, é porque sua aplicação está em execução. Neste ponto, provavelmente não será possível acessar sua aplicação pela rede externa fora do seu servidor, pois as regras de acesso, como Firewall, não foram configuradas. Vamos considerar isso nas próximas etapas. Você deve ter o endereço do host virtual onde sua aplicação está escutando. Isso é definido manualmente na aplicação e depende de como você está instanciando seu serviço Sisk. Se você não estiver usando o pacote Sisk.ServiceProvider, você deve encontrar o endereço onde definiu sua instância de HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk deve escutar em http://localhost:5000/ Associando um ListeningHost manualmente: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Ou se você estiver usando o pacote Sisk.ServiceProvider, em seu service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } A partir disso, podemos criar um proxy reverso para escutar seu serviço e tornar o tráfego disponível sobre a rede aberta. Proxyando sua aplicação Proxyar seu serviço significa não expor diretamente seu serviço Sisk à rede externa. Essa prática é muito comum para implantações de servidor porque: Permite associar um certificado SSL à sua aplicação; Cria regras de acesso antes de acessar o serviço e evitar sobrecargas; Controla a largura de banda e os limites de solicitação; Separa os balanceadores de carga para sua aplicação; Previne danos de segurança à infraestrutura de falha. Você pode servir sua aplicação por meio de um proxy reverso como Nginx ou Apache, ou você pode usar um túnel http-over-dns como Cloudflared. Além disso, lembre-se de resolver corretamente os cabeçalhos de encaminhamento do proxy para obter as informações do cliente, como endereço IP e host, por meio de resolutores de encaminhamento. A próxima etapa após criar seu túnel, configurar o firewall e ter sua aplicação em execução é criar um serviço para sua aplicação. Note Usar certificados SSL diretamente no serviço Sisk em sistemas não-Windows não é possível. Isso é um ponto da implementação do HttpListener, que é o módulo central para como a gestão da fila HTTP é feita no Sisk, e essa implementação varia de sistema operacional para sistema operacional. Você pode usar SSL em seu serviço Sisk se associar um certificado ao host virtual com IIS. Para outros sistemas, usar um proxy reverso é altamente recomendado. Criando um serviço Criar um serviço fará com que sua aplicação esteja sempre disponível, mesmo após reiniciar a instância do servidor ou uma falha não recuperável. Neste tutorial simples, vamos usar o conteúdo do tutorial anterior como um exemplo para manter seu serviço sempre ativo. Acesse o diretório onde os arquivos de configuração do serviço estão localizados: cd /etc/systemd/system Crie seu arquivo my-app.service e inclua o conteúdo: my-app.service INI [Unit] Description=<descrição sobre sua aplicação> [Service] # defina o usuário que lançará o serviço User=<usuário que lançará o serviço> # o caminho do ExecStart não é relativo ao WorkingDirectory. # defina-o como o caminho completo para o arquivo executável WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # defina o serviço para sempre reiniciar em caso de falha Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Reinicie o módulo de gerenciamento de serviços: $ sudo systemctl daemon-reload Inicie seu novo serviço criado a partir do nome do arquivo que você definiu e verifique se ele está em execução: $ sudo systemctl start my-app $ sudo systemctl status my-app Agora, se sua aplicação estiver em execução (\"Active: active\"), habilite seu serviço para continuar em execução após uma reinicialização do sistema: $ sudo systemctl enable my-app Agora você está pronto para apresentar sua aplicação Sisk a todos."
  },
  "docs/pt-br/extensions/basic-auth.html": {
    "href": "docs/pt-br/extensions/basic-auth.html",
    "title": "Autenticação Básica | Sisk",
    "keywords": "Autenticação Básica O pacote Basic Auth adiciona um processador de solicitações capaz de lidar com o esquema de autenticação básica em seu aplicativo Sisk com pouca configuração e esforço. A autenticação HTTP básica é uma forma mínima de entrada de autenticação de solicitações por um ID de usuário e senha, onde a sessão é controlada exclusivamente pelo cliente e não há tokens de autenticação ou acesso. Leia mais sobre o esquema de autenticação básica na especificação MDN. Instalando Para começar, instale o pacote Sisk.BasicAuth em seu projeto: > dotnet add package Sisk.BasicAuth Você pode visualizar mais maneiras de instalá-lo em seu projeto no repositório Nuget. Criando seu manipulador de autenticação Você pode controlar o esquema de autenticação para um módulo inteiro ou para rotas individuais. Para isso, primeiro vamos escrever nosso primeiro manipulador de autenticação básica. No exemplo abaixo, uma conexão é feita com o banco de dados, verifica se o usuário existe e se a senha é válida e, em seguida, armazena o usuário na bolsa de contexto. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Para entrar nesta página, informe suas credenciais.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // neste caso, estamos usando o email como campo de ID de usuário, então vamos // procurar um usuário usando seu email. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Desculpe! Nenhum usuário foi encontrado por este email.\"); } // valida que a senha das credenciais é válida para este usuário. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Credenciais inválidas.\"); } // adiciona o usuário logado ao contexto HTTP // e continua a execução context.Bag.Add(\"loggedUser\", user); return null; } } Então, basta associar este manipulador de solicitações à nossa rota ou classe. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Olá, \" + loggedUser.Name + \"!\"; } } Ou usando a classe RouterModule: public class UsersController : RouterModule { public ClientModule() { // agora todas as rotas dentro desta classe serão tratadas por // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Olá, \" + loggedUser.Name + \"!\"; } } Observações A principal responsabilidade da autenticação básica é realizada no lado do cliente. Armazenamento, controle de cache e criptografia são todos gerenciados localmente no cliente. O servidor apenas recebe as credenciais e valida se o acesso é permitido ou não. Observe que este método não é uma das soluções mais seguras porque coloca uma responsabilidade significativa no cliente, o que pode ser difícil de rastrear e manter a segurança de suas credenciais. Além disso, é essencial que as senhas sejam transmitidas em um contexto de conexão segura (SSL), pois elas não possuem nenhuma criptografia inerente. Uma breve interceptação nos cabeçalhos de uma solicitação pode expor as credenciais de acesso do seu usuário. Opte por soluções de autenticação mais robustas para aplicativos em produção e evite usar muitos componentes prontos para uso, pois eles podem não se adaptar às necessidades do seu projeto e acabar expondo-o a riscos de segurança."
  },
  "docs/pt-br/extensions/ini-configuration.html": {
    "href": "docs/pt-br/extensions/ini-configuration.html",
    "title": "Configuração INI | Sisk",
    "keywords": "Configuração INI O Sisk tem um método para obter configurações de inicialização além do JSON. Na verdade, qualquer pipeline que implemente IConfigurationReader pode ser usado com PortableConfigurationBuilder.WithConfigurationPipeline, lendo a configuração do servidor de qualquer tipo de arquivo. O pacote Sisk.IniConfiguration fornece um leitor de arquivos INI baseado em fluxo que não lança exceções para erros de sintaxe comuns e tem uma sintaxe de configuração simples. Esse pacote pode ser usado fora do framework Sisk, oferecendo flexibilidade para projetos que requerem um leitor de documentos INI eficiente. Instalando Para instalar o pacote, você pode começar com: $ dotnet add package Sisk.IniConfiguration Você também pode instalar o pacote core, que não inclui o IConfigurationReader INI, nem a dependência do Sisk, apenas os serializadores INI: $ dotnet add package Sisk.IniConfiguration.Core Com o pacote principal, você pode usá-lo em seu código como mostrado no exemplo abaixo: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // usa o leitor de configuração IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } O código acima procurará por um arquivo app.ini no diretório atual do processo (CurrentDirectory). O arquivo INI tem a seguinte aparência: [Server] # Múltiplos endereços de escuta são suportados Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Sabor e sintaxe INI Implementação atual do sabor: Nomes de propriedades e seções são insensíveis a letras maiúsculas e minúsculas. Nomes de propriedades e valores são recortados, a menos que os valores sejam citados. Valores podem ser citados com aspas simples ou duplas. Aspas podem ter quebras de linha dentro delas. Comentários são suportados com # e ;. Além disso, comentários de tralha são permitidos. Propriedades podem ter múltiplos valores. Em detalhe, a documentação para o \"sabor\" do analisador INI usado no Sisk está disponível neste documento. Usando o seguinte código INI como exemplo: One = 1 Value = este é um valor Another value = \"este valor tem uma quebra de linha nele\" ; o código abaixo tem algumas cores [some section] Color = Red Color = Blue Color = Yellow ; não use amarelo Analisá-lo com: // analisa o texto INI da string IniDocument doc = IniDocument.FromString(iniText); // obtenha um valor string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // obtenha múltiplos valores string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Parâmetros de configuração Seção e nome Permite múltiplos valores Descrição Server.Listen Sim Os endereços/ports de escuta do servidor. Server.Encoding Não A codificação padrão do servidor. Server.MaximumContentLength Não O tamanho máximo do conteúdo em bytes. Server.IncludeRequestIdHeader Não Especifica se o servidor HTTP deve enviar o cabeçalho X-Request-Id. Server.ThrowExceptions Não Especifica se as exceções não tratadas devem ser lançadas. Server.AccessLogsStream Não Especifica o fluxo de saída do log de acesso. Server.ErrorsLogsStream Não Especifica o fluxo de saída do log de erros. Cors.AllowMethods Não Especifica o valor do cabeçalho Allow-Methods CORS. Cors.AllowHeaders Não Especifica o valor do cabeçalho Allow-Headers CORS. Cors.AllowOrigins Não Especifica múltiplos cabeçalhos Allow-Origin, separados por vírgulas. AllowOrigins para mais informações. Cors.AllowOrigin Não Especifica um cabeçalho Allow-Origin. Cors.ExposeHeaders Não Especifica o valor do cabeçalho Expose-Headers CORS. Cors.AllowCredentials Não Especifica o valor do cabeçalho Allow-Credentials CORS. Cors.MaxAge Não Especifica o valor do cabeçalho Max-Age CORS."
  },
  "docs/pt-br/extensions/json-rpc.html": {
    "href": "docs/pt-br/extensions/json-rpc.html",
    "title": "Sisk + JSON-RPC | Sisk",
    "keywords": "Sisk + JSON-RPC Sisk possui um módulo experimental de uma API JSON-RPC 2.0, o que possibilita criar aplicações ainda mais simples. Essa extensão implementa extritamente a interface de transporte JSON-RPC 2.0, e oferece transporte via requisições HTTP GET, POST e também web-sockets com Sisk. Você pode instalar a extensão pelo Nuget com o comando abaixo. Note que, em versões experimentais/betas, deverá ser ativado a opção de buscar por pacotes em pré-lançamento pelo Visual Studio. dotnet add package Sisk.JsonRpc Interface de transporte O JSON-RPC é um protocolo de execução remota de procedimentos (RDP) sem estado, assíncrono, e utiliza o JSON para comunicação unilateral dos dados. Uma requisição JSON-RPC é normalmente identificada por um ID, e uma resposta é entregue pelo mesmo ID que foi enviado na requisição. Nem todas as requisições são necessárias de resposta, o que são chamadas de \"notificações\". Na especificação do JSON-RPC 2.0 é explicado com detalhes como o transporte funciona. Este transporte é agnóstico de onde será usado. O Sisk implementa esse protocolo através do HTTP, seguindo as conformidades do JSON-RPC over HTTP, que suporta parcialmente requisições GET, mas completamente requisições POST. Também é suportado o uso de web-sockets, o que provê uma comunicação assíncrona de mensagens. Uma requisição JSON-RPC é parecida com: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } E uma resposta, quando bem-sucedida, é semelhante: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Métodos JSON-RPC O exemplo a seguir mostra como criar uma API JSON-RPC usando o Sisk. Uma classe de operações matemáticas realiza as operações remotas e entrega a resposta serializada ao cliente. using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // add all methods tagged with WebMethod to the JSON-RPC handler args.Handler.Methods.AddMethodsFromType(new MathOperations()); // maps the /service route to handle JSON-RPC POST and GET requests args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // creates an websocket handler on GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } O exemplo acima irá mapear os métodos Sum e Sqrt para o handler JSON-RPC, e estes métodos ficarão disponíveis no GET /service, POST /service e GET /ws. O nome dos métodos não são sensíveis a caso. Os parâmetros dos métodos são deserializados automaticamente para seus tipos específicos. Usar uma requisição com parâmetros nomeados também é suportado. A serialização JSON é feita pela biblioteca LightJson. Quando um tipo não é corretamente deserializado, você poderá criar um conversor JSON específico para aquele tipo e associar ele em seu JsonSerializerOptions posteriormente. Você também pode obter o objeto $.params cru da requisição JSON-RPC diretamente no seu método. [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Para isso ocorrer, @params deve ser o único parâmetro no seu método, com exatamente o nome params (em C#, o @ é necessário para escapar o nome deste parâmetro). A deserialização dos parâmetros ocorre tanto para objetos nomeados ou para arrays posicionais. Por exemplo, o método abaixo pode ser chamado remotamente por ambas requisições: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Por um objeto em params não é necessário seguir a ordem dos parâmetros: { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": { \"apiKey\": \"1234567890\", \"store\": { \"name\": \"My Store\" }, \"user\": { \"name\": \"John Doe\", \"email\": \"john@example.com\" } }, \"id\": 1 } Por array é necessário seguir a ordem dos parâmetros. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Personalizando o serializer Você pode personalizar o serializador JSON na propriedade JsonRpcHandler.JsonSerializerOptions. Nessa propriedade, você pode ativar o uso de JSON5 para deserialização de mensagens. Por mais que não é conformidade com o JSON-RPC 2.0, JSON5 é uma extensão do JSON que permite uma escrita mais humanizada e legível. using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // usa um comparador de nomes sanitizado. esse comparador compara apenas letras // e dígitos em um nome, e descarta outros símbolos. ex: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // habilita JSON5 para o interpretador JSON. mesmo ativando isso, JSON plano ainda é permitido e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // mapeia a rota POST /service para o handler JSON RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/pt-br/extensions/service-providers.html": {
    "href": "docs/pt-br/extensions/service-providers.html",
    "title": "Service Providers | Sisk",
    "keywords": "Service Providers Service Providers é uma forma de portar sua aplicação Sisk para diferentes ambientes com um arquivo de configuração portátil. Este recurso possibilita alterar funcionamento de portas, parâmetros e demais opções do servidor sem ter que alterar o código do aplicativo para cada ambiente. Este módulo depende da sintaxe de construção do Sisk e pode ser configurada através do método UsePortableConfiguration. Um provedor de configuração é implementado com IConfigurationProvider, o que provê um leitor de configurações e pode receber qualquer implementação. Por padrão, o Sisk fornece um leitor de configurações em JSON, mas também existe um pacote para arquivos INI. Você também pode criar seu próprio provedor de configurações e registrar com: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Como mencionado anteriormente, o provedor padrão é de um arquivo JSON. Por padrão, o nome do arquivo buscado é service-config.json, e é buscado na pasta atual (Current Directory) do processo em execução, e não do diretório do executável. Você pode optar em alterar o nome do arquivo, bem como onde o Sisk deve procurar pelo arquivo de configuração, com: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); O código acima irá procurar o arquivo config.toml na pasta atual do processo em execução. Se não encontrado o arquivo, irá então buscar no diretório de onde o executável está localizado. Caso o arquivo não exista, o parâmetro createIfDontExists é honrado, criando o arquivo, sem nenhum conteúdo, no último caminho testado (com base em lookupDirectories), e um erro é lançado no console, impedindo a inicialização do aplicativo. Tip Você pode olhar no código fonte do leitor de configurações de arquivos INI e no de JSON para entender como um IConfigurationProvider é implementado. Lendo configurações de um arquivo JSON Por padrão, o Sisk fornece um provedor de configuração que lê configurações em um arquivo JSON. Este arquivo segue uma estrutura fixa e é composto pelos parâmetros: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Configuration files also supports comments ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // new on 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Os parâmetros criados a partir de um arquivo de configurações pode ser acessado no construtor do servidor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Cada leitor de configurações fornece uma forma de ler os parâmetros de inicialização do servidor. Algumas propriedades são indicadas a ficarem no ambiente do processo ao invés de serem definidas no arquivo de configuração, como por exemplo, dados sensíveis de API, chaves de API, etc. Estrutura de arquivo de configuração O arquivo de configuração JSON é composto pelas propriedades: Property Mandatory Description Server Required Represents the server itself with their settings. Server.AccessLogsStream Optional Default to console. Specifies the access log output stream. Can be an filename, null or console. Server.ErrorsLogsStream Optional Default to null. Specifies the error log output stream. Can be an filename, null or console. Server.MaximumContentLength Optional Default to 0. Specifies the maximum content length in bytes. Zero means infinite. Server.IncludeRequestIdHeader Optional Default to false. Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions Optional Default to true. Specifies if unhandled exceptions should be thrown. Set to false when production and true when debugging. ListeningHost Required Represents the server listening host. ListeningHost.Label Optional Represents the application label. ListeningHost.Ports Required Represents an array of strings, matching the ListeningPort syntax. ListeningHost.CrossOriginResourceSharingPolicy Optional Setup the CORS headers for the application. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Optional Defaults to false. Specifies the Allow-Credentials header. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Expose-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Optional Defaults to null. This property expects an string. Specifies the Allow-Origin header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Optional Defaults to null. This property expects an array of strings. Specifies multiples Allow-Origin headers. See AllowOrigins for more information. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Methods header. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Optional Defaults to null. This property expects an interger. Specifies the Max-Age header in seconds. ListeningHost.Parameters Optional Specifies the properties provided to the application setup method."
  },
  "docs/pt-br/extensions/ssl-proxy.html": {
    "href": "docs/pt-br/extensions/ssl-proxy.html",
    "title": "Proxy SSL | Sisk",
    "keywords": "Proxy SSL Warning Este recurso é experimental e não deve ser usado em produção. Consulte este documento se quiser fazer o Sisk funcionar com SSL. O Proxy SSL do Sisk é um módulo que fornece uma conexão HTTPS para um ListeningHost no Sisk e roteia mensagens HTTPS para um contexto HTTP inseguro. O módulo foi construído para fornecer conexão SSL para um serviço que usa HttpListener para executar, que não suporta SSL. O proxy é executado dentro do mesmo aplicativo e escuta por mensagens HTTP/1.1, encaminhando-as para o Sisk no mesmo protocolo. Atualmente, esse recurso é altamente experimental e pode ser instável o suficiente para não ser usado em produção. No momento, o SslProxy suporta quase todos os recursos HTTP/1.1, como keep-alive, codificação chunked, websockets, etc. Para uma conexão aberta ao proxy SSL, uma conexão TCP é criada para o servidor de destino e o proxy é encaminhado para a conexão estabelecida. O SslProxy pode ser usado com HttpServer.CreateBuilder da seguinte forma: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // adicionar SSL ao projeto .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Você deve fornecer um certificado SSL válido para o proxy. Para garantir que o certificado seja aceito pelos navegadores, lembre-se de importá-lo no sistema operacional para que ele funcione corretamente."
  },
  "docs/pt-br/faq.html": {
    "href": "docs/pt-br/faq.html",
    "title": "Perguntas Frequentes | Sisk",
    "keywords": "Perguntas Frequentes Perguntas frequentes sobre Sisk. O Sisk é de código aberto? Totalmente. Todo o código-fonte utilizado pelo Sisk é publicado e atualizado frequentemente no GitHub. Contribuições são aceitas? Desde que sejam compatíveis com a filosofia do Sisk, todas as contribuições são muito bem-vindas! As contribuições não precisam ser apenas código! Você pode contribuir com documentação, testes, traduções, doações e posts, por exemplo. O Sisk é financiado? Não. Nenhuma organização ou projeto atualmente patrocina o Sisk. Posso usar o Sisk em produção? Absolutamente. O projeto está em desenvolvimento há mais de três anos e teve testes intensivos em aplicações comerciais que estão em produção desde então. O Sisk é usado em projetos comerciais importantes como infraestrutura principal. Um guia sobre como implantar em diferentes sistemas e ambientes foi escrito e está disponível. O Sisk tem autenticação, monitoramento e serviços de banco de dados? Não. O Sisk não tem nenhum desses. É um framework para desenvolver aplicações web HTTP, mas é um framework minimalista que entrega o que é necessário para que sua aplicação funcione. Você pode implementar todos os serviços que desejar usando qualquer biblioteca de terceiros que preferir. O Sisk foi feito para ser agnóstico, flexível e funcionar com qualquer coisa. Por que devo usar o Sisk em vez de ? Não sei. Você me diz. O Sisk foi criado para atender a um cenário genérico para aplicações web HTTP em .NET. Projetos estabelecidos, como o ASP.NET, resolvem vários problemas, mas com diferentes vieses. Diferentemente de frameworks maiores, o Sisk exige que o usuário saiba o que está fazendo e construindo. Noções básicas de desenvolvimento web e do protocolo HTTP são essenciais para trabalhar com o Sisk. O Sisk é mais próximo do Express do Node.js do que do ASP.NET Core. É uma abstração de alto nível que permite criar aplicações com lógica HTTP que você deseja. O que preciso aprender para usar o Sisk? Você precisa dos básicos de: Desenvolvimento web (HTTP, Restful, etc.) .NET Isso é tudo. Tendo uma noção desses dois tópicos, você pode dedicar algumas horas para desenvolver uma aplicação avançada com o Sisk. Posso desenvolver aplicações comerciais com o Sisk? Absolutamente. O Sisk foi criado sob a licença MIT, o que significa que você pode usar o Sisk em qualquer projeto comercial, comercial ou não comercial, sem a necessidade de uma licença proprietária. O que pedimos é que em algum lugar da sua aplicação, você tenha um aviso dos projetos de código aberto utilizados em seu projeto, e que o Sisk esteja lá."
  },
  "docs/pt-br/features/content-streaming.html": {
    "href": "docs/pt-br/features/content-streaming.html",
    "title": "Streaming de Conteúdo | Sisk",
    "keywords": "Streaming de Conteúdo O Sisk suporta a leitura e o envio de fluxos de conteúdo para e do cliente. Essa funcionalidade é útil para remover a sobrecarga de memória para serializar e deserializar conteúdo durante a vida útil de uma solicitação. Fluxo de Conteúdo da Solicitação Conteúdos pequenos são carregados automaticamente no buffer de memória da conexão HTTP, carregando rapidamente esse conteúdo para HttpRequest.Body e HttpRequest.RawBody. Para conteúdos maiores, o método HttpRequest.GetRequestStream pode ser usado para obter o fluxo de leitura do conteúdo da solicitação. É importante notar que o método HttpRequest.GetMultipartFormContent lê todo o conteúdo da solicitação na memória, portanto, pode não ser útil para ler conteúdos grandes. Considere o seguinte exemplo: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // solicitação não tem conteúdo return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"Arquivo enviado com sucesso.\" } ) }; } No exemplo acima, o método UploadDocument lê o conteúdo da solicitação e salva o conteúdo em um arquivo. Nenhuma alocação adicional de memória é feita, exceto pelo buffer de leitura usado por Stream.CopyToAsync. O exemplo acima remove a pressão de alocação de memória para um arquivo muito grande, o que pode otimizar o desempenho da aplicação. Uma boa prática é sempre usar um CancellationToken em uma operação que possa ser demorada, como enviar arquivos, pois depende da velocidade da rede entre o cliente e o servidor. A ajuste com um CancellationToken pode ser feito da seguinte forma: Controller/UploadDocument.cs C# // o token de cancelamento abaixo irá lançar uma exceção se o tempo limite de 30 segundos for atingido. CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"O upload excedeu o tempo máximo de upload (30 segundos).\" } ) }; } Fluxo de Conteúdo da Resposta Enviar conteúdo de resposta também é possível. Atualmente, existem duas maneiras de fazer isso: através do método HttpRequest.GetResponseStream e usando um conteúdo do tipo StreamContent. Considere um cenário em que precisamos servir um arquivo de imagem. Para fazer isso, podemos usar o seguinte código: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // método de exemplo para obter uma imagem de perfil var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } O método acima faz uma alocação de memória a cada vez que lê o conteúdo da imagem. Se a imagem for grande, isso pode causar um problema de desempenho, e em situações de pico, até mesmo uma sobrecarga de memória e travar o servidor. Nesses casos, o cache pode ser útil, mas não eliminará o problema, pois a memória ainda será reservada para esse arquivo. O cache aliviará a pressão de ter que alocar memória para cada solicitação, mas para arquivos grandes, não será suficiente. Enviar a imagem por meio de um fluxo pode ser uma solução para o problema. Em vez de ler todo o conteúdo da imagem, um fluxo de leitura é criado no arquivo e copiado para o cliente usando um buffer pequeno. Enviar através do método GetResponseStream O método HttpRequest.GetResponseStream cria um objeto que permite enviar pedaços da resposta HTTP à medida que o fluxo de conteúdo é preparado. Esse método é mais manual, exigindo que você defina o status, cabeçalhos e tamanho do conteúdo antes de enviar o conteúdo. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // nessa forma de envio, o status e o cabeçalho devem ser definidos // antes de enviar o conteúdo var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // nessa forma de envio, também é necessário definir o tamanho do conteúdo // antes de enviá-lo. requestStreamManager.SetContentLength ( fs.Length ); // se você não souber o tamanho do conteúdo, pode usar o codificação em chunk // para enviar o conteúdo requestStreamManager.SendChunked = true; // e então, escrever no fluxo de saída await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } Enviar conteúdo através de um StreamContent A classe StreamContent permite enviar conteúdo de uma fonte de dados como um fluxo de bytes. Essa forma de envio é mais fácil, removendo os requisitos anteriores, e até mesmo permitindo o uso de codificação de compressão para reduzir o tamanho do conteúdo. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important Nesse tipo de conteúdo, não encapsule o fluxo em um bloco using. O conteúdo será automaticamente descartado pelo servidor HTTP quando o fluxo de conteúdo for finalizado, com ou sem erros."
  },
  "docs/pt-br/features/cors.html": {
    "href": "docs/pt-br/features/cors.html",
    "title": "Habilitando CORS (Compartilhamento de Recursos de Origem Cruzada) no Sisk | Sisk",
    "keywords": "Habilitando CORS (Compartilhamento de Recursos de Origem Cruzada) no Sisk Sisk tem uma ferramenta que pode ser útil para lidar com Compartilhamento de Recursos de Origem Cruzada (CORS) ao expor seu serviço publicamente. Essa funcionalidade não faz parte do protocolo HTTP, mas é uma característica específica dos navegadores da web definida pela W3C. Esse mecanismo de segurança impede que uma página da web faça solicitações a um domínio diferente daquele que forneceu a página da web. Um provedor de serviços pode permitir que certos domínios acessem seus recursos ou apenas um. Mesma Origem Para que um recurso seja identificado como \"mesma origem\", uma solicitação deve identificar o cabeçalho Origin em sua solicitação: GET /api/usuarios HTTP/1.1 Host: example.com Origin: http://example.com ... E o servidor remoto deve responder com um cabeçalho Access-Control-Allow-Origin com o mesmo valor que a origem solicitada: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... Essa verificação é explícita: o host, porta e protocolo devem ser os mesmos solicitados. Verifique o exemplo: Um servidor responde que seu Access-Control-Allow-Origin é https://example.com: https://example.net - o domínio é diferente. http://example.com - o esquema é diferente. http://example.com:5555 - a porta é diferente. https://www.example.com - o host é diferente. Na especificação, apenas a sintaxe é permitida para ambos os cabeçalhos, seja para solicitações e respostas. O caminho da URL é ignorado. A porta também é omitida se for uma porta padrão (80 para HTTP e 443 para HTTPS). Origin: null Origin: <esquema>://<nome_do_host> Origin: <esquema>://<nome_do_host>:<porta> Habilitando CORS Nativamente, você tem o objeto CrossOriginResourceSharingHeaders dentro de seu ListeningHost. Você pode configurar CORS ao inicializar o servidor: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } O código acima enviará os seguintes cabeçalhos para todas as respostas: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type Esses cabeçalhos precisam ser enviados para todas as respostas a um cliente da web, incluindo erros e redirecionamentos. Você pode notar que a classe CrossOriginResourceSharingHeaders tem duas propriedades semelhantes: AllowOrigin e AllowOrigins. Observe que uma é plural, enquanto a outra é singular. A propriedade AllowOrigin é estática: apenas a origem que você especificar será enviada para todas as respostas. A propriedade AllowOrigins é dinâmica: o servidor verifica se a origem da solicitação está contida nessa lista. Se for encontrada, ela é enviada para a resposta daquela origem. Caracter Coringa na Origem Alternativamente, você pode usar um caractere coringa (*) na origem da resposta para especificar que qualquer origem é permitida acessar o recurso. No entanto, esse valor não é permitido para solicitações que têm credenciais (cabeçalhos de autorização) e essa operação resultará em um erro. Você pode contornar esse problema explicitamente listando quais origens serão permitidas por meio da propriedade AllowOrigins ou também usar a constante AutoAllowOrigin no valor da propriedade AllowOrigin. Essa propriedade mágica definirá o cabeçalho Access-Control-Allow-Origin para o mesmo valor que o cabeçalho Origin da solicitação. Outras Maneiras de Aplicar CORS Se você estiver lidando com provedores de serviços, você pode substituir valores definidos no arquivo de configuração: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // Substituirá a origem definida no arquivo de configuração. cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } Desabilitando CORS em Rotas Específicas A propriedade UseCors está disponível para ambas as rotas e todos os atributos de rota e pode ser desabilitada com o seguinte exemplo: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } Substituindo Valores na Resposta Você pode substituir ou remover valores explicitamente em uma ação de roteamento: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Remove o cabeçalho Access-Control-Allow-Credentials request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Substitui o Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } Solicitações de Pré-voo Uma solicitação de pré-voo é um método de solicitação OPTIONS que o cliente envia antes da solicitação real. O servidor Sisk sempre responderá à solicitação com um 200 OK e os cabeçalhos CORS aplicáveis, e então o cliente pode prosseguir com a solicitação real. Essa condição só não se aplica quando uma rota existe para a solicitação com o RouteMethod explicitamente configurado para Options. Desabilitando CORS Globalmente Isso não é possível. Para não usar CORS, não configure-o."
  },
  "docs/pt-br/features/discard-syntax.html": {
    "href": "docs/pt-br/features/discard-syntax.html",
    "title": "Sintaxe de descarte | Sisk",
    "keywords": "Sintaxe de descarte O servidor HTTP pode ser usado para escutar uma solicitação de retorno de uma ação, como autenticação OAuth, e pode ser descartado após receber essa solicitação. Isso pode ser útil em casos em que você precisa de uma ação em segundo plano, mas não deseja configurar um aplicativo HTTP inteiro para isso. O exemplo a seguir mostra como criar um servidor HTTP ouvindo na porta 5555 com CreateListener e aguardar o próximo contexto: using (var server = HttpServer.CreateListener(5555)) { // aguardar a próxima solicitação HTTP var context = await server.WaitNextAsync(); Console.WriteLine($\"Caminho solicitado: {context.Request.Path}\"); } A função WaitNext aguarda o próximo contexto de um processamento de solicitação concluído. Uma vez que o resultado dessa operação é obtido, o servidor já tratou completamente a solicitação e enviou a resposta para o cliente."
  },
  "docs/pt-br/features/instancing.html": {
    "href": "docs/pt-br/features/instancing.html",
    "title": "Instanciando membros por solicitação | Sisk",
    "keywords": "Instanciando membros por solicitação É comum dedicar membros e instâncias que duram por toda a vida de uma solicitação, como uma conexão com banco de dados, um usuário autenticado ou um token de sessão. Uma das possibilidades é através do HttpContext.RequestBag, que cria um dicionário que dura por toda a vida de uma solicitação. Este dicionário pode ser acessado por tratadores de solicitação e definir variáveis ​​durante toda a solicitação. Por exemplo, um tratador de solicitação que autentica um usuário define esse usuário dentro do HttpContext.RequestBag, e dentro da lógica da solicitação, esse usuário pode ser recuperado com HttpContext.RequestBag.Get<User>(). Aqui está um exemplo: public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // avançar para o próximo tratador de solicitação ou lógica da solicitação } } [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Olá {authenticatedUser.Name}!\") }; } Este é um exemplo preliminar dessa operação. A instância de User foi criada dentro do tratador de solicitação dedicado à autenticação, e todas as rotas que usam esse tratador de solicitação terão a garantia de que haverá um User em sua instância de HttpContext.RequestBag. É possível definir lógica para obter instâncias quando não definidas anteriormente no RequestBag através de métodos como GetOrAdd ou GetOrAddAsync. Desde a versão 1.3, a propriedade estática HttpContext.Current foi introduzida, permitindo o acesso ao HttpContext atualmente em execução do contexto da solicitação. Isso permite expor membros do HttpContext fora do contexto da solicitação atual e definir instâncias em objetos de rota. O exemplo abaixo define um controlador que possui membros comumente acessados pelo contexto de uma solicitação. public abstract class Controller : RouterModule { public DbContext Database { get { // criar um DbContext ou obter o existente return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // a linha seguinte lançará uma exceção se a propriedade for acessada quando o User não // estiver definido no bag da solicitação public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // Expor a instância HttpRequest também é suportado public HttpRequest Request { get => HttpContext.Current.Request; } } E definir tipos que herdam do controlador: [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Para o exemplo acima, você precisará configurar um tratador de valor no seu roteador para que os objetos retornados pelo roteador sejam transformados em um HttpResponse válido. Observe que os métodos não têm um argumento HttpRequest request como presente em outros métodos. Isso ocorre porque, desde a versão 1.3, o roteador suporta dois tipos de delegados para roteamento de respostas: RouteAction, que é o delegado padrão que recebe um argumento HttpRequest, e ParameterlessRouteAction. O objeto HttpRequest ainda pode ser acessado por ambos os delegados através da propriedade Request do HttpContext estático no thread. No exemplo acima, definimos um objeto descartável, o DbContext, e precisamos garantir que todas as instâncias criadas em um DbContext sejam descartadas quando a sessão HTTP terminar. Para isso, podemos usar duas maneiras de alcançar isso. Uma é criar um tratador de solicitação que é executado após a ação do roteador, e a outra maneira é através de um tratador de servidor personalizado. Para o primeiro método, podemos criar o tratador de solicitação inline diretamente no método OnSetup herdado de RouterModule: public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // obter um DbContext definido no contexto do tratador de solicitação e // descartá-lo ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } O método acima garantirá que o DbContext seja descartado quando a sessão HTTP for finalizada. Você pode fazer isso para mais membros que precisam ser descartados no final de uma resposta. Para o segundo método, você pode criar um tratador de servidor personalizado que descartará o DbContext quando a sessão HTTP for finalizada. public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } E usá-lo no seu construtor: using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Esta é uma maneira de lidar com a limpeza de código e manter as dependências de uma solicitação separadas pelo tipo de módulo que será usado, reduzindo a quantidade de código duplicado dentro de cada ação de um roteador. É uma prática semelhante ao que a injeção de dependência é usada em frameworks como ASP.NET."
  },
  "docs/pt-br/features/logging.html": {
    "href": "docs/pt-br/features/logging.html",
    "title": "Log | Sisk",
    "keywords": "Log Você pode configurar o Sisk para escrever logs de acesso e erros automaticamente. É possível definir rotação de logs, extensões e frequência. A classe LogStream fornece uma maneira assíncrona de escrever logs e mantê-los em uma fila de escrita aguarda. Neste artigo, mostraremos como configurar o log para seu aplicativo. Logs de acesso baseados em arquivo Logs para arquivos abrem o arquivo, escrevem o texto da linha e, em seguida, fecham o arquivo para cada linha escrita. Este procedimento foi adotado para manter a responsividade de escrita nos logs. config.AccessLogsStream = new LogStream(\"logs/access.log\"); O código acima escreverá todas as solicitações recebidas no arquivo logs/access.log. Observe que o arquivo é criado automaticamente se não existir, mas a pasta anterior não. Não é necessário criar o diretório logs/ pois a classe LogStream o cria automaticamente. Logamento baseado em stream Você pode escrever arquivos de log para instâncias de objetos TextWriter, como Console.Out, passando um objeto TextWriter no construtor: config.AccessLogsStream = new LogStream(Console.Out); Para cada mensagem escrita no log baseado em stream, o método TextWriter.Flush() é chamado. Formatação do log de acesso Você pode personalizar o formato do log de acesso usando variáveis predefinidas. Considere a seguinte linha: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; Ele escreverá uma mensagem como: 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ \\[200 OK\\] 689B -> 707B in 84ms \\[Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36\\] Você pode formatar seu arquivo de log de acordo com a tabela descrita: Variável Descrição Exemplo %dd O dia do timestamp atual, no formato 00. 25 %dm O mês do timestamp atual, no formato 00. 03 %dmm O mês do timestamp atual, no formato abreviado. mar. %dmmm O mês do timestamp atual, no formato completo. Março %dy O ano do timestamp atual, no formato 0000. 2023 %th A hora atual do timestamp, no formato de 12 horas. 03 %tH A hora atual do timestamp, no formato de 24 horas. 15 %ti Os minutos atuais do timestamp, no formato 00. 25 %ts Os segundos atuais do timestamp, no formato 00. 32 %tm Os milissegundos atuais do timestamp, no formato 000. 633 %tz A diferença de fuso horário atual, no formato +/- 0000. +0300, -0500, +0000 %ri O endereço IP do usuário solicitante (pode ser IPv4 ou IPv6). 192.168.0.1 %rm O método de solicitação em maiúsculas. GET %rs O esquema do URL do usuário solicitante. https, http %ra A autoridade do URL do usuário solicitante. my.contorso.com:8080 %rh O host do URL do usuário solicitante. my.contorso.com %rp A porta do URL do usuário solicitante. 8080 %rz O caminho absoluto do URL do usuário solicitante. /index.html %rq A cadeia de consulta do URL do usuário solicitante. ?foo=bar&aaa=bbb %sc O código de status da resposta, no formato 000. 404 %sd A descrição do código de status da resposta. Não encontrado %lin O tamanho do conteúdo da solicitação entrante, em uma forma legível por humanos. 12,5kb %lou O tamanho do conteúdo da resposta saindo, em uma forma legível por humanos. 65,8kb %lms O tempo de processamento do servidor da solicitação e entrega da resposta, em milissegundos (000). 18 %{header} Obtém o valor de um cabeçalho HTTP, onde o cabeçalho é o nome do cabeçalho, ou um valor vazio se o cabeçalho não estiver presente. Este campo é insensível a maiúsculas e minúsculas. %{user-agent} Rotação de logs Tip Em Sisk 0.15 e versões anteriores, essa função está disponível apenas com o pacote Sisk.ServiceProvider. Em Sisk 0.16 e versões posteriores, essa função é implementada no pacote principal. Você pode configurar o servidor HTTP para rotar os arquivos de log para um arquivo .gz compactado quando eles atingirem um determinado tamanho. O tamanho é verificado periodicamente pelo limiar que você define. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); O código acima verificará a cada seis horas se o arquivo do LogStream tenha atingido o limite de 1 MB. Se sim, o arquivo é compactado para um arquivo .gz e, em seguida, access.log é limpo. Durante esse processo, a escrita no arquivo é bloqueada até que o arquivo seja compactado e limpo. Todas as linhas que entram para serem escritas neste período ficarão em uma fila aguardando o final da compactação. Essa função funciona apenas com LogStreams baseados em arquivos. Log de erros Quando um servidor não está lançando erros para o depurador, ele encaminha os erros para o log de escrita quando houver algum. Você pode configurar a escrita de erros com: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Essa propriedade só escreverá algo no log se o erro não for capturado pelo callback ou pela propriedade Router.CallbackErrorHandler. O erro escrito pelo servidor sempre escreve a data e hora, os cabeçalhos da solicitação (não o corpo), o rastreamento de erros e o rastreamento de exceções internas, se houver. Outras instâncias de log Seu aplicativo pode ter zero ou várias LogStreams, não há limite para o número de canais de log que ele pode ter. Portanto, é possível direcionar o log do seu aplicativo para um arquivo diferente do log de acesso padrão ou do log de erros. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Application started at {0}\", DateTime.Now); Extensão de LogStream Você pode estender a classe LogStream para escrever formatos personalizados, compatíveis com o mecanismo de log atual do Sisk. O exemplo abaixo permite escrever mensagens coloridas no Console usando a biblioteca Spectre.Console. public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Outra maneira de escrever automaticamente logs personalizados para cada solicitação/resposta é criar um HttpServerHandler. O exemplo abaixo é um pouco mais completo. Ele escreve o corpo da solicitação e a resposta em JSON para o Console. Pode ser útil para depurar solicitações em geral. Este exemplo usa ContextBag e HttpServerHandler. class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!! \" })); }); await app.StartAsync(); } } class JsonMessageHandler : HttpServerHandler { protected override async void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // Neste ponto, a conexão está aberta e o cliente enviou o cabeçalho especificando que o conteúdo é JSON. // O conteúdo é lido e armazenado na solicitação. // // Se o conteúdo não for lido na ação da solicitação, o GC provavelmente coletará o conteúdo após o envio da resposta para o cliente, então o conteúdo pode não estar disponível após o fechamento da resposta. // _ = request.RawBody; // adicionar uma dica no contexto para indicar que esta solicitação tem um corpo JSON. request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformatted the JSON using the CypherPotato.LightJson library var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // check if the response is JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // gets the internal server handling status responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson is not null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine(\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/pt-br/features/server-sent-events.html": {
    "href": "docs/pt-br/features/server-sent-events.html",
    "title": "Eventos Enviados pelo Servidor | Sisk",
    "keywords": "Eventos Enviados pelo Servidor O Sisk suporta o envio de mensagens por meio de Eventos Enviados pelo Servidor fora da caixa. Você pode criar conexões descartáveis e persistentes, obter as conexões durante a execução e usá-las. Essa funcionalidade tem algumas limitações impostas pelos navegadores, como enviar apenas mensagens de texto e não ser capaz de fechar permanentemente uma conexão. Uma conexão fechada pelo servidor terá um cliente tentando se reconectar periodicamente a cada 5 segundos (3 para alguns navegadores). Essas conexões são úteis para enviar eventos do servidor para o cliente sem que o cliente solicite as informações todas as vezes. Criando uma conexão SSE Uma conexão SSE funciona como uma solicitação HTTP regular, mas em vez de enviar uma resposta e fechar imediatamente a conexão, a conexão é mantida aberta para enviar mensagens. Chamando o método HttpRequest.GetEventSource(), a solicitação é colocada em um estado de espera enquanto a instância SSE é criada. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Olá, mundo!\"); return sse.Close(); }); No código acima, criamos uma conexão SSE e enviamos uma mensagem \"Olá, mundo\", então fechamos a conexão SSE do lado do servidor. Note Ao fechar uma conexão do lado do servidor, por padrão o cliente tentará se conectar novamente naquele ponto e a conexão será reiniciada, executando o método novamente, para sempre. É comum encaminhar uma mensagem de término do servidor sempre que a conexão for fechada do lado do servidor para evitar que o cliente tente se reconectar novamente. Anexando cabeçalhos Se você precisar enviar cabeçalhos, você pode usar o método HttpRequestEventSource.AppendHeader antes de enviar quaisquer mensagens. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Chave-Do-Cabeçalho\", \"Valor-Do-Cabeçalho\"); sse.Send(\"Olá!\"); return sse.Close(); }); Observe que é necessário enviar os cabeçalhos antes de enviar quaisquer mensagens. Conexões Wait-For-Fail As conexões normalmente são encerradas quando o servidor não é mais capaz de enviar mensagens devido a uma possível desconexão do lado do cliente. Com isso, a conexão é automaticamente encerrada e a instância da classe é descartada. Mesmo com uma reconexão, a instância da classe não funcionará, pois está vinculada à conexão anterior. Em algumas situações, você pode precisar dessa conexão posteriormente e não deseja gerenciá-la por meio do método de retorno de chamada da rota. Para isso, podemos identificar as conexões SSE com um identificador e obtê-las usando-o posteriormente, até mesmo fora do retorno de chamada da rota. Além disso, marcamos a conexão com WaitForFail para não encerrar a rota e encerrar a conexão automaticamente. Uma conexão SSE em KeepAlive aguardará um erro de envio (causado por desconexão) para retomar a execução do método. Também é possível definir um tempo limite para isso. Após o tempo, se nenhuma mensagem tiver sido enviada, a conexão será encerrada e a execução será retomada. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"minha-conexao-index\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // aguarde 15 segundos sem nenhuma mensagem antes de encerrar a conexão return sse.Close(); }); O método acima criará a conexão, manipulará-la e aguardará uma desconexão ou erro. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"minha-conexao-index\"); if (evs != null) { // a conexão ainda está ativa evs.Send(\"Olá novamente!\"); } E o trecho acima tentará procurar a conexão recém-criada e, se existir, enviará uma mensagem para ela. Todas as conexões ativas do servidor que são identificadas estarão disponíveis na coleção HttpServer.EventSources. Essa coleção armazena apenas conexões ativas e identificadas. Conexões fechadas são removidas da coleção. Note É importante notar que o keep alive tem um limite estabelecido por componentes que podem estar conectados ao Sisk de forma incontrolável, como um proxy da web, um kernel HTTP ou um driver de rede, e eles fecham conexões ociosas após um determinado período de tempo. Portanto, é importante manter a conexão aberta enviando pings periódicos ou estendendo o tempo máximo antes que a conexão seja fechada. Leia a próxima seção para entender melhor o envio de pings periódicos. Configurar política de ping da conexão A Política de Ping é uma maneira automatizada de enviar mensagens periódicas para o cliente. Essa função permite que o servidor entenda quando o cliente foi desconectado dessa conexão sem ter que manter a conexão aberta indefinidamente. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"mensagem-ping\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } No código acima, a cada 5 segundos, uma nova mensagem de ping será enviada para o cliente. Isso manterá a conexão TCP ativa e evitará que ela seja fechada devido à inatividade. Além disso, quando uma mensagem falhar ao ser enviada, a conexão será automaticamente fechada, liberando os recursos usados pela conexão. Consultando conexões Você pode pesquisar conexões ativas usando um predicado no identificador da conexão, para poder transmitir, por exemplo. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"minha-conexao-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Transmitindo para todas as fontes de eventos que começam com 'minha-conexao-'\"); } Você também pode usar o método All para obter todas as conexões SSE ativas."
  },
  "docs/pt-br/features/websockets.html": {
    "href": "docs/pt-br/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets O Sisk também suporta web sockets, permitindo receber e enviar mensagens para os clientes. Esta funcionalidade funciona bem na maioria dos navegadores, mas no Sisk ainda é experimental. Por favor, se encontrar algum bug, reporte no github. Aceitando e recebendo mensagens assincronamente O exemplo abaixo mostra como funciona o websocket na prática, com um exemplo de abrir uma conexão, receber uma mensagem e exibir no console. Todas as mensagens recebidas pelo WebSocket são recebidas em bytes, então você terá que decodificá-las ao recebê-las. Por padrão, as mensagens são fragmentadas em pedaços e o último pedaço é enviado como o pacote final da mensagem. Você pode configurar o tamanho do pacote com a flag WebSocketBufferSize. Este buffer é o mesmo para enviar e receber mensagens. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Mensagem recebida: \" + msgText); // obtém o contexto do HttpWebSocket que recebeu a mensagem HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Resposta!\"); }; ws.WaitForClose(); return ws.Close(); }); Note Não use eventos assíncronos desta forma. Você pode ter exceções lançadas fora do domínio do servidor HTTP e elas podem travar sua aplicação. Se você precisar lidar com código assíncrono e lidar com várias mensagens ao mesmo tempo, você pode usar o loop de mensagens: router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Mensagem recebida: {messageText}\"); await ws.SendAsync(\"Olá do servidor!\"); } return ws.Close(); }); Aceitando e recebendo mensagens sincronicamente O exemplo abaixo contém uma maneira de usar um websocket síncrono, sem um contexto assíncrono, onde você recebe as mensagens, lida com elas e termina de usar o socket. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"Qual é o seu nome?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Por favor, insira seu nome!\"); goto askName; } askAge: ws.Send(\"E sua idade?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Por favor, insira um número válido\"); goto askAge; } ws.Send($\"Você é {name} e tem {age} anos.\"); return ws.Close(); }); Enviando mensagens O método Send tem três sobrecargas, que permitem enviar texto, um array de bytes ou um span de bytes. Todas elas são fragmentadas se o tamanho do pacote do servidor WebSocketBufferSize for maior que o tamanho total da carga. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Olá, mundo\"); // será codificado como um array de bytes UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Esperando o fechamento do websocket O método WaitForClose() bloqueia a pilha de chamadas atual até que a conexão seja terminada pelo cliente ou pelo servidor. Com isso, a execução do callback da solicitação será bloqueada até que o cliente ou o servidor desconecte. Você também pode fechar a conexão manualmente com o método Close(). Este método retorna um objeto HttpResponse vazio, que não é enviado ao cliente, mas funciona como um retorno da função onde a solicitação HTTP foi recebida. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // espera o cliente fechar a conexão ws.WaitForClose(); // espera até que não haja mensagens trocadas em 60 segundos // ou até que alguma parte feche a conexão ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Política de Ping Semelhante a como a política de ping em Server Side Events funciona, você também pode configurar uma política de ping para manter a conexão TCP aberta se houver inatividade nela. ws.WithPing(ping => { ping.DataMessage = \"mensagem-ping\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/pt-br/fundamentals/request-handlers.html": {
    "href": "docs/pt-br/fundamentals/request-handlers.html",
    "title": "Tratamento de Requisições | Sisk",
    "keywords": "Tratamento de Requisições Os tratadores de requisições, também conhecidos como \"middlewares\", são funções que são executadas antes ou após uma requisição ser executada no roteador. Eles podem ser definidos por rota ou por roteador. Existem dois tipos de tratadores de requisições: BeforeResponse: define que o tratador de requisição será executado antes de chamar a ação do roteador. AfterResponse: define que o tratador de requisição será executado após chamar a ação do roteador. Enviar uma resposta HTTP neste contexto substituirá a resposta da ação do roteador. Ambos os tratadores de requisições podem substituir a resposta da função de callback real do roteador. Além disso, os tratadores de requisições podem ser úteis para validar uma requisição, como autenticação, conteúdo ou qualquer outra informação, como armazenar informações, logs ou outras etapas que podem ser realizadas antes ou após uma resposta. Dessa forma, um tratador de requisição pode interromper toda a execução e retornar uma resposta antes de finalizar o ciclo, descartando tudo o mais no processo. Exemplo: suponha que um tratador de requisição de autenticação de usuário não autentique o usuário. Isso impedirá que o ciclo de requisição continue e ficará pendente. Se isso acontecer no tratador de requisição na posição dois, o terceiro e subsequentes não serão avaliados. Criando um Tratador de Requisição Para criar um tratador de requisição, podemos criar uma classe que herda a interface IRequestHandler, no seguinte formato: Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Retornar null indica que o ciclo de requisição pode continuar return null; } else { // Retornar um objeto HttpResponse indica que essa resposta substituirá as respostas adjacentes. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } No exemplo acima, indicamos que, se o cabeçalho Authorization estiver presente na requisição, deve continuar e a próxima requisição ou a ação do roteador deve ser chamada, dependendo do que vier a seguir. Se um tratador de requisição for executado após a resposta por meio de sua propriedade ExecutionMode e retornar um valor não nulo, ele substituirá a resposta do roteador. Sempre que um tratador de requisição retorna null, isso indica que a requisição deve continuar e o próximo objeto deve ser chamado ou o ciclo deve terminar com a resposta do roteador. Associando um Tratador de Requisição a uma Rota Única Você pode definir um ou mais tratadores de requisição para uma rota. Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // antes do tratador de requisição new ValidateJsonContentRequestHandler(), // antes do tratador de requisição // -- método IndexPage será executado aqui new WriteToLogRequestHandler() // após o tratador de requisição }); Ou criando um objeto Route: Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Associando um Tratador de Requisição a um Roteador Você pode definir um tratador de requisição global que será executado em todas as rotas de um roteador. Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Associando um Tratador de Requisição a um Atributo Você pode definir um tratador de requisição em um atributo de método junto com um atributo de rota. Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } } Observe que é necessário passar o tipo de tratador de requisição desejado e não uma instância do objeto. Dessa forma, o tratador de requisição será instanciado pelo analisador do roteador. Você pode passar argumentos no construtor da classe com a propriedade ConstructorArguments. Exemplo: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } Você também pode criar seu próprio atributo que implementa RequestHandler: Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } E usá-lo como: Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } Ignorando um Tratador de Requisição Global Depois de definir um tratador de requisição global em uma rota, você pode ignorá-lo em rotas específicas. Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: a mesma instância do que está nos tratadores de requisição globais new AuthenticateUserRequestHandler() // errado: não ignorará o tratador de requisição global } }); Note Se você estiver ignorando um tratador de requisição, é necessário usar a mesma referência do que foi instanciada anteriormente para ignorar. Criar outra instância do tratador de requisição não ignorará o tratador de requisição global, pois sua referência será alterada. Lembre-se de usar a mesma referência do tratador de requisição usada em ambos GlobalRequestHandlers e BypassGlobalRequestHandlers."
  },
  "docs/pt-br/fundamentals/requests.html": {
    "href": "docs/pt-br/fundamentals/requests.html",
    "title": "Requisições | Sisk",
    "keywords": "Requisições Requisições são estruturas que representam uma mensagem de requisição HTTP. O objeto HttpRequest contém funções úteis para manipular mensagens HTTP em toda a sua aplicação. Uma requisição HTTP é formada pelo método, caminho, versão, cabeçalhos e corpo. Neste documento, vamos ensinar como obter cada um desses elementos. Obtendo o método da requisição Para obter o método da requisição recebida, você pode usar a propriedade Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Essa propriedade retorna o método da requisição representado por um objeto HttpMethod. Note Ao contrário dos métodos de rota, essa propriedade não serve o item RouteMethod.Any. Em vez disso, ela retorna o método de requisição real. Obtendo componentes da URL da requisição Você pode obter vários componentes de uma URL por meio de propriedades de uma requisição. Para este exemplo, vamos considerar a URL: http://localhost:5000/user/login?email=foo@bar.com Nome do componente Descrição Valor do componente Path Obtém o caminho da requisição. /user/login FullPath Obtém o caminho da requisição e a string de consulta. /user/login?email=foo@bar.com FullUrl Obtém a string de requisição URL completa. http://localhost:5000/user/login?email=foo@bar.com Host Obtém o host da requisição. localhost Authority Obtém o host e a porta da requisição. localhost:5000 QueryString Obtém a string de consulta da requisição. ?email=foo@bar.com Query Obtém a string de consulta da requisição em uma coleção de valores nomeados. {StringValueCollection object} IsSecure Determina se a requisição está usando SSL (true) ou não (false). false Você também pode optar por usar a propriedade HttpRequest.Uri, que inclui tudo acima em um objeto. Obtendo o corpo da requisição Algumas requisições incluem corpo, como formulários, arquivos ou transações de API. Você pode obter o corpo de uma requisição a partir da propriedade: // obtém o corpo da requisição como uma string, usando o codificador de requisição como codificador string body = request.Body; // ou obtém como um array de bytes byte[] bodyBytes = request.RawBody; // ou ainda, você pode transmiti-lo. Stream requestStream = request.GetRequestStream(); Também é possível determinar se há um corpo na requisição e se ele está carregado com as propriedades HasContents, que determina se a requisição tem conteúdo e IsContentAvailable que indica que o servidor HTTP recebeu completamente o conteúdo do ponto remoto. Não é possível ler o conteúdo da requisição por meio de GetRequestStream mais de uma vez. Se você ler com este método, os valores em RawBody e Body também não estarão disponíveis. Não é necessário descartar o fluxo de requisição no contexto da requisição, pois ele é descartado no final da sessão HTTP em que é criado. Além disso, você pode usar a propriedade HttpRequest.RequestEncoding para obter o melhor codificador para decodificar a requisição manualmente. O servidor tem limites para ler o conteúdo da requisição, o que se aplica a ambos HttpRequest.Body e HttpRequest.RawBody. Essas propriedades copiam o fluxo de entrada inteiro para um buffer local do mesmo tamanho de HttpRequest.ContentLength. Uma resposta com status 413 Conteúdo Muito Grande é retornada ao cliente se o conteúdo enviado for maior que HttpServerConfiguration.MaximumContentLength definido na configuração do usuário. Além disso, se não houver limite configurado ou se ele for muito grande, o servidor lançará uma OutOfMemoryException quando o conteúdo enviado pelo cliente exceder Int32.MaxValue (2 GB) e se o conteúdo for acessado por meio de uma das propriedades mencionadas acima. Você ainda pode lidar com o conteúdo por meio de transmissão. Note Embora o Sisk permita, é sempre uma boa ideia seguir a Semântica HTTP para criar sua aplicação e não obter ou servir conteúdo em métodos que não o permitam. Leia sobre RFC 9110 \"HTTP Semantics\". Obtendo o contexto da requisição O Contexto HTTP é um objeto exclusivo do Sisk que armazena informações do servidor HTTP, rota, roteador e manipulador de requisição. Você pode usá-lo para se organizar em um ambiente onde esses objetos são difíceis de organizar. O objeto RequestBag contém informações armazenadas que são passadas de um manipulador de requisição para outro ponto e podem ser consumidas no destino final. Esse objeto também pode ser usado por manipuladores de requisição que são executados após o callback da rota. Tip Essa propriedade também é acessível pela propriedade HttpRequest.Bag. Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } O manipulador de requisição acima definirá AuthenticatedUser no saco de requisição e pode ser consumido posteriormente no callback final: Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } Você também pode usar os métodos auxiliares Bag.Set() e Bag.Get() para obter ou definir objetos por seus tipos singleton. Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } Obtendo dados de formulário Você pode obter os valores de dados de formulário em uma NameValueCollection com o exemplo abaixo: Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } Obtendo dados de formulário multipart A requisição HTTP do Sisk permite obter conteúdos multipart, como arquivos, campos de formulário ou qualquer conteúdo binário. Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // o método a seguir lê a entrada de requisição inteira em um // array de MultipartObjects var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // O nome do arquivo fornecido pelo Multipart form data. // Null é retornado se o objeto não for um arquivo. Console.WriteLine(\"Nome do arquivo : \" + uploadedObject.Filename); // O nome do campo do formulário Multipart form data. Console.WriteLine(\"Nome do campo : \" + uploadedObject.Name); // O comprimento do conteúdo do Multipart form data. Console.WriteLine(\"Comprimento do conteúdo : \" + uploadedObject.ContentLength); // Determina o formato de arquivo com base no cabeçalho do arquivo para cada // tipo de conteúdo conhecido. Se o conteúdo não for um formato de arquivo comum // reconhecido, o método abaixo retornará MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Formato comum : \" + uploadedObject.GetCommonFileFormat()); } } Você pode ler mais sobre os objetos Multipart form do Sisk e seus métodos, propriedades e funcionalidades. Suporte a eventos enviados pelo servidor O Sisk suporta Eventos enviados pelo servidor, que permitem enviar pedaços como um fluxo e manter a conexão entre o servidor e o cliente viva. Chamar o método HttpRequest.GetEventSource colocará a requisição HTTP em seu estado de ouvinte. A partir disso, o contexto dessa requisição HTTP não esperará uma resposta HttpResponse, pois ela sobreporá os pacotes enviados por eventos do servidor. Depois de enviar todos os pacotes, o callback deve retornar o método Close, que enviará a resposta final ao servidor e indicará que o streaming terminou. Não é possível prever o comprimento total de todos os pacotes que serão enviados, portanto, não é possível determinar o fim da conexão com o cabeçalho Content-Length. A maioria dos navegadores não suporta envio de cabeçalhos HTTP ou métodos diferentes do GET com eventos do servidor. Portanto, tenha cuidado ao usar manipuladores de requisição com solicitações de evento-fonte que exigem cabeçalhos específicos na requisição, pois eles provavelmente não os terão. Além disso, a maioria dos navegadores reinicia os fluxos se o método EventSource.close não for chamado no lado do cliente após receber todos os pacotes, causando processamento infinito adicional no lado do servidor. Para evitar esse tipo de problema, é comum enviar um pacote final indicando que a fonte de eventos terminou de enviar todos os pacotes. O exemplo abaixo mostra como o navegador pode se comunicar com o servidor que suporta Eventos do Servidor. sse-example.html HTML <html> <body> <b>Frutas:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `mensagem: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomate\") { evtSource.close(); } } </script> </html> E envie progressivamente as mensagens para o cliente: Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] frutas = new[] { \"Maçã\", \"Banana\", \"Melancia\", \"Tomate\" }; foreach (string fruta in frutas) { await serverEvents.SendAsync(fruta); await Task.Delay(1500); } return serverEvents.Close(); } } Quando executar esse código, esperamos um resultado semelhante a este: Resolvendo IPs e hosts proxy O Sisk pode ser usado com proxies, portanto, os endereços IP podem ser substituídos pelo endpoint do proxy na transação de um cliente para o proxy. Você pode definir seus próprios resolvidores no Sisk com resolvidores de encaminhamento. Codificação de cabeçalhos A codificação de cabeçalhos pode ser um problema para algumas implementações. No Windows, cabeçalhos UTF-8 não são suportados, portanto, o ASCII é usado. O Sisk tem um conversor de codificação embutido, que pode ser útil para decodificar cabeçalhos codificados incorretamente. Essa operação é custosa e está desabilitada por padrão, mas pode ser habilitada sob a flag NormalizeHeadersEncodings."
  },
  "docs/pt-br/fundamentals/responses.html": {
    "href": "docs/pt-br/fundamentals/responses.html",
    "title": "Respostas | Sisk",
    "keywords": "Respostas Respostas representam objetos que são respostas HTTP para solicitações HTTP. Elas são enviadas pelo servidor ao cliente como uma indicação da solicitação de um recurso, página, documento, arquivo ou outro objeto. Uma resposta HTTP é formada por status, cabeçalhos e conteúdo. Neste documento, ensinaremos como arquitetar respostas HTTP com Sisk. Definindo um status HTTP A lista de status HTTP é a mesma desde o HTTP/1.0, e Sisk suporta todos eles. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 Ou com Sintaxe Fluente: new HttpResponse() .WithStatus(200) // ou .WithStatus(HttpStatusCode.Ok) // ou .WithStatus(HttpStatusInformation.Ok); Você pode ver a lista completa de HttpStatusCode disponíveis aqui. Você também pode fornecer seu próprio código de status usando a estrutura HttpStatusInformation. Corpo e tipo de conteúdo Sisk suporta objetos de conteúdo .NET nativos para enviar corpos em respostas. Você pode usar a classe StringContent para enviar uma resposta JSON, por exemplo: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); O servidor sempre tentará calcular o Content-Length do que você definiu no conteúdo se você não o definiu explicitamente em um cabeçalho. Se o servidor não puder obter implicitamente o cabeçalho Content-Length do conteúdo da resposta, a resposta será enviada com Chunked-Encoding. Você também pode transmitir a resposta enviando um StreamContent ou usando o método GetResponseStream. Cabeçalhos de resposta Você pode adicionar, editar ou remover cabeçalhos que está enviando na resposta. O exemplo abaixo mostra como enviar uma resposta de redirecionamento para o cliente. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Ou com Sintaxe Fluente: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Quando você usa o método Add de HttpHeaderCollection, você está adicionando um cabeçalho à solicitação sem alterar os que já foram enviados. O método Set substitui os cabeçalhos com o mesmo nome pelo valor instruído. O indexador de HttpHeaderCollection chama internamente o método Set para substituir os cabeçalhos. Enviando cookies Sisk tem métodos que facilitam a definição de cookies no cliente. Cookies definidos por este método já estão codificados em URL e atendem ao padrão RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"nome-do-cookie\", \"valor-do-cookie\"); Ou com Sintaxe Fluente: new HttpResponse(301) .WithCookie(\"nome-do-cookie\", \"valor-do-cookie\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Existem outras versões mais completas do mesmo método. Respostas chunked Você pode definir a codificação de transferência como chunked para enviar respostas grandes. HttpResponse res = new HttpResponse(); res.SendChunked = true; Quando usar chunked-encoding, o cabeçalho Content-Length é automaticamente omitido. Fluxo de resposta Os fluxos de resposta são uma maneira gerenciada que permite enviar respostas de forma segmentada. É uma operação de nível mais baixo do que usar objetos HttpResponse, pois exigem que você envie os cabeçalhos e o conteúdo manualmente e, em seguida, feche a conexão. Este exemplo abre um fluxo de leitura somente para o arquivo, copia o fluxo para o fluxo de saída da resposta e não carrega o arquivo inteiro na memória. Isso pode ser útil para servir arquivos médios ou grandes. // obtém o fluxo de saída da resposta using var fileStream = File.OpenRead(\"meu-arquivo-grande.zip\"); var responseStream = request.GetResponseStream(); // define a codificação de resposta para usar chunked-encoding // também você não deve enviar o cabeçalho content-length quando usar // chunked encoding responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copia o fluxo do arquivo para o fluxo de saída da resposta fileStream.CopyTo(responseStream.ResponseStream); // fecha o fluxo return responseStream.Close(); Compressão GZip, Deflate e Brotli Você pode enviar respostas com conteúdo comprimido em Sisk com conteúdos HTTP comprimidos. Primeiramente, encapsule seu objeto HttpContent dentro de um dos compressores abaixo para enviar a resposta comprimida ao cliente. router.MapGet(\"/hello.html\", request => { string meuHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(meuHtml)), // ou Content = new BrotliContent(new HtmlContent(meuHtml)), // ou Content = new DeflateContent(new HtmlContent(meuHtml)), }; }); Você também pode usar esses conteúdos comprimidos com fluxos. router.MapGet(\"/archive.zip\", request => { // não aplique \"using\" aqui. o HttpServer irá descartar seu conteúdo // após enviar a resposta. var arquivo = File.OpenRead(\"/caminho/para/arquivo-grande.zip\"); return new HttpResponse () { Content = new GZipContent(arquivo) } }); Os cabeçalhos Content-Encoding são automaticamente definidos quando usados esses conteúdos. Compressão automática É possível comprimir automaticamente respostas HTTP com a propriedade EnableAutomaticResponseCompression. Essa propriedade encapsula automaticamente o conteúdo da resposta do roteador em um conteúdo comprimido que é aceito pela solicitação, desde que a resposta não seja herdada de um CompressedContent. Apenas um conteúdo comprimido é escolhido para uma solicitação, escolhido de acordo com o cabeçalho Accept-Encoding, que segue a ordem: BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) Se a solicitação especificar que aceita qualquer um desses métodos de compressão, a resposta será automaticamente comprimida. Tipos de resposta implícitos Você pode usar outros tipos de retorno além de HttpResponse, mas é necessário configurar o roteador para lidar com cada tipo de objeto. O conceito é sempre retornar um tipo de referência e transformá-lo em um objeto HttpResponse válido. Rotas que retornam HttpResponse não passam por nenhuma conversão. Tipos de valor (estruturas) não podem ser usados como tipo de retorno porque não são compatíveis com o RouterCallback, portanto, devem ser encapsulados em um ValueResult para poderem ser usados em manipuladores. Considere o exemplo a seguir de um módulo de roteador que não usa HttpResponse no tipo de retorno: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } Com isso, agora é necessário definir no roteador como ele lidará com cada tipo de objeto. Objetos são sempre o primeiro argumento do manipulador e o tipo de saída deve ser um HttpResponse válido. Além disso, os objetos de saída de uma rota nunca devem ser nulos. Para tipos ValueResult, não é necessário indicar que o objeto de entrada é um ValueResult e apenas T, pois ValueResult é um objeto refletido de seu componente original. A associação de tipos não compara o que foi registrado com o tipo do objeto retornado do callback do roteador. Em vez disso, verifica se o tipo do resultado do roteador é atribuível ao tipo registrado. Registrar um manipulador do tipo Object será um fallback para todos os tipos não validados anteriormente. A ordem de inserção dos manipuladores de valor também importa, portanto, registrar um manipulador de objeto primeiro ignorará todos os outros manipuladores específicos de tipo. Sempre registre manipuladores de valor específicos primeiro para garantir a ordem. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // registrando um manipulador de valor de objeto deve ser o último // manipulador de valor que será usado como fallback r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); Nota sobre objetos enumeráveis e arrays Objetos de resposta implícitos que implementam IEnumerable são lidos na memória através do método ToArray() antes de serem convertidos através de um manipulador de valor definido. Para que isso ocorra, o objeto IEnumerable é convertido em uma matriz de objetos, e o conversor de resposta sempre receberá um Object[] em vez do tipo original. Considere o cenário a seguir: using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"Matriz de string:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Matriz de objeto:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); No exemplo acima, o conversor IEnumerable<string> nunca será chamado, porque o objeto de entrada sempre será um Object[] e não é conversível para um IEnumerable<string>. No entanto, o conversor abaixo que recebe um IEnumerable<object> receberá sua entrada, pois seu valor é compatível. Se você precisar lidar com o tipo de objeto que será enumerado, você precisará usar reflexão para obter o tipo do elemento da coleção. Todos os objetos enumeráveis (listas, arrays e coleções) são convertidos em uma matriz de objetos pelo conversor de resposta HTTP. Valores que implementam IAsyncEnumerable são tratados automaticamente pelo servidor se a propriedade ConvertIAsyncEnumerableIntoEnumerable estiver habilitada, semelhante ao que acontece com IEnumerable. Uma enumeração assíncrona é convertida em um enumerador bloqueador e, em seguida, convertida em uma matriz de objetos síncronos."
  },
  "docs/pt-br/fundamentals/routing.html": {
    "href": "docs/pt-br/fundamentals/routing.html",
    "title": "Roteamento | Sisk",
    "keywords": "Roteamento O Router é o primeiro passo na construção do servidor. Ele é responsável por armazenar objetos Route, que são endpoints que mapeiam URLs e seus métodos para ações executadas pelo servidor. Cada ação é responsável por receber uma solicitação e entregar uma resposta ao cliente. As rotas são pares de expressões de caminho (\"padrão de caminho\") e o método HTTP que elas podem ouvir. Quando uma solicitação é feita ao servidor, ele tentará encontrar uma rota que corresponda à solicitação recebida, então ele chamará a ação daquela rota e entregará a resposta resultante ao cliente. Existem várias maneiras de definir rotas no Sisk: elas podem ser estáticas, dinâmicas ou auto-escaneadas, definidas por atributos ou diretamente no objeto Router. Router mainRouter = new Router(); // mapeia o GET / para a ação a seguir mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Olá, mundo!\"); }); Para entender o que uma rota é capaz de fazer, precisamos entender o que uma solicitação é capaz de fazer. Um HttpRequest conterá tudo o que você precisa. O Sisk também inclui alguns recursos extras que aceleram o desenvolvimento geral. Para cada ação recebida pelo servidor, um delegado do tipo RouteAction será chamado. Este delegado contém um parâmetro que segura um HttpRequest com todas as informações necessárias sobre a solicitação recebida pelo servidor. O objeto resultante deste delegado deve ser um HttpResponse ou um objeto que mapeia para ele por meio de tipos de resposta implícitos. Correspondência de rotas Quando uma solicitação é recebida pelo servidor HTTP, o Sisk procura uma rota que satisfaça a expressão do caminho recebido pela solicitação. A expressão é sempre testada entre a rota e o caminho da solicitação, sem considerar a string de consulta. Este teste não tem prioridade e é exclusivo para uma única rota. Quando nenhuma rota é correspondida com aquela solicitação, a resposta Router.NotFoundErrorHandler é retornada ao cliente. Quando o padrão de caminho é correspondido, mas o método HTTP é incorreto, a resposta Router.MethodNotAllowedErrorHandler é enviada de volta ao cliente. O Sisk verifica a possibilidade de colisões de rotas para evitar esses problemas. Quando as rotas são definidas, o Sisk procurará por rotas possíveis que possam colidir com a rota sendo definida. Este teste inclui a verificação do caminho e do método que a rota está configurada para aceitar. Criando rotas usando padrões de caminho Você pode definir rotas usando vários métodos SetRoute. // maneira SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Olá, {name}\"); }); // maneira Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 200 ok vazio }); // métodos de ajuda Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // o StreamContent interno // stream é descartado após o envio // da resposta. Content = new StreamContent(imageStream) }; }); // vários parâmetros mainRouter.MapGet(\"/hey/<name>/sobrenome/<sobrenome>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string sobrenome = request.RouteParameters[\"sobrenome\"].GetString(); return new HttpResponse($\"Olá, {name} {sobrenome}!\"); }); A propriedade RouteParameters do HttpResponse contém todas as informações sobre as variáveis de caminho da solicitação recebida. Cada caminho recebido pelo servidor é normalizado antes que o teste do padrão de caminho seja executado, seguindo essas regras: Todos os segmentos vazios são removidos do caminho, por exemplo: ////foo//bar se torna /foo/bar. A correspondência de caminho é sensível a maiúsculas e minúsculas, a menos que Router.MatchRoutesIgnoreCase seja definido como true. As propriedades Query e RouteParameters do HttpRequest retornam um objeto StringValueCollection, onde cada propriedade indexada retorna um StringValue não nulo, que pode ser usado como uma opção/monad para converter seu valor bruto em um objeto gerenciado. O exemplo abaixo lê o parâmetro de rota \"id\" e obtém um Guid a partir dele. Se o parâmetro não for um Guid válido, uma exceção é lançada e um erro 500 é retornado ao cliente se o servidor não estiver lidando com Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); [!NOTA] Os caminhos têm sua barra final / ignorada em ambos os caminhos da solicitação e da rota, ou seja, se você tentar acessar uma rota definida como /index/page você poderá acessá-la usando /index/page/ também. Você também pode forçar as URLs a terminar com / habilitando a flag ForceTrailingSlash. Criando rotas usando instâncias de classe Você também pode definir rotas dinamicamente usando reflexão com o atributo RouteAttribute. Dessa forma, a instância de uma classe na qual seus métodos implementam esse atributo terá suas rotas definidas no roteador de destino. Para que um método seja definido como uma rota, ele deve ser marcado com um RouteAttribute, como o próprio atributo ou um RouteGetAttribute. O método pode ser estático, de instância, público ou privado. Quando o método SetObject(type) ou SetObject<TType>() é usado, os métodos de instância são ignorados. Controller/MyController.cs C# public class MyController { // corresponderá ao GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // métodos estáticos também funcionam [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Olá, mundo!\"); return res; } } A linha abaixo definirá tanto o método Index quanto o método Hello de MyController como rotas, pois ambos são marcados como rotas e uma instância da classe foi fornecida, não seu tipo. Se seu tipo tivesse sido fornecido em vez de uma instância, apenas os métodos estáticos seriam definidos. var myController = new MyController(); mainRouter.SetObject(myController); Desde a versão 0.16 do Sisk, é possível habilitar o AutoScan, que procurará por classes definidas pelo usuário que implementam RouterModule e as associará automaticamente ao roteador. Isso não é suportado com compilação AOT. mainRouter.AutoScanModules<ApiController>(); A instrução acima procurará por todos os tipos que implementam ApiController, mas não o tipo em si. Os dois parâmetros opcionais indicam como o método procurará por esses tipos. O primeiro argumento implica a Assembly onde os tipos serão procurados e o segundo indica a forma como os tipos serão definidos. Rotas de regex Em vez de usar os métodos de correspondência de caminho HTTP padrão, você pode marcar uma rota para ser interpretada com Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"Minha rota\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Ou com a classe RegexRoute: mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"olá, mundo\"); })); Você também pode capturar grupos da expressão regular no padrão para o conteúdo de HttpRequest.RouteParameters: Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessando arquivo {filename}\"); } } Prefixo de rotas Você pode prefixar todas as rotas em uma classe ou módulo com o atributo RoutePrefix e definir o prefixo como uma string. Veja o exemplo abaixo usando a arquitetura BREAD (Browse, Read, Edit, Add e Delete): Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // corresponderá ao GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // corresponderá ao GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // corresponderá ao PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // corresponderá ao POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // corresponderá ao DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } No exemplo acima, o parâmetro HttpResponse é omitido em favor de ser usado por meio do contexto global HttpContext.Current. Leia mais na seção a seguir. Rotas sem parâmetro de solicitação As rotas podem ser definidas sem o parâmetro HttpRequest e ainda é possível obter a solicitação e seus componentes no contexto da solicitação. Vamos considerar uma abstração ControllerBase que serve como base para todos os controladores de uma API e que fornece a propriedade Request para obter a HttpRequest atualmente. Controller/ControllerBase.cs C# public abstract class ControllerBase { // obtém a solicitação do thread atual public HttpRequest Request { get => HttpContext.Current.Request; } // a linha abaixo, quando chamada, obtém o banco de dados da sessão HTTP atual, // ou cria um novo se ele não existir public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } E para que todos os seus descendentes possam usar a sintaxe de rota sem o parâmetro de solicitação: Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // lê os dados JSON do corpo da solicitação atual UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } Mais detalhes sobre o contexto atual e injeção de dependência podem ser encontrados no tutorial de injeção de dependência. Rotas de qualquer método Você pode definir uma rota para ser correspondida apenas por seu caminho e ignorar o método HTTP. Isso pode ser útil para você fazer a validação do método dentro da callback da rota. // corresponderá ao / em qualquer método HTTP mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Rotas de qualquer caminho As rotas de qualquer caminho testam para qualquer caminho recebido pelo servidor HTTP, sujeito ao método da rota sendo testado. Se o método da rota for RouteMethod.Any e a rota usar Route.AnyPath em sua expressão de caminho, essa rota ouvirá todas as solicitações do servidor HTTP e nenhuma outra rota pode ser definida. // a rota a seguir corresponderá a todas as solicitações POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Correspondência de rota ignorando caso Por padrão, a interpretação de rotas com solicitações é sensível a maiúsculas e minúsculas. Para fazer com que ela ignore o caso, habilite essa opção: mainRouter.MatchRoutesIgnoreCase = true; Isso também habilitará a opção RegexOptions.IgnoreCase para rotas que usam correspondência de regex. Tratador de callback de não encontrado (404) Você pode criar um callback personalizado para quando uma solicitação não corresponde a nenhuma rota conhecida. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Desde a v0.14 Content = new HtmlContent(\"<h1>Não encontrado</h1>\") // versões anteriores Content = new StringContent(\"<h1>Não encontrado</h1>\", Encoding.UTF8, \"text/html\") }; }; Tratador de callback de método não permitido (405) Você também pode criar um callback personalizado para quando uma solicitação corresponde ao seu caminho, mas não corresponde ao método. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Método não permitido para esta rota.\") }; }; Tratador de erro interno Os callbacks de rota podem lançar erros durante a execução do servidor. Se não forem tratados corretamente, o funcionamento geral do servidor HTTP pode ser interrompido. O roteador tem um callback para quando um callback de rota falha e impede a interrupção do serviço. Esse método só é alcançável quando ThrowExceptions é definido como false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Erro: {ex.Message}\") }; };"
  },
  "docs/pt-br/getting-started.html": {
    "href": "docs/pt-br/getting-started.html",
    "title": "Introdução | Sisk",
    "keywords": "Introdução Bem-vindo à documentação do Sisk! Finalmente, o que é o Sisk Framework? É uma biblioteca leve de código aberto construída com .NET, projetada para ser minimalista, flexível e abstrata. Ela permite que os desenvolvedores criem serviços de internet rapidamente, com pouca ou nenhuma configuração necessária. O Sisk torna possível que seu aplicativo existente tenha um módulo HTTP gerenciado, completo e descartável. Os valores do Sisk incluem transparência de código, modularidade, desempenho e escalabilidade, e podem lidar com vários tipos de aplicativos, como Restful, JSON-RPC, Web-sockets e mais. Seus principais recursos incluem: Recurso Descrição Routing Um roteador de caminhos que suporta prefixos, métodos personalizados, variáveis de caminho, conversores de valor e mais. Request Handlers Também conhecidos como middlewares, fornecem uma interface para criar seus próprios manipuladores de solicitações que funcionam com a solicitação antes ou após uma ação. Compression Comprima o conteúdo de suas respostas facilmente com o Sisk. Web sockets Fornece rotas que aceitam web-sockets completos, para leitura e escrita no cliente. Server-sent events Fornece o envio de eventos do servidor para clientes que suportam o protocolo SSE. Logging Registro de logs simplificado. Registre erros, acesso, defina logs rotativos por tamanho, múltiplos fluxos de saída para o mesmo log e mais. Multi-host Tenha um servidor HTTP para várias portas, e cada porta com seu próprio roteador, e cada roteador com seu próprio aplicativo. Server handlers Estenda sua própria implementação do servidor HTTP. Personalize com extensões, melhorias e novos recursos. Primeiros passos O Sisk pode ser executado em qualquer ambiente .NET. Neste guia, vamos ensinar como criar um aplicativo Sisk usando .NET. Se você ainda não o instalou, por favor, baixe o SDK aqui. Neste tutorial, vamos cobrir como criar uma estrutura de projeto, receber uma solicitação, obter um parâmetro de URL e enviar uma resposta. Este guia se concentrará em criar um servidor simples usando C#. Você também pode usar sua linguagem de programação favorita. Note Você pode estar interessado em um projeto de início rápido. Verifique este repositório para obter mais informações. Criando um Projeto Vamos nomear nosso projeto \"Meu Aplicativo Sisk\". Uma vez que você tenha o .NET configurado, você pode criar seu projeto com o seguinte comando: dotnet new console -n meu-aplicativo-sisk Em seguida, navegue até o diretório do seu projeto e instale o Sisk usando a ferramenta de utilitário .NET: cd meu-aplicativo-sisk dotnet add package Sisk.HttpServer Você pode encontrar maneiras adicionais de instalar o Sisk em seu projeto aqui. Agora, vamos criar uma instância do nosso servidor HTTP. Para este exemplo, vamos configurá-lo para ouvir na porta 5000. Construindo o Servidor HTTP O Sisk permite que você construa seu aplicativo passo a passo manualmente, pois ele roteia para o objeto HttpServer. No entanto, isso pode não ser muito conveniente para a maioria dos projetos. Portanto, podemos usar o método de construtor, que torna mais fácil colocar nosso aplicativo em execução. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Olá, mundo!\") }; }); await app.StartAsync(); } } É importante entender cada componente vital do Sisk. Mais tarde, neste documento, você aprenderá mais sobre como o Sisk funciona. Configuração manual (avançada) Você pode aprender como cada mecanismo do Sisk funciona nesta seção da documentação, que explica o comportamento e as relações entre o HttpServer, Router, ListeningPort e outros componentes."
  },
  "docs/pt-br/installing.html": {
    "href": "docs/pt-br/installing.html",
    "title": "Instalando | Sisk",
    "keywords": "Instalando Você pode instalar o Sisk por meio do Nuget, dotnet cli ou outras opções. Você pode configurar facilmente o ambiente do Sisk executando este comando no console do desenvolvedor: dotnet add package Sisk.HttpServer Este comando instalará a versão mais recente do Sisk no seu projeto."
  },
  "docs/pt-br/native-aot.html": {
    "href": "docs/pt-br/native-aot.html",
    "title": "Suporte Nativo AOT | Sisk",
    "keywords": "Suporte Nativo AOT .NET Native AOT permite a publicação de aplicativos .NET nativos que são autossuficientes e não requerem o tempo de execução .NET instalado no host de destino. Além disso, o Native AOT fornece benefícios como: Aplicativos muito menores Inicialização significativamente mais rápida Consumo de memória mais baixo O Sisk Framework, por sua natureza explícita, permite o uso de Native AOT para quase todos os seus recursos sem exigir rework no código-fonte para adaptá-lo ao Native AOT. Recursos não suportados No entanto, o Sisk usa reflexão, embora mínima, para alguns recursos. Os recursos mencionados abaixo podem estar parcialmente disponíveis ou completamente indisponíveis durante a execução de código nativo: Auto-escaneamento de módulos do roteador: este recurso escaneia os tipos incorporados na Assembly em execução e registra os tipos que são módulos do roteador. Este recurso requer tipos que possam ser excluídos durante a redução da Assembly. Todos os outros recursos são compatíveis com o AOT no Sisk. É comum encontrar um ou outro método que dá um aviso de AOT, mas o mesmo, se não for mencionado aqui, tem uma sobrecarga que indica a passagem de um tipo, parâmetro ou informação de tipo que ajuda o compilador AOT a compilar o objeto."
  },
  "docs/pt-br/registering-namespace.html": {
    "href": "docs/pt-br/registering-namespace.html",
    "title": "Configurando reservas de namespace no Windows | Sisk",
    "keywords": "Configurando reservas de namespace no Windows Sisk trabalha com a interface de rede HttpListener, que vincula um host virtual ao sistema para ouvir solicitações. No Windows, essa vinculação é um pouco restritiva, permitindo apenas que o localhost seja vinculado como um host válido. Ao tentar ouvir outro host, um erro de acesso negado é lançado no servidor. Este tutorial explica como conceder autorização para ouvir em qualquer host que você desejar no sistema. Namespace Setup.bat BATCH @echo off :: insira o prefixo aqui, sem espaços ou aspas SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Onde em PREFIX, é o prefixo (\"Host de Escuta->Porta\") que o servidor irá ouvir. Ele deve ser formatado com o esquema de URL, host, porta e uma barra no final, exemplo: Namespace Setup.bat BATCH SET PREFIX=http://meu-aplicativo.exemplo.teste/ Para que você possa ser ouvido em sua aplicação por meio de: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://meu-aplicativo.exemplo.teste/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Olá, mundo!\") }; }); await app.StartAsync(); } }"
  },
  "docs/pt-br/ssl.html": {
    "href": "docs/pt-br/ssl.html",
    "title": "Trabalhando com SSL | Sisk",
    "keywords": "Trabalhando com SSL Trabalhar com SSL para desenvolvimento pode ser necessário quando se trabalha em contextos que exigem segurança, como a maioria dos cenários de desenvolvimento web. O Sisk opera em cima do HttpListener, que não suporta HTTPS nativo, apenas HTTP. No entanto, existem soluções que permitem trabalhar com SSL no Sisk. Veja-as abaixo: Através do IIS no Windows Disponível em: Windows Esforço: médio Se você estiver no Windows, pode usar o IIS para habilitar o SSL no seu servidor HTTP. Para que isso funcione, é aconselhável seguir este tutorial antes, se você quiser que sua aplicação esteja ouvindo em um host diferente de \"localhost\". Para que isso funcione, você deve instalar o IIS através das recursos do Windows. O IIS está disponível gratuitamente para usuários do Windows e Windows Server. Para configurar o SSL na sua aplicação, tenha o certificado SSL pronto, mesmo que seja autoassinado. Em seguida, você pode ver como configurar o SSL no IIS 7 ou superior. Através do mitmproxy Disponível em: Linux, macOS, Windows Esforço: fácil mitmproxy é uma ferramenta de proxy de interceptação que permite que desenvolvedores e testadores de segurança inspecionem, modifiquem e gravem o tráfego HTTP e HTTPS entre um cliente (como um navegador da web) e um servidor. Você pode usar a utilidade mitmdump para iniciar um proxy SSL reverso entre o seu cliente e a aplicação Sisk. Primeiramente, instale o mitmproxy na sua máquina. Inicie a aplicação Sisk. Neste exemplo, usaremos a porta 8000 como a porta HTTP insegura. Inicie o servidor mitmproxy para ouvir a porta segura na porta 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 E pronto! Você já pode acessar a aplicação através de https://localhost:8001/. A aplicação não precisa estar em execução para iniciar o mitmdump. Alternativamente, você pode adicionar uma referência ao helper do mitmproxy no seu projeto. Isso ainda exige que o mitmproxy esteja instalado no seu computador. Através do pacote Sisk.SslProxy Disponível em: Linux, macOS, Windows Esforço: fácil O pacote Sisk.SslProxy é uma maneira simples de habilitar o SSL na aplicação Sisk. No entanto, é um pacote extremamente experimental. Pode ser instável trabalhar com esse pacote, mas você pode ser parte do pequeno percentual de pessoas que contribuirão para tornar esse pacote viável e estável. Para começar, você pode instalar o pacote Sisk.SslProxy com: dotnet add package Sisk.SslProxy Note Você deve habilitar \"Habilitar pacotes de pré-lançamento\" no Gerenciador de Pacotes do Visual Studio para instalar o Sisk.SslProxy. Novamente, é um projeto experimental, então não pense em colocá-lo em produção. No momento, o Sisk.SslProxy pode lidar com a maioria dos recursos do HTTP/1.1, incluindo HTTP Continue, Chunked-Encoding, WebSockets e SSE. Leia mais sobre o SslProxy aqui."
  },
  "docs/registering-namespace.html": {
    "href": "docs/registering-namespace.html",
    "title": "Configuring namespace reservations on Windows | Sisk",
    "keywords": "Configuring namespace reservations on Windows Sisk works with the HttpListener network interface, which binds a virtual host to the system to listen for requests. On Windows, this binding is a bit restrictive, only allowing localhost to be bound as a valid host. When attempting to listen to another host, an access denied error is thrown on the server. This tutorial explains how to grant authorization to listen on any host you want on the system. Namespace Setup.bat BATCH @echo off :: insert prefix here, without spaces or quotes SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Where in PREFIX, is the prefix (\"Listening Host->Port\") that your server will listen to. It must be formatted with the URL scheme, host, port and a slash at the end, example: Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ So that you can be listened in your application through: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/ru/advanced/forwarding-resolvers.html": {
    "href": "docs/ru/advanced/forwarding-resolvers.html",
    "title": "Перенаправляющие Резолверы | Sisk",
    "keywords": "Перенаправляющие Резолверы Перенаправляющий Резолвер - это помощник, который помогает декодировать информацию, идентифицирующую клиента через запрос, прокси, CDN или балансировщики нагрузки. Когда ваш сервис Sisk запускается через обратный или прямой прокси, IP-адрес клиента, хост и протокол могут быть khácными от исходного запроса, поскольку это перенаправление из одного сервиса в другой. Эта функциональность Sisk позволяет вам контролировать и решать эту информацию перед работой с запросом. Эти прокси обычно предоставляют полезные заголовки для идентификации их клиента. В настоящее время с помощью класса ForwardingResolver возможно решить IP-адрес клиента, хост и HTTP-протокол, используемый. После версии 1.0 Sisk сервер больше не имеет стандартной реализации для декодирования этих заголовков по причинам безопасности, которые варьируются от сервиса к сервису. Например, заголовок X-Forwarded-For содержит информацию об IP-адресах, которые перенаправили запрос. Этот заголовок используется прокси для переноса цепочки информации к конечному сервису и включает IP-адрес всех прокси, использованных, включая реальный адрес клиента. Проблема в том, что иногда бывает сложно идентифицировать удаленный IP-адрес клиента, и нет конкретного правила для идентификации этого заголовка. Высоко рекомендуется прочитать документацию для заголовков, которые вы собираетесь реализовать ниже: Прочитайте о заголовке X-Forwarded-For здесь. Прочитайте о заголовке X-Forwarded-Host здесь. Прочитайте о заголовке X-Forwarded-Proto здесь. Класс ForwardingResolver Этот класс имеет три виртуальных метода, которые позволяют наиболее подходящую реализацию для каждого сервиса. Каждый метод отвечает за решение информации из запроса через прокси: IP-адрес клиента, хост запроса и протокол безопасности, используемый. По умолчанию Sisk всегда будет использовать информацию из исходного запроса, не решая никаких заголовков. Пример ниже показывает, как можно использовать эту реализацию. Этот пример решает IP-адрес клиента через заголовок X-Forwarded-For и выбрасывает ошибку, когда более одного IP-адреса было перенаправлено в запросе. Important Не используйте этот пример в производственном коде. Всегда проверяйте, является ли реализация подходящей для использования. Прочитайте документацию заголовков перед их реализацией. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"Заголовок X-Forwarded-For отсутствует.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Слишком много адресов в заголовке X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/ru/advanced/http-server-handlers.html": {
    "href": "docs/ru/advanced/http-server-handlers.html",
    "title": "Обработчики HTTP-сервера | Sisk",
    "keywords": "Обработчики HTTP-сервера В версии Sisk 0.16 мы ввели класс HttpServerHandler, целью которого является расширение общего поведения Sisk и предоставление дополнительных обработчиков событий для Sisk, таких как обработка запросов HTTP, маршрутизаторы, контекстные сумки и многое другое. Этот класс концентрирует события, которые происходят во время существования всего HTTP-сервера и каждого запроса. Протокол HTTP не имеет сессий, и поэтому невозможно сохранить информацию от одного запроса к другому. Sisk в настоящее время предоставляет способ реализации сессий, контекстов, подключений к базе данных и других полезных провайдеров, чтобы помочь вашей работе. Пожалуйста, обратитесь к этой странице, чтобы прочитать, где каждое событие вызывается и какова его цель. Вы также можете просмотреть жизненный цикл запроса HTTP, чтобы понять, что происходит с запросом и где вызываются события. HTTP-сервер позволяет использовать несколько обработчиков одновременно. Каждый вызов события является синхронным, то есть он будет блокировать текущую нить для каждого запроса или контекста, пока все обработчики, связанные с этой функцией, не будут выполнены и завершены. В отличие от RequestHandlers, они не могут быть применены к определенным группам маршрутов или конкретным маршрутам. Вместо этого они применяются к整个 HTTP-серверу. Вы можете применять условия внутри вашего обработчика HTTP-сервера. Кроме того, синглтоны каждого HttpServerHandler определяются для каждого приложения Sisk, поэтому существует только один экземпляр на HttpServerHandler. Практическим примером использования HttpServerHandler является автоматическое освобождение подключения к базе данных в конце запроса. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // проверяет, определена ли DbContext в контекстной сумке запроса if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // позволяет пользователю создать контекст базы данных из запроса HTTP // и сохранить его в контекстной сумке public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } С помощью кода выше, расширение GetDbContext позволяет создать контекст подключения к базе данных直接 из объекта HttpRequest. Неправильно освобожденное подключение может вызвать проблемы при работе с базой данных, поэтому оно завершается в OnHttpRequestClose. Вы можете зарегистрировать обработчик на HTTP-сервере в вашем построителе или直接 с помощью HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } С помощью этого, класс UsersController может использовать контекст базы данных следующим образом: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Пользователь добавлен.\"); } } Код выше использует методы, такие как JsonOk и JsonMessage, которые встроены в ApiController, который наследуется от RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Разработчики могут реализовать сессии, контексты и подключения к базе данных, используя этот класс. Предоставленный код демонстрирует практический пример с DatabaseConnectionHandler, автоматизирующий освобождение подключения к базе данных в конце каждого запроса. Интеграция проста, с обработчиками, зарегистрированными во время настройки сервера. Класс HttpServerHandler предлагает мощный набор инструментов для управления ресурсами и расширения поведения Sisk в HTTP-приложениях."
  },
  "docs/ru/advanced/manual-setup.html": {
    "href": "docs/ru/advanced/manual-setup.html",
    "title": "Руководство (расширенная) настройка | Sisk",
    "keywords": "Руководство (расширенная) настройка В этом разделе мы создадим наш HTTP-сервер без каких-либо предопределенных стандартов, совершенно абстрактным способом. Здесь вы можете вручную настроить, как будет функционировать ваш HTTP-сервер. Каждый ListeningHost имеет маршрутизатор, и HTTP-сервер может иметь несколько ListeningHosts, каждый из которых указывает на другой хост на другом порту. Сначала нам нужно понять концепцию запроса/ответа. Это довольно просто: на каждый запрос должен быть ответ. Sisk также следует этому принципу. Давайте создадим метод, который отвечает сообщением \"Hello, World!\" в HTML, указывая статусный код и заголовки. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Привет, мир!</h1> </body> </html> \") }; return indexResponse; } Следующий шаг - связать этот метод с HTTP-маршрутом. Маршрутизаторы Маршрутизаторы являются абстракциями запросов и служат мостом между запросами и ответами для службы. Маршрутизаторы управляют маршрутами службы, функциями и ошибками. Маршрутизатор может иметь несколько маршрутов, и каждый маршрут может выполнять разные операции на этом пути, такие как выполнение функции, служба страницы или предоставление ресурса с сервера. Давайте создадим наш первый маршрутизатор и свяжем наш метод IndexPage с индексным путем. Router mainRouter = new Router(); // SetRoute будет связывать все индексные маршруты с нашим методом. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Теперь наш маршрутизатор может получать запросы и отправлять ответы. Однако mainRouter не привязан к хосту или серверу, поэтому он не будет работать самостоятельно. Следующий шаг - создать наш ListeningHost. Listening Hosts и Порты ListeningHost может хостить маршрутизатор и несколько прослушиваемых портов для одного и того же маршрутизатора. ListeningPort - это префикс, где HTTP-сервер будет слушать. Здесь мы можем создать ListeningHost, который указывает на два端пойнта для нашего маршрутизатора: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Теперь наш HTTP-сервер будет слушать указанные端пойнты и перенаправлять свои запросы на наш маршрутизатор. Настройка Сервера Настройка сервера отвечает за большую часть поведения HTTP-сервера. В этой конфигурации мы можем связать ListeningHosts с нашим сервером. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Добавляем наш ListeningHost в эту конфигурацию сервера Далее мы можем создать наш HTTP-сервер: HttpServer server = new HttpServer(config); server.Start(); // Запускает сервер Console.ReadKey(); // Предотвращает выход из приложения Теперь мы можем скомпилировать наш исполняемый файл и запустить наш HTTP-сервер с командой: dotnet watch Во время выполнения откройте браузер и перейдите по пути сервера, и вы должны увидеть:"
  },
  "docs/ru/advanced/multi-host-setup.html": {
    "href": "docs/ru/advanced/multi-host-setup.html",
    "title": "Несколько прослушивающих хостов на сервере | Sisk",
    "keywords": "Несколько прослушивающих хостов на сервере Фреймворк Sisk всегда поддерживал использование более одного хоста на сервер, то есть один HTTP-сервер может прослушивать несколько портов, и каждый порт имеет свой собственный маршрутизатор и свою службу, работающую на нем. Таким образом, легко разделить обязанности и управлять службами на одном HTTP-сервере с помощью Sisk. Пример ниже показывает создание двух прослушивающих хостов, каждый из которых прослушивает разный порт, с разными маршрутизаторами и действиями. Прочитайте создание приложения вручную, чтобы понять детали об этом абстрактном классе. static void Main(string[] args) { // создаем два прослушивающих хоста, каждый из которых имеет свой собственный маршрутизатор и // прослушивает свой собственный порт // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста А!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста Б!\")); // создаем конфигурацию сервера и добавляем оба // прослушивающих хоста в нее // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // создаем HTTP-сервер, который использует указанную // конфигурацию // HttpServer server = new HttpServer(configuration); // запускаем сервер server.Start(); Console.WriteLine(\"Попробуйте обратиться к хосту А по адресу {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Попробуйте обратиться к хосту Б по адресу {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/ru/advanced/request-lifecycle.html": {
    "href": "docs/ru/advanced/request-lifecycle.html",
    "title": "Жизненный цикл запроса | Sisk",
    "keywords": "Жизненный цикл запроса Ниже объясняется весь жизненный цикл запроса на примере HTTP-запроса. Приём запроса: каждый запрос создаёт контекст HTTP между самим запросом и ответом, который будет доставлен клиенту. Этот контекст поступает от встроенного слушателя в Sisk, который может быть HttpListener, Kestrel или Cadente. Внешняя валидация запроса: выполняется валидация HttpServerConfiguration.RemoteRequestsAction для запроса. Если запрос внешний и свойство равно Drop, соединение закрывается без ответа клиенту с HttpServerExecutionStatus = RemoteRequestDropped. Конфигурация разрешения пересылки: если настроен ForwardingResolver, вызывается метод OnResolveRequestHost для исходного хоста запроса. Сопоставление DNS: с разрешённым хостом и более чем одним настроенным ListeningHost, сервер ищет соответствующий хост для запроса. Если ни один ListeningHost не соответствует, клиенту возвращается ответ 400 Bad Request и статус HttpServerExecutionStatus = DnsUnknownHost возвращается контексту HTTP. Если ListeningHost соответствует, но его Router ещё не инициализирован, клиенту возвращается ответ 503 Service Unavailable и статус HttpServerExecutionStatus = ListeningHostNotReady возвращается контексту HTTP. Связывание маршрутизатора: маршрутизатор соответствующего ListeningHost связывается с полученным HTTP-сервером. Если маршрутизатор уже связан с другим HTTP-сервером, что не допускается, поскольку маршрутизатор активно использует ресурсы конфигурации сервера, выбрасывается исключение InvalidOperationException. Это происходит только во время инициализации HTTP-сервера, а не во время создания контекста HTTP. Предварительное определение заголовков: Предварительно определяет заголовок X-Request-Id в ответе, если он настроен. Предварительно определяет заголовок X-Powered-By в ответе, если он настроен. Валидация размера содержимого: проверяет, является ли содержимое запроса меньше HttpServerConfiguration.MaximumContentLength, только если оно больше нуля. Если запрос отправляет Content-Length больше настроенного, клиенту возвращается ответ 413 Payload Too Large и статус HttpServerExecutionStatus = ContentTooLarge возвращается контексту HTTP. Событие OnHttpRequestOpen вызывается для всех настроенных обработчиков HTTP-сервера. Маршрутизация действия: сервер вызывает маршрутизатор для полученного запроса. Если маршрутизатор не находит маршрут, соответствующий запросу: Если свойство Router.NotFoundErrorHandler настроено, вызывается действие, и ответ действия пересылается HTTP-клиенту. Если предыдущее свойство равно null, клиенту возвращается ответ 404 Not Found по умолчанию. Если маршрутизатор находит соответствующий маршрут, но метод маршрута не соответствует методу запроса: Если свойство Router.MethodNotAllowedErrorHandler настроено, вызывается действие, и ответ действия пересылается HTTP-клиенту. Если предыдущее свойство равно null, клиенту возвращается ответ 405 Method Not Allowed по умолчанию. Если запрос имеет метод OPTIONS: Маршрутизатор возвращает ответ 200 Ok клиенту только в том случае, если ни один маршрут не соответствует методу запроса (метод маршрута не явно указан как RouteMethod.Options). Если свойство HttpServerConfiguration.ForceTrailingSlash включено, соответствующий маршрут не является регулярным выражением, путь запроса не заканчивается на /, и метод запроса равен GET: Клиенту возвращается ответ 307 Temporary Redirect с заголовком Location, содержащим путь и запрос к тому же месту с / в конце. Событие OnContextBagCreated вызывается для всех настроенных обработчиков HTTP-сервера. Все глобальные экземпляры IRequestHandler с флагом BeforeResponse выполняются. Если любой обработчик возвращает непустой ответ, этот ответ пересылается HTTP-клиенту, и контекст закрывается. Если во время этого шага возникает ошибка и HttpServerConfiguration.ThrowExceptions отключено: Если свойство Router.CallbackErrorHandler включено, оно вызывается, и полученный ответ возвращается клиенту. Если предыдущее свойство не определено, серверу возвращается пустой ответ, который пересылает ответ в зависимости от типа возбуждённого исключения, обычно 500 Internal Server Error. Все экземпляры IRequestHandler, определённые в маршруте и имеющие флаг BeforeResponse, выполняются. Если любой обработчик возвращает непустой ответ, этот ответ пересылается HTTP-клиенту, и контекст закрывается. Если во время этого шага возникает ошибка и HttpServerConfiguration.ThrowExceptions отключено: Если свойство Router.CallbackErrorHandler включено, оно вызывается, и полученный ответ возвращается клиенту. Если предыдущее свойство не определено, серверу возвращается пустой ответ, который пересылает ответ в зависимости от типа возбуждённого исключения, обычно 500 Internal Server Error. Действие маршрутизатора вызывается и преобразуется в HTTP-ответ. Если во время этого шага возникает ошибка и HttpServerConfiguration.ThrowExceptions отключено: Если свойство Router.CallbackErrorHandler включено, оно вызывается, и полученный ответ возвращается клиенту. Если предыдущее свойство не определено, серверу возвращается пустой ответ, который пересылает ответ в зависимости от типа возбуждённого исключения, обычно 500 Internal Server Error. Все глобальные экземпляры IRequestHandler с флагом AfterResponse выполняются. Если любой обработчик возвращает непустой ответ, ответ обработчика заменяет предыдущий ответ и сразу пересылается HTTP-клиенту. Если во время этого шага возникает ошибка и HttpServerConfiguration.ThrowExceptions отключено: Если свойство Router.CallbackErrorHandler включено, оно вызывается, и полученный ответ возвращается клиенту. Если предыдущее свойство не определено, серверу возвращается пустой ответ, который пересылает ответ в зависимости от типа возбуждённого исключения, обычно 500 Internal Server Error. Все экземпляры IRequestHandler, определённые в маршруте и имеющие флаг AfterResponse, выполняются. Если любой обработчик возвращает непустой ответ, ответ обработчика заменяет предыдущий ответ и сразу пересылается HTTP-клиенту. Если во время этого шага возникает ошибка и HttpServerConfiguration.ThrowExceptions отключено: Если свойство Router.CallbackErrorHandler включено, оно вызывается, и полученный ответ возвращается клиенту. Если предыдущее свойство не определено, серверу возвращается пустой ответ, который пересылает ответ в зависимости от типа возбуждённого исключения, обычно 500 Internal Server Error. Обработка ответа: с готовым ответом сервер готовит его для отправки клиенту. Заголовки Cross-Origin Resource Sharing Policy (CORS) определяются в ответе в соответствии с настройками текущего ListeningHost.CrossOriginResourceSharingPolicy. Код состояния и заголовки ответа отправляются клиенту. Содержимое ответа отправляется клиенту: Если содержимое ответа является потомком ByteArrayContent, байты ответа直接 копируются в поток вывода ответа. Если предыдущее условие не выполнено, ответ сериализуется в поток и копируется в поток вывода ответа. Потоки закрываются, и содержимое ответа удаляется. Если HttpServerConfiguration.DisposeDisposableContextValues включено, все объекты, определённые в контексте запроса и наследующие IDisposable, удаляются. Событие OnHttpRequestClose вызывается для всех настроенных обработчиков HTTP-сервера. Если на сервере возникло исключение, событие OnException вызывается для всех настроенных обработчиков HTTP-сервера. Если маршрут позволяет доступ-логирование и HttpServerConfiguration.AccessLogsStream не равно null, строка лога записывается в выходной лог. Если маршрут позволяет ошибочно-логирование, есть исключение, и HttpServerConfiguration.ErrorsLogsStream не равно null, строка лога записывается в выходной лог ошибок. Если сервер ожидает запрос через HttpServer.WaitNext, мьютекс освобождается, и контекст становится доступным пользователю."
  },
  "docs/ru/changelogs.html": {
    "href": "docs/ru/changelogs.html",
    "title": "Журнал изменений | Sisk",
    "keywords": "Журнал изменений Каждое изменение, внесенное в Sisk, записывается в журнал изменений. Вы можете просмотреть журналы изменений для всех версий Sisk здесь."
  },
  "docs/ru/deploying.html": {
    "href": "docs/ru/deploying.html",
    "title": "Развертывание вашего приложения Sisk | Sisk",
    "keywords": "Развертывание вашего приложения Sisk Процесс развертывания приложения Sisk состоит в том, чтобы опубликовать ваш проект в производстве. Хотя процесс относительно прост, стоит отметить детали, которые могут быть опасны для безопасности и стабильности инфраструктуры развертывания. Идеально, вы должны быть готовы развернуть ваше приложение в облаке после проведения всех возможных тестов, чтобы ваше приложение было готово. Публикация вашего приложения Публикация вашего приложения Sisk или сервиса заключается в генерации бинарных файлов, готовых и оптимизированных для производства. В этом примере мы скомпилируем бинарные файлы для производства, чтобы они могли работать на машине, на которой установлен .NET Runtime. Вам понадобится .NET SDK, установленный на вашей машине, чтобы построить ваше приложение, и .NET Runtime, установленный на целевом сервере, чтобы запустить ваше приложение. Вы можете узнать, как установить .NET Runtime на вашем Linux-сервере здесь, Windows и Mac OS. В папке, где находится ваш проект, откройте терминал и используйте команду .NET publish: $ dotnet publish -r linux-x64 -c Release Это сгенерирует ваши бинарные файлы внутри bin/Release/publish/linux-x64. Note Если ваше приложение запускается с помощью пакета Sisk.ServiceProvider, вы должны скопировать ваш service-config.json на ваш хост-сервер вместе со всеми бинарными файлами, сгенерированными командой dotnet publish. Вы можете оставить файл предварительно настроенным, с переменными окружения, портами и хостами, а также дополнительными настройками сервера. Следующий шаг - перенести эти файлы на сервер, где будет размещено ваше приложение. После этого, дайте права на выполнение вашему бинарному файлу. В этом случае давайте рассмотрим, что наш проект называется \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app После запуска вашего приложения, проверьте, не выдает ли оно какие-либо сообщения об ошибках. Если оно не выдало, это означает, что ваше приложение работает. На этом этапе, скорее всего, не будет возможно получить доступ к вашему приложению из внешней сети, поскольку правила доступа, такие как брандмауэр, не настроены. Мы рассмотрим это в следующих шагах. У вас должна быть адрес виртуального хоста, на котором слушает ваше приложение. Это устанавливается вручную в приложении и зависит от того, как вы создаете экземпляр вашего сервиса Sisk. Если вы не используете пакет Sisk.ServiceProvider, вы должны найти его там, где вы определили экземпляр вашего HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk должен слушать на http://localhost:5000/ Присвоение ListeningHost вручную: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Или если вы используете пакет Sisk.ServiceProvider, в вашем service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } Из этого мы можем создать обратный прокси, чтобы слушать ваш сервис и сделать трафик доступным по открытой сети. Проксирование вашего приложения Проксирование вашего сервиса означает, что вы не直接 подвергаете ваш сервис Sisk внешней сети. Эта практика очень распространена для серверных развертываний, потому что: Позволяет присвоить сертификат SSL в вашем приложении; Создать правила доступа перед доступом к сервису и избежать перегрузок; Контролировать пропускную способность и ограничения запросов; Отделить балансировщики нагрузки для вашего приложения; Предотвратить повреждение безопасности из-за неисправной инфраструктуры. Вы можете обслуживать ваше приложение через обратный прокси, такой как Nginx или Apache, или вы можете использовать туннель http-over-dns, такой как Cloudflared. Также помните, что необходимо правильно разрешить заголовки прокси для получения информации о клиенте, такой как IP-адрес и хост, через forwarding resolvers. Следующий шаг после создания туннеля, настройки брандмауэра и запуска вашего приложения - создать сервис для вашего приложения. Note Использование сертификатов SSL напрямую в сервисе Sisk на не-Windows системах невозможно. Это связано с реализацией HttpListener, который является центральным модулем для управления очередью HTTP в Sisk, и эта реализация варьируется от операционной системы к операционной системе. Вы можете использовать SSL в вашем сервисе Sisk, если присвоите сертификат виртуальному хосту с помощью IIS. Для других систем использование обратного прокси высоко рекомендуется. Создание сервиса Создание сервиса сделает ваше приложение всегда доступным, даже после перезапуска вашего сервера или неисправной ошибки. В этом простом учебнике мы будем использовать содержимое из предыдущего учебника в качестве примера, чтобы ваш сервис всегда был активен. Получите доступ к папке, где находятся файлы конфигурации сервиса: cd /etc/systemd/system Создайте файл my-app.service и включите содержимое: my-app.service INI [Unit] Description=<описание вашего приложения> [Service] # задайте пользователя, который будет запускать сервис User=<пользователь, который будет запускать сервис> # путь к ExecStart не относителен к WorkingDirectory. # задайте его как полный путь к исполняемому файлу WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # задайте сервис для перезапуска после краха Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Перезапустите модуль сервиса: $ sudo systemctl daemon-reload Запустите созданный сервис с именем файла, который вы задали, и проверьте, запущен ли он: $ sudo systemctl start my-app $ sudo systemctl status my-app Теперь, если ваше приложение запущено (\"Active: active\"), включите сервис, чтобы он запускался после перезапуска системы: $ sudo systemctl enable my-app Теперь вы готовы представить ваше приложение Sisk всем."
  },
  "docs/ru/es/advanced/forwarding-resolvers.html": {
    "href": "docs/ru/es/advanced/forwarding-resolvers.html",
    "title": "Резолверы Перенаправления | Sisk",
    "keywords": "Резолверы Перенаправления Резолвер перенаправления - это помощник, который помогает декодировать информацию, идентифицирующую клиента, через запрос, прокси, CDN или балансировщик нагрузки. Когда ваш сервис Sisk запускается через обратный прокси или прямой прокси, адрес IP клиента, хост и протокол могут быть khácными от исходного запроса, поскольку это перенаправление из одного сервиса в другой. Эта функциональность Sisk позволяет контролировать и решать эту информацию до работы с запросом. Эти прокси обычно предоставляют полезные заголовки для идентификации вашего клиента. В настоящее время, с классом ForwardingResolver, возможно решить адрес IP клиента, хост и протокол HTTP, используемый. После версии 1.0 Sisk сервер больше не имеет стандартной реализации для декодирования этих заголовков по причинам безопасности, которые варьируются от сервиса к сервису. Например, заголовок X-Forwarded-For включает информацию о адресах IP, которые перенаправили запрос. Этот заголовок используется для передачи цепочки информации конечному сервису и включает адрес IP всех использованных прокси, включая реальный адрес клиента. Проблема в том, что иногда бывает трудно идентифицировать удаленный адрес IP клиента, и нет конкретного правила для идентификации этого заголовка. Рекомендуется внимательно прочитать документацию о заголовках, которые будут реализованы: Прочитайте о заголовке X-Forwarded-For здесь. Прочитайте о заголовке X-Forwarded-Host здесь. Прочитайте о заголовке X-Forwarded-Proto здесь. Класс ForwardingResolver Этот класс имеет три виртуальных метода, которые позволяют реализовать наиболее подходящую реализацию для каждого сервиса. Каждый метод отвечает за решение информации запроса через прокси: адрес IP клиента, хост запроса и протокол безопасности, используемый. По умолчанию Sisk всегда будет использовать информацию исходного запроса, не решая никаких заголовков. Пример ниже показывает, как можно использовать эту реализацию. Этот пример решает адрес IP клиента через заголовок X-Forwarded-For и генерирует ошибку, когда в запросе перенаправляются более одной адреса IP. Important Не используйте этот пример в коде производства. Всегда проверяйте, является ли реализация подходящей для вашего использования. Прочитайте документацию заголовка перед его реализацией. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"Заголовок X-Forwarded-For отсутствует.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Слишком много адресов в заголовке X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/ru/es/advanced/http-server-handlers.html": {
    "href": "docs/ru/es/advanced/http-server-handlers.html",
    "title": "Обработчики сервера HTTP | Sisk",
    "keywords": "Обработчики сервера HTTP В Sisk версии 0.16, мы ввели класс HttpServerHandler, целью которого является расширение общего поведения Sisk и предоставление дополнительных обработчиков событий для Sisk, таких как обработка HTTP-запросов, маршрутизация, контекстные сумки и многое другое. Этот класс концентрирует события, которые происходят во время жизненного цикла всего HTTP-сервера и отдельного запроса. Протокол HTTP не имеет сессий, и поэтому невозможно сохранять информацию от одного запроса к другому. Sisk предоставляет на данный момент способ реализации сессий, контекстов, подключений к базе данных и других полезных провайдеров, чтобы помочь в вашей работе. Пожалуйста, ознакомьтесь с этой страницей, чтобы узнать, где срабатывает каждое событие и какова его цель. Также вы можете ознакомиться с жизненным циклом HTTP-запроса, чтобы понять, что происходит с запросом и где срабатывают события. HTTP-сервер позволяет использовать несколько обработчиков одновременно. Каждый вызов события является синхронным, то есть блокирует текущий поток для каждого запроса или контекста до тех пор, пока все связанные с ним обработчики не будут выполнены и завершены. В отличие от обработчиков запросов, их нельзя применять к группам маршрутов или конкретным маршрутам. Вместо этого они применяются ко всему HTTP-серверу. Вы можете применять условия внутри своего обработчика сервера HTTP. Кроме того, определяются синглтоны для каждого HttpServerHandler для каждой приложения Sisk, поэтому определяется только одна инстанция для HttpServerHandler. Практический пример использования HttpServerHandler — автоматическое удаление подключения к базе данных в конце запроса. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // проверяет, определено ли в контексте запроса DbContext if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // позволяет пользователю создать контекст базы данных из HTTP-запроса // и сохранить его в контекстной сумке public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } С помощью приведенного выше кода, расширение GetDbContext позволяет создать контекст подключения直接 из объекта HttpRequest. Неразорванное подключение может вызвать проблемы при работе с базой данных, поэтому оно завершается в OnHttpRequestClose. Вы можете зарегистрировать обработчик в HTTP-сервере в его конструкторе или直接 с помощью HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } С этим, класс UsersController может использовать контекст базы данных следующим образом: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Пользователь добавлен.\"); } } Приведенный выше код использует методы, такие как JsonOk и JsonMessage, которые интегрированы в ApiController, который наследует от RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Разработчики могут реализовать сессии, контексты и подключения к базе данных, используя этот класс. Приведенный выше код демонстрирует практический пример с DatabaseConnectionHandler, автоматизирующий удаление подключения к базе данных в конце каждого запроса. Интеграция проста, с обработчиками, зарегистрированными во время настройки сервера. Класс HttpServerHandler предлагает набор мощных инструментов для управления ресурсами и расширения поведения Sisk в HTTP-приложениях."
  },
  "docs/ru/es/advanced/manual-setup.html": {
    "href": "docs/ru/es/advanced/manual-setup.html",
    "title": "Ручная настройка (продвинутая) | Sisk",
    "keywords": "Ручная настройка (продвинутая) В этом разделе мы создадим наш сервер HTTP без использования каких-либо предварительно определенных стандартов, совершенно абстрактным способом. Здесь вы можете вручную настроить, как будет работать ваш сервер HTTP. Каждый ListeningHost имеет маршрутизатор, и сервер HTTP может иметь несколько ListeningHosts, каждый из которых указывает на разный хост на разном порту. Сначала нам нужно понять концепцию запрос/ответ. Это довольно просто: на каждый запрос должен быть ответ. Sisk также следует этому принципу. Мы создаем метод, который отвечает сообщением \"Привет, мир!\" в HTML, указывая код состояния и заголовки. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Привет, мир!</h1> </body> </html> \") }; return indexResponse; } Следующий шаг - связать этот метод с маршрутом HTTP. Маршрутизаторы Маршрутизаторы являются абстракциями маршрутов запросов и служат мостом между запросами и ответами для службы. Маршрутизаторы управляют маршрутами службы, функциями и ошибками. Маршрутизатор может иметь несколько маршрутов, и каждый маршрут может выполнять различные операции на этом маршруте, такие как выполнение функции, обслуживание страницы или предоставление ресурса с сервера. Мы создаем наш первый маршрутизатор и связываем наш метод IndexPage с маршрутом индекса. Router mainRouter = new Router(); // SetRoute связывает все маршруты индекса с нашим методом. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Теперь наш маршрутизатор может получать запросы и отправлять ответы. Однако mainRouter не связан с хостом или сервером, поэтому он не будет работать самостоятельно. Следующий шаг - создать наш ListeningHost. Хосты и порты прослушивания ListeningHost может размещать маршрутизатор и несколько портов прослушивания для одного и того же маршрутизатора. ListeningPort является префиксом, где сервер HTTP будет прослушивать. Здесь мы можем создать ListeningHost, который указывает на два конца для нашего маршрутизатора: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Теперь наш сервер HTTP будет прослушивать указанные концы и перенаправлять свои запросы на наш маршрутизатор. Настройка сервера Настройка сервера отвечает за большинство поведения сервера HTTP сам по себе. В этой настройке мы можем связать ListeningHosts с нашим сервером. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Добавьте наш ListeningHost в эту настройку сервера Далее мы можем создать наш сервер HTTP: HttpServer server = new HttpServer(config); server.Start(); // Запускает сервер Console.ReadKey(); // Предотвращает закрытие приложения Теперь мы можем скомпилировать наш исполняемый файл и запустить наш сервер HTTP с помощью команды: dotnet watch В время выполнения откройте свой браузер и перейдите по маршруту сервера, и вы должны увидеть:"
  },
  "docs/ru/es/advanced/multi-host-setup.html": {
    "href": "docs/ru/es/advanced/multi-host-setup.html",
    "title": "Несколько хостов для прослушивания на сервере | Sisk",
    "keywords": "Несколько хостов для прослушивания на сервере Фреймворк Sisk всегда поддерживал использование нескольких хостов на сервере, то есть один сервер HTTP может прослушивать на нескольких портах, и каждый порт имеет свой собственный маршрутизатор и свой собственный сервис в исполнении. Таким образом, легко разделить обязанности и управлять сервисами на одном сервере HTTP с помощью Sisk. Пример ниже показывает создание двух ListeningHosts, каждый из которых прослушивает на разных портах, с разными маршрутизаторами и действиями. Прочитайте создание приложения вручную, чтобы понять детали об этой абстракции. static void Main(string[] args) { // создает два хоста для прослушивания, каждый со своим собственным маршрутизатором и // прослушивающий на своем собственном порту // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста А!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста Б!\")); // создает конфигурацию сервера и добавляет оба хоста для прослушивания // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // создает сервер HTTP, который использует указанную конфигурацию // HttpServer server = new HttpServer(configuration); // запускает сервер server.Start(); Console.WriteLine(\"Попробуйте обратиться к хосту А по {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Попробуйте обратиться к хосту Б по {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/ru/es/advanced/request-lifecycle.html": {
    "href": "docs/ru/es/advanced/request-lifecycle.html",
    "title": "Жизненный цикл запроса | Sisk",
    "keywords": "Жизненный цикл запроса Эта диаграмма объясняет процесс жизни запроса HTTP с момента его поступления на сервер до доставки клиенту."
  },
  "docs/ru/es/changelogs.html": {
    "href": "docs/ru/es/changelogs.html",
    "title": "Журнал изменений | Sisk",
    "keywords": "Журнал изменений Каждое изменение, внесенное в Sisk, регистрируется через журнал изменений. Вы можете просмотреть журнал изменений для всех версий Sisk здесь."
  },
  "docs/ru/extensions/basic-auth.html": {
    "href": "docs/ru/extensions/basic-auth.html",
    "title": "Базовая Аутентификация | Sisk",
    "keywords": "Базовая Аутентификация Пакет Basic Auth добавляет обработчик запросов, способный обрабатывать базовую схему аутентификации в вашем приложении Sisk с минимальной конфигурацией и усилиями. Базовая аутентификация HTTP - это минимальная форма аутентификации запросов по идентификатору пользователя и паролю, где сессия контролируется исключительно клиентом, и нет аутентификационных или доступных токенов. Читайте больше о схеме базовой аутентификации в спецификации MDN. Установка Чтобы начать, установите пакет Sisk.BasicAuth в вашем проекте: > dotnet add package Sisk.BasicAuth Вы можете просмотреть больше способов установки его в вашем проекте в репозитории Nuget. Создание обработчика аутентификации Вы можете контролировать схему аутентификации для всего модуля или для отдельных маршрутов. Для этого давайте сначала напишем наш первый базовый обработчик аутентификации. В примере ниже устанавливается соединение с базой данных, проверяется, существует ли пользователь и является ли пароль действительным, и после этого хранит пользователя в контексте. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Чтобы войти на эту страницу, пожалуйста, введите ваши учетные данные.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // в этом случае мы используем электронную почту в качестве идентификатора пользователя, поэтому мы // ищем пользователя по его электронной почте. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Извините! Пользователь с таким электронным адресом не найден.\"); } // проверяет, что пароль учетных данных действителен для этого пользователя. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Недействительные учетные данные.\"); } // добавляет вошедшего пользователя в контекст HTTP // и продолжает выполнение context.Bag.Add(\"loggedUser\", user); return null; } } Итак, просто ассоциируйте этот обработчик запросов с нашим маршрутом или классом. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Привет, \" + loggedUser.Name + \"!\"; } } Или используя класс RouterModule: public class UsersController : RouterModule { public ClientModule() { // теперь все маршруты внутри этого класса будут обрабатываться // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Привет, \" + loggedUser.Name + \"!\"; } } Примечания Основная ответственность базовой аутентификации лежит на клиентской стороне. Хранение, кэширование и шифрование обрабатываются локально на клиенте. Сервер получает только учетные данные и проверяет, разрешен ли доступ или нет. Обратите внимание, что этот метод не является одним из самых безопасных, поскольку он возлагает значительную ответственность на клиента, что может быть трудно отслеживать и поддерживать безопасность его учетных данных. Кроме того, важно передавать пароли в безопасном контексте соединения (SSL), поскольку они не имеют встроенного шифрования. Короткий перехват в заголовках запроса может раскрыть учетные данные доступа вашего пользователя. Выбирайте более надежные решения аутентификации для приложений в производстве и избегайте использования слишком многих готовых компонентов, поскольку они могут не адаптироваться к потребностям вашего проекта и в конечном итоге подвергать его риску безопасности."
  },
  "docs/ru/extensions/ini-configuration.html": {
    "href": "docs/ru/extensions/ini-configuration.html",
    "title": "Провайдер конфигурации INI | Sisk",
    "keywords": "Провайдер конфигурации INI Sisk имеет метод для получения конфигураций запуска, отличных от JSON. На самом деле, любой конвейер, реализующий IConfigurationReader, может быть использован с PortableConfigurationBuilder.WithConfigurationPipeline, читая конфигурацию сервера из любого типа файла. Пакет Sisk.IniConfiguration предоставляет потоковый читатель файлов INI, который не выбрасывает исключения для обычных синтаксических ошибок и имеет простой синтаксис конфигурации. Этот пакет можно использовать вне рамок фреймворка Sisk, предлагая гибкость для проектов, требующих эффективного считывателя документов INI. Установка Чтобы установить пакет, можно начать с: $ dotnet add package Sisk.IniConfiguration Также можно установить основной пакет, который не включает в себя INI IConfigurationReader, ни зависимость от Sisk, только сериализаторы INI: $ dotnet add package Sisk.IniConfiguration.Core С основным пакетом можно использовать его в коде, как показано в примере ниже: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // использует конфигурационный читатель IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } Код выше будет искать файл app.ini в текущем каталоге процесса (CurrentDirectory). Файл INI выглядит так: [Server] # Множественные адреса прослушивания поддерживаются Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Вкус и синтаксис INI Текущая реализация вкуса: Имена свойств и секций не чувствительны к регистру. Имена свойств и значения обрезаются, если значения не заключены в кавычки. Значения можно заключать в одинарные или двойные кавычки. Кавычки могут содержать переносы строк внутри себя. Комментарии поддерживаются с помощью # и ;. Также допускаются конечные комментарии. Свойства могут иметь несколько значений. Подробнее, документация для \"вкуса\" парсера INI, используемого в Sisk, доступна в этом документе. Используя следующий код INI в качестве примера: One = 1 Value = это значение Another value = \"это значение имеет перенос строки на нем\" ; код ниже имеет некоторые цвета [some section] Color = Red Color = Blue Color = Yellow ; не используйте желтый Парсить его с помощью: // парсить текст INI из строки IniDocument doc = IniDocument.FromString(iniText); // получить одно значение string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // получить несколько значений string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Параметры конфигурации Секция и имя Разрешить несколько значений Описание Server.Listen Да Адреса и порты прослушивания сервера. Server.Encoding Нет Кодировка сервера по умолчанию. Server.MaximumContentLength Нет Максимальный размер содержимого в байтах. Server.IncludeRequestIdHeader Нет Указывает, должен ли HTTP-сервер отправлять заголовок X-Request-Id. Server.ThrowExceptions Нет Указывает, должны ли быть выброшены необработанные исключения. Server.AccessLogsStream Нет Указывает поток вывода журнала доступа. Server.ErrorsLogsStream Нет Указывает поток вывода журнала ошибок. Cors.AllowMethods Нет Указывает значение заголовка CORS Allow-Methods. Cors.AllowHeaders Нет Указывает значение заголовка CORS Allow-Headers. Cors.AllowOrigins Нет Указывает несколько заголовков Allow-Origin, разделенных запятыми. AllowOrigins для более подробной информации. Cors.AllowOrigin Нет Указывает один заголовок Allow-Origin. Cors.ExposeHeaders Нет Указывает значение заголовка CORS Expose-Headers. Cors.AllowCredentials Нет Указывает значение заголовка CORS Allow-Credentials. Cors.MaxAge Нет Указывает значение заголовка CORS Max-Age."
  },
  "docs/ru/extensions/json-rpc.html": {
    "href": "docs/ru/extensions/json-rpc.html",
    "title": "Расширение JSON-RPC | Sisk",
    "keywords": "Расширение JSON-RPC Sisk имеет экспериментальный модуль для API JSON-RPC 2.0, который позволяет создавать еще более простые приложения. Это расширение строго реализует транспортный интерфейс JSON-RPC 2.0 и предлагает транспорт через HTTP GET, POST-запросы и также веб-сокеты с Sisk. Вы можете установить расширение через Nuget с помощью команды ниже. Обратите внимание, что в экспериментальных/бета-версиях необходимо включить опцию поиска предварительных пакетов в Visual Studio. dotnet add package Sisk.JsonRpc Транспортный Интерфейс JSON-RPC - это бесстаточный, асинхронный протокол удаленного выполнения процедур (RDP), который использует JSON для односторонней передачи данных. Запрос JSON-RPC обычно идентифицируется по ID, и ответ доставляется с тем же ID, который был отправлен в запросе. Не все запросы требуют ответа, которые называются \"уведомлениями\". Спецификация JSON-RPC 2.0 подробно объясняет, как работает транспорт. Этот транспорт независим от того, где он будет использоваться. Sisk реализует этот протокол через HTTP, следуя соответствиям JSON-RPC over HTTP, который частично поддерживает GET-запросы, но полностью поддерживает POST-запросы. Также поддерживаются веб-сокеты, которые обеспечивают асинхронную передачу сообщений. Запрос JSON-RPC выглядит примерно так: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } И успешный ответ выглядит примерно так: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Методы JSON-RPC Следующий пример показывает, как создать API JSON-RPC с помощью Sisk. Класс математических операций выполняет удаленные операции и доставляет сериализированный ответ клиенту. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // добавляет все методы, помеченные как WebMethod, в обработчик JSON-RPC args.Handler.Methods.AddMethodsFromType(new MathOperations()); // сопоставляет маршрут /service с обработчиком JSON-RPC POST и GET-запросов args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // создает обработчик веб-сокета на GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } Вышеуказанный пример сопоставит методы Sum и Sqrt с обработчиком JSON-RPC, и эти методы будут доступны по адресам GET /service, POST /service и GET /ws. Имена методов регистронезависимы. Параметры методов автоматически десериализуются в свои конкретные типы. Также поддерживается использование запросов с именованными параметрами. Сериализация JSON выполняется библиотекой LightJson. Если тип не десериализуется правильно, вы можете создать специальный конвертер JSON для этого типа и связать его с вашими JsonSerializerOptions позже. Вы также можете получить объект $.params из запроса JSON-RPC напрямую в вашем методе. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Для этого @params должен быть единственным параметром в вашем методе, с точным именем params (в C#, символ @ необходим для экранирования этого имени параметра). Десериализация параметров происходит как для именованных объектов, так и для позиционных массивов. Например, следующий метод можно вызвать удаленно как с помощью запроса с именованными параметрами, так и с помощью запроса с позиционными параметрами. [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Для массива порядок параметров должен быть соблюдён. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Настройка сериализатора Вы можете настроить сериализатор JSON в свойстве JsonRpcHandler.JsonSerializerOptions. В этом свойстве вы можете включить использование JSON5 для десериализации сообщений. Хотя это не соответствует спецификации JSON-RPC 2.0, JSON5 является расширением JSON, которое позволяет писать более читаемые и понятные данные. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // использует санитизированный компаратор имен. этот компаратор сравнивает только буквы // и цифры в имени, и игнорирует другие символы. например: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // включает JSON5 для интерпретатора JSON. даже активируя это, обычный JSON все еще поддерживается e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // сопоставляет маршрут POST /service с обработчиком JSON-RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/ru/extensions/service-providers.html": {
    "href": "docs/ru/extensions/service-providers.html",
    "title": "Поставщики услуг | Sisk",
    "keywords": "Поставщики услуг Поставщики услуг - это способ переноса вашего приложения Sisk в разные среды с помощью переносимого файла конфигурации. Эта функция позволяет изменить порт сервера, параметры и другие настройки без необходимости изменения кода приложения для каждой среды. Этот модуль зависит от синтаксиса конструкции Sisk и может быть настроен с помощью метода UsePortableConfiguration. Поставщик конфигурации реализуется с помощью IConfigurationProvider, который предоставляет читатель конфигурации и может получать любую реализацию. По умолчанию, Sisk предоставляет читатель конфигурации JSON, но также есть пакет для файлов INI. Вы также можете создать свой собственный поставщик конфигурации и зарегистрировать его с помощью: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Как упоминалось ранее, поставщик конфигурации по умолчанию - это файл JSON. По умолчанию, имя файла, которое ищется, - это service-config.json, и он ищется в текущем каталоге запускаемого процесса, а не в каталоге исполняемого файла. Вы можете выбрать изменение имени файла, а также указать, где Sisk должен искать файл конфигурации, с помощью: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); Код выше будет искать файл config.toml в текущем каталоге запускаемого процесса. Если файл не найден, он затем будет искать в каталоге, где находится исполняемый файл. Если файл не существует, параметр createIfDontExists будет выполнен, создав файл без содержимого в последнем проверенном пути (на основе lookupDirectories), и будет выдано сообщение об ошибке в консоли, предотвращая инициализацию приложения. Tip Вы можете посмотреть исходный код поставщика конфигурации INI и поставщика конфигурации JSON, чтобы понять, как реализуется IConfigurationProvider. Чтение конфигураций из файла JSON По умолчанию, Sisk предоставляет поставщик конфигурации, который читает конфигурации из файла JSON. Этот файл имеет фиксированную структуру и состоит из следующих параметров: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"Мое приложение Sisk\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Файлы конфигурации также поддерживают комментарии ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // новое в 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Параметры, созданные из файла конфигурации, можно получить в конструкторе сервера: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Каждый поставщик конфигурации предоставляет способ чтения параметров инициализации сервера. Некоторые свойства указаны для того, чтобы они находились в процессе окружения вместо того, чтобы быть определены в файле конфигурации, такие как чувствительные данные API, ключи API и т. д. Структура файла конфигурации Файл конфигурации JSON состоит из следующих свойств: Свойство Обязательное Описание Server Требуется Представляет собой сервер с его настройками. Server.AccessLogsStream Необязательно По умолчанию - console. Указывает поток вывода журнала доступа. Может быть именем файла, null или console. Server.ErrorsLogsStream Необязательно По умолчанию - null. Указывает поток вывода журнала ошибок. Может быть именем файла, null или console. Server.MaximumContentLength Необязательно Server.MaximumContentLength Необязательно По умолчанию - 0. Указывает максимальную длину содержимого в байтах. Ноль означает бесконечность. Server.IncludeRequestIdHeader Необязательно По умолчанию - false. Указывает, должен ли HTTP-сервер отправлять заголовок X-Request-Id. Server.ThrowExceptions Необязательно По умолчанию - true. Указывает, должны ли быть выброшены необработанные исключения. Установите значение false при производстве и true при отладке. ListeningHost Требуется Представляет собой хост, на котором слушает сервер. ListeningHost.Label Необязательно Представляет собой метку приложения. ListeningHost.Ports Требуется Представляет собой массив строк, соответствующих синтаксису ListeningPort. ListeningHost.CrossOriginResourceSharingPolicy Необязательно Настройка CORS-заголовков для приложения. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Необязательно По умолчанию - false. Указывает заголовок Allow-Credentials. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Expose-Headers. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Необязательно По умолчанию - null. Это свойство ожидает строку. Указывает заголовок Allow-Origin. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает несколько заголовков Allow-Origin. См. AllowOrigins для получения дополнительной информации. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Allow-Methods. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Allow-Headers. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Необязательно По умолчанию - null. Это свойство ожидает целое число. Указывает заголовок Max-Age в секундах. ListeningHost.Parameters Необязательно Указывает свойства, предоставляемые методу настройки приложения."
  },
  "docs/ru/extensions/ssl-proxy.html": {
    "href": "docs/ru/extensions/ssl-proxy.html",
    "title": "SSL Proxy | Sisk",
    "keywords": "SSL Proxy Warning Эта функция экспериментальная и не должна использоваться в производстве. Пожалуйста, обратитесь к этому документу, если вы хотите сделать Sisk работать с SSL. Sisk SSL Proxy - это модуль, который предоставляет HTTPS-соединение для ListeningHost в Sisk и маршрутизирует HTTPS-сообщения в не安全ный HTTP-контекст. Модуль был создан для предоставления SSL-соединения для службы, которая использует HttpListener для запуска, который не поддерживает SSL. Прокси работает внутри одного и того же приложения и слушает HTTP/1.1-сообщения, пересылая их в том же протоколе в Sisk. В настоящее время эта функция является высокоэкспериментальной и может быть достаточно нестабильной, чтобы не использовать ее в производстве. На данный момент SslProxy поддерживает почти все функции HTTP/1.1, такие как keep-alive, chunked encoding, websockets и т. д. Для открытого соединения с SSL-прокси создается TCP-соединение с целевым сервером, и прокси пересылается на установленное соединение. SslProxy можно использовать с HttpServer.CreateBuilder следующим образом: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // добавление SSL в проект .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Вам необходимо предоставить действительный SSL-сертификат для прокси. Чтобы обеспечить принятие сертификата браузерами, не забудьте импортировать его в операционную систему, чтобы он функционировал правильно."
  },
  "docs/ru/faq.html": {
    "href": "docs/ru/faq.html",
    "title": "Часто задаваемые вопросы | Sisk",
    "keywords": "Часто задаваемые вопросы Часто задаваемые вопросы о Sisk. Является ли Sisk открытым исходным кодом? Полностью. Всё исходный код, используемый Sisk, публикуется и регулярно обновляется на GitHub. Принимаются ли вклады? Пока они совместимы с философией Sisk, все вклады очень приветствуются! Вклады не обязательно должны быть только кодом! Вы можете внести вклад в документацию, тесты, переводы, пожертвования и публикации, например. Является ли Sisk финансируемым? Нет. Никакая организация или проект в настоящее время не спонсирует Sisk. Можно ли использовать Sisk в производстве? Определенно. Проект разрабатывается более трёх лет и прошёл интенсивное тестирование в коммерческих приложениях, которые находятся в производстве с тех пор. Sisk используется в важных коммерческих проектах в качестве основной инфраструктуры. Руководство по развертыванию в различных системах и средах было написано и доступно. Имеет ли Sisk аутентификацию, мониторинг и базу данных? Нет. Sisk не имеет ни одного из этих. Это фреймворк для разработки веб-приложений HTTP, но это всё же минимальный фреймворк, который доставляет всё необходимое для работы вашего приложения. Вы можете реализовать все сервисы, которые вам нужны, используя любую библиотеку третьего лица, которую вы предпочитаете. Sisk был создан, чтобы быть агностическим, гибким и работать с чем угодно. Почему я должен использовать Sisk вместо <фреймворка>? Я не знаю. Вы мне скажите. Sisk был создан, чтобы заполнить общий сценарий для веб-приложений HTTP в .NET. Установленные проекты, такие как ASP.NET, решают различные проблемы, но с разными предубеждениями. В отличие от более крупных фреймворков, Sisk требует от пользователя знать, что он делает и строит. Базовые понятия веб-разработки и протокола HTTP необходимы для работы с Sisk. Sisk ближе к Express в Node.js, чем к ASP.NET Core. Это высокоуровневая абстракция, которая позволяет создавать приложения с логикой HTTP, которую вы хотите. Что мне нужно, чтобы выучить Sisk? Вам нужно базовое понимание: Веб-разработки (HTTP, Restful и т. д.) .NET Всего лишь это. Имея представление о этих двух темах, вы можете посвятить несколько часов разработке продвинутого приложения с Sisk. Можно ли разрабатывать коммерческие приложения с Sisk? Определенно. Sisk был создан под лицензией MIT, что означает, что вы можете использовать Sisk в любом коммерческом проекте, коммерчески или некоммерчески, без необходимости в проприетарной лицензии. Мы просим только, чтобы где-то в вашем приложении был уведомление об использованных открытых исходных проектах, и чтобы Sisk был там."
  },
  "docs/ru/features/content-streaming.html": {
    "href": "docs/ru/features/content-streaming.html",
    "title": "Потоковая передача контента | Sisk",
    "keywords": "Потоковая передача контента Sisk поддерживает чтение и отправку потоков контента на клиент и с клиента. Эта функция полезна для удаления нагрузки на память при сериализации и десериализации контента во время жизни запроса. Поток контента запроса Маленькие содержимые автоматически загружаются в буфер памяти HTTP-соединения, быстро загружая это содержимое в HttpRequest.Body и HttpRequest.RawBody. Для более крупных содержимых можно использовать метод HttpRequest.GetRequestStream, чтобы получить поток чтения контента запроса. Стоит отметить, что метод HttpRequest.GetMultipartFormContent читает весь контент запроса в память, поэтому он может не быть полезен для чтения крупных содержимых. Рассмотрим следующий пример: Controller/UploadDocument.cs C# [RoutePost ( \"/api/upload-document/<filename>\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var fileName = request.RouteParameters [ \"filename\" ].GetString (); if (!request.HasContents) { // запрос не содержит контента return new HttpResponse ( HttpStatusInformation.BadRequest ); } var contentStream = request.GetRequestStream (); var outputFileName = Path.Combine ( AppDomain.CurrentDomain.BaseDirectory, \"uploads\", fileName ); using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs ); } return new HttpResponse () { Content = JsonContent.Create ( new { message = \"Файл отправлен успешно.\" } ) }; } В примере выше метод UploadDocument читает контент запроса и сохраняет контент в файл. Не производится дополнительная аллокация памяти, кроме буфера чтения, используемого Stream.CopyToAsync. Пример выше удаляет нагрузку на аллокацию памяти для очень крупного файла, что может оптимизировать производительность приложения. Хорошей практикой является всегда использовать CancellationToken в операции, которая может занять время, такой как отправка файлов, поскольку она зависит от скорости сети между клиентом и сервером. Настройка с помощью CancellationToken может быть выполнена следующим образом: Controller/UploadDocument.cs C# // токен отмены ниже будет выбрасывать исключение, если истечет 30-секундный таймаут. CancellationTokenSource copyCancellation = new CancellationTokenSource ( delay: TimeSpan.FromSeconds ( 30 ) ); try { using (var fs = File.Create ( outputFileName )) { await contentStream.CopyToAsync ( fs, copyCancellation.Token ); } } catch (OperationCanceledException) { return new HttpResponse ( HttpStatusInformation.BadRequest ) { Content = JsonContent.Create ( new { Error = \"Отправка файла превысила максимальное время отправки (30 секунд).\" } ) }; } Поток контента ответа Отправка контента ответа также возможна. В настоящее время существует два способа сделать это: через метод HttpRequest.GetResponseStream и используя контент типа StreamContent. Рассмотрим сценарий, в котором нам нужно предоставить файл изображения. Для этого можно использовать следующий код: Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { // пример метода для получения изображения профиля var profilePictureFilename = \"profile-picture.jpg\"; byte[] profilePicture = await File.ReadAllBytesAsync ( profilePictureFilename ); return new HttpResponse () { Content = new ByteArrayContent ( profilePicture ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename={profilePictureFilename}\" } }; } Метод выше производит аллокацию памяти каждый раз, когда он читает контент изображения. Если изображение большое, это может вызвать проблему производительности, и в пиковых ситуациях даже привести к переполнению памяти и краху сервера. В таких ситуациях кэширование может быть полезным, но оно не устранит проблему, поскольку память все равно будет зарезервирована для этого файла. Кэширование облегчит нагрузку на аллокацию памяти для каждого запроса, но для крупных файлов оно не будет достаточно. Отправка изображения через поток может быть решением проблемы. Вместо чтения всего контента изображения создается поток чтения файла и копируется на клиент с помощью небольшого буфера. Отправка через метод GetResponseStream Метод HttpRequest.GetResponseStream создает объект, который позволяет отправлять части HTTP-ответа по мере подготовки потока контента. Этот метод более ручной, требующий определения статуса, заголовков и размера контента перед отправкой контента. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public async Task<HttpResponse> UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; // в этой форме отправки необходимо определить статус и заголовки // перед отправкой контента var requestStreamManager = request.GetResponseStream (); requestStreamManager.SetStatus ( System.Net.HttpStatusCode.OK ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentType, \"image/jpeg\" ); requestStreamManager.SetHeader ( HttpKnownHeaderNames.ContentDisposition, $\"inline; filename={profilePictureFilename}\" ); using (var fs = File.OpenRead ( profilePictureFilename )) { // в этой форме отправки также необходимо определить размер контента // перед отправкой его. requestStreamManager.SetContentLength ( fs.Length ); // если вы не знаете размера контента, можно использовать chunked-encoding // для отправки контента requestStreamManager.SendChunked = true; // и затем, записать в поток вывода await fs.CopyToAsync ( requestStreamManager.ResponseStream ); } } Отправка контента через StreamContent Класс StreamContent позволяет отправлять контент из источника данных в виде потока байтов. Эта форма отправки проще, удаляя предыдущие требования, и даже позволяет использовать сжатие контента, чтобы уменьшить размер контента. Controller/ImageController.cs C# [RouteGet ( \"/api/profile-picture\" )] public HttpResponse UploadDocument ( HttpRequest request ) { var profilePictureFilename = \"profile-picture.jpg\"; return new HttpResponse () { Content = new StreamContent ( File.OpenRead ( profilePictureFilename ) ), Headers = new () { ContentType = \"image/jpeg\", ContentDisposition = $\"inline; filename=\\\"{profilePictureFilename}\\\"\" } }; } Important В этом типе контента не заключайте поток в блок using. Контент будет автоматически удален HTTP-сервером, когда поток контента будет завершен, с ошибками или без них."
  },
  "docs/ru/features/cors.html": {
    "href": "docs/ru/features/cors.html",
    "title": "Включение CORS (Cross-Origin Resource Sharing) в Sisk | Sisk",
    "keywords": "Включение CORS (Cross-Origin Resource Sharing) в Sisk Sisk имеет инструмент, который может быть полезен для обработки Cross-Origin Resource Sharing (CORS) при публикации вашего сервиса. Эта функция не является частью протокола HTTP, а является специальной функцией веб-браузеров, определенной W3C. Этот механизм безопасности предотвращает возможность веб-страницы отправлять запросы к другому домену, чем тот, который предоставил веб-страницу. Поставщик сервиса может разрешить доступ к своим ресурсам определенным доменам или только одному. Same Origin Чтобы ресурс был идентифицирован как \"same origin\", запрос должен содержать заголовок Origin: GET /api/users HTTP/1.1 Host: example.com Origin: http://example.com ... И удаленный сервер должен ответить с заголовком Access-Control-Allow-Origin с тем же значением, что и запрошенный origin: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com ... Эта проверка является явной: хост, порт и протокол должны быть одинаковыми, как запрошено. Проверьте пример: Сервер отвечает, что его Access-Control-Allow-Origin равен https://example.com: https://example.net - домен khác. http://example.com - схема khác. http://example.com:5555 - порт другой. https://www.example.com - хост другой. В спецификации разрешена только синтаксис для обоих заголовков, как для запросов, так и для ответов. Путь URL игнорируется. Порт также опускается, если это стандартный порт (80 для HTTP и 443 для HTTPS). Origin: null Origin: <scheme>://<hostname> Origin: <scheme>://<hostname>:<port> Включение CORS По умолчанию у вас есть объект CrossOriginResourceSharingHeaders внутри вашего ListeningHost. Вы можете настроить CORS при инициализации сервера: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseCors(new CrossOriginResourceSharingHeaders( allowOrigin: \"http://example.com\", allowHeaders: [\"Authorization\"], exposeHeaders: [\"Content-Type\"])) .Build(); await app.StartAsync(); } Код выше будет отправлять следующие заголовки для всех ответов: HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Headers: Authorization Access-Control-Expose-Headers: Content-Type Эти заголовки необходимо отправлять для всех ответов веб-клиенту, включая ошибки и перенаправления. Вы можете заметить, что класс CrossOriginResourceSharingHeaders имеет два похожих свойства: AllowOrigin и AllowOrigins. Обратите внимание, что одно свойство является единственным, а другое - множественным. Свойство AllowOrigin является статическим: только указанный вами origin будет отправлен для всех ответов. Свойство AllowOrigins является динамическим: сервер проверяет, содержится ли origin запроса в этом списке. Если он найден, он отправляется для ответа этого origin. Wildcard в Origin Альтернативно, вы можете использовать wildcard (*) в ответе origin, чтобы указать, что любой origin может получить доступ к ресурсу. Однако это значение не разрешено для запросов, которые имеют учетные данные (заголовки авторизации) и эта операция вызовет ошибку. Вы можете обойти эту проблему, явно перечислив, какие origins будут разрешены через свойство AllowOrigins, или также использовать константу AutoAllowOrigin в значении свойства AllowOrigin. Это магическое свойство определит заголовок Access-Control-Allow-Origin для того же значения, что и заголовок Origin запроса. Другие способы применения CORS Если вы работаете с поставщиками сервисов, вы можете переопределить значения, определенные в файле конфигурации: static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(...) .UseCors(cors => { // Will override the origin defined in the configuration // file. cors.AllowOrigin = \"http://example.com\"; }) .Build(); await app.StartAsync(); } Отключение CORS на конкретных маршрутах Свойство UseCors доступно для обоих маршрутов и всех атрибутов маршрутов и может быть отключено следующим образом: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { // GET /api/widgets/colors [RouteGet(\"/colors\", UseCors = false)] public IEnumerable<string> GetWidgets() { return new[] { \"Green widget\", \"Red widget\" }; } } Замена значений в ответе Вы можете заменить или удалить значения явно в действии маршрута: [RoutePrefix(\"api/widgets\")] public class WidgetController : Controller { public IEnumerable<string> GetWidgets(HttpRequest request) { // Removes the Access-Control-Allow-Credentials header request.Context.OverrideHeaders.AccessControlAllowCredentials = string.Empty; // Replaces the Access-Control-Allow-Origin request.Context.OverrideHeaders.AccessControlAllowOrigin = \"https://contorso.com\"; return new[] { \"Green widget\", \"Red widget\" }; } } Preflight запросы Preflight запрос - это запрос метода OPTIONS, который клиент отправляет перед фактическим запросом. Сервер Sisk всегда будет отвечать на запрос с кодом 200 OK и соответствующими заголовками CORS, и затем клиент может продолжить фактический запрос. Это условие не применяется, когда существует маршрут для запроса с явно настроенным методом RouteMethod для Options. Глобальное отключение CORS Это невозможно. Чтобы не использовать CORS, не настраивайте его."
  },
  "docs/ru/features/discard-syntax.html": {
    "href": "docs/ru/features/discard-syntax.html",
    "title": "Синтаксис Discard | Sisk",
    "keywords": "Синтаксис Discard Веб-сервер HTTP можно использовать для прослушивания запроса обратного вызова из действия, такого как аутентификация OAuth, и можно отбросить после получения этого запроса. Это может быть полезно в случаях, когда вам нужна фоновое действие, но вы не хотите настраивать整个 веб-приложение для этого. Следующий пример показывает, как создать прослушивающий HTTP-сервер на порту 5555 с помощью CreateListener и ожидать следующий контекст: using (var server = HttpServer.CreateListener(5555)) { // ожидать следующий HTTP-запрос var context = await server.WaitNextAsync(); Console.WriteLine($\"Запрошенный путь: {context.Request.Path}\"); } Функция WaitNext ожидает следующий контекст завершенной обработки запроса. Как только получен результат этой операции, сервер уже полностью обработал запрос и отправил ответ клиенту."
  },
  "docs/ru/features/instancing.html": {
    "href": "docs/ru/features/instancing.html",
    "title": "Внедрение зависимостей | Sisk",
    "keywords": "Внедрение зависимостей Обычно выделяют члены и экземпляры, которые существуют в течение всего времени жизни запроса, такие как соединение с базой данных, аутентифицированный пользователь или токен сессии. Одним из возможностей является использование HttpContext.RequestBag, который создает словарь, существующий в течение всего времени жизни запроса. Этот словарь можно получить у обработчиков запросов и определить переменные на протяжении всего запроса. Например, обработчик запроса, который аутентифицирует пользователя, устанавливает этого пользователя в HttpContext.RequestBag, и в логике запроса этот пользователь можно получить с помощью HttpContext.RequestBag.Get<User>(). Вот пример: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } Это предварительный пример этой операции. Экземпляр User был создан в обработчике запроса, посвященном аутентификации, и все маршруты, которые используют этот обработчик запроса, будут иметь гарантию, что в их экземпляре HttpContext.RequestBag будет User. Возможно определить логику получения экземпляров, когда они не были предварительно определены в RequestBag, через методы типа GetOrAdd или GetOrAddAsync. С версии 1.3 был введен статический свойство HttpContext.Current, которое позволяет получить доступ к текущему контексту запроса. Это позволяет экспонировать члены HttpContext вне текущего запроса и определять экземпляры в объектах маршрутов. Пример ниже определяет контроллер, который имеет члены, обычно доступные контекстом запроса. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // создать DbContext или получить существующий return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // следующая строка выдаст исключение, если свойство доступно, когда User не // определен в пакете запроса public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // экспонирование экземпляра HttpRequest также поддерживается public HttpRequest Request { get => HttpContext.Current.Request; } } И определить типы, которые наследуются от контроллера: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Для примера выше вам необходимо настроить обработчик значения в вашем маршрутизаторе, чтобы объекты, возвращаемые маршрутизатором, были преобразованы в допустимый HttpResponse. Обратите внимание, что методы не имеют аргумента HttpRequest request, как это присутствует в других методах. Это связано с тем, что с версии 1.3 маршрутизатор поддерживает два типа делегатов для маршрутизации ответов: RouteAction, который является делегатом по умолчанию, получающим аргумент HttpRequest, и ParameterlessRouteAction. Экземпляр HttpRequest все равно можно получить через свойство Request статического HttpContext в потоке. В примере выше мы определили объект, подлежащий удалению, DbContext, и нам необходимо обеспечить, чтобы все экземпляры, созданные в DbContext, были удалены, когда HTTP-сессия завершается. Для этого можно использовать два способа достижения этой цели. Один из них - создать обработчик запроса, который выполняется после действия маршрутизатора, а другой способ - через пользовательский обработчик сервера. Для первого метода можно создать обработчик запроса trực в методе OnSetup, унаследованном от RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // получить один DbContext, определенный в контексте обработчика запроса и // удалить его ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip С версии Sisk 1.4 свойство HttpServerConfiguration.DisposeDisposableContextValues было введено и включено по умолчанию, которое определяет, должен ли HTTP-сервер удалять все значения IDisposable в пакете контекста, когда HTTP-сессия закрывается. Метод выше обеспечит удаление DbContext, когда HTTP-сессия завершается. Вы можете сделать это для других членов, которые необходимо удалить в конце ответа. Для второго метода можно создать пользовательский обработчик сервера, который будет удалять DbContext, когда HTTP-сессия завершается. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } И использовать его в вашем построителе приложения: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Это один из способов обработки очистки кода и поддержания зависимостей запроса, разделенных по типу модуля, который будет использоваться, уменьшая количество дублирующего кода внутри каждого действия маршрутизатора. Это практика, аналогичная тому, для чего используется внедрение зависимостей в фреймворках типа ASP.NET."
  },
  "docs/ru/features/logging.html": {
    "href": "docs/ru/features/logging.html",
    "title": "Журналирование | Sisk",
    "keywords": "Журналирование Вы можете настроить Sisk для автоматического записи журналов доступа и ошибок. Также можно определить ротацию журналов, расширения и частоту. Класс LogStream предоставляет асинхронный способ записи журналов и поддерживает ожидаемую очередь записи. В этой статье мы покажем вам, как настроить журналирование для вашего приложения. Журналы доступа на основе файлов Журналы в файлах открывают файл, записывают текст строки, а затем закрывают файл для каждой записанной строки. Этот процесс был принят для поддержания отзывчивости записи в журналах. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } Вышеуказанный код запишет все входящие запросы в файл logs/access.log. Обратите внимание, что файл создается автоматически, если он не существует, но папка перед ним не создается. Не обязательно создавать папку logs/, поскольку класс LogStream автоматически создает ее. Журналирование на основе потока Вы можете записывать журналы в объекты TextWriter, такие как Console.Out, передав объект TextWriter в конструктор: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); Для каждого сообщения, записанного в потоковом журнале, вызывается метод TextWriter.Flush(). Форматирование журнала доступа Вы можете настроить формат журнала доступа с помощью предопределенных переменных. Рассмотрим следующую строку: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; Она запишет сообщение, подобное: 29/мар./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] Вы можете форматировать свой журнал по формату, описанному в таблице: Значение Что оно представляет Пример %dd День месяца (форматирован как два знака) 05 %dmmm Полное название месяца Июль %dmm Сокращенное название месяца (три знака) Июл %dm Номер месяца (форматирован как два знака) 07 %dy Год (форматирован как четыре знака) 2023 %th Час в 12-часовом формате 03 %tH Час в 24-часовом формате (HH) 15 %ti Минуты (форматированы как два знака) 30 %ts Секунды (форматированы как два знака) 45 %tm Миллисекунды (форматированы как три знака) 123 %tz Часовой пояс (общее количество часов в UTC) +03:00 %ri IP-адрес клиента 192.168.1.100 %rm HTTP-метод (в верхнем регистре) GET %rs Схема URI (http/https) https %ra Авторитет URI (домен) example.com %rh Хост запроса www.example.com %rp Порт запроса 443 %rz Путь запроса /path/to/resource %rq Строка запроса ?key=value&another=123 %sc Код состояния HTTP-ответа 200 %sd Описание состояния HTTP-ответа OK %lin Человекочитаемый размер запроса 1.2 KB %linr Необработанный размер запроса (байты) 1234 %lou Человекочитаемый размер ответа 2.5 KB %lour Необработанный размер ответа (байты) 2560 %lms Затраченное время в миллисекундах 120 %ls Статус выполнения Executed Ротация журналов Tip В Sisk 0.15 и старше, эта функция доступна только с пакетом Sisk.ServiceProvider. В Sisk 0.16 и выше, эта функция реализована в пакете core. Вы можете настроить веб-сервер для ротации файлов журналов в сжатый файл .gz, когда они достигают определенного размера. Размер проверяется периодически по заданному лимиту. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); Вышеуказанный код проверит каждые шесть часов, достиг ли файл LogStream размера 1 МБ. Если да, файл сжимается в файл .gz, а затем файл access.log очищается. Во время этого процесса запись в файл блокируется до тех пор, пока файл не будет сжат и очищен. Все строки, которые поступают для записи в этот период, будут в очереди ожидания до конца сжатия. Эта функция работает только с файловыми LogStreams. Журналирование ошибок Когда сервер не выбрасывает ошибки в отладчик, он пересылает ошибки в журнал записи, когда они есть. Вы можете настроить запись ошибок с помощью: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Это свойство запишет что-то в журнал только в том случае, если ошибка не была поймана обратным вызовом или свойством Router.CallbackErrorHandler. Ошибка, записанная сервером, всегда записывает дату и время, заголовки запроса (не тело), трассировку ошибки и трассировку внутренней ошибки, если она есть. Другие экземпляры журналирования Ваше приложение может иметь ноль или несколько LogStreams, нет ограничения на количество каналов журналирования, которые оно может иметь. Следовательно, возможно направить журнал вашего приложения в файл, отличный от стандартного AccessLog или ErrorLog. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Приложение запущено в {0}\", DateTime.Now); Расширение LogStream Вы можете расширить класс LogStream, чтобы записывать пользовательские форматы, совместимые с текущим движком журналирования Sisk. Пример ниже позволяет записывать цветные сообщения в консоль через библиотеку Spectre.Console: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Другой способ автоматически записывать пользовательские журналы для каждого запроса/ответа — создать HttpServerHandler. Пример ниже немного более полный. Он записывает тело запроса и ответа в JSON в консоль. Это может быть полезно для отладки запросов в целом. Этот пример использует ContextBag и HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // В этот момент соединение открыто, и клиент отправил заголовок, указывающий, // что содержимое является JSON. Строка ниже считывает содержимое и оставляет его // храниться в запросе. // // Если содержимое не прочитано в действии запроса, GC, скорее всего, соберет // содержимое после отправки ответа клиенту, поэтому содержимое может быть недоступно // после закрытия ответа. // _ = request.RawBody; // добавляем намек в контекст, чтобы сказать, что этот запрос имеет JSON-тело request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // переформатирует JSON с помощью библиотеки CypherPotato.LightJson var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // проверяем, является ли ответ JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // получаем внутренний статус обработки сервера responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/ru/features/server-sent-events.html": {
    "href": "docs/ru/features/server-sent-events.html",
    "title": "Server Sent Events | Sisk",
    "keywords": "Server Sent Events Sisk поддерживает отправку сообщений через Server Sent Events из коробки. Вы можете создавать одноразовые и постоянные подключения, получать подключения во время выполнения и использовать их. Эта функция имеет некоторые ограничения, налагаемые браузерами, такие как отправка только текстовых сообщений и невозможность навсегда закрыть подключение. Закрытое с серверной стороны подключение будет иметь клиент, периодически пытающийся reconnect каждые 5 секунд (3 для некоторых браузеров). Эти подключения полезны для отправки событий с сервера клиенту без необходимости запроса информации клиентом каждый раз. Создание подключения SSE Подключение SSE работает как обычный HTTP-запрос, но вместо отправки ответа и немедленного закрытия подключения, подключение остается открытым для отправки сообщений. Вызывая метод HttpRequest.GetEventSource(), запрос помещается в состояние ожидания, пока создается экземпляр SSE. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.Send(\"Hello, world!\"); return sse.Close(); }); В приведенном выше коде мы создаем подключение SSE и отправляем сообщение \"Hello, world\", затем закрываем подключение SSE с серверной стороны. Note При закрытии подключения с серверной стороны, по умолчанию клиент будет пытаться подключиться снова и подключение будет перезапущено, выполняя метод снова, навсегда. Обычно отправляют сообщение о завершении с сервера, когда подключение закрывается с сервера, чтобы предотвратить попытки клиента reconnect снова. Добавление заголовков Если вам нужно отправить заголовки, вы можете использовать метод HttpRequestEventSource.AppendHeader перед отправкой любых сообщений. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hello!\"); return sse.Close(); }); Обратите внимание, что необходимо отправить заголовки перед отправкой любых сообщений. Подключения Wait-For-Fail Подключения обычно завершаются, когда сервер больше не может отправлять сообщения из-за возможного отключения клиента. При этом подключение автоматически завершается и экземпляр класса удаляется. Даже при reconnect, экземпляр класса не будет работать, поскольку он связан с предыдущим подключением. В некоторых ситуациях вам может понадобиться это подключение позже и вы не хотите управлять им через метод callback маршрута. Для этого мы можем идентифицировать подключения SSE с помощью идентификатора и получить их позже, даже вне callback маршрута. Кроме того, мы помечаем подключение с помощью WaitForFail, чтобы не завершать маршрут и не завершать подключение автоматически. Подключение SSE в KeepAlive будет ждать ошибки отправки (вызванной отключением) для возобновления выполнения метода. Также можно установить Timeout для этого. После истечения времени, если не было отправлено никаких сообщений, подключение завершается и выполнение возобновляется. r += new Route(RouteMethod.Get, \"/\", (req) => { using var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // ждать 15 секунд без каких-либо сообщений перед завершением подключения return sse.Close(); }); Приведенный выше метод создаст подключение, обработает его и будет ждать отключения или ошибки. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // подключение все еще живо evs.Send(\"Hello again!\"); } А приведенный выше фрагмент кода попытается найти вновь созданное подключение и если оно существует, отправит ему сообщение. Все активные подключения сервера, которые идентифицированы, будут доступны в коллекции HttpServer.EventSources. Эта коллекция хранит только активные и идентифицированные подключения. Закрытые подключения удаляются из коллекции. Note Важно отметить, что keep alive имеет ограничение, установленное компонентами, которые могут быть подключены к Sisk неконтролируемым образом, такими как веб-прокси, HTTP-ядро или сетевой драйвер, и они закрывают неактивные подключения после определенного периода времени. Поэтому важно поддерживать подключение открытым, отправляя периодические пинги или продлевая максимальное время до закрытия подключения. Читайте следующий раздел, чтобы лучше понять отправку периодических пингов. Настройка политики пингов подключения Политика пингов - это автоматизированный способ отправки периодических сообщений клиенту. Эта функция позволяет серверу понимать, когда клиент отключился от этого подключения, не держа подключение открытым бесконечно. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { using var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } В приведенном выше коде, каждые 5 секунд, будет отправлено новое сообщение пинга клиенту. Это будет поддерживать подключение TCP в активном состоянии и предотвращать его закрытие из-за неактивности. Кроме того, когда отправка сообщения fails, подключение автоматически закрывается, освобождая ресурсы, используемые подключением. Запрос подключений Вы можете искать активные подключения, используя предикат по идентификатору подключения, чтобы иметь возможность广播, например. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcasting to all event sources that starts with 'my-connection-'\"); } Вы также можете использовать метод All, чтобы получить все активные подключения SSE."
  },
  "docs/ru/features/websockets.html": {
    "href": "docs/ru/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk также поддерживает веб-сокеты, позволяя получать и отправлять сообщения клиентам. Эта функция работает в большинстве браузеров, но в Sisk она все еще является экспериментальной. Пожалуйста, если вы обнаружите какие-либо ошибки, сообщите о них на github. Принятие и получение сообщений асинхронно Пример ниже показывает, как веб-сокет работает на практике, с примером открытия соединения, получения сообщения и отображения его в консоли. Все сообщения, полученные по WebSocket, принимаются в байтах, поэтому вам придется декодировать их при получении. По умолчанию сообщения фрагментируются на части, и последняя часть отправляется в качестве окончательного пакета сообщения. Вы можете настроить размер пакета с помощью флага WebSocketBufferSize. Это буферизация одинакова для отправки и получения сообщений. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // получает контекст HttpWebSocket, который получил сообщение HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); Note Не используйте асинхронные события таким образом. Вы можете получить исключения, выброшенные вне домена HTTP-сервера, и они могут привести к сбою вашего приложения. Если вам нужно обрабатывать асинхронный код и иметь дело с несколькими сообщениями одновременно, вы можете использовать цикл сообщений: router.MapGet(\"/\", async delegate (HttpRequest request) { using var ws = await request.GetWebSocketAsync(); WebSocketMessage? message; while ((message = ws.WaitNext(timeout: TimeSpan.FromSeconds(30))) != null) { var messageText = message.GetString(); Console.WriteLine($\"Received message: {messageText}\"); await ws.SendAsync(\"Hello from server!\"); } return ws.Close(); }); Принятие и получение сообщений синхронно Пример ниже содержит способ использования синхронного веб-сокета без асинхронного контекста, где вы получаете сообщения, обрабатываете их и завершаете использование сокета. router.MapGet(\"/connect\", req => { using var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); Отправка сообщений Метод Send имеет три перегрузки, которые позволяют отправлять текст, массив байтов или span байтов. Все они фрагментируются, если размер пакета сервера WebSocketBufferSize больше общего размера полезной нагрузки. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // будет закодировано как массив байтов UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Ожидание закрытия веб-сокета Метод WaitForClose() блокирует текущий стек вызовов до тех пор, пока соединение не будет завершено клиентом или сервером. Таким образом, выполнение обратного вызова запроса будет заблокировано до тех пор, пока клиент или сервер не отключится. Вы также можете вручную закрыть соединение с помощью метода Close(). Этот метод возвращает пустой объект HttpResponse, который не отправляется клиенту, но работает как возврат из функции, где был получен HTTP-запрос. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // ожидание закрытия соединения клиентом ws.WaitForClose(); // ожидание в течение 60 секунд без обмена сообщениями // или до тех пор, пока одна из сторон не закроет соединение ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\",5551, r); } Политика ping Аналогично тому, как политика ping работает в Server Side Events, вы также можете настроить политику ping, чтобы поддерживать открытое TCP-соединение в случае бездействия. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/ru/fundamentals/request-handlers.html": {
    "href": "docs/ru/fundamentals/request-handlers.html",
    "title": "Обработка запросов | Sisk",
    "keywords": "Обработка запросов Обработчики запросов, также известные как \"посредники\", являются функциями, которые выполняются до или после выполнения запроса на маршрутизаторе. Они могут быть определены для каждого маршрута или для всего маршрутизатора. Существует два типа обработчиков запросов: BeforeResponse: определяет, что обработчик запроса будет выполнен до вызова действия маршрутизатора. AfterResponse: определяет, что обработчик запроса будет выполнен после вызова действия маршрутизатора. Отправка HTTP-ответа в этом контексте перезапишет ответ действия маршрутизатора. Оба обработчика запросов могут переопределить фактический ответ функции обратного вызова маршрутизатора. Кроме того, обработчики запросов могут быть полезны для проверки запроса, такой как аутентификация, содержимое или любую другую информацию, такую как хранение информации, журналов или других шагов, которые можно выполнить до или после ответа. Таким образом, обработчик запроса может прервать все это выполнение и вернуть ответ до завершения цикла, отбрасывая все остальное в процессе. Пример: предположим, что обработчик запроса аутентификации пользователя не аутентифицирует его. Это предотвратит продолжение жизненного цикла запроса и повесит. Если это происходит в обработчике запроса на позиции два, третий и последующие не будут оценены. Создание обработчика запроса Чтобы создать обработчик запроса, мы можем создать класс, который наследует интерфейс IRequestHandler, в следующем формате: Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Возвращение null указывает на то, что запрос может быть продолжен return null; } else { // Возвращение объекта HttpResponse указывает на то, что этот ответ перезапишет соседние ответы. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } В приведенном выше примере мы указали, что если заголовок Authorization присутствует в запросе, он должен продолжаться, и следующий обработчик запроса или функция обратного вызова маршрутизатора должна быть вызвана, в зависимости от того, что происходит дальше. Если обработчик запроса выполняется после ответа по свойству ExecutionMode и возвращает не-нулевое значение, он перезапишет ответ маршрутизатора. Когда обработчик запроса возвращает null, это указывает на то, что запрос должен продолжаться, и следующий объект должен быть вызван, или цикл должен завершиться ответом маршрутизатора. Связывание обработчика запроса с одним маршрутом Вы можете определить один или несколько обработчиков запросов для маршрута. Router.cs C# mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // до запроса обработчик new ValidateJsonContentRequestHandler(), // до запроса обработчик // -- метод IndexPage будет выполнен здесь new WriteToLogRequestHandler() // после запроса обработчик }); Или создавая объект Route: Router.cs C# Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Связывание обработчика запроса с маршрутизатором Вы можете определить глобальный обработчик запроса, который будет запущен на всех маршрутах маршрутизатора. Router.cs C# mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Связывание обработчика запроса с атрибутом Вы можете определить обработчик запроса на методе атрибута вместе с атрибутом маршрута. Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } } Обратите внимание, что необходимо передать желаемый тип обработчика запроса, а не экземпляр объекта. Таким образом, обработчик запроса будет создан парсером маршрутизатора. Вы можете передать аргументы в конструктор класса с помощью свойства ConstructorArguments. Пример: Controller/MyController.cs C# [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] public HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } Вы также можете создать собственный атрибут, который реализует RequestHandler: Middleware/Attributes/AuthenticateAttribute.cs C# public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } И использовать его как: Controller/MyController.cs C# [Authenticate] static HttpResponse Index(HttpRequest request) { return res = new HttpResponse() { Content = new StringContent(\"Hello world!\") }; } Пропуск глобального обработчика запроса После определения глобального обработчика запроса на маршруте вы можете игнорировать этот обработчик запроса на конкретных маршрутах. Router.cs C# var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ок: тот же экземпляр, что и в глобальных обработчиках запросов new AuthenticateUserRequestHandler() // неправильно: не пропустит глобальный обработчик запроса } }); Note Если вы пропускаете обработчик запроса, вы должны использовать тот же ссылку на то, что было создано ранее, чтобы пропустить. Создание другого экземпляра обработчика запроса не пропустит глобальный обработчик запроса, поскольку ссылка изменится. Помните, что необходимо использовать ту же ссылку на обработчик запроса, которая используется как в GlobalRequestHandlers, так и в BypassGlobalRequestHandlers."
  },
  "docs/ru/fundamentals/requests.html": {
    "href": "docs/ru/fundamentals/requests.html",
    "title": "Запросы | Sisk",
    "keywords": "Запросы Запросы представляют собой структуры, которые представляют сообщение HTTP-запроса. Объект HttpRequest содержит полезные функции для обработки HTTP-сообщений на протяжении всего вашего приложения. HTTP-запрос формируется методом, путем, версией, заголовками и телом. В этом документе мы научим вас, как получить каждый из этих элементов. Получение метода запроса Чтобы получить метод полученного запроса, вы можете использовать свойство Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Это свойство возвращает метод запроса, представленный объектом HttpMethod. Note В отличие от методов маршрутизации, это свойство не служит для RouteMethod.Any элемента. Вместо этого оно возвращает фактический метод запроса. Получение компонентов URL Вы можете получить различные компоненты из URL через определенные свойства запроса. Для этого примера давайте рассмотрим URL: http://localhost:5000/user/login?email=foo@bar.com Название компонента Описание Значение компонента Path Получает путь запроса. /user/login FullPath Получает путь запроса и строку запроса. /user/login?email=foo@bar.com FullUrl Получает всю строку URL запроса. http://localhost:5000/user/login?email=foo@bar.com Host Получает хост запроса. localhost Authority Получает хост и порт запроса. localhost:5000 QueryString Получает строку запроса запроса. ?email=foo@bar.com Query Получает строку запроса запроса в виде коллекции именованных значений. {StringValueCollection object} IsSecure Определяет, использует ли запрос SSL (true) или нет (false). false Вы также можете использовать свойство HttpRequest.Uri, которое включает все вышеперечисленное в один объект. Получение тела запроса Некоторые запросы включают тело, такие как формы, файлы или транзакции API. Вы можете получить тело запроса из свойства: // получает тело запроса как строку, используя кодировку запроса в качестве кодировщика string body = request.Body; // или получает его в виде массива байтов byte[] bodyBytes = request.RawBody; // или же вы можете передать его как поток. Stream requestStream = request.GetRequestStream(); Также возможно определить, есть ли тело в запросе и загружено ли оно с помощью свойств HasContents, которое определяет, имеет ли запрос содержимое, и IsContentAvailable, которое указывает, что HTTP-сервер полностью получил содержимое из удаленной точки. Невозможно прочитать содержимое запроса через GetRequestStream более одного раза. Если вы прочитаете с помощью этого метода, значения в RawBody и Body также не будут доступны. Не нужно освобождать поток запроса в контексте запроса, поскольку он освобождается в конце HTTP-сессии, в которой он создается. Кроме того, вы можете использовать свойство HttpRequest.RequestEncoding, чтобы получить лучшую кодировку для декодирования запроса вручную. Сервер имеет ограничения на чтение содержимого запроса, которые применяются как к HttpRequest.Body, так и к HttpRequest.RawBody. Эти свойства копируют весь входной поток в локальный буфер того же размера, что и HttpRequest.ContentLength. Ответ с статусом 413 Содержимое слишком велико возвращается клиенту, если содержимое, отправленное клиентом, больше HttpServerConfiguration.MaximumContentLength, определенного в конфигурации пользователя. Кроме того, если нет настроенного ограничения или если оно слишком велико, сервер выдаст исключение OutOfMemoryException, когда содержимое, отправленное клиентом, превышает Int32.MaxValue (2 ГБ) и если содержимое попытается получить доступ через одно из упомянутых выше свойств. Вы все равно можете иметь дело с содержимым через поток. Note Хотя Sisk позволяет это, всегда хорошей идеей является следование семантике HTTP для создания вашего приложения и не получать или обслуживать содержимое в методах, которые не допускают этого. Прочитайте о RFC 9110 \"HTTP Семантика\". Получение контекста запроса Контекст HTTP - это эксклюзивный объект Sisk, который хранит информацию о HTTP-сервере, маршруте, маршрутизаторе и обработчике запроса. Вы можете использовать его, чтобы организовать себя в среде, где эти объекты трудно организовать. Объект RequestBag содержит сохраненную информацию, которая передается из обработчика запроса в другую точку и может быть потреблена в конечной точке. Этот объект также может быть использован обработчиками запросов, которые запускаются после обратного вызова маршрута. Tip Это свойство также доступно через свойство HttpRequest.Bag. Middleware/AuthenticateUserRequestHandler.cs C# public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { context.RequestBag.Add(\"AuthenticatedUser\", new User(\"Bob\")); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } Вышеуказанный обработчик запроса определит AuthenticatedUser в сумке запроса и может быть потреблен позже в конечном обратном вызове: Controller/MyController.cs C# public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { User authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; return new HttpResponse() { Content = new StringContent($\"Hello, {authUser.Name}!\") }; } } Вы также можете использовать методы Bag.Set() и Bag.Get(), чтобы получить или задать объекты по их типам синглтонов. Middleware/Authenticate.cs C# public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } Controller/MyController.cs C# [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse GetUser(HttpRequest request) { var user = request.Bag.Get<User>(); ... } Получение данных формы Вы можете получить значения данных формы в NameValueCollection с помощью следующего примера: Controller/Auth.cs C# [RoutePost(\"/auth\")] public HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password)) { ... } } Получение данных multipart-формы Запрос HTTP Sisk позволяет получить загруженные multipart-содержимое, такое как файлы, поля формы или любое бинарное содержимое. Controller/Auth.cs C# [RoutePost(\"/upload-contents\")] public HttpResponse Index(HttpRequest request) { // следующий метод читает весь входной запрос в массив // MultipartObject var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // имя файла, предоставленное multipart-формой данных. // Null возвращается, если объект не является файлом. Console.WriteLine(\"File name : \" + uploadedObject.Filename); // имя поля multipart-формы данных. Console.WriteLine(\"Field name : \" + uploadedObject.Name); // длина содержимого multipart-формы данных. Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // определите формат изображения на основе заголовка файла для каждого // известного типа содержимого. Если содержимое не является признанным общим форматом файла, // этот метод ниже вернет MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } Вы можете прочитать больше о Sisk Multipart-объектах формы и их методах, свойствах и функциях. Поддержка серверных событий Sisk поддерживает серверные события, которые позволяют отправлять фрагменты как поток и поддерживать соединение между сервером и клиентом. Вызов метода HttpRequest.GetEventSource поставит HttpRequest в его состояние прослушивания. После этого контекст этого HTTP-запроса не будет ожидать HttpResponse, поскольку он перекроет пакеты, отправленные серверными событиями. После отправки всех пакетов обратный вызов должен вернуть метод Close, который отправит окончательный ответ серверу и укажет, что поток закончился. Невозможно предсказать, какой будет общая длина всех пакетов, которые будут отправлены, поэтому невозможно определить конец соединения с помощью заголовка Content-Length. По умолчанию большинства браузеров серверные события не поддерживают отправку HTTP-заголовков или методов, кроме метода GET. Поэтому будьте осторожны при использовании обработчиков запросов с запросами event-source, которые требуют определенных заголовков в запросе, поскольку они, вероятно, не будут иметь их. Кроме того, большинство браузеров перезапускают потоки, если метод EventSource.close не вызван на стороне клиента после получения всех пакетов, что вызывает бесконечную дополнительную обработку на стороне сервера. Чтобы избежать этой проблемы, часто отправляют окончательный пакет, указывающий, что источник событий закончил отправку всех пакетов. Пример ниже показывает, как браузер может общаться с сервером, поддерживающим серверные события. sse-example.html HTML <html> <body> <b>Fruits:</b> <ul></ul> </body> <script> const evtSource = new EventSource('http://localhost:5555/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> И прогрессивно отправляйте сообщения клиенту: Controller/MyController.cs C# public class MyController { [RouteGet(\"/event-source\")] public async Task<HttpResponse> ServerEventsResponse(HttpRequest request) { var sse = await request.GetEventSourceAsync (); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { await serverEvents.SendAsync(fruit); await Task.Delay(1500); } return serverEvents.Close(); } } Когда вы запускаете этот код, мы ожидаем результат, подобный этому: Разрешение прокси-IP и хостов Sisk можно использовать с прокси, и поэтому IP-адреса могут быть заменены на конечную точку прокси в транзакции от клиента к прокси. Вы можете определить свои собственные разрешители в Sisk с помощью forwarding-разрешителей. Кодирование заголовков Кодирование заголовков может быть проблемой для некоторых реализаций. В Windows заголовки UTF-8 не поддерживаются, поэтому используется ASCII. Sisk имеет встроенный конвертер кодировки, который может быть полезен для декодирования неправильно закодированных заголовков. Эта операция дорога и отключена по умолчанию, но может быть включена под флагом NormalizeHeadersEncodings."
  },
  "docs/ru/fundamentals/responses.html": {
    "href": "docs/ru/fundamentals/responses.html",
    "title": "Responses | Sisk",
    "keywords": "Responses Ответы представляют собой объекты, которые являются HTTP-ответами на HTTP-запросы. Они отправляются сервером клиенту в качестве указания на запрос ресурса, страницы, документа, файла или другого объекта. HTTP-ответ состоит из статуса, заголовков и содержимого. В этом документе мы научим вас, как архитектировать HTTP-ответы с помощью Sisk. Установка HTTP-статуса Список HTTP-статусов одинаков с момента появления HTTP/1.0, и Sisk поддерживает все из них. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; //202 Или с помощью Fluent Syntax: new HttpResponse() .WithStatus(200) // или .WithStatus(HttpStatusCode.Ok) // или .WithStatus(HttpStatusInformation.Ok); Вы можете просмотреть полный список доступных HttpStatusCode здесь. Вы также можете указать свой собственный код статуса, используя структуру HttpStatusInformation. Тело и тип содержимого Sisk поддерживает родные объекты содержимого .NET для отправки тела в ответах. Вы можете использовать класс StringContent для отправки JSON-ответа, например: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); Сервер всегда попытается рассчитать Content-Length из того, что вы определили в содержимом, если вы явно не определили его в заголовке. Если сервер не может неявно получить заголовок Content-Length из содержимого ответа, ответ будет отправлен с Chunked-Encoding. Вы также можете передавать ответ, отправляя StreamContent или используя метод GetResponseStream. Заголовки ответа Вы можете добавлять, редактировать или удалять заголовки, которые отправляются в ответе. Пример ниже показывает, как отправить ответ с перенаправлением клиенту. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Или с помощью Fluent Syntax: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Когда вы используете метод Add коллекции HttpHeaderCollection, вы добавляете заголовок к запросу, не изменяя уже отправленные. Метод Set заменяет заголовки с тем же именем на указанное значение. Индексатор HttpHeaderCollection внутренне вызывает метод Set для замены заголовков. Отправка куки Sisk имеет методы, которые облегчают определение куки на клиенте. Куки, установленные этим методом, уже закодированы URL и соответствуют стандарту RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Или с помощью Fluent Syntax: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Имеются другие более полные версии того же метода. Частичные ответы Вы можете установить тип кодирования передачи на частичный для отправки больших ответов. HttpResponse res = new HttpResponse(); res.SendChunked = true; При использовании chunked-encoding заголовок Content-Length автоматически опускается. Поток ответа Потоки ответа - это управляемый способ, который позволяет отправлять ответы в сегментированном виде. Это более низкоуровневая операция, чем использование объектов HttpResponse, поскольку они требуют от вас отправки заголовков и содержимого вручную, а затем закрытия соединения. Этот пример открывает поток только для чтения для файла, копирует поток в выходной поток ответа и не загружает весь файл в память. Это может быть полезно для обслуживания средних или больших файлов. // получает выходной поток ответа using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // устанавливает кодирование ответа для использования chunked-encoding // также не следует отправлять заголовок content-length при использовании // chunked encoding responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // копирует поток файла в выходной поток ответа fileStream.CopyTo(responseStream.ResponseStream); // закрывает поток return responseStream.Close(); Сжатие GZip, Deflate и Brotli Вы можете отправлять ответы со сжатым содержимым в Sisk с помощью сжатия HTTP-содержимого. Во-первых, инкапсулируйте ваш объект HttpContent внутри одного из компрессоров ниже, чтобы отправить сжатый ответ клиенту. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // или Content = new BrotliContent(new HtmlContent(myHtml)), // или Content = new DeflateContent(new HtmlContent(myHtml)), }; }); Вы также можете использовать эти сжатые содержимое с потоками. router.MapGet(\"/archive.zip\", request => { // не применяйте \"using\" здесь. HttpServer отклонит ваше содержимое // после отправки ответа. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Заголовки Content-Encoding устанавливаются автоматически при использовании этих содержимостей. Автоматическое сжатие Возможно автоматически сжимать HTTP-ответы с помощью свойства EnableAutomaticResponseCompression. Это свойство автоматически инкапсулирует содержимое ответа от маршрутизатора в сжимаемое содержимое, которое принимается запросом, при условии, что ответ не унаследован от CompressedContent. Только одно сжимаемое содержимое выбирается для запроса, выбранное в соответствии с заголовком Accept-Encoding, который следует порядку: BrotliContent (br) GZipContent (gzip) DeflateContent (deflate) Если запрос указывает, что он принимает любой из этих методов сжатия, ответ будет автоматически сжат. Неявные типы ответов Вы можете использовать другие типы возвращаемых значений, кроме HttpResponse, но необходимо настроить маршрутизатор, чтобы он обрабатывал каждый тип объекта. Концепция состоит в том, чтобы всегда возвращать ссылочный тип и преобразовывать его в допустимый объект HttpResponse. Маршруты, которые возвращают HttpResponse, не подвергаются никаким преобразованиям. Типы значений (структуры) не могут быть использованы в качестве типа возвращаемого значения, потому что они не совместимы с RouterCallback, поэтому они должны быть обернуты в ValueResult, чтобы иметь возможность использоваться в обработчиках. Рассмотрим следующий пример из модуля маршрутизатора, не использующего HttpResponse в качестве типа возвращаемого значения: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } При этом теперь необходимо определить в маршрутизаторе, как он будет обрабатывать каждый тип объекта. Объекты всегда являются первым аргументом обработчика, а тип вывода должен быть допустимым объектом HttpResponse. Также выходные объекты маршрута никогда не должны быть null. Для типов ValueResult не обязательно указывать, что входной объект является ValueResult, и только T, поскольку ValueResult является объектом, отраженным от его исходного компонента. Ассоциация типов не сравнивает то, что было зарегистрировано, с типом объекта, возвращаемого из обратного вызова маршрутизатора. Вместо этого она проверяет, является ли тип результата маршрутизатора присваиваемым зарегистрированному типу. Регистрация обработчика типа Object будет резервным для всех ранее не проверенных типов. Порядок вставки обработчиков значений также имеет значение, поэтому регистрация обработчика Object проигнорирует все другие обработчики, специфичные для типов. Всегда регистрируйте обработчики значений сначала, чтобы обеспечить порядок. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<ApiResult>(apiResult => { return new HttpResponse() { Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest, Content = apiResult.GetHttpContent(), Headers = apiResult.GetHeaders() }; }); r.RegisterValueHandler<bool>(bvalue => { return new HttpResponse() { Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest }; }); r.RegisterValueHandler<IEnumerable<object>>(enumerableValue => { return new HttpResponse(string.Join(\"\\n\", enumerableValue)); }); // регистрация обработчика значений объекта должна быть последней // обработчиком значений, который будет использоваться в качестве резервного r.RegisterValueHandler<object>(fallback => { return new HttpResponse() { Status = HttpStatusCode.OK, Content = JsonContent.Create(fallback) }; }); Примечание о перечислимых объектах и массивах Неявные объекты ответа, реализующие IEnumerable, читаются в память с помощью метода ToArray() перед преобразованием с помощью определенного обработчика значений. Чтобы это произошло, объект IEnumerable преобразуется в массив объектов, и преобразователь ответа всегда получит Object[] вместо исходного типа. Рассмотрим следующий сценарий: using var host = HttpServer.CreateBuilder(12300) .UseRouter(r => { r.RegisterValueHandler<IEnumerable<string>>(stringEnumerable => { return new HttpResponse(\"Массив строк:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.RegisterValueHandler<IEnumerable<object>>(stringEnumerable => { return new HttpResponse(\"Массив объектов:\\n\" + string.Join(\"\\n\", stringEnumerable)); }); r.MapGet(\"/\", request => { return (IEnumerable<string>)[\"hello\", \"world\"]; }); }) .Build(); В приведенном выше примере преобразователь IEnumerable<string> никогда не будет вызван, потому что входной объект всегда будет массивом Object[] и не может быть преобразован в IEnumerable<string>. Однако преобразователь ниже, который получает IEnumerable<object>, получит свой вход, поскольку его значение совместимо. Если вам нужно фактически обрабатывать тип объекта, который будет перечислен, вам нужно использовать отражение, чтобы получить тип элемента коллекции. Все перечислимые объекты (списки, массивы и коллекции) преобразуются в массив объектов преобразователем HTTP-ответа. Значения, реализующие IAsyncEnumerable, обрабатываются автоматически сервером, если включено свойство ConvertIAsyncEnumerableIntoEnumerable, подобно тому, что происходит с IEnumerable. Асинхронная перечисляемая последовательность преобразуется в блокирующий перечислитель, а затем преобразуется в синхронный массив объектов."
  },
  "docs/ru/fundamentals/routing.html": {
    "href": "docs/ru/fundamentals/routing.html",
    "title": "Маршрутизация | Sisk",
    "keywords": "Маршрутизация Router является первым шагом в построении сервера. Он отвечает за хранение объектов Route, которые являются конечными точками, сопоставляющими URL и их методы с действиями, выполняемыми сервером. Каждое действие отвечает за получение запроса и доставку ответа клиенту. Маршруты представляют собой пары выражений пути (\"шаблон пути\") и HTTP-метода, на который они могут реагировать. Когда сервер получает запрос, он попытается найти маршрут, соответствующий полученному запросу, а затем вызовет действие этого маршрута и доставит результирующий ответ клиенту. Существует несколько способов определить маршруты в Sisk: они могут быть статическими, динамическими или автоматически сканированными, определены атрибутами или直接 в объекте Router. Router mainRouter = new Router(); // сопоставляет GET / с следующим действием mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); Чтобы понять, что может делать маршрут, нам нужно понять, что может делать запрос. HttpRequest будет содержать все необходимое. Sisk также включает некоторые дополнительные функции, которые ускоряют общее развитие. Для каждого действия, полученного сервером, будет вызван делегат типа RouteAction. Этот делегат содержит параметр, который держит HttpRequest со всей необходимой информацией о полученном запросе. Результирующий объект от этого делегата должен быть HttpResponse или объектом, который сопоставляется с ним через неявные типы ответов. Сопоставление маршрутов Когда сервер получает запрос, Sisk ищет маршрут, удовлетворяющий выражению полученного пути. Это выражение всегда тестируется между маршрутом и путем запроса, без учета строки запроса. Этот тест не имеет приоритета и исключителен для одного маршрута. Когда нет маршрута, соответствующего этому запросу, возвращается ответ Router.NotFoundErrorHandler клиенту. Когда шаблон пути совпадает, но HTTP-метод не совпадает, возвращается ответ Router.MethodNotAllowedErrorHandler клиенту. Sisk проверяет возможность коллизий маршрутов, чтобы избежать этих проблем. Когда определяются маршруты, Sisk будет искать возможные маршруты, которые могут столкнуться с определяемым маршрутом. Этот тест включает проверку пути и метода, на который настроен маршрут. Создание маршрутов с помощью шаблонов пути Вы можете определить маршруты, используя различные методы SetRoute. // способ SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // способ Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // пустой 200 ок }); // помощник методов Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // StreamContent inner // stream будет disposed после отправки // ответа. Content = new StreamContent(imageStream) }; }); // несколько параметров mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); Свойство RouteParameters объекта HttpResponse содержит всю информацию о переменных пути полученного запроса. Каждый полученный сервером путь нормализуется перед выполнением теста шаблона пути, следующим этими правилами: Все пустые сегменты удаляются из пути, например: ////foo//bar становится /foo/bar. Сопоставление пути чувствительно к регистру, если только Router.MatchRoutesIgnoreCase не установлен в true. Свойства Query и RouteParameters объекта HttpRequest возвращают объект StringValueCollection, где каждый индексированный свойство возвращает не-нулевой StringValue, который можно использовать как опцию/монаду для преобразования его сырого значения в управляемый объект. Пример ниже читает параметр маршрута \"id\" и получает из него Guid. Если параметр не является допустимым Guid, выбрасывается исключение, и возвращается ошибка 500 клиенту, если сервер не обрабатывает Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note Пути имеют игнорируемый завершающий / как в запросе, так и в пути маршрута, то есть если вы попытаетесь получить доступ к маршруту, определённому как /index/page, вы сможете получить доступ, используя /index/page/ тоже. Вы также можете принудительно завершать URL /, включив флаг ForceTrailingSlash. Создание маршрутов с помощью экземпляров классов Вы также можете определять маршруты динамически с помощью рефлексии и атрибута RouteAttribute. Таким образом, экземпляр класса, в котором его методы реализуют этот атрибут, будут иметь свои маршруты, определенные в целевом маршрутизаторе. Чтобы метод был определен как маршрут, он должен быть помечен атрибутом RouteAttribute, таким как сам атрибут или RouteGetAttribute. Метод может быть статическим, экземпляром, публичным или приватным. Когда метод SetObject(type) или SetObject<TType>() используется, методы экземпляра игнорируются. Controller/MyController.cs C# public class MyController { // будет соответствовать GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // статические методы также работают [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } Строка ниже определит оба метода Index и Hello класса MyController как маршруты, поскольку они помечены как маршруты, и предоставлен экземпляр класса, а не его тип. Если бы вместо этого был предоставлен его тип, были бы определены только статические методы. var myController = new MyController(); mainRouter.SetObject(myController); С версии Sisk 0.16 возможно включить AutoScan, который будет искать пользовательские классы, реализующие RouterModule, и автоматически ассоциировать их с маршрутизатором. Это не поддерживается с AOT-компиляцией. mainRouter.AutoScanModules<ApiController>(); Вышеуказанная инструкция будет искать все типы, которые реализуют ApiController, но не сам тип. Два необязательных параметра указывают, как метод будет искать эти типы. Первый аргумент подразумевает сборку, где будут искаться типы, а второй указывает, каким образом будут определены типы. Регулярные маршруты Вместо использования методов сопоставления пути HTTP по умолчанию вы можете пометить маршрут как интерпретируемый с помощью Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Или с помощью класса RegexRoute: mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); })); Вы также можете захватить группы из шаблона Regex в содержимое HttpRequest.RouteParameters: Controller/MyController.cs C# public class MyController { [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } } Префиксирование маршрутов Вы можете префиксировать все маршруты в классе или модуле с помощью атрибута RoutePrefix и установить префикс как строку. Смотрите пример ниже, используя архитектуру BREAD (Browse, Read, Edit, Add и Delete): Controller/Api/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController { // GET /api/users/<id> [RouteGet] public async Task<HttpResponse> Browse() { ... } // GET /api/users [RouteGet(\"/<id>\")] public async Task<HttpResponse> Read() { ... } // PATCH /api/users/<id> [RoutePatch(\"/<id>\")] public async Task<HttpResponse> Edit() { ... } // POST /api/users [RoutePost] public async Task<HttpResponse> Add() { ... } // DELETE /api/users/<id> [RouteDelete(\"/<id>\")] public async Task<HttpResponse> Delete() { ... } } В вышеуказанном примере параметр HttpResponse опущен в пользу использования через глобальный контекст HttpContext.Current. Читайте больше в следующем разделе. Маршруты без параметра запроса Маршруты можно определять без параметра HttpRequest и все равно можно получить запрос и его компоненты в контексте запроса. Давайте рассмотрим абстракцию ControllerBase, которая служит основой для всех контроллеров API, и эта абстракция предоставляет свойство Request для получения HttpRequest, в настоящее время полученного. Controller/ControllerBase.cs C# public abstract class ControllerBase { // получает запрос из текущей нити public HttpRequest Request { get => HttpContext.Current.Request; } // строка ниже, когда вызывается, получает базу данных из текущей HTTP-сессии, // или создает новую, если она не существует public DbContext Database { get => HttpContext.Current.RequestBag.GetOrAdd<DbContext>(); } } И для всех его потомков, чтобы они могли использовать синтаксис маршрута без параметра запроса: Controller/UsersController.cs C# [RoutePrefix(\"/api/users\")] public class UsersController : ControllerBase { [RoutePost] public async Task<HttpResponse> Create() { // читает JSON-данные из текущего запроса UserCreationDto? user = JsonSerializer.DeserializeAsync<UserCreationDto>(Request.Body); ... Database.Users.Add(user); return new HttpResponse(201); } } Более подробную информацию о текущем контексте и внедрении зависимостей можно найти в учебнике внедрение зависимостей. Маршруты любого метода Вы можете определить маршрут, чтобы он соответствовал только его пути и пропустить HTTP-метод. Это может быть полезно для проверки метода внутри маршрута. // будет соответствовать / на любом HTTP-методе mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Маршруты любого пути Маршруты любого пути тестируют любой путь, полученный HTTP-сервером, подлежащий маршруту метода. Если маршрут метода равен RouteMethod.Any и маршрут использует Route.AnyPath в его выражении пути, этот маршрут будет слушать все запросы от HTTP-сервера, и не могут быть определены другие маршруты. // следующий маршрут будет соответствовать всем запросам POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Игнорирование регистра маршрута По умолчанию интерпретация маршрутов с запросами чувствительна к регистру. Чтобы сделать ее игнорирующей регистр, включите эту опцию: mainRouter.MatchRoutesIgnoreCase = true; Это также включит опцию RegexOptions.IgnoreCase для маршрутов, где используется сопоставление с помощью Regex. Обработчик не найденного (404) обратного вызова Вы можете создать пользовательский обратный вызов для случая, когда запрос не соответствует ни одному известному маршруту. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // С версии v0.14 Content = new HtmlContent(\"<h1>Not found</h1>\") // более ранние версии Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; Обработчик метода не допускается (405) обратного вызова Вы также можете создать пользовательский обратный вызов для случая, когда запрос соответствует его пути, но не соответствует методу. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; Внутренний обработчик ошибок Обратные вызовы маршрутов могут выбрасывать ошибки во время выполнения сервера. Если они не обрабатываются правильно, общая работа HTTP-сервера может быть прервана. Маршрутизатор имеет обратный вызов для случая, когда обратный вызов маршрута неудачно и предотвращает прерывание службы. Этот метод доступен только тогда, когда ThrowExceptions установлен в false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/ru/getting-started.html": {
    "href": "docs/ru/getting-started.html",
    "title": "Начало работы | Sisk",
    "keywords": "Начало работы Добро пожаловать в документацию Sisk. Наконец, что такое Sisk Framework? Это открытая библиотека с открытым исходным кодом, построенная на основе .NET, предназначенная для того, чтобы быть минимальной, гибкой и абстрактной. Она позволяет разработчикам создавать интернет-сервисы быстро, с минимальной или без необходимой конфигурации. Sisk позволяет вашему существующему приложению иметь управляемый модуль HTTP, полный и утилизируемый или полный. Ценности Sisk включают прозрачность кода, модульность, производительность и масштабируемость, и могут обрабатывать различные типы приложений, такие как Restful, JSON-RPC, Web-sockets и многое другое. Его основные функции включают: Ресурс Описание Routing Маршрутизатор пути, поддерживающий префиксы, пользовательские методы, переменные пути, конвертеры значений и многое другое. Request Handlers Также известные как посредники, предоставляют интерфейс для создания собственных обработчиков запросов, которые работают с запросом до или после действия. Compression Сжимайте содержимое ответа легко с помощью Sisk. Web sockets Предоставляет маршруты, которые принимают полные веб-сокеты, для чтения и записи на клиент. Server-sent events Предоставляет отправку событий сервера клиентам, поддерживающим протокол SSE. Logging Упрощенное ведение журнала. Ведите журнал ошибок, доступа, определяйте журналы вращения по размеру, несколько потоков вывода для одного и того же журнала и многое другое. Multi-host Имеете HTTP-сервер для нескольких портов, и каждый порт со своим маршрутизатором, и каждый маршрутизатор со своим приложением. Server handlers Расширяйте свою собственную реализацию HTTP-сервера. Настройте с помощью расширений, улучшений и новых функций. Первые шаги Sisk может работать в любой среде .NET. В этом руководстве мы научим вас, как создать приложение Sisk с помощью .NET. Если вы еще не установили его, пожалуйста, скачайте SDK с сюда. В этом учебнике мы расскажем, как создать структуру проекта, получить запрос, получить параметр URL и отправить ответ. Это руководство будет сосредоточено на построении простого сервера с помощью C#. Вы также можете использовать свой любимый язык программирования. Note Вам может быть интересно начать с проекта. Проверьте этот репозиторий для получения дополнительной информации. Создание проекта Давайте назовем наш проект \"Мое приложение Sisk\". Как только вы настроите .NET, вы можете создать свой проект с помощью следующей команды: dotnet new console -n my-sisk-application Далее перейдите в каталог вашего проекта и установите Sisk с помощью утилиты .NET: cd my-sisk-application dotnet add package Sisk.HttpServer Вы можете найти дополнительные способы установки Sisk в вашем проекте здесь. Теперь давайте создадим экземпляр нашего HTTP-сервера. Для этого примера мы настроим его на прослушивание порта 5000. Построение HTTP-сервера Sisk позволяет вам строить свое приложение шаг за шагом вручную, поскольку оно маршрутизируется к объекту HttpServer. Однако это может быть не очень удобно для большинства проектов. Поэтому мы можем использовать метод построения, который делает его проще получить наше приложение в работу. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } Важно понять каждый важный компонент Sisk. Позже в этой документации вы узнаете больше о том, как работает Sisk. Ручная (расширенная) настройка Вы можете узнать, как работает каждый механизм Sisk в этом разделе документации, который объясняет поведение и отношения между HttpServer, Router, ListeningPort и другими компонентами."
  },
  "docs/ru/installing.html": {
    "href": "docs/ru/installing.html",
    "title": "Установка | Sisk",
    "keywords": "Установка Вы можете установить Sisk через Nuget, dotnet cli или другие варианты. Вы можете легко настроить среду Sisk, выполнив эту команду в вашей консоли разработчика: dotnet add package Sisk.HttpServer Эта команда установит последнюю версию Sisk в вашем проекте."
  },
  "docs/ru/native-aot.html": {
    "href": "docs/ru/native-aot.html",
    "title": "Native AOT Поддержка | Sisk",
    "keywords": "Native AOT Поддержка .NET Native AOT позволяет публиковать родные приложения .NET, которые являются самодостаточными и не требуют установки среды выполнения .NET на целевом хосте. Кроме того, Native AOT предоставляет такие преимущества, как: Значительно меньшие приложения Значительно более быстрая инициализация Низкое потребление памяти Sisk Framework, благодаря своей явной природе, позволяет использовать Native AOT для几乎 всех своих функций без необходимости переработки исходного кода для адаптации его к Native AOT. Не поддерживаемые функции Однако Sisk использует рефлексию, хотя и минимальную, для некоторых функций. Функции, упомянутые ниже, могут быть частично доступны или полностью недоступны во время выполнения родного кода: Автоматическое сканирование модулей маршрутизатора: этот ресурс сканирует типы, встроенные в выполняемую сборку, и регистрирует типы, которые являются модулями маршрутизатора. Этот ресурс требует типов, которые могут быть исключены во время обрезки сборки. Все остальные функции совместимы с AOT в Sisk. Обычно можно найти один или другой метод, который выдает предупреждение AOT, но тот же метод, если он не упоминается здесь, имеет перегруженную версию, которая указывает на передачу типа, параметра или информации о типе, что помогает компилятору AOT компилировать объект."
  },
  "docs/ru/registering-namespace.html": {
    "href": "docs/ru/registering-namespace.html",
    "title": "Настройка резервирования пространств имен в Windows | Sisk",
    "keywords": "Настройка резервирования пространств имен в Windows Sisk работает с сетевым интерфейсом HttpListener, который связывает виртуальный хост с системой для прослушивания запросов. В Windows это связывание немного ограничено, разрешая связывать только localhost в качестве допустимого хоста. При попытке прослушивать другой хост на сервере возникает ошибка доступа. Это руководство объясняет, как предоставить авторизацию для прослушивания на любом хосте, который вы хотите на системе. Namespace Setup.bat BATCH @echo off :: вставьте префикс здесь, без пробелов или кавычек SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Где в PREFIX находится префикс (\"Хост->Порт прослушивания\"), который будет прослушивать ваш сервер. Он должен быть отформатирован по схеме URL, хосту, порту и слэшу в конце, например: Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ Таким образом, вы можете прослушивать в вашем приложении через: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/ru/ssl.html": {
    "href": "docs/ru/ssl.html",
    "title": "Работа с SSL | Sisk",
    "keywords": "Работа с SSL Работа с SSL для разработки может быть необходима в контекстах, требующих безопасности, таких как большинство сценариев веб-разработки. Sisk работает поверх HttpListener, который не поддерживает родной HTTPS, только HTTP. Однако существуют обходные пути, которые позволяют работать с SSL в Sisk. См. их ниже: Через IIS на Windows Доступно на: Windows Уровень сложности: средний Если вы находитесь на Windows, вы можете использовать IIS для включения SSL на вашем HTTP-сервере. Для этого рекомендуется следовать этому учебнику заранее, если вы хотите, чтобы ваше приложение слушало хост, отличный от \"localhost\". Для этого необходимо установить IIS через функции Windows. IIS доступен бесплатно для пользователей Windows и Windows Server. Чтобы настроить SSL в вашем приложении, необходимо иметь сертификат SSL, даже если он самоподписанный. Далее вы можете увидеть как настроить SSL на IIS 7 или выше. Через mitmproxy Доступно на: Linux, macOS, Windows Уровень сложности: легкий mitmproxy - это инструмент перехвата прокси, который позволяет разработчикам и тестировщикам безопасности осматривать, изменять и записывать HTTP- и HTTPS-трафик между клиентом (таким как веб-браузер) и сервером. Вы можете использовать утилиту mitmdump, чтобы начать обратный SSL-прокси между вашим клиентом и приложением Sisk. Сначала установите mitmproxy на вашем компьютере. Запустите ваше приложение Sisk. В этом примере мы будем использовать порт 8000 в качестве не安全ного HTTP-порта. Запустите сервер mitmproxy, чтобы прослушивать безопасный порт на 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 И вы готовы! Вы уже можете использовать ваше приложение через https://localhost:8001/. Вашему приложению не нужно запускаться, чтобы начать mitmdump. Альтернативно, вы можете добавить ссылку на помощник mitmproxy в ваш проект. Это все равно требует, чтобы mitmproxy был установлен на вашем компьютере. Через пакет Sisk.SslProxy Доступно на: Linux, macOS, Windows Уровень сложности: легкий Пакет Sisk.SslProxy - это простой способ включить SSL на вашем приложении Sisk. Однако это крайне экспериментальный пакет. Он может быть нестабильным для работы с этим пакетом, но вы можете быть частью небольшого процента людей, которые будут вносить вклад в то, чтобы этот пакет был жизнеспособным и стабильным. Чтобы начать, вы можете установить пакет Sisk.SslProxy с: dotnet add package Sisk.SslProxy Note Вам необходимо включить \"Enable pre-release packages\" в менеджере пакетов Visual Studio, чтобы установить Sisk.SslProxy. Опять же, это экспериментальный проект, поэтому даже не думайте о том, чтобы использовать его в производстве. На данный момент Sisk.SslProxy может обрабатывать большинство функций HTTP/1.1, включая HTTP Continue, Chunked-Encoding, WebSockets и SSE. Читайте больше о SslProxy здесь."
  },
  "docs/ssl.html": {
    "href": "docs/ssl.html",
    "title": "Working with SSL | Sisk",
    "keywords": "Working with SSL Working with SSL for development may be necessary when working in contexts that require security, such as most web development scenarios. Sisk operates on top of HttpListener, which does not support native HTTPS, only HTTP. However, there are workarounds that allow you to work with SSL in Sisk. See them below: Through IIS on Windows Available on: Windows Effort: medium If you are on Windows, you can use IIS to enable SSL on your HTTP server. For this to work, it is advisable that you follow this tutorial beforehand if you want your application to be listening on a host other than \"localhost.\" For this to work, you must install IIS through Windows features. IIS is available for free to Windows and Windows Server users. To configure SSL in your application, have the SSL certificate ready, even if it is self-signed. Next, you can see how to set up SSL on IIS 7 or higher. Through mitmproxy Available on: Linux, macOS, Windows Effort: easy mitmproxy is an interception proxy tool that allows developers and security testers to inspect, modify, and record HTTP and HTTPS traffic between a client (such as a web browser) and a server. You can use the mitmdump utility to start an reverse SSL proxy between your client and your Sisk application. Firstly, install the mitmprxy in your machine. Start your Sisk application. For this example, we'll use the 8000 port as the insecure HTTP port. Start the mitmproxy server to listen the secure port at 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 And you're ready to go! You can already your application through https://localhost:8001/. Your application does not need to be running for you to start mitmdump. Alternatively, you can add a reference to the mitmproxy helper in your project. This still requires that mitmproxy is installed on your computer. Through Sisk.SslProxy package Available on: Linux, macOS, Windows Effort: easy The Sisk.SslProxy package is a simple way to enable SSL on your Sisk application. However, it is an extremely experimental package. It may be unstable to work with this package, but you can be part of the small percentage of people who will contribute to making this package viable and stable. To get started, you can install the Sisk.SslProxy package with: dotnet add package Sisk.SslProxy Note You must enable \"Enable pre-release packages\" in the Visual Studio Package Manger to install Sisk.SslProxy. Again, it is an experimental project, so don't even think about putting it into production. At the moment, Sisk.SslProxy can handle most HTTP/1.1 features, including HTTP Continue, Chunked-Encoding, WebSockets, and SSE. Read more about SslProxy here."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome! | Sisk",
    "keywords": "Welcome! Welcome to the Sisk Framework! This project was initially created to explore the capabilities of the native .NET HttpListener and has gradually evolved into a more commercially oriented framework as I began applying it to personal and commercial projects. What is Sisk? Sisk is a lightweight, agnostic, simple, and robust web development framework. Its core idea is to create a service that runs on the internet, following the patterns you define. Moreover, Sisk adapts to your preferred working style, rather than the other way around. Due to its explicit nature, Sisk's behavior is predictable. The main differentiator from ASP.NET is that Sisk can be up and running with very few lines of code, avoiding unnecessary configurations and requiring minimal setup to get your server operational. Additionally, it does not require any additional .NET SDK packages for development, as the base package of .NET 6 is sufficient to start working with Sisk. Sisk's philosophy emphasizes simplicity and provides all the essential tools for building cloud applications without relying on specific or proprietary technologies from other companies. However, the Sisk environment allows for the implementation of both proprietary and non-proprietary technologies, enabling their use, development, and support within the framework. Furthermore, the term \"framework\" refers to the collection of methods, tools, and libraries that make Sisk a complete web development ecosystem. Contributions must adhere to this philosophy and maintain readable, maintainable code that anyone with a basic understanding can read, maintain, and compile. Sisk has a strict policy of transparency in its code. All technologies used to build Sisk must be open source, traceable, maintainable, and compilable, allowing anyone to edit, view, and create their own version of Sisk. What is Sisk for? With Sisk, you can create RESTful applications, Web sockets, file servers, GraphQL APIs, Entity Framework integrations, and more—essentially, whatever you need. Sisk is an extremely modular and sustainable framework. Its current development is intense, with much more to be added, but the focus remains on keeping it simple, easy to maintain, and enjoyable for developers working on projects of any size. Sisk has also been tested in low-performance environments, such as machines with less than 1GB of RAM, handling over 20,000 requests per second. The code, from the moment it arrives on the server to the response sent back, is extremely concise, with very few steps before reaching the client. One of the pillars of developing with Sisk is its compatibility with any machine that supports .NET, including those that do not require Native AOT. Additional implementations are also provided within the Sisk ecosystem, such as porting projects to other machines using configuration files and a view engine based on LISP, among others, served with packages beyond the core Sisk package. By design, Sisk is built to work with routers, but you are not obligated to use them. Sisk provides all the necessary infrastructure to create a secure application without obfuscating your code. There's no need for excessive ceremony, fluff, or spending hours on tedious documentation. Sisk is simple and elegant in its syntax, facilitating the development of fast and complex systems. But why not just use ASP.NET? ASP.NET is a great and well-established web framework, and many features present in Sisk were inspired by it. However, Sisk focuses on simpler and more performant development, eliminating the need to install additional components in your system, project, or editor. Sisk was designed to be straightforward and robust, enabling you to create anything you desire. Moreover, its development model allows you to choose how you want to work. You can handle requests in a simple, efficient, explicit, and fast manner. A basic understanding of HTTP is required if you want to manage everything manually, but even then, Sisk can greatly simplify the process with the functions it provides in its core package. Getting started with Sisk is easy. Those with prior web development experience typically learn Sisk in one or two days. The Sisk documentation is a valuable resource, serving not just as a specification but as a complete manual with examples and support. You can get started with Sisk here. Let's get started with Sisk."
  },
  "readme.html": {
    "href": "readme.html",
    "title": "Sisk Documentation | Sisk",
    "keywords": "Sisk Documentation This repository contains the source code of the Sisk Documentation website. Building Firstly, make sure you have docfx installed in your machine. You'll need .NET SDK to install it. Clone this repository. Build the Sisk Framework project and put the .DLL binaries and XML documentation file at the ref/ directory, on the repository root. Run docfx, then docfx serve. Warning Please, do not use the docfx version 2.78.0 or later. This version has a bug that changes the documentation navigation layout. See the tracking issue. Prefer the version 2.76.0: dotnet tool install -g docfx --version 2.76.0 Then you're ready to go and you'll have the static website files at /_site. Contributing Contributions are always welcome. Contribute with spelling corrections, fixing broken links and more. Please, only edit english documentation files. Documentation files for another languages are AI-generated from english files through. Note Please do not edit API specification files (XML). These files are generated. If you want to edit any API documentation, edit it in the repository where the code is hosted."
  }
}