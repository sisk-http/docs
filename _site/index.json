{
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.-ctor.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.-ctor.html",
    "title": "Constructor BasicAuthenticateRequestHandler | Sisk",
    "keywords": "Constructor BasicAuthenticateRequestHandler Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll BasicAuthenticateRequestHandler() public BasicAuthenticateRequestHandler()"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.CreateUnauthorizedResponse.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.CreateUnauthorizedResponse.html",
    "title": "Method CreateUnauthorizedResponse | Sisk",
    "keywords": "Method CreateUnauthorizedResponse Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll CreateUnauthorizedResponse(string) Creates an empty HTTP response with the WWW-Authenticate header and an custom realm message. public HttpResponse CreateUnauthorizedResponse(string realm) Parameters realm string Defines the realm message to send back to the client. Returns HttpResponse CreateUnauthorizedResponse() Creates an empty HTTP response with the WWW-Authenticate header and with the realm message defined in this class instance. public HttpResponse CreateUnauthorizedResponse() Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Execute.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Execute.html",
    "title": "Method Execute | Sisk",
    "keywords": "Method Execute Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route callback is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. public HttpResponse? Execute(HttpRequest request, HttpContext context) Parameters request HttpRequest context HttpContext Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll ExecutionMode Gets or sets when this RequestHandler should run. public RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.OnValidating.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.OnValidating.html",
    "title": "Method OnValidating | Sisk",
    "keywords": "Method OnValidating Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll OnValidating(BasicAuthenticationCredentials, HttpContext) Indicates the method that is called to validate a request with client credentials. When returning an HttpResponse, it will be sent immediately to the client and the rest of the stack will not be executed. If the return is null, it is interpretable that the authentication was successful and the execution should continue. public virtual HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) Parameters credentials BasicAuthenticationCredentials Represents the credentials sent by the client, already decoded and ready for use. context HttpContext Represents the Http context. Returns HttpResponse"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Realm.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.Realm.html",
    "title": "Property Realm | Sisk",
    "keywords": "Property Realm Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Realm Gets or sets a message to show the client which protection scope it needs to authenticate to. public string Realm { get; set; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticateRequestHandler.html",
    "title": "Class BasicAuthenticateRequestHandler | Sisk",
    "keywords": "Class BasicAuthenticateRequestHandler Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Gets a IRequestHandler that serves as an authenticator for the Basic Authentication scheme, which can validate a user id and password. public class BasicAuthenticateRequestHandler : IRequestHandler Inheritance object BasicAuthenticateRequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors BasicAuthenticateRequestHandler() Properties ExecutionMode Gets or sets when this RequestHandler should run. Realm Gets or sets a message to show the client which protection scope it needs to authenticate to. Methods CreateUnauthorizedResponse() Creates an empty HTTP response with the WWW-Authenticate header and with the realm message defined in this class instance. CreateUnauthorizedResponse(string) Creates an empty HTTP response with the WWW-Authenticate header and an custom realm message. Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route callback is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. OnValidating(BasicAuthenticationCredentials, HttpContext) Indicates the method that is called to validate a request with client credentials. When returning an HttpResponse, it will be sent immediately to the client and the rest of the stack will not be executed. If the return is null, it is interpretable that the authentication was successful and the execution should continue."
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.Password.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.Password.html",
    "title": "Property Password | Sisk",
    "keywords": "Property Password Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Password Gets the plain password component from this credentials. public string Password { get; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.UserId.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.UserId.html",
    "title": "Property UserId | Sisk",
    "keywords": "Property UserId Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll UserId Gets the user id component from this credentials. public string UserId { get; } Property Value string"
  },
  "api/Sisk.BasicAuth.BasicAuthenticationCredentials.html": {
    "href": "api/Sisk.BasicAuth.BasicAuthenticationCredentials.html",
    "title": "Class BasicAuthenticationCredentials | Sisk",
    "keywords": "Class BasicAuthenticationCredentials Namespace Sisk.BasicAuth Assembly Sisk.BasicAuth.dll Represents basic authentication credentials for an HTTP request. public class BasicAuthenticationCredentials Inheritance object BasicAuthenticationCredentials Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Password Gets the plain password component from this credentials. UserId Gets the user id component from this credentials."
  },
  "api/Sisk.BasicAuth.html": {
    "href": "api/Sisk.BasicAuth.html",
    "title": "Namespace Sisk.BasicAuth | Sisk",
    "keywords": "Namespace Sisk.BasicAuth Classes BasicAuthenticateRequestHandler Gets a IRequestHandler that serves as an authenticator for the Basic Authentication scheme, which can validate a user id and password. BasicAuthenticationCredentials Represents basic authentication credentials for an HTTP request."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.-ctor.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.-ctor.html",
    "title": "Constructor CrossOriginResourceSharingHeaders | Sisk",
    "keywords": "Constructor CrossOriginResourceSharingHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CrossOriginResourceSharingHeaders() Creates an empty CrossOriginResourceSharingHeaders instance with no predefined CORS headers. public CrossOriginResourceSharingHeaders()"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowCredentials.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowCredentials.html",
    "title": "Property AllowCredentials | Sisk",
    "keywords": "Property AllowCredentials Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowCredentials Gets or sets the Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. public bool? AllowCredentials { get; set; } Property Value bool?"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowHeaders.html",
    "title": "Property AllowHeaders | Sisk",
    "keywords": "Property AllowHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowHeaders Gets or sets the Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. public string[] AllowHeaders { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowMethods.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowMethods.html",
    "title": "Property AllowMethods | Sisk",
    "keywords": "Property AllowMethods Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowMethods Gets or sets the Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. public string[] AllowMethods { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigin.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigin.html",
    "title": "Property AllowOrigin | Sisk",
    "keywords": "Property AllowOrigin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowOrigin From MDN: Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the \"*\" wildcard tells browsers to allow any origin to access the resource. public string? AllowOrigin { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigins.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.AllowOrigins.html",
    "title": "Property AllowOrigins | Sisk",
    "keywords": "Property AllowOrigins Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AllowOrigins Gets or sets domains which will define the source header according to one of the domains present below. public string[] AllowOrigins { get; set; } Property Value string[] Remarks This property makes the server compare the origin of the request and associate the domain that corresponds to it."
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.CreatePublicContext.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.CreatePublicContext.html",
    "title": "Method CreatePublicContext | Sisk",
    "keywords": "Method CreatePublicContext Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CreatePublicContext() Create an instance of Cross-Origin Resource Sharing that allows any origin, any method and any header in the request. public static CrossOriginResourceSharingHeaders CreatePublicContext() Returns CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.Empty.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.Empty.html",
    "title": "Property Empty | Sisk",
    "keywords": "Property Empty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Empty Gets an instance of an empty CrossOriginResourceSharingHeaders. public static CrossOriginResourceSharingHeaders Empty { get; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.ExposeHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.ExposeHeaders.html",
    "title": "Property ExposeHeaders | Sisk",
    "keywords": "Property ExposeHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ExposeHeaders Gets or sets the Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript in browsers is allowed to access. public string[] ExposeHeaders { get; set; } Property Value string[]"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.MaxAge.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.MaxAge.html",
    "title": "Property MaxAge | Sisk",
    "keywords": "Property MaxAge Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaxAge Gets or sets the Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. public TimeSpan MaxAge { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.html": {
    "href": "api/Sisk.Core.Entity.CrossOriginResourceSharingHeaders.html",
    "title": "Class CrossOriginResourceSharingHeaders | Sisk",
    "keywords": "Class CrossOriginResourceSharingHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Provides a class to provide Cross Origin response headers for when communicating with a browser. public sealed class CrossOriginResourceSharingHeaders Inheritance object CrossOriginResourceSharingHeaders Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors CrossOriginResourceSharingHeaders() Creates an empty CrossOriginResourceSharingHeaders instance with no predefined CORS headers. Properties AllowCredentials Gets or sets the Access-Control-Allow-Credentials header indicates whether or not the response to the request can be exposed when the credentials flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. AllowHeaders Gets or sets the Access-Control-Allow-Headers header is used in response to a preflight request to indicate which HTTP headers can be used when making the actual request. AllowMethods Gets or sets the Access-Control-Allow-Methods header specifies the method or methods allowed when accessing the resource. AllowOrigin From MDN: Access-Control-Allow-Origin specifies either a single origin which tells browsers to allow that origin to access the resource; or else — for requests without credentials — the \"*\" wildcard tells browsers to allow any origin to access the resource. AllowOrigins Gets or sets domains which will define the source header according to one of the domains present below. Empty Gets an instance of an empty CrossOriginResourceSharingHeaders. ExposeHeaders Gets or sets the Access-Control-Expose-Headers header adds the specified headers to the allowlist that JavaScript in browsers is allowed to access. MaxAge Gets or sets the Access-Control-Max-Age header indicates how long the results of a preflight request can be cached. Methods CreatePublicContext() Create an instance of Cross-Origin Resource Sharing that allows any origin, any method and any header in the request."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.-ctor.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.-ctor.html",
    "title": "Constructor HttpHeaderCollection | Sisk",
    "keywords": "Constructor HttpHeaderCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll HttpHeaderCollection() Create an new instance of the HttpHeaderCollection class. public HttpHeaderCollection() HttpHeaderCollection(IDictionary<string, string[]>) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(IDictionary<string, string[]> items) Parameters items IDictionary<string, string[]> The inner collection to add to this collection. HttpHeaderCollection(IDictionary<string, string?>) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(IDictionary<string, string?> items) Parameters items IDictionary<string, string> The inner collection to add to this collection. HttpHeaderCollection(WebHeaderCollection) Create an new instance of the HttpHeaderCollection class with values from another collection. public HttpHeaderCollection(WebHeaderCollection items) Parameters items WebHeaderCollection The inner collection to add to this collection."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Accept.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Accept.html",
    "title": "Property Accept | Sisk",
    "keywords": "Property Accept Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Accept Gets the value of the HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. public string? Accept { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCharset.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptCharset.html",
    "title": "Property AcceptCharset | Sisk",
    "keywords": "Property AcceptCharset Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptCharset Gets the value of the HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. public string? AcceptCharset { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptEncoding.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptEncoding.html",
    "title": "Property AcceptEncoding | Sisk",
    "keywords": "Property AcceptEncoding Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptEncoding Gets the value of the HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. public string? AcceptEncoding { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptLanguage.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptLanguage.html",
    "title": "Property AcceptLanguage | Sisk",
    "keywords": "Property AcceptLanguage Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptLanguage Gets the value of the HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. public string? AcceptLanguage { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptPatch.html",
    "title": "Property AcceptPatch | Sisk",
    "keywords": "Property AcceptPatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptPatch Gets the value of the HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. public string? AcceptPatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptRanges.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AcceptRanges.html",
    "title": "Property AcceptRanges | Sisk",
    "keywords": "Property AcceptRanges Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AcceptRanges Gets or sets the value of the HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. public string? AcceptRanges { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowCredentials.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowCredentials.html",
    "title": "Property AccessControlAllowCredentials | Sisk",
    "keywords": "Property AccessControlAllowCredentials Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowCredentials Gets or sets the value of the HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. public string? AccessControlAllowCredentials { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowHeaders.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowHeaders.html",
    "title": "Property AccessControlAllowHeaders | Sisk",
    "keywords": "Property AccessControlAllowHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowHeaders Gets or sets the value of the HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. public string? AccessControlAllowHeaders { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowMethods.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowMethods.html",
    "title": "Property AccessControlAllowMethods | Sisk",
    "keywords": "Property AccessControlAllowMethods Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowMethods Gets or sets the value of the HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. public string? AccessControlAllowMethods { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowOrigin.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlAllowOrigin.html",
    "title": "Property AccessControlAllowOrigin | Sisk",
    "keywords": "Property AccessControlAllowOrigin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlAllowOrigin Gets or sets the value of the HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. public string? AccessControlAllowOrigin { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlExposeHeaders.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlExposeHeaders.html",
    "title": "Property AccessControlExposeHeaders | Sisk",
    "keywords": "Property AccessControlExposeHeaders Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlExposeHeaders Gets or sets the value of the HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. public string? AccessControlExposeHeaders { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlMaxAge.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.AccessControlMaxAge.html",
    "title": "Property AccessControlMaxAge | Sisk",
    "keywords": "Property AccessControlMaxAge Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AccessControlMaxAge Gets or sets the value of the HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. public string? AccessControlMaxAge { get; set; } Property Value string Remarks Note: this header can be overwritten by the current CrossOriginResourceSharingHeaders configuration."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Age.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Age.html",
    "title": "Property Age | Sisk",
    "keywords": "Property Age Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Age Gets or sets the value of the HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. public string? Age { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Allow.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Allow.html",
    "title": "Property Allow | Sisk",
    "keywords": "Property Allow Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Allow Gets or sets the value of the HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. public string? Allow { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Authorization.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Authorization.html",
    "title": "Property Authorization | Sisk",
    "keywords": "Property Authorization Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Authorization Gets or sets the value of the HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. public string? Authorization { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.CacheControl.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.CacheControl.html",
    "title": "Property CacheControl | Sisk",
    "keywords": "Property CacheControl Namespace Sisk.Core.Entity Assembly Sisk.Core.dll CacheControl Gets or sets the value of the HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. public string? CacheControl { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Connection.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Connection.html",
    "title": "Property Connection | Sisk",
    "keywords": "Property Connection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Connection Gets the value of the HTTP Connection header. To set this header in a HTTP response, use the KeepAlive property. public string? Connection { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentDisposition.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentDisposition.html",
    "title": "Property ContentDisposition | Sisk",
    "keywords": "Property ContentDisposition Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentDisposition Gets or sets the value of the HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. public string? ContentDisposition { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentEncoding.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentEncoding.html",
    "title": "Property ContentEncoding | Sisk",
    "keywords": "Property ContentEncoding Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentEncoding Gets or sets the value of the HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. This header should not be interpreted as the content text charset. public string? ContentEncoding { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLanguage.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLanguage.html",
    "title": "Property ContentLanguage | Sisk",
    "keywords": "Property ContentLanguage Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLanguage Gets or sets the value of the HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. public string? ContentLanguage { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLocation.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentLocation.html",
    "title": "Property ContentLocation | Sisk",
    "keywords": "Property ContentLocation Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLocation Gets or sets the value of the HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public string? ContentLocation { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentMD5.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentMD5.html",
    "title": "Property ContentMD5 | Sisk",
    "keywords": "Property ContentMD5 Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentMD5 Gets or sets the value of the HTTP Content-MD5 header. Contains the MD5 hash of the response body in an base-64 format, allowing clients to verify the integrity of the received data. public string? ContentMD5 { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentRange.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentRange.html",
    "title": "Property ContentRange | Sisk",
    "keywords": "Property ContentRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentRange Gets or sets the value of the HTTP Content-Range header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. public string? ContentRange { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentSecurityPolicy.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentSecurityPolicy.html",
    "title": "Property ContentSecurityPolicy | Sisk",
    "keywords": "Property ContentSecurityPolicy Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentSecurityPolicy Gets or sets the value of the HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. public string? ContentSecurityPolicy { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ContentType.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ContentType.html",
    "title": "Property ContentType | Sisk",
    "keywords": "Property ContentType Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentType Gets or sets the value of the HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. public string? ContentType { get; set; } Property Value string Remarks Note: setting the value of this header, the value present in the response's HttpContent will be overwritten."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Cookie.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Cookie.html",
    "title": "Property Cookie | Sisk",
    "keywords": "Property Cookie Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Cookie Gets the value of the HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. public string? Cookie { get; } Property Value string Remarks Tip: use Cookies property to getting cookies values from requests and SetCookie(string, string) on HttpResponse to set cookies."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ETag.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ETag.html",
    "title": "Property ETag | Sisk",
    "keywords": "Property ETag Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ETag Gets or sets the value of the HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. public string? ETag { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Expect.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Expect.html",
    "title": "Property Expect | Sisk",
    "keywords": "Property Expect Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Expect Gets the value of the HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. public string? Expect { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Expires.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Expires.html",
    "title": "Property Expires | Sisk",
    "keywords": "Property Expires Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Expires Gets or sets the value of the HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. public string? Expires { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Host.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Host Gets the value of the HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. public string? Host { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfMatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfMatch.html",
    "title": "Property IfMatch | Sisk",
    "keywords": "Property IfMatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfMatch Gets the value of the HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. public string? IfMatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfModifiedSince.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfModifiedSince.html",
    "title": "Property IfModifiedSince | Sisk",
    "keywords": "Property IfModifiedSince Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfModifiedSince Gets the value of the HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public string? IfModifiedSince { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfNoneMatch.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfNoneMatch.html",
    "title": "Property IfNoneMatch | Sisk",
    "keywords": "Property IfNoneMatch Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfNoneMatch Gets the value of the HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public string? IfNoneMatch { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfRange.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfRange.html",
    "title": "Property IfRange | Sisk",
    "keywords": "Property IfRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfRange Gets the value of the HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. public string? IfRange { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.IfUnmodifiedSince.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.IfUnmodifiedSince.html",
    "title": "Property IfUnmodifiedSince | Sisk",
    "keywords": "Property IfUnmodifiedSince Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IfUnmodifiedSince Gets the value of the HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. public string? IfUnmodifiedSince { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Location.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Location.html",
    "title": "Property Location | Sisk",
    "keywords": "Property Location Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Location Gets or sets the value of the HTTP Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public string? Location { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.MaxForwards.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.MaxForwards.html",
    "title": "Property MaxForwards | Sisk",
    "keywords": "Property MaxForwards Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaxForwards Gets or sets the value of the HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. public string? MaxForwards { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Origin.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Origin.html",
    "title": "Property Origin | Sisk",
    "keywords": "Property Origin Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Origin Gets the value of the HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. public string? Origin { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Pragma.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Pragma.html",
    "title": "Property Pragma | Sisk",
    "keywords": "Property Pragma Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Pragma Gets or sets the value of the HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. public string? Pragma { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthenticate.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthenticate.html",
    "title": "Property ProxyAuthenticate | Sisk",
    "keywords": "Property ProxyAuthenticate Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ProxyAuthenticate Gets or sets the value of the HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. public string? ProxyAuthenticate { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthorization.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.ProxyAuthorization.html",
    "title": "Property ProxyAuthorization | Sisk",
    "keywords": "Property ProxyAuthorization Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ProxyAuthorization Gets or sets the value of the HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. public string? ProxyAuthorization { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Range.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Range.html",
    "title": "Property Range | Sisk",
    "keywords": "Property Range Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Range Gets the value of the HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. public string? Range { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Referer.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Referer.html",
    "title": "Property Referer | Sisk",
    "keywords": "Property Referer Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Referer Gets the value of the HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. public string? Referer { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.RetryAfter.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.RetryAfter.html",
    "title": "Property RetryAfter | Sisk",
    "keywords": "Property RetryAfter Namespace Sisk.Core.Entity Assembly Sisk.Core.dll RetryAfter Gets or sets the value of the HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. public string? RetryAfter { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.SetCookie.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.SetCookie.html",
    "title": "Property SetCookie | Sisk",
    "keywords": "Property SetCookie Namespace Sisk.Core.Entity Assembly Sisk.Core.dll SetCookie Gets or sets the value of the HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. public string? SetCookie { get; set; } Property Value string Remarks Note: setting this property, it will override all previous Set-Cookie headers. Use the Add(string, string) method to add more than one Set-Cookie header or use the SetCookie(string, string) method."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.TE.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.TE.html",
    "title": "Property TE | Sisk",
    "keywords": "Property TE Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TE Gets the value of the HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. public string? TE { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.UserAgent.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.UserAgent.html",
    "title": "Property UserAgent | Sisk",
    "keywords": "Property UserAgent Namespace Sisk.Core.Entity Assembly Sisk.Core.dll UserAgent Gets the value of the HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. public string? UserAgent { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Vary.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Vary.html",
    "title": "Property Vary | Sisk",
    "keywords": "Property Vary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Vary Gets or sets the value of the HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. public string? Vary { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.Via.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.Via.html",
    "title": "Property Via | Sisk",
    "keywords": "Property Via Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Via Gets or sets the value of the HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. public string? Via { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.WWWAuthenticate.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.WWWAuthenticate.html",
    "title": "Property WWWAuthenticate | Sisk",
    "keywords": "Property WWWAuthenticate Namespace Sisk.Core.Entity Assembly Sisk.Core.dll WWWAuthenticate Gets or sets the value of the HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. public string? WWWAuthenticate { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedFor.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedFor.html",
    "title": "Property XForwardedFor | Sisk",
    "keywords": "Property XForwardedFor Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XForwardedFor Gets the value of the HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. public string? XForwardedFor { get; } Property Value string Remarks Tip: use the ForwardingResolver property to obtain the user client proxied IP throught RemoteAddress."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedHost.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XForwardedHost.html",
    "title": "Property XForwardedHost | Sisk",
    "keywords": "Property XForwardedHost Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XForwardedHost Gets the value of the HTTP X-Forwarded-Host header Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. public string? XForwardedHost { get; } Property Value string Remarks Tip: use the ForwardingResolver property to obtain the client requested host throught Host."
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XFrameOptions.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XFrameOptions.html",
    "title": "Property XFrameOptions | Sisk",
    "keywords": "Property XFrameOptions Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XFrameOptions Gets or sets the value of the HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. public string? XFrameOptions { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.XUACompatible.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.XUACompatible.html",
    "title": "Property XUACompatible | Sisk",
    "keywords": "Property XUACompatible Namespace Sisk.Core.Entity Assembly Sisk.Core.dll XUACompatible Gets or sets the value of the HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions. public string? XUACompatible { get; set; } Property Value string"
  },
  "api/Sisk.Core.Entity.HttpHeaderCollection.html": {
    "href": "api/Sisk.Core.Entity.HttpHeaderCollection.html",
    "title": "Class HttpHeaderCollection | Sisk",
    "keywords": "Class HttpHeaderCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an collection of HTTP headers with their name and values. public sealed class HttpHeaderCollection : StringKeyStore, IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStore HttpHeaderCollection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members StringKeyStore.FromQueryString(string) StringKeyStore.FromCookieString(string) StringKeyStore.FromNameValueCollection(NameValueCollection) StringKeyStore.ImportNameValueCollection(NameValueCollection) StringKeyStore.ImportQueryString(string) StringKeyStore.ImportCookieString(string) StringKeyStore.Add(string, string[]) StringKeyStore.Add(string, IEnumerable<string>) StringKeyStore.Add(string, string) StringKeyStore.Add(KeyValuePair<string, string[]>) StringKeyStore.AddRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStore.AddRange(IEnumerable<KeyValuePair<string, string>>) StringKeyStore.SetRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStore.Set(KeyValuePair<string, string[]>) StringKeyStore.Set(string, string) StringKeyStore.Set(string, IEnumerable<string>) StringKeyStore.GetValue(string) StringKeyStore.GetValues(string) StringKeyStore.Clear() StringKeyStore.Remove(string) StringKeyStore.MakeReadOnly() StringKeyStore.ContainsKey(string) StringKeyStore.GetEnumerator() StringKeyStore.TryGetValue(string, out string[]) StringKeyStore.AsDictionary() StringKeyStore.AsNameValueCollection() StringKeyStore.AsStringValueCollection() StringKeyStore.ToString() StringKeyStore.Comparer StringKeyStore.this[string] StringKeyStore.Keys StringKeyStore.Values StringKeyStore.Count StringKeyStore.IsReadOnly object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpHeaderCollection() Create an new instance of the HttpHeaderCollection class. HttpHeaderCollection(IDictionary<string, string[]>) Create an new instance of the HttpHeaderCollection class with values from another collection. HttpHeaderCollection(IDictionary<string, string?>) Create an new instance of the HttpHeaderCollection class with values from another collection. HttpHeaderCollection(WebHeaderCollection) Create an new instance of the HttpHeaderCollection class with values from another collection. Properties Accept Gets the value of the HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. AcceptCharset Gets the value of the HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. AcceptEncoding Gets the value of the HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. AcceptLanguage Gets the value of the HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. AcceptPatch Gets the value of the HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. AcceptRanges Gets or sets the value of the HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. AccessControlAllowCredentials Gets or sets the value of the HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. AccessControlAllowHeaders Gets or sets the value of the HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. AccessControlAllowMethods Gets or sets the value of the HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. AccessControlAllowOrigin Gets or sets the value of the HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. AccessControlExposeHeaders Gets or sets the value of the HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. AccessControlMaxAge Gets or sets the value of the HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. Age Gets or sets the value of the HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. Allow Gets or sets the value of the HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. Authorization Gets or sets the value of the HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. CacheControl Gets or sets the value of the HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. Connection Gets the value of the HTTP Connection header. To set this header in a HTTP response, use the KeepAlive property. ContentDisposition Gets or sets the value of the HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. ContentEncoding Gets or sets the value of the HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. This header should not be interpreted as the content text charset. ContentLanguage Gets or sets the value of the HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. ContentLocation Gets or sets the value of the HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. ContentMD5 Gets or sets the value of the HTTP Content-MD5 header. Contains the MD5 hash of the response body in an base-64 format, allowing clients to verify the integrity of the received data. ContentRange Gets or sets the value of the HTTP Content-Range header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. ContentSecurityPolicy Gets or sets the value of the HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. ContentType Gets or sets the value of the HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. Cookie Gets the value of the HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. ETag Gets or sets the value of the HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. Expect Gets the value of the HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. Expires Gets or sets the value of the HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. Host Gets the value of the HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. IfMatch Gets the value of the HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. IfModifiedSince Gets the value of the HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfNoneMatch Gets the value of the HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfRange Gets the value of the HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. IfUnmodifiedSince Gets the value of the HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. Location Gets or sets the value of the HTTP Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. MaxForwards Gets or sets the value of the HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. Origin Gets the value of the HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. Pragma Gets or sets the value of the HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. ProxyAuthenticate Gets or sets the value of the HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. ProxyAuthorization Gets or sets the value of the HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. Range Gets the value of the HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. Referer Gets the value of the HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. RetryAfter Gets or sets the value of the HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. SetCookie Gets or sets the value of the HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. TE Gets the value of the HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. UserAgent Gets the value of the HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. Vary Gets or sets the value of the HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. Via Gets or sets the value of the HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. WWWAuthenticate Gets or sets the value of the HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. XForwardedFor Gets the value of the HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. XForwardedHost Gets the value of the HTTP X-Forwarded-Host header Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. XFrameOptions Gets or sets the value of the HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. XUACompatible Gets or sets the value of the HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.ContainsKey.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContainsKey(string) public bool ContainsKey(string key) Parameters key string Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Count.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetEnumerator.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<MultipartObject> GetEnumerator() Returns IEnumerator<MultipartObject>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetItem.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetItem.html",
    "title": "Method GetItem | Sisk",
    "keywords": "Method GetItem Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItem(string) Gets the last form item by their name. This search is case-insensitive. public MultipartObject? GetItem(string name) Parameters name string The form item name. Returns MultipartObject"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetItems.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetItems.html",
    "title": "Method GetItems | Sisk",
    "keywords": "Method GetItems Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItems(string) Gets all form items that shares the specified name. This search is case-insensitive. public MultipartObject[] GetItems(string name) Parameters name string The form item name. Returns MultipartObject[] An array of MultipartObject with the specified name."
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.GetStringValue.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.GetStringValue.html",
    "title": "Method GetStringValue | Sisk",
    "keywords": "Method GetStringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetStringValue(string) Gets an StringValue object from the form item content string. This method reads the contents of the last matched last item with the request encoding. public StringValue GetStringValue(string name) Parameters name string The form item name. Returns StringValue"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Keys.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Keys public IEnumerable<string> Keys { get; } Property Value IEnumerable<string>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.ToArray.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.ToArray.html",
    "title": "Method ToArray | Sisk",
    "keywords": "Method ToArray Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ToArray() Creates an array with the MultipartObject in this collection. public MultipartObject[] ToArray() Returns MultipartObject[]"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out MultipartObject) public bool TryGetValue(string key, out MultipartObject value) Parameters key string value MultipartObject Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.Values.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Values public IEnumerable<MultipartObject> Values { get; } Property Value IEnumerable<MultipartObject>"
  },
  "api/Sisk.Core.Entity.MultipartFormCollection.html": {
    "href": "api/Sisk.Core.Entity.MultipartFormCollection.html",
    "title": "Class MultipartFormCollection | Sisk",
    "keywords": "Class MultipartFormCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an class which hosts an multipart form data contents. public sealed class MultipartFormCollection : IReadOnlyList<MultipartObject>, IReadOnlyCollection<MultipartObject>, IEnumerable<MultipartObject>, IReadOnlyDictionary<string, MultipartObject>, IReadOnlyCollection<KeyValuePair<string, MultipartObject>>, IEnumerable<KeyValuePair<string, MultipartObject>>, IEnumerable Inheritance object MultipartFormCollection Implements IReadOnlyList<MultipartObject> IReadOnlyCollection<MultipartObject> IEnumerable<MultipartObject> IReadOnlyDictionary<string, MultipartObject> IReadOnlyCollection<KeyValuePair<string, MultipartObject>> IEnumerable<KeyValuePair<string, MultipartObject>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Count Keys Values Methods ContainsKey(string) GetEnumerator() GetItem(string) Gets the last form item by their name. This search is case-insensitive. GetItems(string) Gets all form items that shares the specified name. This search is case-insensitive. GetStringValue(string) Gets an StringValue object from the form item content string. This method reads the contents of the last matched last item with the request encoding. ToArray() Creates an array with the MultipartObject in this collection. TryGetValue(string, out MultipartObject)"
  },
  "api/Sisk.Core.Entity.MultipartObject.ContentBytes.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ContentBytes.html",
    "title": "Property ContentBytes | Sisk",
    "keywords": "Property ContentBytes Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentBytes Gets this MultipartObject form data content in bytes. public byte[] ContentBytes { get; } Property Value byte[]"
  },
  "api/Sisk.Core.Entity.MultipartObject.ContentLength.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ContentLength.html",
    "title": "Property ContentLength | Sisk",
    "keywords": "Property ContentLength Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContentLength Gets this MultipartObject form data content length in byte count. public int ContentLength { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.MultipartObject.Equals.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool Equals(MultipartObject?) public bool Equals(MultipartObject? other) Parameters other MultipartObject Returns bool"
  },
  "api/Sisk.Core.Entity.MultipartObject.Filename.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Filename.html",
    "title": "Property Filename | Sisk",
    "keywords": "Property Filename Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Filename Gets this MultipartObject provided file name. If this object ins't disposing a file, nothing is returned. public string? Filename { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.MultipartObject.GetCommonFileFormat.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.GetCommonFileFormat.html",
    "title": "Method GetCommonFileFormat | Sisk",
    "keywords": "Method GetCommonFileFormat Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetCommonFileFormat() Determines the image format based in the file header for each image content type. public MultipartObjectCommonFormat GetCommonFileFormat() Returns MultipartObjectCommonFormat"
  },
  "api/Sisk.Core.Entity.MultipartObject.GetHashCode.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Entity.MultipartObject.HasContents.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.HasContents.html",
    "title": "Property HasContents | Sisk",
    "keywords": "Property HasContents Namespace Sisk.Core.Entity Assembly Sisk.Core.dll HasContents Gets an booolean indicating if this MultipartObject has contents or not. public bool HasContents { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.MultipartObject.Headers.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Headers Gets this MultipartObject headers. public HttpHeaderCollection Headers { get; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Entity.MultipartObject.Name.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Name Gets this MultipartObject field name. public string Name { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.MultipartObject.ReadContentAsString.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.ReadContentAsString.html",
    "title": "Method ReadContentAsString | Sisk",
    "keywords": "Method ReadContentAsString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ReadContentAsString(Encoding) Reads the content bytes with the given encoder. public string ReadContentAsString(Encoding encoder) Parameters encoder Encoding Returns string ReadContentAsString() Reads the content bytes using the HTTP request content-encoding. public string ReadContentAsString() Returns string"
  },
  "api/Sisk.Core.Entity.MultipartObject.html": {
    "href": "api/Sisk.Core.Entity.MultipartObject.html",
    "title": "Class MultipartObject | Sisk",
    "keywords": "Class MultipartObject Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an multipart/form-data object. public sealed class MultipartObject : IEquatable<MultipartObject> Inheritance object MultipartObject Implements IEquatable<MultipartObject> Inherited Members object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Properties ContentBytes Gets this MultipartObject form data content in bytes. ContentLength Gets this MultipartObject form data content length in byte count. Filename Gets this MultipartObject provided file name. If this object ins't disposing a file, nothing is returned. HasContents Gets an booolean indicating if this MultipartObject has contents or not. Headers Gets this MultipartObject headers. Name Gets this MultipartObject field name. Methods Equals(MultipartObject?) Equals(object?) GetCommonFileFormat() Determines the image format based in the file header for each image content type. GetHashCode() ReadContentAsString() Reads the content bytes using the HTTP request content-encoding. ReadContentAsString(Encoding) Reads the content bytes with the given encoder."
  },
  "api/Sisk.Core.Entity.MultipartObjectCommonFormat.html": {
    "href": "api/Sisk.Core.Entity.MultipartObjectCommonFormat.html",
    "title": "Enum MultipartObjectCommonFormat | Sisk",
    "keywords": "Enum MultipartObjectCommonFormat Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an image format for Multipart objects. public enum MultipartObjectCommonFormat Fields BMP = 104 Represents an bitmap image. GIF = 101 Represents an GIF image. JPEG = 100 Represents an JPEG/JPG image. PDF = 200 Represents an PDF file. PNG = 102 Represents an PNG image. TIFF = 103 Represents an TIFF image. Unknown = 0 Represents that the object is not a recognized image. WEBP = 105 Represents an WebP image."
  },
  "api/Sisk.Core.Entity.StringKeyStore.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.-ctor.html",
    "title": "Constructor StringKeyStore | Sisk",
    "keywords": "Constructor StringKeyStore Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringKeyStore() Initializes a new instance of the StringKeyStore class, public StringKeyStore() StringKeyStore(IEqualityComparer<string>) Initializes a new instance of the StringKeyStore class with a specified comparer. public StringKeyStore(IEqualityComparer<string> comparer) Parameters comparer IEqualityComparer<string> The comparer used for key equality. StringKeyStore(IEqualityComparer<string>, IDictionary<string, string[]>?) Initializes a new instance of the StringKeyStore class, public StringKeyStore(IEqualityComparer<string> comparer, IDictionary<string, string[]>? items) Parameters comparer IEqualityComparer<string> The comparer used for key equality. items IDictionary<string, string[]> The inner collection to add to this instance."
  },
  "api/Sisk.Core.Entity.StringKeyStore.Add.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Add(string, string[]) Adds an array of values associated with the specified key. public void Add(string key, string[] value) Parameters key string The key to which the values will be added. value string[] The array of values to associate with the key. Add(string, IEnumerable<string>) Adds a collection of values associated with the specified key. public void Add(string key, IEnumerable<string> value) Parameters key string The key to which the values will be added. value IEnumerable<string> The collection of values to associate with the key. Add(string, string) Adds a single value associated with the specified key. public void Add(string key, string value) Parameters key string The key to which the value will be added. value string The value to associate with the key. Add(KeyValuePair<string, string[]>) Adds a key-value pair to the StringKeyStore. public void Add(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> The key-value pair to add, where the key is associated with an array of values."
  },
  "api/Sisk.Core.Entity.StringKeyStore.AddRange.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.AddRange.html",
    "title": "Method AddRange | Sisk",
    "keywords": "Method AddRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AddRange(IEnumerable<KeyValuePair<string, string[]>>) Adds the elements of the specified collection to the end of this collection. public void AddRange(IEnumerable<KeyValuePair<string, string[]>> items) Parameters items IEnumerable<KeyValuePair<string, string[]>> The collection whose items should be added to the end of this collection. AddRange(IEnumerable<KeyValuePair<string, string?>>) Adds the elements of the specified collection to the end of this collection. public void AddRange(IEnumerable<KeyValuePair<string, string?>> items) Parameters items IEnumerable<KeyValuePair<string, string>> The collection whose items should be added to the end of this collection."
  },
  "api/Sisk.Core.Entity.StringKeyStore.AsDictionary.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.AsDictionary.html",
    "title": "Method AsDictionary | Sisk",
    "keywords": "Method AsDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsDictionary() Copies the contents of this StringKeyStore into an Dictionary<TKey, TValue>. public IDictionary<string, string[]> AsDictionary() Returns IDictionary<string, string[]>"
  },
  "api/Sisk.Core.Entity.StringKeyStore.AsNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.AsNameValueCollection.html",
    "title": "Method AsNameValueCollection | Sisk",
    "keywords": "Method AsNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsNameValueCollection() Copies the contents of this StringKeyStore into an NameValueCollection, with values separated with an comma (,). public NameValueCollection AsNameValueCollection() Returns NameValueCollection"
  },
  "api/Sisk.Core.Entity.StringKeyStore.AsStringValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.AsStringValueCollection.html",
    "title": "Method AsStringValueCollection | Sisk",
    "keywords": "Method AsStringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll AsStringValueCollection() Copies the contents of this StringKeyStore into an StringValueCollection. public StringValueCollection AsStringValueCollection() Returns StringValueCollection"
  },
  "api/Sisk.Core.Entity.StringKeyStore.Clear.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Clear() Removes all key-value pairs from the StringKeyStore. Throws an exception if the store is read-only. public void Clear()"
  },
  "api/Sisk.Core.Entity.StringKeyStore.Comparer.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Comparer.html",
    "title": "Property Comparer | Sisk",
    "keywords": "Property Comparer Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Comparer Gets the IEqualityComparer<T> used to compare keys in this StringKeyStore. public IEqualityComparer<string> Comparer { get; } Property Value IEqualityComparer<string>"
  },
  "api/Sisk.Core.Entity.StringKeyStore.ContainsKey.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ContainsKey(string) Determines whether the StringKeyStore contains a specific key. public bool ContainsKey(string key) Parameters key string The key to locate in the StringKeyStore. Returns bool true if the StringKeyStore contains an element with the specified key; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStore.Count.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Count Gets the number of key-value pairs in the StringKeyStore. public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Entity.StringKeyStore.FromCookieString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.FromCookieString.html",
    "title": "Method FromCookieString | Sisk",
    "keywords": "Method FromCookieString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromCookieString(string) Creates a new instance of the StringKeyStore from a cookie string. The query string should be in the format of \"key1=value1; key2=value2\". public static StringKeyStore FromCookieString(string queryString) Parameters queryString string The query string containing the key-value pairs to import. Returns StringKeyStore A new StringKeyStore populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStore.FromNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.FromNameValueCollection.html",
    "title": "Method FromNameValueCollection | Sisk",
    "keywords": "Method FromNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromNameValueCollection(NameValueCollection) Creates a new instance of the StringKeyStore from a NameValueCollection. public static StringKeyStore FromNameValueCollection(NameValueCollection collection) Parameters collection NameValueCollection The NameValueCollection containing the key-value pairs to import. Returns StringKeyStore A new StringKeyStore populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStore.FromQueryString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.FromQueryString.html",
    "title": "Method FromQueryString | Sisk",
    "keywords": "Method FromQueryString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll FromQueryString(string) Creates a new instance of the StringKeyStore from a query string. The query string should be in the format of \"key1=value1&key2=value2\". public static StringKeyStore FromQueryString(string queryString) Parameters queryString string The query string containing the key-value pairs to import. Returns StringKeyStore A new StringKeyStore populated with the key-value pairs from the query string."
  },
  "api/Sisk.Core.Entity.StringKeyStore.GetEnumerator.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnumerator() public IEnumerator<KeyValuePair<string, string[]>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, string[]>>"
  },
  "api/Sisk.Core.Entity.StringKeyStore.GetValue.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.GetValue.html",
    "title": "Method GetValue | Sisk",
    "keywords": "Method GetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetValue(string) Retrieves the last value associated with the specified key. Returns null if the key does not exist. public string? GetValue(string name) Parameters name string The key for which to retrieve the value. Returns string The last value associated with the specified key, or null if the key is not found."
  },
  "api/Sisk.Core.Entity.StringKeyStore.GetValues.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.GetValues.html",
    "title": "Method GetValues | Sisk",
    "keywords": "Method GetValues Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetValues(string) Retrieves all values associated with the specified key. Returns an empty array if the key does not exist. public string[] GetValues(string name) Parameters name string The key for which to retrieve the values. Returns string[] An array of values associated with the specified key, or an empty array if the key is not found."
  },
  "api/Sisk.Core.Entity.StringKeyStore.ImportCookieString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.ImportCookieString.html",
    "title": "Method ImportCookieString | Sisk",
    "keywords": "Method ImportCookieString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportCookieString(string) Imports key-value pairs from a cookie string into the StringKeyStore. The query string should be in the format of \"key1=value1; key2=value2\". public void ImportCookieString(string queryString) Parameters queryString string The query string containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStore.ImportNameValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.ImportNameValueCollection.html",
    "title": "Method ImportNameValueCollection | Sisk",
    "keywords": "Method ImportNameValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportNameValueCollection(NameValueCollection) Imports key-value pairs from a NameValueCollection into the StringKeyStore. Each key can have multiple associated values. public void ImportNameValueCollection(NameValueCollection items) Parameters items NameValueCollection The NameValueCollection containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStore.ImportQueryString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.ImportQueryString.html",
    "title": "Method ImportQueryString | Sisk",
    "keywords": "Method ImportQueryString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ImportQueryString(string) Imports key-value pairs from a query string into the StringKeyStore. The query string should be in the format of \"key1=value1&key2=value2\". public void ImportQueryString(string queryString) Parameters queryString string The query string containing the key-value pairs to import."
  },
  "api/Sisk.Core.Entity.StringKeyStore.IsReadOnly.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsReadOnly Gets a value indicating whether the StringKeyStore is read-only. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringKeyStore.Item.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Entity Assembly Sisk.Core.dll this[string] Gets or sets the array of values associated with the specified key. Returns null if the key does not exist in the store. public string? this[string key] { get; set; } Parameters key string Property Value string"
  },
  "api/Sisk.Core.Entity.StringKeyStore.Keys.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Keys Gets the collection of keys in the StringKeyStore. public ICollection<string> Keys { get; } Property Value ICollection<string>"
  },
  "api/Sisk.Core.Entity.StringKeyStore.MakeReadOnly.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.MakeReadOnly.html",
    "title": "Method MakeReadOnly | Sisk",
    "keywords": "Method MakeReadOnly Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MakeReadOnly() Marks the StringKeyStore as read-only, preventing further modifications. public void MakeReadOnly()"
  },
  "api/Sisk.Core.Entity.StringKeyStore.Remove.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Remove(string) Removes the value associated with the specified key from the StringKeyStore. Throws an exception if the store is read-only. public bool Remove(string key) Parameters key string The key of the value to remove. Returns bool true if the key was successfully removed; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStore.Set.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Set.html",
    "title": "Method Set | Sisk",
    "keywords": "Method Set Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Set(KeyValuePair<string, string[]>) Sets the value associated with the specified key, replacing any existing values. public void Set(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> The key-value pair to add, where the key is associated with an array of values. Set(string, string) Sets the value associated with the specified key, replacing any existing values. public void Set(string key, string value) Parameters key string The key for which to set the value. value string The value to associate with the key. Set(string, IEnumerable<string>) Sets the collection of values associated with the specified key, replacing any existing values. public void Set(string key, IEnumerable<string> value) Parameters key string The key for which to set the values. value IEnumerable<string> The collection of values to associate with the key."
  },
  "api/Sisk.Core.Entity.StringKeyStore.SetRange.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.SetRange.html",
    "title": "Method SetRange | Sisk",
    "keywords": "Method SetRange Namespace Sisk.Core.Entity Assembly Sisk.Core.dll SetRange(IEnumerable<KeyValuePair<string, string[]>>) Sets the elements of the specified collection, replacing existing values. public void SetRange(IEnumerable<KeyValuePair<string, string[]>> items) Parameters items IEnumerable<KeyValuePair<string, string[]>> The collection whose items should be replaced or added to this collection."
  },
  "api/Sisk.Core.Entity.StringKeyStore.ToString.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll ToString() public override string ToString() Returns string"
  },
  "api/Sisk.Core.Entity.StringKeyStore.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out string[]) Tries to get the array of values associated with the specified key. public bool TryGetValue(string key, out string[] value) Parameters key string The key for which to retrieve the values. value string[] When this method returns, contains the array of values associated with the specified key, or an empty array if the key is not found. Returns bool true if the key was found and the values were retrieved; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringKeyStore.Values.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Values Gets the collection of values in the StringKeyStore as arrays. Each key may have multiple associated values. public ICollection<string[]> Values { get; } Property Value ICollection<string[]>"
  },
  "api/Sisk.Core.Entity.StringKeyStore.html": {
    "href": "api/Sisk.Core.Entity.StringKeyStore.html",
    "title": "Class StringKeyStore | Sisk",
    "keywords": "Class StringKeyStore Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents a collection of string keys associated with multiple string values. public class StringKeyStore : IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStore Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Derived HttpHeaderCollection StringValueCollection Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors StringKeyStore() Initializes a new instance of the StringKeyStore class, StringKeyStore(IEqualityComparer<string>) Initializes a new instance of the StringKeyStore class with a specified comparer. StringKeyStore(IEqualityComparer<string>, IDictionary<string, string[]>?) Initializes a new instance of the StringKeyStore class, Properties Comparer Gets the IEqualityComparer<T> used to compare keys in this StringKeyStore. Count Gets the number of key-value pairs in the StringKeyStore. IsReadOnly Gets a value indicating whether the StringKeyStore is read-only. this[string] Gets or sets the array of values associated with the specified key. Returns null if the key does not exist in the store. Keys Gets the collection of keys in the StringKeyStore. Values Gets the collection of values in the StringKeyStore as arrays. Each key may have multiple associated values. Methods Add(KeyValuePair<string, string[]>) Adds a key-value pair to the StringKeyStore. Add(string, IEnumerable<string>) Adds a collection of values associated with the specified key. Add(string, string) Adds a single value associated with the specified key. Add(string, string[]) Adds an array of values associated with the specified key. AddRange(IEnumerable<KeyValuePair<string, string[]>>) Adds the elements of the specified collection to the end of this collection. AddRange(IEnumerable<KeyValuePair<string, string?>>) Adds the elements of the specified collection to the end of this collection. AsDictionary() Copies the contents of this StringKeyStore into an Dictionary<TKey, TValue>. AsNameValueCollection() Copies the contents of this StringKeyStore into an NameValueCollection, with values separated with an comma (,). AsStringValueCollection() Copies the contents of this StringKeyStore into an StringValueCollection. Clear() Removes all key-value pairs from the StringKeyStore. Throws an exception if the store is read-only. ContainsKey(string) Determines whether the StringKeyStore contains a specific key. FromCookieString(string) Creates a new instance of the StringKeyStore from a cookie string. The query string should be in the format of \"key1=value1; key2=value2\". FromNameValueCollection(NameValueCollection) Creates a new instance of the StringKeyStore from a NameValueCollection. FromQueryString(string) Creates a new instance of the StringKeyStore from a query string. The query string should be in the format of \"key1=value1&key2=value2\". GetEnumerator() GetValue(string) Retrieves the last value associated with the specified key. Returns null if the key does not exist. GetValues(string) Retrieves all values associated with the specified key. Returns an empty array if the key does not exist. ImportCookieString(string) Imports key-value pairs from a cookie string into the StringKeyStore. The query string should be in the format of \"key1=value1; key2=value2\". ImportNameValueCollection(NameValueCollection) Imports key-value pairs from a NameValueCollection into the StringKeyStore. Each key can have multiple associated values. ImportQueryString(string) Imports key-value pairs from a query string into the StringKeyStore. The query string should be in the format of \"key1=value1&key2=value2\". MakeReadOnly() Marks the StringKeyStore as read-only, preventing further modifications. Remove(string) Removes the value associated with the specified key from the StringKeyStore. Throws an exception if the store is read-only. Set(KeyValuePair<string, string[]>) Sets the value associated with the specified key, replacing any existing values. Set(string, IEnumerable<string>) Sets the collection of values associated with the specified key, replacing any existing values. Set(string, string) Sets the value associated with the specified key, replacing any existing values. SetRange(IEnumerable<KeyValuePair<string, string[]>>) Sets the elements of the specified collection, replacing existing values. ToString() TryGetValue(string, out string[]) Tries to get the array of values associated with the specified key."
  },
  "api/Sisk.Core.Entity.StringValue.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringValue.-ctor.html",
    "title": "Constructor StringValue | Sisk",
    "keywords": "Constructor StringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringValue(string) Creates an new empty value of the StringValue with no predefined value. public StringValue(string name) Parameters name string The StringValue name. StringValue(string, string?) Creates an new value of the StringValue. public StringValue(string name, string? value) Parameters name string The StringValue name. value string The StringValue value."
  },
  "api/Sisk.Core.Entity.StringValue.Clone.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Clone.html",
    "title": "Method Clone | Sisk",
    "keywords": "Method Clone Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Clone() public object Clone() Returns object"
  },
  "api/Sisk.Core.Entity.StringValue.Create.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Create(string?) Creates an new StringValue from the specified string. public static StringValue Create(string? value) Parameters value string The string value. Returns StringValue"
  },
  "api/Sisk.Core.Entity.StringValue.Get.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Get<T>(IFormatProvider?) Gets an not null value from the specified T. public T Get<T>(IFormatProvider? fmtProvider = null) where T : IParsable<T> Parameters fmtProvider IFormatProvider Returns T Type Parameters T The type to convert the value to."
  },
  "api/Sisk.Core.Entity.StringValue.GetBoolean.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetBoolean.html",
    "title": "Method GetBoolean | Sisk",
    "keywords": "Method GetBoolean Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetBoolean() Gets a bool from this StringValue. public bool GetBoolean() Returns bool An non-null boolean value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetByte.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetByte.html",
    "title": "Method GetByte | Sisk",
    "keywords": "Method GetByte Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetByte() Gets a byte from this StringValue. public int GetByte() Returns int An non-null byte value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetChar.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetChar.html",
    "title": "Method GetChar | Sisk",
    "keywords": "Method GetChar Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetChar() Gets a char from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. public char GetChar() Returns char An non-null char value."
  },
  "api/Sisk.Core.Entity.StringValue.GetDateTime.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetDateTime.html",
    "title": "Method GetDateTime | Sisk",
    "keywords": "Method GetDateTime Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetDateTime(IFormatProvider?) Gets a DateTime from this StringValue. public DateTime GetDateTime(IFormatProvider? fmtProvider = null) Parameters fmtProvider IFormatProvider Optional. Specifies the culture-specific format information. Returns DateTime An non-null DateTime value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetDouble.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetDouble.html",
    "title": "Method GetDouble | Sisk",
    "keywords": "Method GetDouble Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetDouble(IFormatProvider?) Gets a double from this StringValue. public double GetDouble(IFormatProvider? fmtProvider = null) Parameters fmtProvider IFormatProvider Optional. Specifies the culture-specific format information. Returns double An non-null double value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetEnum.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetEnum.html",
    "title": "Method GetEnum | Sisk",
    "keywords": "Method GetEnum Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetEnum<TEnum>() Gets an Enum object representation from this StringValue, parsing the current string expression into an value of TEnum. This method will throw an NullReferenceException if the value stored in this instance is null. public TEnum GetEnum<TEnum>() where TEnum : struct, Enum Returns TEnum Type Parameters TEnum The Enum type."
  },
  "api/Sisk.Core.Entity.StringValue.GetGuid.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetGuid.html",
    "title": "Method GetGuid | Sisk",
    "keywords": "Method GetGuid Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetGuid() Gets a Guid from this StringValue. public Guid GetGuid() Returns Guid An non-null Guid value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetInteger.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetInteger.html",
    "title": "Method GetInteger | Sisk",
    "keywords": "Method GetInteger Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetInteger() Gets a int from this StringValue. public int GetInteger() Returns int An non-null Int32 value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetLong.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetLong.html",
    "title": "Method GetLong | Sisk",
    "keywords": "Method GetLong Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetLong() Gets a long from this StringValue. public long GetLong() Returns long An non-null long value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetShort.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetShort.html",
    "title": "Method GetShort | Sisk",
    "keywords": "Method GetShort Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetShort(IFormatProvider?) Gets a short from this StringValue. public short GetShort(IFormatProvider? fmtProvider = null) Parameters fmtProvider IFormatProvider Optional. Specifies the culture-specific format information. Returns short An non-null short value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetSingle.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetSingle.html",
    "title": "Method GetSingle | Sisk",
    "keywords": "Method GetSingle Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetSingle(IFormatProvider?) Gets a float from this StringValue. public double GetSingle(IFormatProvider? fmtProvider = null) Parameters fmtProvider IFormatProvider Optional. Specifies the culture-specific format information. Returns double An non-null double value. Exceptions NullReferenceException Thrown when the value stored in this instance is null. FormatException Thrown when the value stored in this instance is not parseable to the desired type."
  },
  "api/Sisk.Core.Entity.StringValue.GetString.html": {
    "href": "api/Sisk.Core.Entity.StringValue.GetString.html",
    "title": "Method GetString | Sisk",
    "keywords": "Method GetString Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetString() Gets a non-null string from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. public string GetString() Returns string An non-null string value. Exceptions NullReferenceException Thrown when the value stored in this instance is null."
  },
  "api/Sisk.Core.Entity.StringValue.IsNull.html": {
    "href": "api/Sisk.Core.Entity.StringValue.IsNull.html",
    "title": "Property IsNull | Sisk",
    "keywords": "Property IsNull Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsNull Gets an boolean indicating if this object value is null. public bool IsNull { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringValue.IsNullOrEmpty.html": {
    "href": "api/Sisk.Core.Entity.StringValue.IsNullOrEmpty.html",
    "title": "Property IsNullOrEmpty | Sisk",
    "keywords": "Property IsNullOrEmpty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsNullOrEmpty Gets an boolean indicating if this object value is null or an empty string. public bool IsNullOrEmpty { get; } Property Value bool"
  },
  "api/Sisk.Core.Entity.StringValue.MaybeNull.html": {
    "href": "api/Sisk.Core.Entity.StringValue.MaybeNull.html",
    "title": "Method MaybeNull | Sisk",
    "keywords": "Method MaybeNull Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaybeNull() Returns a self-reference to this object when it's value is not null. public StringValue? MaybeNull() Returns StringValue?"
  },
  "api/Sisk.Core.Entity.StringValue.MaybeNullOrEmpty.html": {
    "href": "api/Sisk.Core.Entity.StringValue.MaybeNullOrEmpty.html",
    "title": "Method MaybeNullOrEmpty | Sisk",
    "keywords": "Method MaybeNullOrEmpty Namespace Sisk.Core.Entity Assembly Sisk.Core.dll MaybeNullOrEmpty() Returns a self-reference to this object when it's value is not null or an empty string. public StringValue? MaybeNullOrEmpty() Returns StringValue?"
  },
  "api/Sisk.Core.Entity.StringValue.Name.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Name Gets the name of the property that hosts this StringValue. public string Name { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.StringValue.Value.html": {
    "href": "api/Sisk.Core.Entity.StringValue.Value.html",
    "title": "Property Value | Sisk",
    "keywords": "Property Value Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Value Gets the value of the current StringValue string if it has been assigned a valid underlying value. public string? Value { get; } Property Value string"
  },
  "api/Sisk.Core.Entity.StringValue.html": {
    "href": "api/Sisk.Core.Entity.StringValue.html",
    "title": "Struct StringValue | Sisk",
    "keywords": "Struct StringValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an option/monad item that wraps an string value and allows conversion to most common types. public readonly struct StringValue : ICloneable, IEquatable<StringValue>, IComparable<StringValue> Implements ICloneable IEquatable<StringValue> IComparable<StringValue> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors StringValue(string) Creates an new empty value of the StringValue with no predefined value. StringValue(string, string?) Creates an new value of the StringValue. Properties IsNull Gets an boolean indicating if this object value is null. IsNullOrEmpty Gets an boolean indicating if this object value is null or an empty string. Name Gets the name of the property that hosts this StringValue. Value Gets the value of the current StringValue string if it has been assigned a valid underlying value. Methods Clone() Create(string?) Creates an new StringValue from the specified string. GetBoolean() Gets a bool from this StringValue. GetByte() Gets a byte from this StringValue. GetChar() Gets a char from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. GetDateTime(IFormatProvider?) Gets a DateTime from this StringValue. GetDouble(IFormatProvider?) Gets a double from this StringValue. GetEnum<TEnum>() Gets an Enum object representation from this StringValue, parsing the current string expression into an value of TEnum. This method will throw an NullReferenceException if the value stored in this instance is null. GetGuid() Gets a Guid from this StringValue. GetInteger() Gets a int from this StringValue. GetLong() Gets a long from this StringValue. GetShort(IFormatProvider?) Gets a short from this StringValue. GetSingle(IFormatProvider?) Gets a float from this StringValue. GetString() Gets a non-null string from this StringValue. This method will throw an NullReferenceException if the value stored in this instance is null. Get<T>(IFormatProvider?) Gets an not null value from the specified T. MaybeNull() Returns a self-reference to this object when it's value is not null. MaybeNullOrEmpty() Returns a self-reference to this object when it's value is not null or an empty string."
  },
  "api/Sisk.Core.Entity.StringValueCollection.-ctor.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.-ctor.html",
    "title": "Constructor StringValueCollection | Sisk",
    "keywords": "Constructor StringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll StringValueCollection(IDictionary<string, string?>) Creates an new StringValueCollection instance with values from another IDictionary instance. public StringValueCollection(IDictionary<string, string?> values) Parameters values IDictionary<string, string> StringValueCollection(IDictionary<string, string[]>) Creates an new StringValueCollection instance with values from another IDictionary instance. public StringValueCollection(IDictionary<string, string[]> values) Parameters values IDictionary<string, string[]> StringValueCollection() Creates an new empty StringValueCollection. public StringValueCollection()"
  },
  "api/Sisk.Core.Entity.StringValueCollection.GetItem.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.GetItem.html",
    "title": "Method GetItem | Sisk",
    "keywords": "Method GetItem Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItem(string) Gets an StringValue from their key name. If the object was not found by their name, an empty non-null StringValue with no value is returned. public StringValue GetItem(string name) Parameters name string Returns StringValue"
  },
  "api/Sisk.Core.Entity.StringValueCollection.GetItems.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.GetItems.html",
    "title": "Method GetItems | Sisk",
    "keywords": "Method GetItems Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetItems(string) Gets an array of StringValue from their key name. If the object was not found by their name, an empty array of StringValue is returned. public StringValue[] GetItems(string name) Parameters name string Returns StringValue[]"
  },
  "api/Sisk.Core.Entity.StringValueCollection.Item.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Entity Assembly Sisk.Core.dll this[string] Gets or sets an StringValue item by their key name. public StringValue this[string name] { get; set; } Parameters name string Property Value StringValue"
  },
  "api/Sisk.Core.Entity.StringValueCollection.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue(string, out StringValue) Tries to get the last StringValue associated with the specified key. public bool TryGetValue(string key, out StringValue value) Parameters key string The key for which to retrieve the values. value StringValue When this method returns, the StringValue containing the value, or empty StringValue. Returns bool true if the key was found; otherwise, false."
  },
  "api/Sisk.Core.Entity.StringValueCollection.html": {
    "href": "api/Sisk.Core.Entity.StringValueCollection.html",
    "title": "Class StringValueCollection | Sisk",
    "keywords": "Class StringValueCollection Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents an collection of StringValue. public sealed class StringValueCollection : StringKeyStore, IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object StringKeyStore StringValueCollection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members StringKeyStore.FromQueryString(string) StringKeyStore.FromCookieString(string) StringKeyStore.FromNameValueCollection(NameValueCollection) StringKeyStore.ImportNameValueCollection(NameValueCollection) StringKeyStore.ImportQueryString(string) StringKeyStore.ImportCookieString(string) StringKeyStore.Add(string, string[]) StringKeyStore.Add(string, IEnumerable<string>) StringKeyStore.Add(string, string) StringKeyStore.Add(KeyValuePair<string, string[]>) StringKeyStore.AddRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStore.AddRange(IEnumerable<KeyValuePair<string, string>>) StringKeyStore.SetRange(IEnumerable<KeyValuePair<string, string[]>>) StringKeyStore.Set(KeyValuePair<string, string[]>) StringKeyStore.Set(string, string) StringKeyStore.Set(string, IEnumerable<string>) StringKeyStore.GetValue(string) StringKeyStore.GetValues(string) StringKeyStore.Clear() StringKeyStore.Remove(string) StringKeyStore.MakeReadOnly() StringKeyStore.ContainsKey(string) StringKeyStore.GetEnumerator() StringKeyStore.TryGetValue(string, out string[]) StringKeyStore.AsDictionary() StringKeyStore.AsNameValueCollection() StringKeyStore.AsStringValueCollection() StringKeyStore.ToString() StringKeyStore.Comparer StringKeyStore.Keys StringKeyStore.Values StringKeyStore.Count StringKeyStore.IsReadOnly object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors StringValueCollection() Creates an new empty StringValueCollection. StringValueCollection(IDictionary<string, string[]>) Creates an new StringValueCollection instance with values from another IDictionary instance. StringValueCollection(IDictionary<string, string?>) Creates an new StringValueCollection instance with values from another IDictionary instance. Properties this[string] Gets or sets an StringValue item by their key name. Methods GetItem(string) Gets an StringValue from their key name. If the object was not found by their name, an empty non-null StringValue with no value is returned. GetItems(string) Gets an array of StringValue from their key name. If the object was not found by their name, an empty array of StringValue is returned. TryGetValue(string, out StringValue) Tries to get the last StringValue associated with the specified key."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.-ctor.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.-ctor.html",
    "title": "Constructor TypedValueDictionary | Sisk",
    "keywords": "Constructor TypedValueDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TypedValueDictionary() Creates an new TypedValueDictionary instance with default parameters. public TypedValueDictionary() TypedValueDictionary(StringComparer) Creates an new TypedValueDictionary instance with default parameters with the specified StringComparer. public TypedValueDictionary(StringComparer keyComparer) Parameters keyComparer StringComparer"
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Get.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Get<T>() Gets a singleton previously defined in this context bag via it's type T. public T Get<T>() where T : notnull Returns T Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAdd.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAdd.html",
    "title": "Method GetOrAdd | Sisk",
    "keywords": "Method GetOrAdd Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrAdd<T>(Func<T>) Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided getter function. public T GetOrAdd<T>(Func<T> getter) where T : notnull Parameters getter Func<T> A function that provides the object to be added if it does not exist. Returns T The object of type T from the context bag. Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAddAsync.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrAddAsync.html",
    "title": "Method GetOrAddAsync | Sisk",
    "keywords": "Method GetOrAddAsync Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrAddAsync<T>(Func<Task<T>>) Asynchronously gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided asynchronous getter function. public Task<T> GetOrAddAsync<T>(Func<Task<T>> getter) where T : notnull Parameters getter Func<Task<T>> An asynchronous function that provides the object to be added if it does not exist. Returns Task<T> A task that represents the asynchronous operation. The task result contains the object of type T from the context bag. Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetOrDefault.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetOrDefault.html",
    "title": "Method GetOrDefault | Sisk",
    "keywords": "Method GetOrDefault Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetOrDefault<T>() Gets a singleton previously defined in this context bag via its type T. Returns the default value if the object is not defined. public T? GetOrDefault<T>() where T : notnull Returns T The object of type T if it exists; otherwise, null. Type Parameters T The type of the object defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.GetTypeKeyName.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.GetTypeKeyName.html",
    "title": "Method GetTypeKeyName | Sisk",
    "keywords": "Method GetTypeKeyName Namespace Sisk.Core.Entity Assembly Sisk.Core.dll GetTypeKeyName(Type) Gets the Type full qualified key name. protected string GetTypeKeyName(Type t) Parameters t Type The type to get their qualified key name. Returns string"
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.IsSet.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.IsSet.html",
    "title": "Method IsSet | Sisk",
    "keywords": "Method IsSet Namespace Sisk.Core.Entity Assembly Sisk.Core.dll IsSet<T>() Determines whether the specified T singleton is defined in this context. public bool IsSet<T>() where T : notnull Returns bool Type Parameters T The singleton type. IsSet<T>(out T) Determines whether the specified T singleton is defined in this context and tries to output it. public bool IsSet<T>(out T value) where T : notnull Parameters value T When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized. Returns bool True if the object is find with the specified key; otherwise, false. Type Parameters T The singleton type."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Set.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Set.html",
    "title": "Method Set | Sisk",
    "keywords": "Method Set Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Set<T>() Creates and adds an singleton of T in this context bag. public T Set<T>() where T : notnull, new() Returns T Type Parameters T The object that will be defined in this context bag. Set<T>(T) Adds an singleton of T in this context bag. public T Set<T>(T value) where T : notnull Parameters value T The instance of T which will be defined in this context bag. Returns T Type Parameters T The object that will be defined in this context bag."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.TryGetValue.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.Core.Entity Assembly Sisk.Core.dll TryGetValue<TResult>(string, out TResult?) Gets the value associated with the specified key and casts it into TResult. public bool TryGetValue<TResult>(string key, out TResult? value) Parameters key string The key whose to get. value TResult When this method returns, the value associated with the specified key, if the key is found; otherwise, the default value for the type of the value parameter. This parameter is passed uninitialized. Returns bool true if the object is find with the specified key; otherwise, false. Type Parameters TResult The type which will be casted into."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.Unset.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.Unset.html",
    "title": "Method Unset | Sisk",
    "keywords": "Method Unset Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Unset<T>() Removes an singleton object from it's type T. public bool Unset<T>() where T : notnull Returns bool Type Parameters T The singleton type."
  },
  "api/Sisk.Core.Entity.TypedValueDictionary.html": {
    "href": "api/Sisk.Core.Entity.TypedValueDictionary.html",
    "title": "Class TypedValueDictionary | Sisk",
    "keywords": "Class TypedValueDictionary Namespace Sisk.Core.Entity Assembly Sisk.Core.dll Represents the base class for storing and retriving data by their type. public class TypedValueDictionary : IDictionary<string, object?>, ICollection<KeyValuePair<string, object?>>, IEnumerable<KeyValuePair<string, object?>>, IEnumerable Inheritance object TypedValueDictionary Implements IDictionary<string, object> ICollection<KeyValuePair<string, object>> IEnumerable<KeyValuePair<string, object>> IEnumerable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors TypedValueDictionary() Creates an new TypedValueDictionary instance with default parameters. TypedValueDictionary(StringComparer) Creates an new TypedValueDictionary instance with default parameters with the specified StringComparer. Methods GetOrAddAsync<T>(Func<Task<T>>) Asynchronously gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided asynchronous getter function. GetOrAdd<T>(Func<T>) Gets a singleton previously defined in this context bag via its type T. If it does not exist, it adds the object to the context bag using the provided getter function. GetOrDefault<T>() Gets a singleton previously defined in this context bag via its type T. Returns the default value if the object is not defined. GetTypeKeyName(Type) Gets the Type full qualified key name. Get<T>() Gets a singleton previously defined in this context bag via it's type T. IsSet<T>() Determines whether the specified T singleton is defined in this context. IsSet<T>(out T) Determines whether the specified T singleton is defined in this context and tries to output it. Set<T>() Creates and adds an singleton of T in this context bag. Set<T>(T) Adds an singleton of T in this context bag. TryGetValue<TResult>(string, out TResult?) Gets the value associated with the specified key and casts it into TResult. Unset<T>() Removes an singleton object from it's type T."
  },
  "api/Sisk.Core.Entity.html": {
    "href": "api/Sisk.Core.Entity.html",
    "title": "Namespace Sisk.Core.Entity | Sisk",
    "keywords": "Namespace Sisk.Core.Entity Classes CrossOriginResourceSharingHeaders Provides a class to provide Cross Origin response headers for when communicating with a browser. HttpHeaderCollection Represents an collection of HTTP headers with their name and values. MultipartFormCollection Represents an class which hosts an multipart form data contents. MultipartObject Represents an multipart/form-data object. StringKeyStore Represents a collection of string keys associated with multiple string values. StringValueCollection Represents an collection of StringValue. TypedValueDictionary Represents the base class for storing and retriving data by their type. Structs StringValue Represents an option/monad item that wraps an string value and allows conversion to most common types. Enums MultipartObjectCommonFormat Represents an image format for Multipart objects."
  },
  "api/Sisk.Core.Helpers.CookieHelper.BuildCookieHeaderValue.html": {
    "href": "api/Sisk.Core.Helpers.CookieHelper.BuildCookieHeaderValue.html",
    "title": "Method BuildCookieHeaderValue | Sisk",
    "keywords": "Method BuildCookieHeaderValue Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll BuildCookieHeaderValue(Cookie) Builds the cookie header value and returns an string from it. public static string BuildCookieHeaderValue(Cookie cookie) Parameters cookie Cookie The Cookie instance to build the cookie string. Returns string BuildCookieHeaderValue(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Builds the cookie header value and returns an string from it. public static string BuildCookieHeaderValue(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter. Returns string"
  },
  "api/Sisk.Core.Helpers.CookieHelper.html": {
    "href": "api/Sisk.Core.Helpers.CookieHelper.html",
    "title": "Class CookieHelper | Sisk",
    "keywords": "Class CookieHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides a class that contains useful methods for working with cookies in HTTP responses. public static class CookieHelper Inheritance object CookieHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods BuildCookieHeaderValue(Cookie) Builds the cookie header value and returns an string from it. BuildCookieHeaderValue(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Builds the cookie header value and returns an string from it."
  },
  "api/Sisk.Core.Helpers.HeaderHelper.CopyHttpHeaders.html": {
    "href": "api/Sisk.Core.Helpers.HeaderHelper.CopyHttpHeaders.html",
    "title": "Method CopyHttpHeaders | Sisk",
    "keywords": "Method CopyHttpHeaders Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll CopyHttpHeaders(HttpContentHeaders, HttpContentHeaders, bool) Copies HTTP headers from one HttpContentHeaders instance to another. public static void CopyHttpHeaders(HttpContentHeaders from, HttpContentHeaders to, bool safe = true) Parameters from HttpContentHeaders The source HttpContentHeaders instance. to HttpContentHeaders The target HttpContentHeaders instance. safe bool If set to true, headers that are added will be validated (an exception can be throw if an header is invalid). If false, invalid headers could be discarded, but no exception is thrown."
  },
  "api/Sisk.Core.Helpers.HeaderHelper.html": {
    "href": "api/Sisk.Core.Helpers.HeaderHelper.html",
    "title": "Class HeaderHelper | Sisk",
    "keywords": "Class HeaderHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides helper methods for working with HTTP headers. public static class HeaderHelper Inheritance object HeaderHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods CopyHttpHeaders(HttpContentHeaders, HttpContentHeaders, bool) Copies HTTP headers from one HttpContentHeaders instance to another."
  },
  "api/Sisk.Core.Helpers.MimeHelper.DefaultMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.DefaultMimeType.html",
    "title": "Property DefaultMimeType | Sisk",
    "keywords": "Property DefaultMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll DefaultMimeType Gets or sets the MimeHelper default fallback mime-type. public static string DefaultMimeType { get; set; } Property Value string Remarks This property is not used by the HTTP server itself, only this helper class."
  },
  "api/Sisk.Core.Helpers.MimeHelper.GetMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.GetMimeType.html",
    "title": "Method GetMimeType | Sisk",
    "keywords": "Method GetMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll GetMimeType(string, string?) Gets the content mime-type from the specified file extension. public static string GetMimeType(string fileExtension, string? fallback = null) Parameters fileExtension string The file extension, with or without the initial dot. fallback string Optional. The default mime-type when the file best mime-type is not found. If this argument is null, DefaultMimeType is used. Returns string The best matched mime-type, or the default if no mime-type was matched with the specified extension."
  },
  "api/Sisk.Core.Helpers.MimeHelper.IsBrowserKnownInlineMimeType.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.IsBrowserKnownInlineMimeType.html",
    "title": "Method IsBrowserKnownInlineMimeType | Sisk",
    "keywords": "Method IsBrowserKnownInlineMimeType Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll IsBrowserKnownInlineMimeType(string) Determines whether the specified mime-type is considered an inline content type that can be displayed directly in the browser. public static bool IsBrowserKnownInlineMimeType(string mimeType) Parameters mimeType string The mime-type to evaluate. Returns bool true if the content type is an inline content type; otherwise, false."
  },
  "api/Sisk.Core.Helpers.MimeHelper.IsPlainTextFile.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.IsPlainTextFile.html",
    "title": "Method IsPlainTextFile | Sisk",
    "keywords": "Method IsPlainTextFile Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll IsPlainTextFile(string) Gets an boolean indicating if the specified file is an well-known plain text file. public static bool IsPlainTextFile(string fileExtension) Parameters fileExtension string The file extension, with or without the initial dot. Returns bool"
  },
  "api/Sisk.Core.Helpers.MimeHelper.html": {
    "href": "api/Sisk.Core.Helpers.MimeHelper.html",
    "title": "Class MimeHelper | Sisk",
    "keywords": "Class MimeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful helper methods for resolving mime-types from common formats. public static class MimeHelper Inheritance object MimeHelper Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DefaultMimeType Gets or sets the MimeHelper default fallback mime-type. Methods GetMimeType(string, string?) Gets the content mime-type from the specified file extension. IsBrowserKnownInlineMimeType(string) Determines whether the specified mime-type is considered an inline content type that can be displayed directly in the browser. IsPlainTextFile(string) Gets an boolean indicating if the specified file is an well-known plain text file."
  },
  "api/Sisk.Core.Helpers.PathHelper.-ctor.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.-ctor.html",
    "title": "Constructor PathHelper | Sisk",
    "keywords": "Constructor PathHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll PathHelper() public PathHelper()"
  },
  "api/Sisk.Core.Helpers.PathHelper.CombinePaths.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.CombinePaths.html",
    "title": "Method CombinePaths | Sisk",
    "keywords": "Method CombinePaths Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll CombinePaths(params string[]) Combines the specified URL paths into one. public static string CombinePaths(params string[] paths) Parameters paths string[] The string array which contains parts that will be combined. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.FilesystemCombinePaths.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.FilesystemCombinePaths.html",
    "title": "Method FilesystemCombinePaths | Sisk",
    "keywords": "Method FilesystemCombinePaths Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll FilesystemCombinePaths(bool, char, params string[]) Normalizes and combines the specified file-system paths into one. public static string FilesystemCombinePaths(bool allowRelativeReturn, char separator, params string[] paths) Parameters allowRelativeReturn bool Specifies if relative paths should be merged and \"..\" returns should be respected. separator char Specifies the path separator character. paths string[] Specifies the array of paths to combine. Returns string FilesystemCombinePaths(bool, char, ReadOnlySpan<string>) Normalizes and combines the specified file-system paths into one. public static string FilesystemCombinePaths(bool allowRelativeReturn, char separator, ReadOnlySpan<string> paths) Parameters allowRelativeReturn bool Specifies if relative paths should be merged and \"..\" returns should be respected. separator char Specifies the path separator character. paths ReadOnlySpan<string> Specifies the array of paths to combine. Returns string FilesystemCombinePaths(params string[]) Normalizes and combines the specified file-system paths into one, using the default environment directory separator char. public static string FilesystemCombinePaths(params string[] paths) Parameters paths string[] Specifies the array of paths to combine. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.NormalizePath.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.NormalizePath.html",
    "title": "Method NormalizePath | Sisk",
    "keywords": "Method NormalizePath Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll NormalizePath(string, char) Normalize the given path to use the specified directory separator, trim the last separator and remove empty entries. public static string NormalizePath(string path, char directorySeparator = '/') Parameters path string The path to normalize. directorySeparator char The directory separator. Returns string"
  },
  "api/Sisk.Core.Helpers.PathHelper.html": {
    "href": "api/Sisk.Core.Helpers.PathHelper.html",
    "title": "Class PathHelper | Sisk",
    "keywords": "Class PathHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful path-dedicated helper members. public sealed class PathHelper Inheritance object PathHelper Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors PathHelper() Methods CombinePaths(params string[]) Combines the specified URL paths into one. FilesystemCombinePaths(bool, char, ReadOnlySpan<string>) Normalizes and combines the specified file-system paths into one. FilesystemCombinePaths(bool, char, params string[]) Normalizes and combines the specified file-system paths into one. FilesystemCombinePaths(params string[]) Normalizes and combines the specified file-system paths into one, using the default environment directory separator char. NormalizePath(string, char) Normalize the given path to use the specified directory separator, trim the last separator and remove empty entries."
  },
  "api/Sisk.Core.Helpers.SizeHelper.-ctor.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.-ctor.html",
    "title": "Constructor SizeHelper | Sisk",
    "keywords": "Constructor SizeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll SizeHelper() public SizeHelper()"
  },
  "api/Sisk.Core.Helpers.SizeHelper.HumanReadableSize.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.HumanReadableSize.html",
    "title": "Method HumanReadableSize | Sisk",
    "keywords": "Method HumanReadableSize Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll HumanReadableSize(long) Converts a byte count into a human-readable string representation. public static string HumanReadableSize(long byteCount) Parameters byteCount long The total number of bytes to convert. Returns string A string representing the byte count in a human-readable format. HumanReadableSize(double) Converts a byte count into a human-readable string representation. public static string HumanReadableSize(double byteCount) Parameters byteCount double The total number of bytes to convert. Returns string A string representing the byte count in a human-readable format."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitEb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitEb.html",
    "title": "Field UnitEb | Sisk",
    "keywords": "Field UnitEb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes. public const long UnitEb = 1152921504606846976 Returns long Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitGb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitGb.html",
    "title": "Field UnitGb | Sisk",
    "keywords": "Field UnitGb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes. public const long UnitGb = 1073741824 Returns long Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitKb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitKb.html",
    "title": "Field UnitKb | Sisk",
    "keywords": "Field UnitKb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes. public const long UnitKb = 1024 Returns long Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitMb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitMb.html",
    "title": "Field UnitMb | Sisk",
    "keywords": "Field UnitMb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes. public const long UnitMb = 1048576 Returns long Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitPb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitPb.html",
    "title": "Field UnitPb | Sisk",
    "keywords": "Field UnitPb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes. public const long UnitPb = 1125899906842624 Returns long Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.UnitTb.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.UnitTb.html",
    "title": "Field UnitTb | Sisk",
    "keywords": "Field UnitTb Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes. public const long UnitTb = 1099511627776 Returns long Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes."
  },
  "api/Sisk.Core.Helpers.SizeHelper.html": {
    "href": "api/Sisk.Core.Helpers.SizeHelper.html",
    "title": "Class SizeHelper | Sisk",
    "keywords": "Class SizeHelper Namespace Sisk.Core.Helpers Assembly Sisk.Core.dll Provides useful size-dedicated helper members. public sealed class SizeHelper Inheritance object SizeHelper Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SizeHelper() Fields UnitEb Represents the number of bytes in one exibibyte (EiB). This is calculated as 1024 pebibytes. UnitGb Represents the number of bytes in one gibibyte (GiB). This is calculated as 1024 mebibytes. UnitKb Represents the number of bytes in one kibibyte (KiB). This is calculated as 1024 bytes. UnitMb Represents the number of bytes in one mebibyte (MiB). This is calculated as 1024 kibibytes. UnitPb Represents the number of bytes in one pebibyte (PiB). This is calculated as 1024 tebibytes. UnitTb Represents the number of bytes in one tebibyte (TiB). This is calculated as 1024 gibibytes. Methods HumanReadableSize(double) Converts a byte count into a human-readable string representation. HumanReadableSize(long) Converts a byte count into a human-readable string representation."
  },
  "api/Sisk.Core.Helpers.html": {
    "href": "api/Sisk.Core.Helpers.html",
    "title": "Namespace Sisk.Core.Helpers | Sisk",
    "keywords": "Namespace Sisk.Core.Helpers Classes CookieHelper Provides a class that contains useful methods for working with cookies in HTTP responses. HeaderHelper Provides helper methods for working with HTTP headers. MimeHelper Provides useful helper methods for resolving mime-types from common formats. PathHelper Provides useful path-dedicated helper members. SizeHelper Provides useful size-dedicated helper members."
  },
  "api/Sisk.Core.Http.BrotliContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.-ctor.html",
    "title": "Constructor BrotliContent | Sisk",
    "keywords": "Constructor BrotliContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll BrotliContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public BrotliContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. BrotliContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public BrotliContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. BrotliContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public BrotliContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.BrotliContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.BrotliContent.Setup.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.BrotliContent.html": {
    "href": "api/Sisk.Core.Http.BrotliContent.html",
    "title": "Class BrotliContent | Sisk",
    "keywords": "Class BrotliContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the Brotli algorithm. public sealed class BrotliContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent BrotliContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.LoadIntoBufferAsync(CancellationToken) HttpContent.LoadIntoBufferAsync(long, CancellationToken) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors BrotliContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. BrotliContent(Stream) Initializes a new instance of compressing stream with the specified stream content. BrotliContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.CompressedContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.-ctor.html",
    "title": "Constructor CompressedContent | Sisk",
    "keywords": "Constructor CompressedContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll CompressedContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public CompressedContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. CompressedContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public CompressedContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. CompressedContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public CompressedContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.CompressedContent.Dispose.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose(bool) protected override void Dispose(bool disposing) Parameters disposing bool"
  },
  "api/Sisk.Core.Http.CompressedContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public abstract Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.CompressedContent.InnerContent.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.InnerContent.html",
    "title": "Property InnerContent | Sisk",
    "keywords": "Property InnerContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll InnerContent Gets the inner HTTP content. public HttpContent InnerContent { get; } Property Value HttpContent"
  },
  "api/Sisk.Core.Http.CompressedContent.SerializeToStream.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.SerializeToStream.html",
    "title": "Method SerializeToStream | Sisk",
    "keywords": "Method SerializeToStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll SerializeToStream(Stream, TransportContext?, CancellationToken) protected override sealed void SerializeToStream(Stream stream, TransportContext? context, CancellationToken cancellationToken) Parameters stream Stream context TransportContext cancellationToken CancellationToken"
  },
  "api/Sisk.Core.Http.CompressedContent.SerializeToStreamAsync.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.SerializeToStreamAsync.html",
    "title": "Method SerializeToStreamAsync | Sisk",
    "keywords": "Method SerializeToStreamAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll SerializeToStreamAsync(Stream, TransportContext?) protected override sealed Task SerializeToStreamAsync(Stream stream, TransportContext? context) Parameters stream Stream context TransportContext Returns Task SerializeToStreamAsync(Stream, TransportContext?, CancellationToken) protected override sealed Task SerializeToStreamAsync(Stream stream, TransportContext? context, CancellationToken cancellationToken) Parameters stream Stream context TransportContext cancellationToken CancellationToken Returns Task"
  },
  "api/Sisk.Core.Http.CompressedContent.Setup.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public abstract void Setup()"
  },
  "api/Sisk.Core.Http.CompressedContent.TryComputeLength.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.TryComputeLength.html",
    "title": "Method TryComputeLength | Sisk",
    "keywords": "Method TryComputeLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll TryComputeLength(out long) protected override sealed bool TryComputeLength(out long length) Parameters length long Returns bool"
  },
  "api/Sisk.Core.Http.CompressedContent.html": {
    "href": "api/Sisk.Core.Http.CompressedContent.html",
    "title": "Class CompressedContent | Sisk",
    "keywords": "Class CompressedContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents a base class for HTTP contents served over an compressing stream. public abstract class CompressedContent : HttpContent, IDisposable Inheritance object HttpContent CompressedContent Implements IDisposable Derived BrotliContent DeflateContent GZipContent Inherited Members HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.LoadIntoBufferAsync(CancellationToken) HttpContent.LoadIntoBufferAsync(long, CancellationToken) HttpContent.CreateContentReadStream(CancellationToken) HttpContent.CreateContentReadStreamAsync() HttpContent.CreateContentReadStreamAsync(CancellationToken) HttpContent.Dispose() HttpContent.Headers object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors CompressedContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. CompressedContent(Stream) Initializes a new instance of compressing stream with the specified stream content. CompressedContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Properties InnerContent Gets the inner HTTP content. Methods Dispose(bool) GetCompressingStream(Stream) Gets a stream that compresses the output stream. SerializeToStream(Stream, TransportContext?, CancellationToken) SerializeToStreamAsync(Stream, TransportContext?) SerializeToStreamAsync(Stream, TransportContext?, CancellationToken) Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. TryComputeLength(out long)"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultPageHtml.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultPageHtml.html",
    "title": "Method CreateDefaultPageHtml | Sisk",
    "keywords": "Method CreateDefaultPageHtml Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateDefaultPageHtml(string, string) Creates an static default page with given header and description. public static string CreateDefaultPageHtml(string firstHeader, string description) Parameters firstHeader string The static page header text. description string The static page description text. Returns string"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultResponse.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.CreateDefaultResponse.html",
    "title": "Method CreateDefaultResponse | Sisk",
    "keywords": "Method CreateDefaultResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateDefaultResponse(in HttpStatusInformation, string) Creates an static default page with given status code and description. public static HttpResponse CreateDefaultResponse(in HttpStatusInformation status, string longDescription) Parameters status HttpStatusInformation The static page status code. longDescription string The static page description text. Returns HttpResponse"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.DefaultPageCSS.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.DefaultPageCSS.html",
    "title": "Property DefaultPageCSS | Sisk",
    "keywords": "Property DefaultPageCSS Namespace Sisk.Core.Http Assembly Sisk.Core.dll DefaultPageCSS Gets or sets the page CSS string used by the page code. public static string DefaultPageCSS { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.DefaultMessagePage.html": {
    "href": "api/Sisk.Core.Http.DefaultMessagePage.html",
    "title": "Class DefaultMessagePage | Sisk",
    "keywords": "Class DefaultMessagePage Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides methods for creating informative static pages used by Sisk. public static class DefaultMessagePage Inheritance object DefaultMessagePage Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DefaultPageCSS Gets or sets the page CSS string used by the page code. Methods CreateDefaultPageHtml(string, string) Creates an static default page with given header and description. CreateDefaultResponse(in HttpStatusInformation, string) Creates an static default page with given status code and description."
  },
  "api/Sisk.Core.Http.DeflateContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.-ctor.html",
    "title": "Constructor DeflateContent | Sisk",
    "keywords": "Constructor DeflateContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll DeflateContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public DeflateContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. DeflateContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public DeflateContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. DeflateContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public DeflateContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.DeflateContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.DeflateContent.Setup.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.DeflateContent.html": {
    "href": "api/Sisk.Core.Http.DeflateContent.html",
    "title": "Class DeflateContent | Sisk",
    "keywords": "Class DeflateContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the Deflate algorithm. public sealed class DeflateContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent DeflateContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.LoadIntoBufferAsync(CancellationToken) HttpContent.LoadIntoBufferAsync(long, CancellationToken) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors DeflateContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. DeflateContent(Stream) Initializes a new instance of compressing stream with the specified stream content. DeflateContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.ForwardingResolver.-ctor.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.-ctor.html",
    "title": "Constructor ForwardingResolver | Sisk",
    "keywords": "Constructor ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForwardingResolver() protected ForwardingResolver()"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveClientAddress.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveClientAddress.html",
    "title": "Method OnResolveClientAddress | Sisk",
    "keywords": "Method OnResolveClientAddress Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveClientAddress(HttpRequest, IPEndPoint) Method that is called when resolving the IP address of the client in the request. public virtual IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. connectingEndpoint IPEndPoint The original connecting endpoint. Returns IPAddress"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveRequestHost.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveRequestHost.html",
    "title": "Method OnResolveRequestHost | Sisk",
    "keywords": "Method OnResolveRequestHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveRequestHost(HttpRequest, string) Method that is called when resolving the client request host. public virtual string OnResolveRequestHost(HttpRequest request, string requestedHost) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. requestedHost string The original requested host. Returns string"
  },
  "api/Sisk.Core.Http.ForwardingResolver.OnResolveSecureConnection.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.OnResolveSecureConnection.html",
    "title": "Method OnResolveSecureConnection | Sisk",
    "keywords": "Method OnResolveSecureConnection Namespace Sisk.Core.Http Assembly Sisk.Core.dll OnResolveSecureConnection(HttpRequest, bool) Method that is called when resolving whether the HTTP request is using HTTPS or HTTP. public virtual bool OnResolveSecureConnection(HttpRequest request, bool isSecure) Parameters request HttpRequest The HttpRequest object which contains parameters of the request. isSecure bool The original security state of the request. Returns bool"
  },
  "api/Sisk.Core.Http.ForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.ForwardingResolver.html",
    "title": "Class ForwardingResolver | Sisk",
    "keywords": "Class ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides HTTP forwarding resolving methods that can be used to resolving the client remote address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. public abstract class ForwardingResolver Inheritance object ForwardingResolver Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors ForwardingResolver() Methods OnResolveClientAddress(HttpRequest, IPEndPoint) Method that is called when resolving the IP address of the client in the request. OnResolveRequestHost(HttpRequest, string) Method that is called when resolving the client request host. OnResolveSecureConnection(HttpRequest, bool) Method that is called when resolving whether the HTTP request is using HTTPS or HTTP."
  },
  "api/Sisk.Core.Http.GZipContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.GZipContent.-ctor.html",
    "title": "Constructor GZipContent | Sisk",
    "keywords": "Constructor GZipContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GZipContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. public GZipContent(HttpContent innerContent) Parameters innerContent HttpContent The inner HTTP content. GZipContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. public GZipContent(byte[] byteArrayContent) Parameters byteArrayContent byte[] The byte array content. GZipContent(Stream) Initializes a new instance of compressing stream with the specified stream content. public GZipContent(Stream baseContent) Parameters baseContent Stream The stream content."
  },
  "api/Sisk.Core.Http.GZipContent.GetCompressingStream.html": {
    "href": "api/Sisk.Core.Http.GZipContent.GetCompressingStream.html",
    "title": "Method GetCompressingStream | Sisk",
    "keywords": "Method GetCompressingStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetCompressingStream(Stream) Gets a stream that compresses the output stream. public override Stream GetCompressingStream(Stream outputStream) Parameters outputStream Stream The output stream to compress. Returns Stream A stream that compresses the output stream."
  },
  "api/Sisk.Core.Http.GZipContent.Setup.html": {
    "href": "api/Sisk.Core.Http.GZipContent.Setup.html",
    "title": "Method Setup | Sisk",
    "keywords": "Method Setup Namespace Sisk.Core.Http Assembly Sisk.Core.dll Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor. public override void Setup()"
  },
  "api/Sisk.Core.Http.GZipContent.html": {
    "href": "api/Sisk.Core.Http.GZipContent.html",
    "title": "Class GZipContent | Sisk",
    "keywords": "Class GZipContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP content that is compressed using the GZip algorithm. public sealed class GZipContent : CompressedContent, IDisposable Inheritance object HttpContent CompressedContent GZipContent Implements IDisposable Inherited Members CompressedContent.InnerContent HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.LoadIntoBufferAsync(CancellationToken) HttpContent.LoadIntoBufferAsync(long, CancellationToken) HttpContent.Dispose() HttpContent.Headers object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors GZipContent(byte[]) Initializes a new instance of compressing stream with the specified byte array content. GZipContent(Stream) Initializes a new instance of compressing stream with the specified stream content. GZipContent(HttpContent) Initializes a new instance of compressing stream with the specified inner HTTP content. Methods GetCompressingStream(Stream) Gets a stream that compresses the output stream. Setup() Represents the method that is invoked once within the constructor to setup this compressor. This method is indeeded to add the missing Content-Encoding headers used by this compressor."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.-ctor.html",
    "title": "Constructor AsyncHttpServerHandler | Sisk",
    "keywords": "Constructor AsyncHttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll AsyncHttpServerHandler() protected AsyncHttpServerHandler()"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreated.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreated.html",
    "title": "Method OnContextBagCreated | Sisk",
    "keywords": "Method OnContextBagCreated Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. protected override sealed void OnContextBagCreated(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreatedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnContextBagCreatedAsync.html",
    "title": "Method OnContextBagCreatedAsync | Sisk",
    "keywords": "Method OnContextBagCreatedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreatedAsync(TypedValueDictionary) Method that is called when an HTTP context is created within an HttpRequest object. protected virtual Task OnContextBagCreatedAsync(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnException.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnException.html",
    "title": "Method OnException | Sisk",
    "keywords": "Method OnException Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected override sealed void OnException(Exception exception) Parameters exception Exception The exception object."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnExceptionAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnExceptionAsync.html",
    "title": "Method OnExceptionAsync | Sisk",
    "keywords": "Method OnExceptionAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnExceptionAsync(Exception) Method that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected virtual Task OnExceptionAsync(Exception exception) Parameters exception Exception The exception object. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestClose.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestClose.html",
    "title": "Method OnHttpRequestClose | Sisk",
    "keywords": "Method OnHttpRequestClose Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. protected override sealed void OnHttpRequestClose(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestCloseAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestCloseAsync.html",
    "title": "Method OnHttpRequestCloseAsync | Sisk",
    "keywords": "Method OnHttpRequestCloseAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestCloseAsync(HttpServerExecutionResult) Method that is called when an HttpRequest is closed in the HTTP server. protected virtual Task OnHttpRequestCloseAsync(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpen.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpen.html",
    "title": "Method OnHttpRequestOpen | Sisk",
    "keywords": "Method OnHttpRequestOpen Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. protected override sealed void OnHttpRequestOpen(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpenAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnHttpRequestOpenAsync.html",
    "title": "Method OnHttpRequestOpenAsync | Sisk",
    "keywords": "Method OnHttpRequestOpenAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpenAsync(HttpRequest) Method that is called when an HttpRequest is received in the HTTP server. protected virtual Task OnHttpRequestOpenAsync(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarted.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarted.html",
    "title": "Method OnServerStarted | Sisk",
    "keywords": "Method OnServerStarted Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. protected override sealed void OnServerStarted(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartedAsync.html",
    "title": "Method OnServerStartedAsync | Sisk",
    "keywords": "Method OnServerStartedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStartedAsync(HttpServer) Method that is called immediately after starting the HttpServer, when it's ready and listening. protected virtual Task OnServerStartedAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected override sealed void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartingAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStartingAsync.html",
    "title": "Method OnServerStartingAsync | Sisk",
    "keywords": "Method OnServerStartingAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStartingAsync(HttpServer) Method that is called immediately before starting the HttpServer. protected virtual Task OnServerStartingAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopped.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopped.html",
    "title": "Method OnServerStopped | Sisk",
    "keywords": "Method OnServerStopped Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected override sealed void OnServerStopped(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppedAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppedAsync.html",
    "title": "Method OnServerStoppedAsync | Sisk",
    "keywords": "Method OnServerStoppedAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStoppedAsync(HttpServer) Method that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected virtual Task OnServerStoppedAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopping.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStopping.html",
    "title": "Method OnServerStopping | Sisk",
    "keywords": "Method OnServerStopping Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. protected override sealed void OnServerStopping(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppingAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnServerStoppingAsync.html",
    "title": "Method OnServerStoppingAsync | Sisk",
    "keywords": "Method OnServerStoppingAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStoppingAsync(HttpServer) Method that is called before the HttpServer stop, when it is stopping from listening requests. protected virtual Task OnServerStoppingAsync(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected override sealed void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouterAsync.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.OnSetupRouterAsync.html",
    "title": "Method OnSetupRouterAsync | Sisk",
    "keywords": "Method OnSetupRouterAsync Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouterAsync(Router) Method that is called when an Router is binded to the HTTP server. protected virtual Task OnSetupRouterAsync(Router router) Parameters router Router The router entity which is binded. Returns Task"
  },
  "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.html": {
    "href": "api/Sisk.Core.Http.Handlers.AsyncHttpServerHandler.html",
    "title": "Class AsyncHttpServerHandler | Sisk",
    "keywords": "Class AsyncHttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll Represents an asynchronous event handler for the HttpServer, router, and related events. public abstract class AsyncHttpServerHandler : HttpServerHandler Inheritance object HttpServerHandler AsyncHttpServerHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors AsyncHttpServerHandler() Methods OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. OnContextBagCreatedAsync(TypedValueDictionary) Method that is called when an HTTP context is created within an HttpRequest object. OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnExceptionAsync(Exception) Method that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestCloseAsync(HttpServerExecutionResult) Method that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. OnHttpRequestOpenAsync(HttpRequest) Method that is called when an HttpRequest is received in the HTTP server. OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStartedAsync(HttpServer) Method that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnServerStartingAsync(HttpServer) Method that is called immediately before starting the HttpServer. OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStoppedAsync(HttpServer) Method that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. OnServerStoppingAsync(HttpServer) Method that is called before the HttpServer stop, when it is stopping from listening requests. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. OnSetupRouterAsync(Router) Method that is called when an Router is binded to the HTTP server."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.-ctor.html",
    "title": "Constructor HttpServerHandler | Sisk",
    "keywords": "Constructor HttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll HttpServerHandler() protected HttpServerHandler()"
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnContextBagCreated.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnContextBagCreated.html",
    "title": "Method OnContextBagCreated | Sisk",
    "keywords": "Method OnContextBagCreated Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. protected virtual void OnContextBagCreated(TypedValueDictionary contextBag) Parameters contextBag TypedValueDictionary The creating context bag."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnException.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnException.html",
    "title": "Method OnException | Sisk",
    "keywords": "Method OnException Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. protected virtual void OnException(Exception exception) Parameters exception Exception The exception object."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestClose.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestClose.html",
    "title": "Method OnHttpRequestClose | Sisk",
    "keywords": "Method OnHttpRequestClose Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. protected virtual void OnHttpRequestClose(HttpServerExecutionResult result) Parameters result HttpServerExecutionResult The result of the execution of the request."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestOpen.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnHttpRequestOpen.html",
    "title": "Method OnHttpRequestOpen | Sisk",
    "keywords": "Method OnHttpRequestOpen Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. protected virtual void OnHttpRequestOpen(HttpRequest request) Parameters request HttpRequest The connecting HTTP request entity."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarted.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarted.html",
    "title": "Method OnServerStarted | Sisk",
    "keywords": "Method OnServerStarted Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. protected virtual void OnServerStarted(HttpServer server) Parameters server HttpServer The HTTP server entity which is ready."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected virtual void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopped.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopped.html",
    "title": "Method OnServerStopped | Sisk",
    "keywords": "Method OnServerStopped Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. protected virtual void OnServerStopped(HttpServer server) Parameters server HttpServer The HTTP server entity which has stopped."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopping.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnServerStopping.html",
    "title": "Method OnServerStopping | Sisk",
    "keywords": "Method OnServerStopping Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. protected virtual void OnServerStopping(HttpServer server) Parameters server HttpServer The HTTP server entity which is stopping."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected virtual void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.Core.Http.Handlers.HttpServerHandler.html": {
    "href": "api/Sisk.Core.Http.Handlers.HttpServerHandler.html",
    "title": "Class HttpServerHandler | Sisk",
    "keywords": "Class HttpServerHandler Namespace Sisk.Core.Http.Handlers Assembly Sisk.Core.dll Represents an event handler for the HttpServer, router, and related events. public abstract class HttpServerHandler Inheritance object HttpServerHandler Derived AsyncHttpServerHandler JsonRpcServerHandler SslProxyServerHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServerHandler() Methods OnContextBagCreated(TypedValueDictionary) Event that is called when an HTTP context is created within an HttpRequest object. OnException(Exception) Event that is called when an exception is caught in the HTTP server. This method is called regardless of whether ThrowExceptions is enabled or not. OnHttpRequestClose(HttpServerExecutionResult) Event that is called when an HttpRequest is closed in the HTTP server. OnHttpRequestOpen(HttpRequest) Event that is called when an HttpRequest is received in the HTTP server. OnServerStarted(HttpServer) Event that is called immediately after starting the HttpServer, when it's ready and listening. OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnServerStopped(HttpServer) Event that is called after the HttpServer is stopped, meaning it has stopped from listening to requests. OnServerStopping(HttpServer) Event that is called before the HttpServer stop, when it is stopping from listening requests. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server."
  },
  "api/Sisk.Core.Http.Handlers.html": {
    "href": "api/Sisk.Core.Http.Handlers.html",
    "title": "Namespace Sisk.Core.Http.Handlers | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Handlers Classes AsyncHttpServerHandler Represents an asynchronous event handler for the HttpServer, router, and related events. HttpServerHandler Represents an event handler for the HttpServer, router, and related events."
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.ConfigurationFile.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.ConfigurationFile.html",
    "title": "Property ConfigurationFile | Sisk",
    "keywords": "Property ConfigurationFile Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ConfigurationFile Gets the absolute path to the configuration file. The file is guaranteed to exist when getting this property value. public string ConfigurationFile { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.Host.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Host Gets the HttpServerHostContext which are configuring this context. public HttpServerHostContext Host { get; } Property Value HttpServerHostContext"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.Parameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Parameters Gets the InitializationParameterCollection collection for defining configuration parameters of the host application. public InitializationParameterCollection Parameters { get; } Property Value InitializationParameterCollection"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.TargetListeningHost.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.TargetListeningHost.html",
    "title": "Property TargetListeningHost | Sisk",
    "keywords": "Property TargetListeningHost Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll TargetListeningHost Gets the target ListeningHost which are configuring this context. public ListeningHost TargetListeningHost { get; } Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationContext.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationContext.html",
    "title": "Class ConfigurationContext | Sisk",
    "keywords": "Class ConfigurationContext Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents a reading context for a portable configuration file. public sealed class ConfigurationContext Inheritance object ConfigurationContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ConfigurationFile Gets the absolute path to the configuration file. The file is guaranteed to exist when getting this property value. Host Gets the HttpServerHostContext which are configuring this context. Parameters Gets the InitializationParameterCollection collection for defining configuration parameters of the host application. TargetListeningHost Gets the target ListeningHost which are configuring this context."
  },
  "api/Sisk.Core.Http.Hosting.ConfigurationFileLookupDirectory.html": {
    "href": "api/Sisk.Core.Http.Hosting.ConfigurationFileLookupDirectory.html",
    "title": "Enum ConfigurationFileLookupDirectory | Sisk",
    "keywords": "Enum ConfigurationFileLookupDirectory Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the base directory where the IConfigurationReader should search for the configuration file. [Flags] public enum ConfigurationFileLookupDirectory Fields AppDirectory = 4 The IConfigurationReader should search in the executable base directory. CurrentDirectory = 2 The IConfigurationReader should search in the process current/base directory."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.AccessLogs.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.AccessLogs.html",
    "title": "Property AccessLogs | Sisk",
    "keywords": "Property AccessLogs Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll AccessLogs Gets the configured access log stream. This property is inherited from ServerConfiguration. public LogStream? AccessLogs { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.CrossOriginResourceSharingPolicy.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.CrossOriginResourceSharingPolicy.html",
    "title": "Property CrossOriginResourceSharingPolicy | Sisk",
    "keywords": "Property CrossOriginResourceSharingPolicy Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll CrossOriginResourceSharingPolicy Gets the host CrossOriginResourceSharingPolicy. public CrossOriginResourceSharingHeaders CrossOriginResourceSharingPolicy { get; set; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Dispose.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. public void Dispose()"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ErrorLogs.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ErrorLogs.html",
    "title": "Property ErrorLogs | Sisk",
    "keywords": "Property ErrorLogs Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ErrorLogs Gets the configured error log stream. This property is inherited from ServerConfiguration. public LogStream? ErrorLogs { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.HttpServer.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.HttpServer.html",
    "title": "Property HttpServer | Sisk",
    "keywords": "Property HttpServer Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll HttpServer Gets the host HTTP server. public HttpServer HttpServer { get; } Property Value HttpServer"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Parameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Parameters Gets the initialization parameters from the portable configuration file. public InitializationParameterCollection Parameters { get; } Property Value InitializationParameterCollection"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Router.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Router Gets the host router. public Router Router { get; set; } Property Value Router"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ServerConfiguration Gets the host server configuration. public HttpServerConfiguration ServerConfiguration { get; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Start.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Start(bool, bool) Starts the HTTP server. public void Start(bool verbose = true, bool preventHault = true) Parameters verbose bool Optional. Specifies if the application should write the listening prefix welcome message. preventHault bool Optional. Specifies if the application should pause the main application loop."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.StartAsync.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.StartAsync.html",
    "title": "Method StartAsync | Sisk",
    "keywords": "Method StartAsync Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll StartAsync(bool, bool) Asynchronously starts the HTTP server. public Task StartAsync(bool verbose = true, bool preventHault = true) Parameters verbose bool Optional. Specifies if the application should write the listening prefix welcome message. preventHault bool Optional. Specifies if the application should pause the main application loop. Returns Task"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContext.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContext.html",
    "title": "Class HttpServerHostContext | Sisk",
    "keywords": "Class HttpServerHostContext Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the class that hosts most of the components needed to run a Sisk application. public sealed class HttpServerHostContext : IDisposable Inheritance object HttpServerHostContext Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties AccessLogs Gets the configured access log stream. This property is inherited from ServerConfiguration. CrossOriginResourceSharingPolicy Gets the host CrossOriginResourceSharingPolicy. ErrorLogs Gets the configured error log stream. This property is inherited from ServerConfiguration. HttpServer Gets the host HTTP server. Parameters Gets the initialization parameters from the portable configuration file. Router Gets the host router. ServerConfiguration Gets the host server configuration. Methods Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. Start(bool, bool) Starts the HTTP server. StartAsync(bool, bool) Asynchronously starts the HTTP server."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.Build.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.Build.html",
    "title": "Method Build | Sisk",
    "keywords": "Method Build Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Build() Builds an HttpServerHostContext with the specified parameters. public HttpServerHostContext Build() Returns HttpServerHostContext"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.CatchConfigurationExceptions.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.CatchConfigurationExceptions.html",
    "title": "Property CatchConfigurationExceptions | Sisk",
    "keywords": "Property CatchConfigurationExceptions Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll CatchConfigurationExceptions Defines how the constructor should capture errors thrown within UsePortableConfiguration(Action<PortableConfigurationBuilder>) and display in the Console. public static HttpServerHostContextBuilderExceptionMode CatchConfigurationExceptions { get; set; } Property Value HttpServerHostContextBuilderExceptionMode"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ServerConfiguration Gets the Server Configuration object. public HttpServerConfiguration ServerConfiguration { get; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseAutoScan.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseAutoScan.html",
    "title": "Method UseAutoScan | Sisk",
    "keywords": "Method UseAutoScan Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseAutoScan<TModule>() This method is an shortcut for calling AutoScanModules<TModule>(). public HttpServerHostContextBuilder UseAutoScan<TModule>() where TModule : RouterModule Returns HttpServerHostContextBuilder Type Parameters TModule An class which implements RouterModule, or the router module itself. UseAutoScan<TModule>(Assembly) This method is an shortcut for calling AutoScanModules<TModule>(). public HttpServerHostContextBuilder UseAutoScan<TModule>(Assembly t) where TModule : RouterModule Parameters t Assembly The assembly where the scanning types are. Returns HttpServerHostContextBuilder Type Parameters TModule An class which implements RouterModule, or the router module itself."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseBootstraper.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseBootstraper.html",
    "title": "Method UseBootstraper | Sisk",
    "keywords": "Method UseBootstraper Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseBootstraper(Action) Adds an function that will be executed immediately before starting the HTTP server. public HttpServerHostContextBuilder UseBootstraper(Action bootstrapAction) Parameters bootstrapAction Action The action which will be executed before the HTTP server start. Returns HttpServerHostContextBuilder UseBootstraper(string, Action) Adds an function that will be executed immediately before starting the HTTP server. public HttpServerHostContextBuilder UseBootstraper(string name, Action bootstrapAction) Parameters name string Defines an custom label for the bootstraping action name. bootstrapAction Action The action which will be executed before the HTTP server start. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseConfiguration.html",
    "title": "Method UseConfiguration | Sisk",
    "keywords": "Method UseConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseConfiguration(Action<HttpServerConfiguration>) Calls an action that has the HTTP server configuration as an argument. public HttpServerHostContextBuilder UseConfiguration(Action<HttpServerConfiguration> handler) Parameters handler Action<HttpServerConfiguration> An action where the first argument is an HttpServerConfiguration. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseCors.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseCors.html",
    "title": "Method UseCors | Sisk",
    "keywords": "Method UseCors Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseCors(Action<CrossOriginResourceSharingHeaders>) Calls an action that has an CrossOriginResourceSharingHeaders instance from the main listening host as an argument. public HttpServerHostContextBuilder UseCors(Action<CrossOriginResourceSharingHeaders> handler) Parameters handler Action<CrossOriginResourceSharingHeaders> An action where the first argument is the main CrossOriginResourceSharingHeaders object. Returns HttpServerHostContextBuilder UseCors(CrossOriginResourceSharingHeaders) Sets an CrossOriginResourceSharingHeaders instance in the current listening host. public HttpServerHostContextBuilder UseCors(CrossOriginResourceSharingHeaders cors) Parameters cors CrossOriginResourceSharingHeaders The CrossOriginResourceSharingHeaders to the current host builder. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseForwardingResolver.html",
    "title": "Method UseForwardingResolver | Sisk",
    "keywords": "Method UseForwardingResolver Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseForwardingResolver(ForwardingResolver) This method is a shortcut for setting ForwardingResolver. public HttpServerHostContextBuilder UseForwardingResolver(ForwardingResolver resolver) Parameters resolver ForwardingResolver The ForwardingResolver object. Returns HttpServerHostContextBuilder UseForwardingResolver<TForwardingResolver>() This method is a shortcut for setting ForwardingResolver. public HttpServerHostContextBuilder UseForwardingResolver<TForwardingResolver>() where TForwardingResolver : ForwardingResolver, new() Returns HttpServerHostContextBuilder Type Parameters TForwardingResolver The type which implements ForwardingResolver."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHandler.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHandler.html",
    "title": "Method UseHandler | Sisk",
    "keywords": "Method UseHandler Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseHandler<THandler>() This method is an shortcut for calling RegisterHandler<T>(). public HttpServerHostContextBuilder UseHandler<THandler>() where THandler : HttpServerHandler, new() Returns HttpServerHostContextBuilder Type Parameters THandler The handler which implements HttpServerHandler. UseHandler(HttpServerHandler) This method is an shortcut for calling RegisterHandler(HttpServerHandler). public HttpServerHostContextBuilder UseHandler(HttpServerHandler handler) Parameters handler HttpServerHandler The instance of the server handler. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHttpServer.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseHttpServer.html",
    "title": "Method UseHttpServer | Sisk",
    "keywords": "Method UseHttpServer Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseHttpServer(Action<HttpServer>) Calls an action that has the HTTP server instance as an argument. public HttpServerHostContextBuilder UseHttpServer(Action<HttpServer> handler) Parameters handler Action<HttpServer> An action where the first argument is the main HttpServer object. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseListeningPort.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseListeningPort.html",
    "title": "Method UseListeningPort | Sisk",
    "keywords": "Method UseListeningPort Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseListeningPort(ushort) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(ushort port) Parameters port ushort The port the server will listen on. Returns HttpServerHostContextBuilder UseListeningPort(string) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(string uri) Parameters uri string The URI component that will be parsed to the listening port format. Returns HttpServerHostContextBuilder UseListeningPort(ListeningPort) Sets the main ListeningPort of this host builder. public HttpServerHostContextBuilder UseListeningPort(ListeningPort listeningPort) Parameters listeningPort ListeningPort The ListeningPort object which the HTTP server will listen to. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseLocale.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseLocale.html",
    "title": "Method UseLocale | Sisk",
    "keywords": "Method UseLocale Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseLocale(CultureInfo) Overrides the DefaultCultureInfo property in the HTTP server configuration. public HttpServerHostContextBuilder UseLocale(CultureInfo locale) Parameters locale CultureInfo The default CultureInfo object which the HTTP server will apply to the request handlers and callbacks thread. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UsePortableConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UsePortableConfiguration.html",
    "title": "Method UsePortableConfiguration | Sisk",
    "keywords": "Method UsePortableConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UsePortableConfiguration(Action<PortableConfigurationBuilder>) Enables the portable configuration for this application, which imports settings, parameters, and other information from a JSON settings file. public HttpServerHostContextBuilder UsePortableConfiguration(Action<PortableConfigurationBuilder> portableConfigHandler) Parameters portableConfigHandler Action<PortableConfigurationBuilder> The handler of PortableConfigurationBuilder. Returns HttpServerHostContextBuilder Remarks This method overrides almost all of your CreateBuilder() configuration. To avoid this, call this method at the beginning of your builder, as the first immediate method."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseRouter.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseRouter.html",
    "title": "Method UseRouter | Sisk",
    "keywords": "Method UseRouter Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseRouter(Action<Router>) Calls an action that has an Router instance from the host HTTP server. public HttpServerHostContextBuilder UseRouter(Action<Router> handler) Parameters handler Action<Router> An action where the first argument is the main Router object. Returns HttpServerHostContextBuilder UseRouter(Router) Sets an Router instance in the current listening host. public HttpServerHostContextBuilder UseRouter(Router r) Parameters r Router The Router to the current host builder. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseStartupMessage.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.UseStartupMessage.html",
    "title": "Method UseStartupMessage | Sisk",
    "keywords": "Method UseStartupMessage Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll UseStartupMessage(string) Add an optional message to the HttpServerHostContext output verbose. public HttpServerHostContextBuilder UseStartupMessage(string startupMessage) Parameters startupMessage string The startup message. Returns HttpServerHostContextBuilder UseStartupMessage(Func<string>) Adds a function that returns an optional initialization message to the HttpServerHostContext output verbose. public HttpServerHostContextBuilder UseStartupMessage(Func<string> startupMessage) Parameters startupMessage Func<string> The startup message function. Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilder.html",
    "title": "Class HttpServerHostContextBuilder | Sisk",
    "keywords": "Class HttpServerHostContextBuilder Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents a context constructor for HttpServerHostContext. public sealed class HttpServerHostContextBuilder Inheritance object HttpServerHostContextBuilder Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties CatchConfigurationExceptions Defines how the constructor should capture errors thrown within UsePortableConfiguration(Action<PortableConfigurationBuilder>) and display in the Console. ServerConfiguration Gets the Server Configuration object. Methods Build() Builds an HttpServerHostContext with the specified parameters. UseAutoScan<TModule>() This method is an shortcut for calling AutoScanModules<TModule>(). UseAutoScan<TModule>(Assembly) This method is an shortcut for calling AutoScanModules<TModule>(). UseBootstraper(Action) Adds an function that will be executed immediately before starting the HTTP server. UseBootstraper(string, Action) Adds an function that will be executed immediately before starting the HTTP server. UseConfiguration(Action<HttpServerConfiguration>) Calls an action that has the HTTP server configuration as an argument. UseCors(CrossOriginResourceSharingHeaders) Sets an CrossOriginResourceSharingHeaders instance in the current listening host. UseCors(Action<CrossOriginResourceSharingHeaders>) Calls an action that has an CrossOriginResourceSharingHeaders instance from the main listening host as an argument. UseForwardingResolver(ForwardingResolver) This method is a shortcut for setting ForwardingResolver. UseForwardingResolver<TForwardingResolver>() This method is a shortcut for setting ForwardingResolver. UseHandler(HttpServerHandler) This method is an shortcut for calling RegisterHandler(HttpServerHandler). UseHandler<THandler>() This method is an shortcut for calling RegisterHandler<T>(). UseHttpServer(Action<HttpServer>) Calls an action that has the HTTP server instance as an argument. UseListeningPort(ListeningPort) Sets the main ListeningPort of this host builder. UseListeningPort(string) Sets the main ListeningPort of this host builder. UseListeningPort(ushort) Sets the main ListeningPort of this host builder. UseLocale(CultureInfo) Overrides the DefaultCultureInfo property in the HTTP server configuration. UsePortableConfiguration(Action<PortableConfigurationBuilder>) Enables the portable configuration for this application, which imports settings, parameters, and other information from a JSON settings file. UseRouter(Router) Sets an Router instance in the current listening host. UseRouter(Action<Router>) Calls an action that has an Router instance from the host HTTP server. UseStartupMessage(Func<string>) Adds a function that returns an optional initialization message to the HttpServerHostContext output verbose. UseStartupMessage(string) Add an optional message to the HttpServerHostContext output verbose."
  },
  "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilderExceptionMode.html": {
    "href": "api/Sisk.Core.Http.Hosting.HttpServerHostContextBuilderExceptionMode.html",
    "title": "Enum HttpServerHostContextBuilderExceptionMode | Sisk",
    "keywords": "Enum HttpServerHostContextBuilderExceptionMode Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents how the builder event error message should be displayed. public enum HttpServerHostContextBuilderExceptionMode Fields Detailed = 2 Detailed messages, including detailed exception trace and information, should be displayed. Normal = 1 Normal messages, including their exception type and message, should be displayed. Silent = 0 No message should be displayed. Throw = 3 No message should be displayed and exceptions should be thrown instead being caughts."
  },
  "api/Sisk.Core.Http.Hosting.IConfigurationReader.ReadConfiguration.html": {
    "href": "api/Sisk.Core.Http.Hosting.IConfigurationReader.ReadConfiguration.html",
    "title": "Method ReadConfiguration | Sisk",
    "keywords": "Method ReadConfiguration Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file. void ReadConfiguration(ConfigurationContext context) Parameters context ConfigurationContext The configuration context object."
  },
  "api/Sisk.Core.Http.Hosting.IConfigurationReader.html": {
    "href": "api/Sisk.Core.Http.Hosting.IConfigurationReader.html",
    "title": "Interface IConfigurationReader | Sisk",
    "keywords": "Interface IConfigurationReader Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents an interface that reads and applies settings from a settings file. public interface IConfigurationReader Methods ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.-ctor.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.-ctor.html",
    "title": "Constructor InitializationParameterCollection | Sisk",
    "keywords": "Constructor InitializationParameterCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll InitializationParameterCollection() public InitializationParameterCollection()"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.AsNameValueCollection.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.AsNameValueCollection.html",
    "title": "Method AsNameValueCollection | Sisk",
    "keywords": "Method AsNameValueCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll AsNameValueCollection() Gets an instance of NameValueCollection with the values of this class. public NameValueCollection AsNameValueCollection() Returns NameValueCollection"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNull.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNull.html",
    "title": "Method EnsureNotNull | Sisk",
    "keywords": "Method EnsureNotNull Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll EnsureNotNull(string) Ensures that the parameter defined by name parameterName is present in this collection. public void EnsureNotNull(string parameterName) Parameters parameterName string The parameter name which will be evaluated. Remarks If the parameter doens't meet the above requirements, an ArgumentNullException exception is thrown."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNullOrEmpty.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.EnsureNotNullOrEmpty.html",
    "title": "Method EnsureNotNullOrEmpty | Sisk",
    "keywords": "Method EnsureNotNullOrEmpty Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll EnsureNotNullOrEmpty(string) Ensures that the parameter defined by name parameterName is present and not empty in this collection. public void EnsureNotNullOrEmpty(string parameterName) Parameters parameterName string The parameter name which will be evaluated. Remarks If the parameter doens't meet the above requirements, an ArgumentNullException exception is thrown."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOption.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOption.html",
    "title": "Enum InitializationParameterCollection.GetValueOption | Sisk",
    "keywords": "Enum InitializationParameterCollection.GetValueOption Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the option used in the method GetValueOrThrow(string, GetValueOption). public enum InitializationParameterCollection.GetValueOption Fields NotNull = 0 The method should throw if the value is not present in the collection, but allow empty values. NotNullOrEmpty = 1 The method should throw if the value is not present in the collection or has an empty value. NotNullOrWhiteSpace = 2 The method should throw if the value is not present in the collection, has an empty value or consists of whitespaces (spaces, tabs, etc.)."
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOrThrow.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.GetValueOrThrow.html",
    "title": "Method GetValueOrThrow | Sisk",
    "keywords": "Method GetValueOrThrow Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll GetValueOrThrow(string, GetValueOption) Gets the specified value if present in this parameter collection, or throw an exception if the value is not present. public string GetValueOrThrow(string parameterName, InitializationParameterCollection.GetValueOption option = GetValueOption.NotNullOrEmpty) Parameters parameterName string The parameter name. option InitializationParameterCollection.GetValueOption Specifies the InitializationParameterCollection.GetValueOption used for getting the value. Returns string"
  },
  "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.html": {
    "href": "api/Sisk.Core.Http.Hosting.InitializationParameterCollection.html",
    "title": "Class InitializationParameterCollection | Sisk",
    "keywords": "Class InitializationParameterCollection Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Provides a collection of HTTP server initialization variables. public sealed class InitializationParameterCollection : IDictionary<string, string?>, ICollection<KeyValuePair<string, string?>>, IEnumerable<KeyValuePair<string, string?>>, IEnumerable Inheritance object InitializationParameterCollection Implements IDictionary<string, string> ICollection<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors InitializationParameterCollection() Methods AsNameValueCollection() Gets an instance of NameValueCollection with the values of this class. EnsureNotNull(string) Ensures that the parameter defined by name parameterName is present in this collection. EnsureNotNullOrEmpty(string) Ensures that the parameter defined by name parameterName is present and not empty in this collection. GetValueOrThrow(string, GetValueOption) Gets the specified value if present in this parameter collection, or throw an exception if the value is not present."
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigFile.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigFile.html",
    "title": "Method WithConfigFile | Sisk",
    "keywords": "Method WithConfigFile Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithConfigFile(string, bool, ConfigurationFileLookupDirectory) Specifies the name of the server configuration file. public PortableConfigurationBuilder WithConfigFile(string filename, bool createIfDontExists = false, ConfigurationFileLookupDirectory lookupDirectories = ConfigurationFileLookupDirectory.CurrentDirectory) Parameters filename string The name of the JSON configuration file. createIfDontExists bool Optional. Determines if the configuration file should be created if it doens't exists. lookupDirectories ConfigurationFileLookupDirectory Optional. Specifies the directories which the IConfigurationReader should search for the configuration file. Returns PortableConfigurationBuilder"
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigReader.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithConfigReader.html",
    "title": "Method WithConfigReader | Sisk",
    "keywords": "Method WithConfigReader Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithConfigReader(IConfigurationReader) Defines an custom IConfigurationReader configuration pipeline to the builder. public PortableConfigurationBuilder WithConfigReader(IConfigurationReader reader) Parameters reader IConfigurationReader The IConfigurationReader object. Returns PortableConfigurationBuilder WithConfigReader<TReader>() Defines an custom IConfigurationReader configuration pipeline to the builder. public PortableConfigurationBuilder WithConfigReader<TReader>() where TReader : IConfigurationReader, new() Returns PortableConfigurationBuilder Type Parameters TReader The IConfigurationReader type."
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithParameters.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.WithParameters.html",
    "title": "Method WithParameters | Sisk",
    "keywords": "Method WithParameters Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll WithParameters(Action<InitializationParameterCollection>) Invokes a method on the initialization parameter collection. public PortableConfigurationBuilder WithParameters(Action<InitializationParameterCollection> handler) Parameters handler Action<InitializationParameterCollection> The handler of InitializationParameterCollection. Returns PortableConfigurationBuilder"
  },
  "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.html": {
    "href": "api/Sisk.Core.Http.Hosting.PortableConfigurationBuilder.html",
    "title": "Class PortableConfigurationBuilder | Sisk",
    "keywords": "Class PortableConfigurationBuilder Namespace Sisk.Core.Http.Hosting Assembly Sisk.Core.dll Represents the portable configuration builder for HttpServerHostContextBuilder. public sealed class PortableConfigurationBuilder Inheritance object PortableConfigurationBuilder Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WithConfigFile(string, bool, ConfigurationFileLookupDirectory) Specifies the name of the server configuration file. WithConfigReader(IConfigurationReader) Defines an custom IConfigurationReader configuration pipeline to the builder. WithConfigReader<TReader>() Defines an custom IConfigurationReader configuration pipeline to the builder. WithParameters(Action<InitializationParameterCollection>) Invokes a method on the initialization parameter collection."
  },
  "api/Sisk.Core.Http.Hosting.html": {
    "href": "api/Sisk.Core.Http.Hosting.html",
    "title": "Namespace Sisk.Core.Http.Hosting | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Hosting Classes ConfigurationContext Represents a reading context for a portable configuration file. HttpServerHostContext Represents the class that hosts most of the components needed to run a Sisk application. HttpServerHostContextBuilder Represents a context constructor for HttpServerHostContext. InitializationParameterCollection Provides a collection of HTTP server initialization variables. PortableConfigurationBuilder Represents the portable configuration builder for HttpServerHostContextBuilder. Interfaces IConfigurationReader Represents an interface that reads and applies settings from a settings file. Enums ConfigurationFileLookupDirectory Represents the base directory where the IConfigurationReader should search for the configuration file. HttpServerHostContextBuilderExceptionMode Represents how the builder event error message should be displayed. InitializationParameterCollection.GetValueOption Represents the option used in the method GetValueOrThrow(string, GetValueOption)."
  },
  "api/Sisk.Core.Http.HtmlContent.-ctor.html": {
    "href": "api/Sisk.Core.Http.HtmlContent.-ctor.html",
    "title": "Constructor HtmlContent | Sisk",
    "keywords": "Constructor HtmlContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll HtmlContent(string, Encoding) Creates an new HtmlContent class with given HTML content and encoding. public HtmlContent(string content, Encoding encoding) Parameters content string The HTML content string. encoding Encoding The encoding which will encode the HTML contents. HtmlContent(string) Creates an new HtmlContent class with given HTML content, using the environment default encoding. public HtmlContent(string content) Parameters content string The HTML content string."
  },
  "api/Sisk.Core.Http.HtmlContent.html": {
    "href": "api/Sisk.Core.Http.HtmlContent.html",
    "title": "Class HtmlContent | Sisk",
    "keywords": "Class HtmlContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides HTTP content based on HTML contents. public class HtmlContent : StringContent, IDisposable Inheritance object HttpContent ByteArrayContent StringContent HtmlContent Implements IDisposable Inherited Members StringContent.SerializeToStreamAsync(Stream, TransportContext, CancellationToken) ByteArrayContent.SerializeToStream(Stream, TransportContext, CancellationToken) ByteArrayContent.SerializeToStreamAsync(Stream, TransportContext) ByteArrayContent.TryComputeLength(out long) ByteArrayContent.CreateContentReadStream(CancellationToken) ByteArrayContent.CreateContentReadStreamAsync() HttpContent.ReadAsStringAsync() HttpContent.ReadAsStringAsync(CancellationToken) HttpContent.ReadAsByteArrayAsync() HttpContent.ReadAsByteArrayAsync(CancellationToken) HttpContent.ReadAsStream() HttpContent.ReadAsStream(CancellationToken) HttpContent.ReadAsStreamAsync() HttpContent.ReadAsStreamAsync(CancellationToken) HttpContent.CopyTo(Stream, TransportContext, CancellationToken) HttpContent.CopyToAsync(Stream) HttpContent.CopyToAsync(Stream, CancellationToken) HttpContent.CopyToAsync(Stream, TransportContext) HttpContent.CopyToAsync(Stream, TransportContext, CancellationToken) HttpContent.LoadIntoBufferAsync() HttpContent.LoadIntoBufferAsync(long) HttpContent.LoadIntoBufferAsync(CancellationToken) HttpContent.LoadIntoBufferAsync(long, CancellationToken) HttpContent.CreateContentReadStreamAsync(CancellationToken) HttpContent.Dispose(bool) HttpContent.Dispose() HttpContent.Headers object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HtmlContent(string) Creates an new HtmlContent class with given HTML content, using the environment default encoding. HtmlContent(string, Encoding) Creates an new HtmlContent class with given HTML content and encoding."
  },
  "api/Sisk.Core.Http.HttpContext.Current.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Current.html",
    "title": "Property Current | Sisk",
    "keywords": "Property Current Namespace Sisk.Core.Http Assembly Sisk.Core.dll Current Gets the current running HttpContext. public static HttpContext Current { get; } Property Value HttpContext Remarks This property is only accessible during an HTTP session, within the executing HTTP code."
  },
  "api/Sisk.Core.Http.HttpContext.ExtraHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpContext.ExtraHeaders.html",
    "title": "Property ExtraHeaders | Sisk",
    "keywords": "Property ExtraHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll ExtraHeaders Gets or sets the HttpHeaderCollection indicating HTTP headers which will be added (not overwritten) in the final response. public HttpHeaderCollection ExtraHeaders { get; set; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpContext.HttpServer.html": {
    "href": "api/Sisk.Core.Http.HttpContext.HttpServer.html",
    "title": "Property HttpServer | Sisk",
    "keywords": "Property HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServer Gets the context HttpServer instance. public HttpServer HttpServer { get; } Property Value HttpServer"
  },
  "api/Sisk.Core.Http.HttpContext.IsRequestContext.html": {
    "href": "api/Sisk.Core.Http.HttpContext.IsRequestContext.html",
    "title": "Property IsRequestContext | Sisk",
    "keywords": "Property IsRequestContext Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsRequestContext Gets whether the current thread context is running inside an HTTP context. public static bool IsRequestContext { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpContext.ListeningHost.html": {
    "href": "api/Sisk.Core.Http.HttpContext.ListeningHost.html",
    "title": "Property ListeningHost | Sisk",
    "keywords": "Property ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHost Gets the ListeningHost instance of this HTTP context. public ListeningHost? ListeningHost { get; } Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.HttpContext.MatchedRoute.html": {
    "href": "api/Sisk.Core.Http.HttpContext.MatchedRoute.html",
    "title": "Property MatchedRoute | Sisk",
    "keywords": "Property MatchedRoute Namespace Sisk.Core.Http Assembly Sisk.Core.dll MatchedRoute Gets the matched Route for this context. public Route? MatchedRoute { get; } Property Value Route"
  },
  "api/Sisk.Core.Http.HttpContext.OverrideHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpContext.OverrideHeaders.html",
    "title": "Property OverrideHeaders | Sisk",
    "keywords": "Property OverrideHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll OverrideHeaders Gets or sets an HttpHeaderCollection indicating HTTP headers which will overwrite headers set by CORS, router response or request handlers. public HttpHeaderCollection OverrideHeaders { get; set; } Property Value HttpHeaderCollection Remarks This property replaces existing headers in the final response. Use ExtraHeaders to add headers without replacing existing ones."
  },
  "api/Sisk.Core.Http.HttpContext.Request.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Request.html",
    "title": "Property Request | Sisk",
    "keywords": "Property Request Namespace Sisk.Core.Http Assembly Sisk.Core.dll Request Gets the HttpRequest which is contained in this HTTP context. public HttpRequest Request { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.HttpContext.RequestBag.html": {
    "href": "api/Sisk.Core.Http.HttpContext.RequestBag.html",
    "title": "Property RequestBag | Sisk",
    "keywords": "Property RequestBag Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestBag Gets or sets a managed collection for this HTTP context. public TypedValueDictionary RequestBag { get; set; } Property Value TypedValueDictionary"
  },
  "api/Sisk.Core.Http.HttpContext.Router.html": {
    "href": "api/Sisk.Core.Http.HttpContext.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http Assembly Sisk.Core.dll Router Gets the Router where this context was created. public Router? Router { get; } Property Value Router"
  },
  "api/Sisk.Core.Http.HttpContext.RouterResponse.html": {
    "href": "api/Sisk.Core.Http.HttpContext.RouterResponse.html",
    "title": "Property RouterResponse | Sisk",
    "keywords": "Property RouterResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll RouterResponse Gets the HttpResponse for this context. This property acessible when a post-executing IRequestHandler was executed for this router context. public HttpResponse? RouterResponse { get; } Property Value HttpResponse"
  },
  "api/Sisk.Core.Http.HttpContext.html": {
    "href": "api/Sisk.Core.Http.HttpContext.html",
    "title": "Class HttpContext | Sisk",
    "keywords": "Class HttpContext Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an context that is shared in a entire HTTP session. public sealed class HttpContext Inheritance object HttpContext Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Current Gets the current running HttpContext. ExtraHeaders Gets or sets the HttpHeaderCollection indicating HTTP headers which will be added (not overwritten) in the final response. HttpServer Gets the context HttpServer instance. IsRequestContext Gets whether the current thread context is running inside an HTTP context. ListeningHost Gets the ListeningHost instance of this HTTP context. MatchedRoute Gets the matched Route for this context. OverrideHeaders Gets or sets an HttpHeaderCollection indicating HTTP headers which will overwrite headers set by CORS, router response or request handlers. Request Gets the HttpRequest which is contained in this HTTP context. RequestBag Gets or sets a managed collection for this HTTP context. Router Gets the Router where this context was created. RouterResponse Gets the HttpResponse for this context. This property acessible when a post-executing IRequestHandler was executed for this router context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Accept.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Accept.html",
    "title": "Field Accept | Sisk",
    "keywords": "Field Accept Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. public const string Accept = \"Accept\" Returns string The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCharset.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptCharset.html",
    "title": "Field AcceptCharset | Sisk",
    "keywords": "Field AcceptCharset Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. public const string AcceptCharset = \"Accept-Charset\" Returns string The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptEncoding.html",
    "title": "Field AcceptEncoding | Sisk",
    "keywords": "Field AcceptEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. public const string AcceptEncoding = \"Accept-Encoding\" Returns string The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptLanguage.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptLanguage.html",
    "title": "Field AcceptLanguage | Sisk",
    "keywords": "Field AcceptLanguage Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. public const string AcceptLanguage = \"Accept-Language\" Returns string The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptPatch.html",
    "title": "Field AcceptPatch | Sisk",
    "keywords": "Field AcceptPatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. public const string AcceptPatch = \"Accept-Patch\" Returns string The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptRanges.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AcceptRanges.html",
    "title": "Field AcceptRanges | Sisk",
    "keywords": "Field AcceptRanges Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. public const string AcceptRanges = \"Accept-Ranges\" Returns string The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowCredentials.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowCredentials.html",
    "title": "Field AccessControlAllowCredentials | Sisk",
    "keywords": "Field AccessControlAllowCredentials Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. public const string AccessControlAllowCredentials = \"Access-Control-Allow-Credentials\" Returns string The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowHeaders.html",
    "title": "Field AccessControlAllowHeaders | Sisk",
    "keywords": "Field AccessControlAllowHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. public const string AccessControlAllowHeaders = \"Access-Control-Allow-Headers\" Returns string The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowMethods.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowMethods.html",
    "title": "Field AccessControlAllowMethods | Sisk",
    "keywords": "Field AccessControlAllowMethods Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. public const string AccessControlAllowMethods = \"Access-Control-Allow-Methods\" Returns string The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowOrigin.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlAllowOrigin.html",
    "title": "Field AccessControlAllowOrigin | Sisk",
    "keywords": "Field AccessControlAllowOrigin Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. public const string AccessControlAllowOrigin = \"Access-Control-Allow-Origin\" Returns string The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlExposeHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlExposeHeaders.html",
    "title": "Field AccessControlExposeHeaders | Sisk",
    "keywords": "Field AccessControlExposeHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. public const string AccessControlExposeHeaders = \"Access-Control-Expose-Headers\" Returns string The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlMaxAge.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AccessControlMaxAge.html",
    "title": "Field AccessControlMaxAge | Sisk",
    "keywords": "Field AccessControlMaxAge Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. public const string AccessControlMaxAge = \"Access-Control-Max-Age\" Returns string The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Age.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Age.html",
    "title": "Field Age | Sisk",
    "keywords": "Field Age Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. public const string Age = \"Age\" Returns string The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Allow.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Allow.html",
    "title": "Field Allow | Sisk",
    "keywords": "Field Allow Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. public const string Allow = \"Allow\" Returns string The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.AltSvc.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.AltSvc.html",
    "title": "Field AltSvc | Sisk",
    "keywords": "Field AltSvc Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol. public const string AltSvc = \"Alt-Svc\" Returns string The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Authorization.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Authorization.html",
    "title": "Field Authorization | Sisk",
    "keywords": "Field Authorization Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. public const string Authorization = \"Authorization\" Returns string The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.CacheControl.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.CacheControl.html",
    "title": "Field CacheControl | Sisk",
    "keywords": "Field CacheControl Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. public const string CacheControl = \"Cache-Control\" Returns string The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Connection.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Connection.html",
    "title": "Field Connection | Sisk",
    "keywords": "Field Connection Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections. public const string Connection = \"Connection\" Returns string The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentDisposition.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentDisposition.html",
    "title": "Field ContentDisposition | Sisk",
    "keywords": "Field ContentDisposition Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. public const string ContentDisposition = \"Content-Disposition\" Returns string The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentEncoding.html",
    "title": "Field ContentEncoding | Sisk",
    "keywords": "Field ContentEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. public const string ContentEncoding = \"Content-Encoding\" Returns string The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLanguage.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLanguage.html",
    "title": "Field ContentLanguage | Sisk",
    "keywords": "Field ContentLanguage Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. public const string ContentLanguage = \"Content-Language\" Returns string The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLength.html",
    "title": "Field ContentLength | Sisk",
    "keywords": "Field ContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. public const string ContentLength = \"Content-Length\" Returns string The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLocation.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentLocation.html",
    "title": "Field ContentLocation | Sisk",
    "keywords": "Field ContentLocation Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. public const string ContentLocation = \"Content-Location\" Returns string The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentMD5.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentMD5.html",
    "title": "Field ContentMD5 | Sisk",
    "keywords": "Field ContentMD5 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data. public const string ContentMD5 = \"Content-MD5\" Returns string The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentRange.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentRange.html",
    "title": "Field ContentRange | Sisk",
    "keywords": "Field ContentRange Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges. public const string ContentRange = \"Content-Range\" Returns string The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentSecurityPolicy.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentSecurityPolicy.html",
    "title": "Field ContentSecurityPolicy | Sisk",
    "keywords": "Field ContentSecurityPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. public const string ContentSecurityPolicy = \"Content-Security-Policy\" Returns string The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentType.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ContentType.html",
    "title": "Field ContentType | Sisk",
    "keywords": "Field ContentType Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. public const string ContentType = \"Content-Type\" Returns string The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie.html",
    "title": "Field Cookie | Sisk",
    "keywords": "Field Cookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. public const string Cookie = \"Cookie\" Returns string The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie2.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Cookie2.html",
    "title": "Field Cookie2 | Sisk",
    "keywords": "Field Cookie2 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. public const string Cookie2 = \"Cookie2\" Returns string The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Date.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Date.html",
    "title": "Field Date | Sisk",
    "keywords": "Field Date Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response. public const string Date = \"Date\" Returns string The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ETag.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ETag.html",
    "title": "Field ETag | Sisk",
    "keywords": "Field ETag Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. public const string ETag = \"ETag\" Returns string The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Expect.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Expect.html",
    "title": "Field Expect | Sisk",
    "keywords": "Field Expect Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. public const string Expect = \"Expect\" Returns string The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Expires.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Expires.html",
    "title": "Field Expires | Sisk",
    "keywords": "Field Expires Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. public const string Expires = \"Expires\" Returns string The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Host.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Host.html",
    "title": "Field Host | Sisk",
    "keywords": "Field Host Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. public const string Host = \"Host\" Returns string The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfMatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfMatch.html",
    "title": "Field IfMatch | Sisk",
    "keywords": "Field IfMatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. public const string IfMatch = \"If-Match\" Returns string The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfModifiedSince.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfModifiedSince.html",
    "title": "Field IfModifiedSince | Sisk",
    "keywords": "Field IfModifiedSince Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. public const string IfModifiedSince = \"If-Modified-Since\" Returns string The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfNoneMatch.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfNoneMatch.html",
    "title": "Field IfNoneMatch | Sisk",
    "keywords": "Field IfNoneMatch Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag. public const string IfNoneMatch = \"If-None-Match\" Returns string The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfRange.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfRange.html",
    "title": "Field IfRange | Sisk",
    "keywords": "Field IfRange Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. public const string IfRange = \"If-Range\" Returns string The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.IfUnmodifiedSince.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.IfUnmodifiedSince.html",
    "title": "Field IfUnmodifiedSince | Sisk",
    "keywords": "Field IfUnmodifiedSince Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. public const string IfUnmodifiedSince = \"If-Unmodified-Since\" Returns string The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.KeepAlive.html",
    "title": "Field KeepAlive | Sisk",
    "keywords": "Field KeepAlive Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests. public const string KeepAlive = \"Keep-Alive\" Returns string The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.LastModified.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.LastModified.html",
    "title": "Field LastModified | Sisk",
    "keywords": "Field LastModified Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version. public const string LastModified = \"Last-Modified\" Returns string The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Link.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Link.html",
    "title": "Field Link | Sisk",
    "keywords": "Field Link Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking. public const string Link = \"Link\" Returns string The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Location.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Location.html",
    "title": "Field Location | Sisk",
    "keywords": "Field Location Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect. public const string Location = \"Location\" Returns string The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.MaxForwards.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.MaxForwards.html",
    "title": "Field MaxForwards | Sisk",
    "keywords": "Field MaxForwards Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. public const string MaxForwards = \"Max-Forwards\" Returns string The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Origin.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Origin.html",
    "title": "Field Origin | Sisk",
    "keywords": "Field Origin Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. public const string Origin = \"Origin\" Returns string The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.P3P.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.P3P.html",
    "title": "Field P3P | Sisk",
    "keywords": "Field P3P Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled. public const string P3P = \"P3P\" Returns string The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Pragma.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Pragma.html",
    "title": "Field Pragma | Sisk",
    "keywords": "Field Pragma Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. public const string Pragma = \"Pragma\" Returns string The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthenticate.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthenticate.html",
    "title": "Field ProxyAuthenticate | Sisk",
    "keywords": "Field ProxyAuthenticate Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. public const string ProxyAuthenticate = \"Proxy-Authenticate\" Returns string The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthorization.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyAuthorization.html",
    "title": "Field ProxyAuthorization | Sisk",
    "keywords": "Field ProxyAuthorization Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. public const string ProxyAuthorization = \"Proxy-Authorization\" Returns string The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyConnection.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.ProxyConnection.html",
    "title": "Field ProxyConnection | Sisk",
    "keywords": "Field ProxyConnection Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction. public const string ProxyConnection = \"Proxy-Connection\" Returns string The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.PublicKeyPins.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.PublicKeyPins.html",
    "title": "Field PublicKeyPins | Sisk",
    "keywords": "Field PublicKeyPins Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate. public const string PublicKeyPins = \"Public-Key-Pins\" Returns string The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Range.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Range.html",
    "title": "Field Range | Sisk",
    "keywords": "Field Range Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. public const string Range = \"Range\" Returns string The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Referer.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Referer.html",
    "title": "Field Referer | Sisk",
    "keywords": "Field Referer Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. public const string Referer = \"Referer\" Returns string The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.RetryAfter.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.RetryAfter.html",
    "title": "Field RetryAfter | Sisk",
    "keywords": "Field RetryAfter Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. public const string RetryAfter = \"Retry-After\" Returns string The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketAccept.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketAccept.html",
    "title": "Field SecWebSocketAccept | Sisk",
    "keywords": "Field SecWebSocketAccept Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request. public const string SecWebSocketAccept = \"Sec-WebSocket-Accept\" Returns string The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketExtensions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketExtensions.html",
    "title": "Field SecWebSocketExtensions | Sisk",
    "keywords": "Field SecWebSocketExtensions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities. public const string SecWebSocketExtensions = \"Sec-WebSocket-Extensions\" Returns string The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketKey.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketKey.html",
    "title": "Field SecWebSocketKey | Sisk",
    "keywords": "Field SecWebSocketKey Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid. public const string SecWebSocketKey = \"Sec-WebSocket-Key\" Returns string The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketProtocol.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketProtocol.html",
    "title": "Field SecWebSocketProtocol | Sisk",
    "keywords": "Field SecWebSocketProtocol Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection. public const string SecWebSocketProtocol = \"Sec-WebSocket-Protocol\" Returns string The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketVersion.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SecWebSocketVersion.html",
    "title": "Field SecWebSocketVersion | Sisk",
    "keywords": "Field SecWebSocketVersion Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use. public const string SecWebSocketVersion = \"Sec-WebSocket-Version\" Returns string The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Server.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Server.html",
    "title": "Field Server | Sisk",
    "keywords": "Field Server Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes. public const string Server = \"Server\" Returns string The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie.html",
    "title": "Field SetCookie | Sisk",
    "keywords": "Field SetCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. public const string SetCookie = \"Set-Cookie\" Returns string The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie2.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.SetCookie2.html",
    "title": "Field SetCookie2 | Sisk",
    "keywords": "Field SetCookie2 Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. public const string SetCookie2 = \"Set-Cookie2\" Returns string The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.StrictTransportSecurity.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.StrictTransportSecurity.html",
    "title": "Field StrictTransportSecurity | Sisk",
    "keywords": "Field StrictTransportSecurity Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks. public const string StrictTransportSecurity = \"Strict-Transport-Security\" Returns string The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TE.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TE.html",
    "title": "Field TE | Sisk",
    "keywords": "Field TE Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. public const string TE = \"TE\" Returns string The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TSV.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TSV.html",
    "title": "Field TSV | Sisk",
    "keywords": "Field TSV Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols. public const string TSV = \"TSV\" Returns string The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Trailer.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Trailer.html",
    "title": "Field Trailer | Sisk",
    "keywords": "Field Trailer Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata. public const string Trailer = \"Trailer\" Returns string The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.TransferEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.TransferEncoding.html",
    "title": "Field TransferEncoding | Sisk",
    "keywords": "Field TransferEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user. public const string TransferEncoding = \"Transfer-Encoding\" Returns string The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Upgrade.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Upgrade.html",
    "title": "Field Upgrade | Sisk",
    "keywords": "Field Upgrade Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2. public const string Upgrade = \"Upgrade\" Returns string The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.UpgradeInsecureRequests.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.UpgradeInsecureRequests.html",
    "title": "Field UpgradeInsecureRequests | Sisk",
    "keywords": "Field UpgradeInsecureRequests Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP. public const string UpgradeInsecureRequests = \"Upgrade-Insecure-Requests\" Returns string The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.UserAgent.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.UserAgent.html",
    "title": "Field UserAgent | Sisk",
    "keywords": "Field UserAgent Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. public const string UserAgent = \"User-Agent\" Returns string The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Vary.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Vary.html",
    "title": "Field Vary | Sisk",
    "keywords": "Field Vary Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. public const string Vary = \"Vary\" Returns string The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Via.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Via.html",
    "title": "Field Via | Sisk",
    "keywords": "Field Via Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. public const string Via = \"Via\" Returns string The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.WWWAuthenticate.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.WWWAuthenticate.html",
    "title": "Field WWWAuthenticate | Sisk",
    "keywords": "Field WWWAuthenticate Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. public const string WWWAuthenticate = \"WWW-Authenticate\" Returns string The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.Warning.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.Warning.html",
    "title": "Field Warning | Sisk",
    "keywords": "Field Warning Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation. public const string Warning = \"Warning\" Returns string The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentDuration.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentDuration.html",
    "title": "Field XContentDuration | Sisk",
    "keywords": "Field XContentDuration Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files. public const string XContentDuration = \"X-Content-Duration\" Returns string The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentTypeOptions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XContentTypeOptions.html",
    "title": "Field XContentTypeOptions | Sisk",
    "keywords": "Field XContentTypeOptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type. public const string XContentTypeOptions = \"X-Content-Type-Options\" Returns string The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedFor.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedFor.html",
    "title": "Field XForwardedFor | Sisk",
    "keywords": "Field XForwardedFor Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. public const string XForwardedFor = \"X-Forwarded-For\" Returns string The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedHost.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XForwardedHost.html",
    "title": "Field XForwardedHost | Sisk",
    "keywords": "Field XForwardedHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. public const string XForwardedHost = \"X-Forwarded-Host\" Returns string The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XFrameOptions.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XFrameOptions.html",
    "title": "Field XFrameOptions | Sisk",
    "keywords": "Field XFrameOptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. public const string XFrameOptions = \"X-Frame-Options\" Returns string The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XPoweredBy.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XPoweredBy.html",
    "title": "Field XPoweredBy | Sisk",
    "keywords": "Field XPoweredBy Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes. public const string XPoweredBy = \"X-Powered-By\" Returns string The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XRequestID.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XRequestID.html",
    "title": "Field XRequestID | Sisk",
    "keywords": "Field XRequestID Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server. public const string XRequestID = \"X-Request-ID\" Returns string The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.XUACompatible.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.XUACompatible.html",
    "title": "Field XUACompatible | Sisk",
    "keywords": "Field XUACompatible Namespace Sisk.Core.Http Assembly Sisk.Core.dll The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions. public const string XUACompatible = \"X-UA-Compatible\" Returns string The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Http.HttpKnownHeaderNames.html": {
    "href": "api/Sisk.Core.Http.HttpKnownHeaderNames.html",
    "title": "Class HttpKnownHeaderNames | Sisk",
    "keywords": "Class HttpKnownHeaderNames Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides most of the most commonly known HTTP headers for constants. public static class HttpKnownHeaderNames Inheritance object HttpKnownHeaderNames Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Fields Accept The HTTP Accept header. Specifies the media types that are acceptable for the response, allowing the client to indicate its preferences. AcceptCharset The HTTP Accept-Charset header. Indicates the character sets that are acceptable for the response, allowing the client to specify its preferred encoding. AcceptEncoding The HTTP Accept-Encoding header. Specifies the content encodings that are acceptable for the response, allowing the client to indicate its preferences for compression. AcceptLanguage The HTTP Accept-Language header. Indicates the natural languages that are preferred for the response, allowing the client to specify its language preferences. AcceptPatch The HTTP Accept-Patch header. Indicates the patch document formats that are acceptable for the response, allowing the client to specify its preferences for patching resources. AcceptRanges The HTTP Accept-Ranges header. Indicates that the server supports range requests for the resource, allowing clients to request specific byte ranges. AccessControlAllowCredentials The HTTP Access-Control-Allow-Credentials header. Indicates whether the response to the request can expose credentials, allowing cross-origin requests to include credentials. AccessControlAllowHeaders The HTTP Access-Control-Allow-Headers header. Specifies which headers can be used when making the actual request in a cross-origin resource sharing (CORS) context. AccessControlAllowMethods The HTTP Access-Control-Allow-Methods header. Specifies the methods that are allowed when accessing the resource in a CORS context. AccessControlAllowOrigin The HTTP Access-Control-Allow-Origin header. Specifies which origins are allowed to access the resource in a CORS context, helping to control cross-origin requests. AccessControlExposeHeaders The HTTP Access-Control-Expose-Headers header. Indicates which headers can be exposed as part of the response to a cross-origin request. AccessControlMaxAge The HTTP Access-Control-Max-Age header. Specifies how long the results of a preflight request can be cached, reducing the number of preflight requests made. Age The HTTP Age header. Indicates the age of the object in a cache, helping clients understand how fresh the cached response is. Allow The HTTP Allow header. Lists the HTTP methods that are supported by the resource, informing clients about the available actions. AltSvc The HTTP Alt-Svc header. Indicates that an alternative service is available for the resource, allowing clients to connect to a different server or protocol. Authorization The HTTP Authorization header. Contains credentials for authenticating the client with the server, often used for basic or bearer token authentication. CacheControl The HTTP Cache-Control header. Directs caching mechanisms on how to cache the response, including directives for expiration and revalidation. Connection The HTTP Connection header. Controls whether the network connection stays open after the current transaction finishes, allowing for persistent connections. ContentDisposition The HTTP Content-Disposition header. Indicates if the content should be displayed inline in the browser or treated as an attachment to be downloaded. ContentEncoding The HTTP Content-Encoding header. Specifies the encoding transformations that have been applied to the response body, such as gzip or deflate. ContentLanguage The HTTP Content-Language header. Indicates the natural language(s) of the intended audience for the response, helping clients understand the content's language. ContentLength The HTTP Content-Length header. Indicates the size of the response body in bytes, allowing the client to know how much data to expect. ContentLocation The HTTP Content-Location header. Indicates an alternate location for the returned data, often used for redirecting clients to a different resource. ContentMD5 The HTTP Content-MD5 header. Contains the MD5 hash of the response body, allowing clients to verify the integrity of the received data. ContentRange The HTTP Content-Range header. Indicates the part of a document that the server is returning, used in range requests to specify byte ranges. ContentSecurityPolicy The HTTP Content-Security-Policy header. Defines security policies for the content, helping to prevent cross-site scripting (XSS) and other code injection attacks. ContentType The HTTP Content-Type header. Indicates the media type of the resource, allowing the client to understand how to process the response body. Cookie The HTTP Cookie header. Contains stored HTTP cookies previously sent by the server, allowing the server to identify the client on subsequent requests. Cookie2 The HTTP Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. Date The HTTP Date header. Indicates the date and time at which the message was sent, helping clients understand the freshness of the response. ETag The HTTP ETag header. Provides a unique identifier for a specific version of a resource, allowing clients to cache and validate resources efficiently. Expect The HTTP Expect header. Indicates that the client expects certain behaviors from the server, such as support for specific features or conditions. Expires The HTTP Expires header. Indicates the date and time after which the response is considered stale, helping clients manage caching. Host The HTTP Host header. Specifies the domain name of the server and the TCP port number on which the server is listening, allowing for virtual hosting. IfMatch The HTTP If-Match header. Used to make a conditional request, allowing the client to specify that the request should only be processed if the resource matches the given ETag. IfModifiedSince The HTTP If-Modified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has been modified since the given date. IfNoneMatch The HTTP If-None-Match header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it does not match the given ETag. IfRange The HTTP If-Range header. Used to make a conditional range request, allowing the client to specify that the range should only be returned if the resource has not changed. IfUnmodifiedSince The HTTP If-Unmodified-Since header. Used to make a conditional request, allowing the client to specify that the resource should only be returned if it has not been modified since the given date. KeepAlive The HTTP Keep-Alive header. Used to specify parameters for persistent connections, allowing the client and server to maintain an open connection for multiple requests. LastModified The HTTP Last-Modified header. Indicates the date and time at which the resource was last modified, helping clients determine if they need to refresh their cached version. Link The HTTP Link header. Used to provide relationships between the current resource and other resources, often used for navigation and linking. Location The HTTP Location header. Used in redirection responses to indicate the URL to which the client should redirect. MaxForwards The HTTP Max-Forwards header. Used in OPTIONS requests to limit the number of times the request can be forwarded by proxies. Origin The HTTP Origin header. Indicates the origin of the request, helping servers implement CORS and manage cross-origin requests. P3P The HTTP P3P header. Used to indicate the privacy policy of the server, allowing clients to understand how their data will be handled. Pragma The HTTP Pragma header. Used to include implementation-specific directives that might apply to any recipient along the request/response chain. ProxyAuthenticate The HTTP Proxy-Authenticate header. Used by a proxy server to request authentication from the client, indicating the authentication method required. ProxyAuthorization The HTTP Proxy-Authorization header. Contains credentials for authenticating the client with a proxy server, allowing access to the requested resource. ProxyConnection The HTTP Proxy-Connection header. Used to control whether the network connection to the proxy server should be kept open after the current transaction. PublicKeyPins The HTTP Public-Key-Pins header. Used to prevent man-in-the-middle attacks by specifying which public keys are valid for the server's certificate. Range The HTTP Range header. Used to request a specific range of bytes from a resource, allowing clients to download large files in parts. Referer The HTTP Referer header. Indicates the URL of the resource from which the request originated, helping servers understand the source of traffic. RetryAfter The HTTP Retry-After header. Indicates how long the client should wait before making a follow-up request, often used in rate limiting scenarios. SecWebSocketAccept The HTTP Sec-WebSocket-Accept header. Used in the WebSocket handshake to confirm the server's acceptance of the connection request. SecWebSocketExtensions The HTTP Sec-WebSocket-Extensions header. Used to negotiate WebSocket extensions during the handshake, allowing for additional features and capabilities. SecWebSocketKey The HTTP Sec-WebSocket-Key header. Contains a base64-encoded value used to establish a WebSocket connection, ensuring the request is valid. SecWebSocketProtocol The HTTP Sec-WebSocket-Protocol header. Used to specify subprotocols that the client wishes to use during the WebSocket connection. SecWebSocketVersion The HTTP Sec-WebSocket-Version header. Indicates the version of the WebSocket protocol that the client wishes to use. Server The HTTP Server header. Contains information about the server software handling the request, often used for informational purposes. SetCookie The HTTP Set-Cookie header. Used to send cookies from the server to the client, allowing the server to store state information on the client. SetCookie2 The HTTP Set-Cookie2 header. Used to send cookies in a more advanced format, primarily for compatibility with older versions of HTTP. StrictTransportSecurity The HTTP Strict-Transport-Security header. Enforces secure (HTTPS) connections to the server, helping to prevent man-in-the-middle attacks. TE The HTTP TE header. Indicates the transfer encodings that are acceptable for the response, allowing for content negotiation. TSV The HTTP TSV header. Used to indicate the type of data being sent in a transaction, often used in specific applications or protocols. Trailer The HTTP Trailer header. Indicates that the sender will include additional fields in the message trailer, which can be used for metadata. TransferEncoding The HTTP Transfer-Encoding header. Specifies the form of encoding used to safely transfer the payload body to the user. Upgrade The HTTP Upgrade header. Indicates that the client prefers to upgrade to a different protocol, such as switching from HTTP/1.1 to HTTP/2. UpgradeInsecureRequests The HTTP Upgrade-Insecure-Requests header. Indicates that the client prefers to receive an upgraded version of the resource over HTTPS instead of HTTP. UserAgent The HTTP User-Agent header. Contains information about the user agent (browser or application) making the request, including its version and platform. Vary The HTTP Vary header. Indicates that the response varies based on the value of the specified request headers, allowing for content negotiation. Via The HTTP Via header. Used to track message forwards and proxies, indicating the intermediate protocols and recipients involved in the request/response chain. WWWAuthenticate The HTTP WWW-Authenticate header. Used in response to a request for authentication, indicating the authentication method that should be used to access the resource. Warning The HTTP Warning header. Provides additional information about the status or transformation of a message, often used for caching and validation. XContentDuration The HTTP X-Content-Duration header. Specifies the duration of the content in seconds, often used for media files. XContentTypeOptions The HTTP X-Content-Type-Options header. Used to prevent MIME type sniffing, ensuring that the browser respects the declared content type. XForwardedFor The HTTP X-Forwarded-For header. Used to identify the originating IP address of a client connecting to a web server through an HTTP proxy or load balancer. XForwardedHost The HTTP X-Forwarded-Host header. Used to identify the original host requested by the client in the Host HTTP request header, often used in proxy setups. XFrameOptions The HTTP X-Frame-Options header. Used to control whether a browser should be allowed to render a page in a iframe, frame, embed or object tag, helping to prevent clickjacking attacks. XPoweredBy The HTTP X-Powered-By header. Indicates the technology or framework that powers the web application, often used for informational purposes. XRequestID The HTTP X-Request-ID header. Used to uniquely identify a request for tracking and debugging purposes, often generated by the client or server. XUACompatible The HTTP X-UA-Compatible header. Used to specify the document mode that Internet Explorer should use to render the page, helping to ensure compatibility with older versions."
  },
  "api/Sisk.Core.Http.HttpRequest.Abort.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Abort.html",
    "title": "Method Abort | Sisk",
    "keywords": "Method Abort Namespace Sisk.Core.Http Assembly Sisk.Core.dll Abort() Immediately closes the connection with the client and does not send any response. public HttpResponse Abort() Returns HttpResponse Remarks This method returns an HttpResponse indicated to exit outside the scope of the request context. However, when calling this method, the connection is interrupted instantly."
  },
  "api/Sisk.Core.Http.HttpRequest.Authority.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Authority.html",
    "title": "Property Authority | Sisk",
    "keywords": "Property Authority Namespace Sisk.Core.Http Assembly Sisk.Core.dll Authority Get the requested host header with the port from this HTTP request. public string Authority { get; } Property Value string Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.Bag.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Bag.html",
    "title": "Property Bag | Sisk",
    "keywords": "Property Bag Namespace Sisk.Core.Http Assembly Sisk.Core.dll Bag Gets the managed object which holds data for an entire HTTP session. public TypedValueDictionary Bag { get; } Property Value TypedValueDictionary Remarks This property is an shortcut for RequestBag property."
  },
  "api/Sisk.Core.Http.HttpRequest.Body.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Body.html",
    "title": "Property Body | Sisk",
    "keywords": "Property Body Namespace Sisk.Core.Http Assembly Sisk.Core.dll Body Gets the HTTP request body as string, decoded by the request content encoding. public string Body { get; } Property Value string Remarks When calling this property, the entire content of the request is read into memory and stored in RawBody."
  },
  "api/Sisk.Core.Http.HttpRequest.ContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.ContentLength.html",
    "title": "Property ContentLength | Sisk",
    "keywords": "Property ContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll ContentLength Gets the content length in bytes count. public long ContentLength { get; } Property Value long Remarks This value can be negative if the content length is unknown."
  },
  "api/Sisk.Core.Http.HttpRequest.Context.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Context.html",
    "title": "Property Context | Sisk",
    "keywords": "Property Context Namespace Sisk.Core.Http Assembly Sisk.Core.dll Context Gets the HttpContext for this request. public HttpContext Context { get; } Property Value HttpContext"
  },
  "api/Sisk.Core.Http.HttpRequest.Cookies.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Cookies.html",
    "title": "Property Cookies | Sisk",
    "keywords": "Property Cookies Namespace Sisk.Core.Http Assembly Sisk.Core.dll Cookies Gets an StringKeyStore object with all cookies set in this request. public StringKeyStore Cookies { get; } Property Value StringKeyStore"
  },
  "api/Sisk.Core.Http.HttpRequest.FullPath.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.FullPath.html",
    "title": "Property FullPath | Sisk",
    "keywords": "Property FullPath Namespace Sisk.Core.Http Assembly Sisk.Core.dll FullPath Gets the raw, full HTTP request path with the query string. public string FullPath { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.FullUrl.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.FullUrl.html",
    "title": "Property FullUrl | Sisk",
    "keywords": "Property FullUrl Namespace Sisk.Core.Http Assembly Sisk.Core.dll FullUrl Gets the full URL for this request, with scheme, host, port, path and query. public string FullUrl { get; } Property Value string Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.GetEventSource.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetEventSource.html",
    "title": "Method GetEventSource | Sisk",
    "keywords": "Method GetEventSource Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetEventSource(string?) Gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in it's event source listening state. public HttpRequestEventSource GetEventSource(string? identifier = null) Parameters identifier string Optional. Defines an label to the EventStream connection, useful for finding this connection's reference later. Returns HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.HttpRequest.GetFormContent.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetFormContent.html",
    "title": "Method GetFormContent | Sisk",
    "keywords": "Method GetFormContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetFormContent() Reads the request body and extracts form data parameters from it. public StringKeyStore GetFormContent() Returns StringKeyStore"
  },
  "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContent.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetMultipartFormContent.html",
    "title": "Method GetMultipartFormContent | Sisk",
    "keywords": "Method GetMultipartFormContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetMultipartFormContent() Reads the request body and obtains a MultipartFormCollection from it. public MultipartFormCollection GetMultipartFormContent() Returns MultipartFormCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.GetRawHttpRequest.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetRawHttpRequest.html",
    "title": "Method GetRawHttpRequest | Sisk",
    "keywords": "Method GetRawHttpRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRawHttpRequest(bool, bool) Gets a visual representation of this request. public string GetRawHttpRequest(bool includeBody = true, bool appendExtraInfo = false) Parameters includeBody bool Optional. Defines if the body should be included in the output. appendExtraInfo bool Optional. Appends extra information, such as request id and date into the output. Returns string"
  },
  "api/Sisk.Core.Http.HttpRequest.GetRequestStream.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetRequestStream.html",
    "title": "Method GetRequestStream | Sisk",
    "keywords": "Method GetRequestStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRequestStream() Gets the HTTP request content stream. This property is only available while the content has not been imported by the HTTP server and will invalidate the body content cached in this object. public Stream GetRequestStream() Returns Stream"
  },
  "api/Sisk.Core.Http.HttpRequest.GetResponseStream.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetResponseStream.html",
    "title": "Method GetResponseStream | Sisk",
    "keywords": "Method GetResponseStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetResponseStream() Gets an HTTP response stream for this HTTP request. public HttpResponseStream GetResponseStream() Returns HttpResponseStream"
  },
  "api/Sisk.Core.Http.HttpRequest.GetWebSocket.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.GetWebSocket.html",
    "title": "Method GetWebSocket | Sisk",
    "keywords": "Method GetWebSocket Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetWebSocket(string?, string?) Accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. public HttpWebSocket GetWebSocket(string? subprotocol = null, string? identifier = null) Parameters subprotocol string Optional. Determines the sub-protocol to plug the websocket in. identifier string Optional. Defines an label to the Web Socket connection, useful for finding this connection's reference later. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.HttpRequest.HasContents.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.HasContents.html",
    "title": "Property HasContents | Sisk",
    "keywords": "Property HasContents Namespace Sisk.Core.Http Assembly Sisk.Core.dll HasContents Gets a boolean indicating whether this request has body contents. public bool HasContents { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpRequest.Headers.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Http Assembly Sisk.Core.dll Headers Gets the HTTP request headers. public HttpHeaderCollection Headers { get; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.Host.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Host.html",
    "title": "Property Host | Sisk",
    "keywords": "Property Host Namespace Sisk.Core.Http Assembly Sisk.Core.dll Host Get the requested host (without port) for this HttpRequest. public string? Host { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.IsContentAvailable.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.IsContentAvailable.html",
    "title": "Property IsContentAvailable | Sisk",
    "keywords": "Property IsContentAvailable Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsContentAvailable Gets a boolean indicating whether this request has body contents and whether it has already been read into memory by the server. public bool IsContentAvailable { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpRequest.IsSecure.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.IsSecure.html",
    "title": "Property IsSecure | Sisk",
    "keywords": "Property IsSecure Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSecure Gets a boolean indicating whether this request was locally made by an secure transport context (SSL/TLS) or not. public bool IsSecure { get; } Property Value bool Remarks This property brings local request data, so it may not reflect the original client request when used with proxy or CDNs."
  },
  "api/Sisk.Core.Http.HttpRequest.Method.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Http Assembly Sisk.Core.dll Method Gets the HTTP request method. public HttpMethod Method { get; } Property Value HttpMethod"
  },
  "api/Sisk.Core.Http.HttpRequest.Path.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Http Assembly Sisk.Core.dll Path Gets the HTTP request path without the query string. public string Path { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.Query.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Query.html",
    "title": "Property Query | Sisk",
    "keywords": "Property Query Namespace Sisk.Core.Http Assembly Sisk.Core.dll Query Gets the HTTP request query value collection. public StringValueCollection Query { get; } Property Value StringValueCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.QueryString.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.QueryString.html",
    "title": "Property QueryString | Sisk",
    "keywords": "Property QueryString Namespace Sisk.Core.Http Assembly Sisk.Core.dll QueryString Gets the HTTP request URL raw query string, including the '?' char. public string QueryString { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpRequest.RawBody.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RawBody.html",
    "title": "Property RawBody | Sisk",
    "keywords": "Property RawBody Namespace Sisk.Core.Http Assembly Sisk.Core.dll RawBody Gets the HTTP request body as a byte array. public byte[] RawBody { get; } Property Value byte[] Remarks When calling this property, the entire content of the request is read into memory."
  },
  "api/Sisk.Core.Http.HttpRequest.RemoteAddress.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RemoteAddress.html",
    "title": "Property RemoteAddress | Sisk",
    "keywords": "Property RemoteAddress Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoteAddress Gets the incoming local IP address from the request. public IPAddress RemoteAddress { get; } Property Value IPAddress"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestEncoding.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestEncoding.html",
    "title": "Property RequestEncoding | Sisk",
    "keywords": "Property RequestEncoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestEncoding Gets an string Encoding that can be used to decode text in this HTTP request. public Encoding RequestEncoding { get; } Property Value Encoding"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestId.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestId.html",
    "title": "Property RequestId | Sisk",
    "keywords": "Property RequestId Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestId Gets a unique random ID for this request. public Guid RequestId { get; } Property Value Guid"
  },
  "api/Sisk.Core.Http.HttpRequest.RequestedAt.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RequestedAt.html",
    "title": "Property RequestedAt | Sisk",
    "keywords": "Property RequestedAt Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestedAt Gets the moment which the request was received by the server. public DateTime RequestedAt { get; } Property Value DateTime"
  },
  "api/Sisk.Core.Http.HttpRequest.RouteParameters.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.RouteParameters.html",
    "title": "Property RouteParameters | Sisk",
    "keywords": "Property RouteParameters Namespace Sisk.Core.Http Assembly Sisk.Core.dll RouteParameters Gets the StringValueCollection object which represents the current route parameters. public StringValueCollection RouteParameters { get; } Property Value StringValueCollection"
  },
  "api/Sisk.Core.Http.HttpRequest.SendTo.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.SendTo.html",
    "title": "Method SendTo | Sisk",
    "keywords": "Method SendTo Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendTo(RouteAction) Calls another handler for this request, preserving the current call-stack frame, and then returns the response from it. This method manages to prevent possible stack overflows. public object SendTo(RouteAction otherCallback) Parameters otherCallback RouteAction Defines the RouteAction method which will handle this request. Returns object"
  },
  "api/Sisk.Core.Http.HttpRequest.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this HttpRequest object. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpRequest.Uri.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.Uri.html",
    "title": "Property Uri | Sisk",
    "keywords": "Property Uri Namespace Sisk.Core.Http Assembly Sisk.Core.dll Uri Gets the System.Uri component for this HTTP request requested URL. public Uri Uri { get; } Property Value Uri"
  },
  "api/Sisk.Core.Http.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.HttpRequest.html",
    "title": "Class HttpRequest | Sisk",
    "keywords": "Class HttpRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP request received by a Sisk server. public sealed class HttpRequest Inheritance object HttpRequest Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Authority Get the requested host header with the port from this HTTP request. Bag Gets the managed object which holds data for an entire HTTP session. Body Gets the HTTP request body as string, decoded by the request content encoding. ContentLength Gets the content length in bytes count. Context Gets the HttpContext for this request. Cookies Gets an StringKeyStore object with all cookies set in this request. FullPath Gets the raw, full HTTP request path with the query string. FullUrl Gets the full URL for this request, with scheme, host, port, path and query. HasContents Gets a boolean indicating whether this request has body contents. Headers Gets the HTTP request headers. Host Get the requested host (without port) for this HttpRequest. IsContentAvailable Gets a boolean indicating whether this request has body contents and whether it has already been read into memory by the server. IsSecure Gets a boolean indicating whether this request was locally made by an secure transport context (SSL/TLS) or not. Method Gets the HTTP request method. Path Gets the HTTP request path without the query string. Query Gets the HTTP request query value collection. QueryString Gets the HTTP request URL raw query string, including the '?' char. RawBody Gets the HTTP request body as a byte array. RemoteAddress Gets the incoming local IP address from the request. RequestEncoding Gets an string Encoding that can be used to decode text in this HTTP request. RequestId Gets a unique random ID for this request. RequestedAt Gets the moment which the request was received by the server. RouteParameters Gets the StringValueCollection object which represents the current route parameters. Uri Gets the System.Uri component for this HTTP request requested URL. Methods Abort() Immediately closes the connection with the client and does not send any response. GetEventSource(string?) Gets an Event Source interface for this request. Calling this method will put this HttpRequest instance in it's event source listening state. GetFormContent() Reads the request body and extracts form data parameters from it. GetMultipartFormContent() Reads the request body and obtains a MultipartFormCollection from it. GetRawHttpRequest(bool, bool) Gets a visual representation of this request. GetRequestStream() Gets the HTTP request content stream. This property is only available while the content has not been imported by the HTTP server and will invalidate the body content cached in this object. GetResponseStream() Gets an HTTP response stream for this HTTP request. GetWebSocket(string?, string?) Accepts and acquires a websocket for this request. Calling this method will put this HttpRequest instance in streaming state. SendTo(RouteAction) Calls another handler for this request, preserving the current call-stack frame, and then returns the response from it. This method manages to prevent possible stack overflows. ToString() Gets an string representation of this HttpRequest object."
  },
  "api/Sisk.Core.Http.HttpRequestException.html": {
    "href": "api/Sisk.Core.Http.HttpRequestException.html",
    "title": "Class HttpRequestException | Sisk",
    "keywords": "Class HttpRequestException Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an exception that is thrown while a request is being interpreted by the HTTP server. public sealed class HttpRequestException : Exception, ISerializable Inheritance object Exception HttpRequestException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.Data Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode()"
  },
  "api/Sisk.Core.Http.HttpResponse.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.-ctor.html",
    "title": "Constructor HttpResponse | Sisk",
    "keywords": "Constructor HttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpResponse() Creates an new HttpResponse instance with HTTP OK status code and no content. public HttpResponse() HttpResponse(HttpStatusCode) Creates an new HttpResponse instance with given status code. public HttpResponse(HttpStatusCode status) Parameters status HttpStatusCode The HttpStatusCode of this HTTP response. HttpResponse(int) Creates an new HttpResponse instance with given status code. public HttpResponse(int status) Parameters status int The status code of this HTTP response. HttpResponse(int, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP content. public HttpResponse(int status, HttpContent? content) Parameters status int The status code of this HTTP response. content HttpContent The response content, if any. HttpResponse(HttpContent?) Creates an new HttpResponse instance with given HTTP content, with default status code as 200 OK. public HttpResponse(HttpContent? content) Parameters content HttpContent The response content, if any. HttpResponse(string) Creates an new HttpResponse instanec with given string content and status code as 200 OK. public HttpResponse(string stringContent) Parameters stringContent string The UTF-8 string content. HttpResponse(HttpStatusCode, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP contents. public HttpResponse(HttpStatusCode status, HttpContent? content) Parameters status HttpStatusCode The HttpStatusCode of this HTTP response. content HttpContent The response content, if any. HttpResponse(in HttpStatusInformation) Creates an new HttpResponse instance with given status code. public HttpResponse(in HttpStatusInformation status) Parameters status HttpStatusInformation The HttpStatusInformation of this HTTP response."
  },
  "api/Sisk.Core.Http.HttpResponse.Content.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Content.html",
    "title": "Property Content | Sisk",
    "keywords": "Property Content Namespace Sisk.Core.Http Assembly Sisk.Core.dll Content Gets or sets the HTTP response body contents. public HttpContent? Content { get; set; } Property Value HttpContent"
  },
  "api/Sisk.Core.Http.HttpResponse.Equals.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) public override bool Equals(object? obj) Parameters obj object Returns bool"
  },
  "api/Sisk.Core.Http.HttpResponse.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.HttpResponse.GetRawHttpResponse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.GetRawHttpResponse.html",
    "title": "Method GetRawHttpResponse | Sisk",
    "keywords": "Method GetRawHttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRawHttpResponse(bool) Gets a visual representation of this HTTP response. public string GetRawHttpResponse(bool includeBody = true) Parameters includeBody bool Determines whether the message content will also be included in the return from this function. Returns string"
  },
  "api/Sisk.Core.Http.HttpResponse.Headers.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Headers.html",
    "title": "Property Headers | Sisk",
    "keywords": "Property Headers Namespace Sisk.Core.Http Assembly Sisk.Core.dll Headers Gets or sets the HttpHeaderCollection instance of the HTTP response headers. public HttpHeaderCollection Headers { get; set; } Property Value HttpHeaderCollection"
  },
  "api/Sisk.Core.Http.HttpResponse.Refuse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Refuse.html",
    "title": "Method Refuse | Sisk",
    "keywords": "Method Refuse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Refuse() Creates an HttpResponse object which closes the connection with the client immediately (ECONNRESET). public static HttpResponse Refuse() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.HttpResponse.SendChunked.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.SendChunked.html",
    "title": "Property SendChunked | Sisk",
    "keywords": "Property SendChunked Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendChunked Gets or sets whether the HTTP response will be sent chunked. When setting this property to true, the Content-Length header is automatically omitted. public bool SendChunked { get; set; } Property Value bool Remarks The response is always sent as chunked when it is not possible to determine the size of the content to send."
  },
  "api/Sisk.Core.Http.HttpResponse.SetCookie.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.SetCookie.html",
    "title": "Method SetCookie | Sisk",
    "keywords": "Method SetCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(Cookie cookie) Parameters cookie Cookie The cookie object. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value) Parameters name string The cookie name. value string The cookie value. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter."
  },
  "api/Sisk.Core.Http.HttpResponse.Status.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.Status.html",
    "title": "Property Status | Sisk",
    "keywords": "Property Status Namespace Sisk.Core.Http Assembly Sisk.Core.dll Status Gets or sets the HTTP status code and description for this HTTP response. public HttpStatusInformation Status { get; set; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpResponse.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpResponse.html": {
    "href": "api/Sisk.Core.Http.HttpResponse.html",
    "title": "Class HttpResponse | Sisk",
    "keywords": "Class HttpResponse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an HTTP Response. public class HttpResponse Inheritance object HttpResponse Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object, object) object.ReferenceEquals(object, object) Extension Methods HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, HttpContent) HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, string) HttpResponseExtensions.WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) HttpResponseExtensions.WithCookie<THttpResponse>(THttpResponse, Cookie) HttpResponseExtensions.WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, StringKeyStore) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, NameValueCollection) HttpResponseExtensions.WithHeader<THttpResponse>(THttpResponse, string, string) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, int) HttpResponseExtensions.WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Constructors HttpResponse() Creates an new HttpResponse instance with HTTP OK status code and no content. HttpResponse(in HttpStatusInformation) Creates an new HttpResponse instance with given status code. HttpResponse(int) Creates an new HttpResponse instance with given status code. HttpResponse(int, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP content. HttpResponse(HttpContent?) Creates an new HttpResponse instance with given HTTP content, with default status code as 200 OK. HttpResponse(HttpStatusCode) Creates an new HttpResponse instance with given status code. HttpResponse(HttpStatusCode, HttpContent?) Creates an new HttpResponse instance with given status code and HTTP contents. HttpResponse(string) Creates an new HttpResponse instanec with given string content and status code as 200 OK. Properties Content Gets or sets the HTTP response body contents. Headers Gets or sets the HttpHeaderCollection instance of the HTTP response headers. SendChunked Gets or sets whether the HTTP response will be sent chunked. When setting this property to true, the Content-Length header is automatically omitted. Status Gets or sets the HTTP status code and description for this HTTP response. Methods Equals(object?) GetHashCode() GetRawHttpResponse(bool) Gets a visual representation of this HTTP response. Refuse() Creates an HttpResponse object which closes the connection with the client immediately (ECONNRESET). SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. ToString()"
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithContent.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithContent.html",
    "title": "Method WithContent | Sisk",
    "keywords": "Method WithContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithContent<THttpResponse>(THttpResponse, string) Sets an UTF-8 string as the HTTP response content in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, string content) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content string The UTF-8 string containing the response body. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) Sets an string as the HTTP response content in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, string content, Encoding? encoding, string mimeType) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content string The string containing the response body. encoding Encoding The encoding to encode the string message. mimeType string The mime-type of the response content. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithContent<THttpResponse>(THttpResponse, HttpContent) Sets an HttpContent as the HTTP content body in this HttpResponse. public static THttpResponse WithContent<THttpResponse>(this THttpResponse response, HttpContent content) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. content HttpContent The HTTP content object. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithCookie.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithCookie.html",
    "title": "Method WithCookie | Sisk",
    "keywords": "Method WithCookie Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public static THttpResponse WithCookie<THttpResponse>(this THttpResponse response, string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter. Returns THttpResponse Type Parameters THttpResponse The type which implements HttpResponse. WithCookie<THttpResponse>(THttpResponse, Cookie) Sets a cookie and sends it in the response to be set by the client. public static THttpResponse WithCookie<THttpResponse>(this THttpResponse response, Cookie cookie) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. cookie Cookie The cookie object. Returns THttpResponse Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithHeader.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithHeader.html",
    "title": "Method WithHeader | Sisk",
    "keywords": "Method WithHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithHeader<THttpResponse>(THttpResponse, string, string) Sets an HTTP header in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, string headerName, string headerValue) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headerName string The name of the header. headerValue string The header value. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithHeader<THttpResponse>(THttpResponse, NameValueCollection) Sets an list of HTTP headers in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, NameValueCollection headers) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headers NameValueCollection The collection of HTTP headers. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithHeader<THttpResponse>(THttpResponse, StringKeyStore) Sets an list of HTTP headers in this HttpResponse. public static THttpResponse WithHeader<THttpResponse>(this THttpResponse response, StringKeyStore headers) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. headers StringKeyStore The collection of HTTP headers. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.WithStatus.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.WithStatus.html",
    "title": "Method WithStatus | Sisk",
    "keywords": "Method WithStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll WithStatus<THttpResponse>(THttpResponse, int) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, int httpStatusCode) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. httpStatusCode int The HTTP status code. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, HttpStatusCode httpStatusCode) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. httpStatusCode HttpStatusCode The HTTP status code. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse. WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) Sets the HTTP status code of this HttpResponse. public static THttpResponse WithStatus<THttpResponse>(this THttpResponse response, in HttpStatusInformation statusInformation) where THttpResponse : HttpResponse Parameters response THttpResponse The HttpResponse object. statusInformation HttpStatusInformation The HTTP status information. Returns THttpResponse The self THttpResponse object. Type Parameters THttpResponse The type which implements HttpResponse."
  },
  "api/Sisk.Core.Http.HttpResponseExtensions.html": {
    "href": "api/Sisk.Core.Http.HttpResponseExtensions.html",
    "title": "Class HttpResponseExtensions | Sisk",
    "keywords": "Class HttpResponseExtensions Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides useful extensions for HttpResponse objects. public static class HttpResponseExtensions Inheritance object HttpResponseExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods WithContent<THttpResponse>(THttpResponse, HttpContent) Sets an HttpContent as the HTTP content body in this HttpResponse. WithContent<THttpResponse>(THttpResponse, string) Sets an UTF-8 string as the HTTP response content in this HttpResponse. WithContent<THttpResponse>(THttpResponse, string, Encoding?, string) Sets an string as the HTTP response content in this HttpResponse. WithCookie<THttpResponse>(THttpResponse, Cookie) Sets a cookie and sends it in the response to be set by the client. WithCookie<THttpResponse>(THttpResponse, string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. WithHeader<THttpResponse>(THttpResponse, StringKeyStore) Sets an list of HTTP headers in this HttpResponse. WithHeader<THttpResponse>(THttpResponse, NameValueCollection) Sets an list of HTTP headers in this HttpResponse. WithHeader<THttpResponse>(THttpResponse, string, string) Sets an HTTP header in this HttpResponse. WithStatus<THttpResponse>(THttpResponse, in HttpStatusInformation) Sets the HTTP status code of this HttpResponse. WithStatus<THttpResponse>(THttpResponse, int) Sets the HTTP status code of this HttpResponse. WithStatus<THttpResponse>(THttpResponse, HttpStatusCode) Sets the HTTP status code of this HttpResponse."
  },
  "api/Sisk.Core.Http.HttpServer.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpServer.-ctor.html",
    "title": "Constructor HttpServer | Sisk",
    "keywords": "Constructor HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServer(HttpServerConfiguration) Creates a new default configuration HttpServer instance with the given Route and server configuration. public HttpServer(HttpServerConfiguration configuration) Parameters configuration HttpServerConfiguration The configuration object of the server."
  },
  "api/Sisk.Core.Http.HttpServer.CreateBuilder.html": {
    "href": "api/Sisk.Core.Http.HttpServer.CreateBuilder.html",
    "title": "Method CreateBuilder | Sisk",
    "keywords": "Method CreateBuilder Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateBuilder(Action<HttpServerHostContextBuilder>) Builds an HttpServerHostContext context invoking the handler on it. public static HttpServerHostContextBuilder CreateBuilder(Action<HttpServerHostContextBuilder> handler) Parameters handler Action<HttpServerHostContextBuilder> The action which will configure the host context. Returns HttpServerHostContextBuilder CreateBuilder(ushort) Builds an empty HttpServerHostContext context with predefined listening port. public static HttpServerHostContextBuilder CreateBuilder(ushort port) Parameters port ushort Returns HttpServerHostContextBuilder CreateBuilder(string) Builds an empty HttpServerHostContext context with predefined listening host string. public static HttpServerHostContextBuilder CreateBuilder(string listeningHost) Parameters listeningHost string Returns HttpServerHostContextBuilder CreateBuilder() Builds an empty HttpServerHostContext context. public static HttpServerHostContextBuilder CreateBuilder() Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.Core.Http.HttpServer.CreateListener.html": {
    "href": "api/Sisk.Core.Http.HttpServer.CreateListener.html",
    "title": "Method CreateListener | Sisk",
    "keywords": "Method CreateListener Namespace Sisk.Core.Http Assembly Sisk.Core.dll CreateListener() Gets an listening and running HTTP server in an random port. public static HttpServer CreateListener() Returns HttpServer CreateListener(ushort) Gets an listening and running HTTP server in the specified port. public static HttpServer CreateListener(ushort port) Parameters port ushort The listening port of the HTTP server. Returns HttpServer CreateListener(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an listening and running HTTP server in the specified port. public static HttpServer CreateListener(ushort insecureHttpPort, out HttpServerConfiguration configuration, out ListeningHost host, out Router router) Parameters insecureHttpPort ushort The insecure port where the HTTP server will listen. configuration HttpServerConfiguration The HttpServerConfiguration object issued from this method. host ListeningHost The ListeningHost object issued from this method. router Router The Router object issued from this method. Returns HttpServer"
  },
  "api/Sisk.Core.Http.HttpServer.Dispose.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. public void Dispose()"
  },
  "api/Sisk.Core.Http.HttpServer.Emit.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Emit.html",
    "title": "Method Emit | Sisk",
    "keywords": "Method Emit Namespace Sisk.Core.Http Assembly Sisk.Core.dll Emit(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an non-listening HTTP server with configuration, listening host, and router. public static HttpServer Emit(ushort insecureHttpPort, out HttpServerConfiguration configuration, out ListeningHost host, out Router router) Parameters insecureHttpPort ushort The insecure port where the HTTP server will listen. configuration HttpServerConfiguration The HttpServerConfiguration object issued from this method. host ListeningHost The ListeningHost object issued from this method. router Router The Router object issued from this method. Returns HttpServer"
  },
  "api/Sisk.Core.Http.HttpServer.EventSources.html": {
    "href": "api/Sisk.Core.Http.HttpServer.EventSources.html",
    "title": "Property EventSources | Sisk",
    "keywords": "Property EventSources Namespace Sisk.Core.Http Assembly Sisk.Core.dll EventSources Gets an HttpEventSourceCollection with active event source connections in this HTTP server. public HttpEventSourceCollection EventSources { get; } Property Value HttpEventSourceCollection"
  },
  "api/Sisk.Core.Http.HttpServer.IsDynamicCodeSupported.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsDynamicCodeSupported.html",
    "title": "Property IsDynamicCodeSupported | Sisk",
    "keywords": "Property IsDynamicCodeSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsDynamicCodeSupported Gets an bool indicating if the current environment supports dynamic code or it's running in an AOT assembly. public static bool IsDynamicCodeSupported { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.IsListening.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsListening.html",
    "title": "Property IsListening | Sisk",
    "keywords": "Property IsListening Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsListening Gets an boolean indicating if this HTTP server is running and listening. public bool IsListening { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.IsSupported.html": {
    "href": "api/Sisk.Core.Http.HttpServer.IsSupported.html",
    "title": "Property IsSupported | Sisk",
    "keywords": "Property IsSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSupported Gets an bool indicating if Sisk can be used with the current environment. public static bool IsSupported { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServer.ListeningPrefixes.html": {
    "href": "api/Sisk.Core.Http.HttpServer.ListeningPrefixes.html",
    "title": "Property ListeningPrefixes | Sisk",
    "keywords": "Property ListeningPrefixes Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningPrefixes Gets an string array containing all URL prefixes which this HTTP server is listening to. public string[] ListeningPrefixes { get; } Property Value string[]"
  },
  "api/Sisk.Core.Http.HttpServer.PoweredBy.html": {
    "href": "api/Sisk.Core.Http.HttpServer.PoweredBy.html",
    "title": "Property PoweredBy | Sisk",
    "keywords": "Property PoweredBy Namespace Sisk.Core.Http Assembly Sisk.Core.dll PoweredBy Gets the X-Powered-By Sisk header value. public static string PoweredBy { get; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpServer.RegisterHandler.html": {
    "href": "api/Sisk.Core.Http.HttpServer.RegisterHandler.html",
    "title": "Method RegisterHandler | Sisk",
    "keywords": "Method RegisterHandler Namespace Sisk.Core.Http Assembly Sisk.Core.dll RegisterHandler<T>() Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. public void RegisterHandler<T>() where T : HttpServerHandler, new() Type Parameters T The handler which implements HttpServerHandler. RegisterHandler(HttpServerHandler) Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. public void RegisterHandler(HttpServerHandler obj) Parameters obj HttpServerHandler The instance of the server handler."
  },
  "api/Sisk.Core.Http.HttpServer.Restart.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Restart.html",
    "title": "Method Restart | Sisk",
    "keywords": "Method Restart Namespace Sisk.Core.Http Assembly Sisk.Core.dll Restart() Restarts this HTTP server, sending all processing responses and starting them again, reading the listening ports again. public void Restart()"
  },
  "api/Sisk.Core.Http.HttpServer.ServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.HttpServer.ServerConfiguration.html",
    "title": "Property ServerConfiguration | Sisk",
    "keywords": "Property ServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServerConfiguration Gets or sets the Server Configuration object. public HttpServerConfiguration ServerConfiguration { get; set; } Property Value HttpServerConfiguration"
  },
  "api/Sisk.Core.Http.HttpServer.SiskVersion.html": {
    "href": "api/Sisk.Core.Http.HttpServer.SiskVersion.html",
    "title": "Property SiskVersion | Sisk",
    "keywords": "Property SiskVersion Namespace Sisk.Core.Http Assembly Sisk.Core.dll SiskVersion Gets the current Sisk version. public static Version SiskVersion { get; } Property Value Version"
  },
  "api/Sisk.Core.Http.HttpServer.Start.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http Assembly Sisk.Core.dll Start() Starts listening to the set port and handling requests on this server. public void Start()"
  },
  "api/Sisk.Core.Http.HttpServer.Stop.html": {
    "href": "api/Sisk.Core.Http.HttpServer.Stop.html",
    "title": "Method Stop | Sisk",
    "keywords": "Method Stop Namespace Sisk.Core.Http Assembly Sisk.Core.dll Stop() Stops the server from listening and stops the request handler. public void Stop()"
  },
  "api/Sisk.Core.Http.HttpServer.WaitNext.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WaitNext.html",
    "title": "Method WaitNext | Sisk",
    "keywords": "Method WaitNext Namespace Sisk.Core.Http Assembly Sisk.Core.dll WaitNext() Waits for the next execution result from the server. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. public HttpServerExecutionResult WaitNext() Returns HttpServerExecutionResult Remarks Calling this method, it starts the HTTP server if it ins't started yet."
  },
  "api/Sisk.Core.Http.HttpServer.WaitNextAsync.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WaitNextAsync.html",
    "title": "Method WaitNextAsync | Sisk",
    "keywords": "Method WaitNextAsync Namespace Sisk.Core.Http Assembly Sisk.Core.dll WaitNextAsync() Waits for the next execution result from the server asynchronously. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. public Task<HttpServerExecutionResult> WaitNextAsync() Returns Task<HttpServerExecutionResult> Remarks Calling this method, it starts the HTTP server if it ins't started yet."
  },
  "api/Sisk.Core.Http.HttpServer.WebSockets.html": {
    "href": "api/Sisk.Core.Http.HttpServer.WebSockets.html",
    "title": "Property WebSockets | Sisk",
    "keywords": "Property WebSockets Namespace Sisk.Core.Http Assembly Sisk.Core.dll WebSockets Gets an HttpWebSocketConnectionCollection with active Web Sockets connections in this HTTP server. public HttpWebSocketConnectionCollection WebSockets { get; } Property Value HttpWebSocketConnectionCollection"
  },
  "api/Sisk.Core.Http.HttpServer.html": {
    "href": "api/Sisk.Core.Http.HttpServer.html",
    "title": "Class HttpServer | Sisk",
    "keywords": "Class HttpServer Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides an lightweight HTTP server powered by Sisk. public sealed class HttpServer : IDisposable Inheritance object HttpServer Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServer(HttpServerConfiguration) Creates a new default configuration HttpServer instance with the given Route and server configuration. Properties EventSources Gets an HttpEventSourceCollection with active event source connections in this HTTP server. IsDynamicCodeSupported Gets an bool indicating if the current environment supports dynamic code or it's running in an AOT assembly. IsListening Gets an boolean indicating if this HTTP server is running and listening. IsSupported Gets an bool indicating if Sisk can be used with the current environment. ListeningPrefixes Gets an string array containing all URL prefixes which this HTTP server is listening to. PoweredBy Gets the X-Powered-By Sisk header value. ServerConfiguration Gets or sets the Server Configuration object. SiskVersion Gets the current Sisk version. WebSockets Gets an HttpWebSocketConnectionCollection with active Web Sockets connections in this HTTP server. Methods CreateBuilder() Builds an empty HttpServerHostContext context. CreateBuilder(Action<HttpServerHostContextBuilder>) Builds an HttpServerHostContext context invoking the handler on it. CreateBuilder(string) Builds an empty HttpServerHostContext context with predefined listening host string. CreateBuilder(ushort) Builds an empty HttpServerHostContext context with predefined listening port. CreateListener() Gets an listening and running HTTP server in an random port. CreateListener(ushort) Gets an listening and running HTTP server in the specified port. CreateListener(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an listening and running HTTP server in the specified port. Dispose() Invalidates this class and releases the resources used by it, and permanently closes the HTTP server. Emit(ushort, out HttpServerConfiguration, out ListeningHost, out Router) Gets an non-listening HTTP server with configuration, listening host, and router. RegisterHandler(HttpServerHandler) Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. RegisterHandler<T>() Associate an HttpServerHandler in this HttpServer to handle functions such as requests, routers and contexts. Restart() Restarts this HTTP server, sending all processing responses and starting them again, reading the listening ports again. Start() Starts listening to the set port and handling requests on this server. Stop() Stops the server from listening and stops the request handler. WaitNext() Waits for the next execution result from the server. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests. WaitNextAsync() Waits for the next execution result from the server asynchronously. This method obtains the next completed context from the HTTP server, both with the request and its response. This method does not interrupt the asynchronous processing of requests."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.-ctor.html",
    "title": "Constructor HttpServerConfiguration | Sisk",
    "keywords": "Constructor HttpServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServerConfiguration() Creates an new HttpServerConfiguration instance with no parameters. public HttpServerConfiguration()"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsFormat.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsFormat.html",
    "title": "Property AccessLogsFormat | Sisk",
    "keywords": "Property AccessLogsFormat Namespace Sisk.Core.Http Assembly Sisk.Core.dll AccessLogsFormat Gets or sets the access logging format for incoming HTTP requests. public string AccessLogsFormat { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsStream.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AccessLogsStream.html",
    "title": "Property AccessLogsStream | Sisk",
    "keywords": "Property AccessLogsStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll AccessLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server access messages to. public LogStream? AccessLogsStream { get; set; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.AsyncRequestProcessing.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.AsyncRequestProcessing.html",
    "title": "Property AsyncRequestProcessing | Sisk",
    "keywords": "Property AsyncRequestProcessing Namespace Sisk.Core.Http Assembly Sisk.Core.dll AsyncRequestProcessing Gets or sets whether the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. public bool AsyncRequestProcessing { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable.html",
    "title": "Property ConvertIAsyncEnumerableIntoEnumerable | Sisk",
    "keywords": "Property ConvertIAsyncEnumerableIntoEnumerable Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConvertIAsyncEnumerableIntoEnumerable Gets or sets whether the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. public bool ConvertIAsyncEnumerableIntoEnumerable { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.DefaultCultureInfo.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.DefaultCultureInfo.html",
    "title": "Property DefaultCultureInfo | Sisk",
    "keywords": "Property DefaultCultureInfo Namespace Sisk.Core.Http Assembly Sisk.Core.dll DefaultCultureInfo Gets or sets the default CultureInfo object which the HTTP server will apply to the request handlers and callbacks thread. public CultureInfo? DefaultCultureInfo { get; set; } Property Value CultureInfo"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.Dispose.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() Frees the resources and invalidates this instance. public void Dispose()"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.DisposeDisposableContextValues.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.DisposeDisposableContextValues.html",
    "title": "Property DisposeDisposableContextValues | Sisk",
    "keywords": "Property DisposeDisposableContextValues Namespace Sisk.Core.Http Assembly Sisk.Core.dll DisposeDisposableContextValues Gets or sets whether the HTTP server should dispose all IDisposable values in the HttpContext bag when an HTTP session is closed. public bool DisposeDisposableContextValues { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ErrorsLogsStream.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ErrorsLogsStream.html",
    "title": "Property ErrorsLogsStream | Sisk",
    "keywords": "Property ErrorsLogsStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll ErrorsLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server error transcriptions to. public LogStream? ErrorsLogsStream { get; set; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ForceTrailingSlash.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ForceTrailingSlash.html",
    "title": "Property ForceTrailingSlash | Sisk",
    "keywords": "Property ForceTrailingSlash Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForceTrailingSlash Gets or sets whether the HTTP server should automatically rewrite GET requests to end their path with /. This is applyable only to non-Regex routes. public bool ForceTrailingSlash { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ForwardingResolver.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ForwardingResolver.html",
    "title": "Property ForwardingResolver | Sisk",
    "keywords": "Property ForwardingResolver Namespace Sisk.Core.Http Assembly Sisk.Core.dll ForwardingResolver Gets or sets an object that is responsible for resolving the client address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. public ForwardingResolver? ForwardingResolver { get; set; } Property Value ForwardingResolver"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.IdleConnectionTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.IdleConnectionTimeout.html",
    "title": "Property IdleConnectionTimeout | Sisk",
    "keywords": "Property IdleConnectionTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll IdleConnectionTimeout Gets or sets the maximum time allowed for an idle connection. public TimeSpan IdleConnectionTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.IncludeRequestIdHeader.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.IncludeRequestIdHeader.html",
    "title": "Property IncludeRequestIdHeader | Sisk",
    "keywords": "Property IncludeRequestIdHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll IncludeRequestIdHeader Gets or sets whether the server should include the \"X-Request-Id\" header in response headers. public bool IncludeRequestIdHeader { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.KeepAlive.html",
    "title": "Property KeepAlive | Sisk",
    "keywords": "Property KeepAlive Namespace Sisk.Core.Http Assembly Sisk.Core.dll KeepAlive Gets or sets whether the client should mantain an persistent connection with the HTTP server. public bool KeepAlive { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ListeningHosts.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ListeningHosts.html",
    "title": "Property ListeningHosts | Sisk",
    "keywords": "Property ListeningHosts Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHosts Gets or sets the listening hosts repository that the HttpServer instance will listen to. public ListeningHostRepository ListeningHosts { get; set; } Property Value ListeningHostRepository"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength.html",
    "title": "Property MaximumContentLength | Sisk",
    "keywords": "Property MaximumContentLength Namespace Sisk.Core.Http Assembly Sisk.Core.dll MaximumContentLength Gets or sets the maximum size of a request body before it is closed by the socket. public long MaximumContentLength { get; set; } Property Value long Remarks Leave it as \"0\" to set the maximum content length to unlimited."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.NormalizeHeadersEncodings.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.NormalizeHeadersEncodings.html",
    "title": "Property NormalizeHeadersEncodings | Sisk",
    "keywords": "Property NormalizeHeadersEncodings Namespace Sisk.Core.Http Assembly Sisk.Core.dll NormalizeHeadersEncodings Gets or sets whether the HTTP server should convert request headers encoding to the content encoding. public bool NormalizeHeadersEncodings { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.OptionsLogMode.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.OptionsLogMode.html",
    "title": "Property OptionsLogMode | Sisk",
    "keywords": "Property OptionsLogMode Namespace Sisk.Core.Http Assembly Sisk.Core.dll OptionsLogMode Gets or sets the log mode that the HTTP server should use to log OPTIONS requests. public LogOutput OptionsLogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.RemoteRequestsAction.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.RemoteRequestsAction.html",
    "title": "Property RemoteRequestsAction | Sisk",
    "keywords": "Property RemoteRequestsAction Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoteRequestsAction Gets or sets the server's action when it receives an HTTP request outside the localhost. public RequestListenAction RemoteRequestsAction { get; set; } Property Value RequestListenAction Remarks It is recommended to use Drop in this property when working with a reverse proxy or in environments where the service is not directly exposed to the internet."
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.SendSiskHeader.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.SendSiskHeader.html",
    "title": "Property SendSiskHeader | Sisk",
    "keywords": "Property SendSiskHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll SendSiskHeader Gets or sets whether the HTTP server should send the X-Powered-By header in all responses. public bool SendSiskHeader { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions.html",
    "title": "Property ThrowExceptions | Sisk",
    "keywords": "Property ThrowExceptions Namespace Sisk.Core.Http Assembly Sisk.Core.dll ThrowExceptions Gets or sets whether the server should throw exceptions instead of reporting it on HttpServerExecutionStatus if any is thrown while processing requests. public bool ThrowExceptions { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerConfiguration.html": {
    "href": "api/Sisk.Core.Http.HttpServerConfiguration.html",
    "title": "Class HttpServerConfiguration | Sisk",
    "keywords": "Class HttpServerConfiguration Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides execution parameters for an HttpServer. public sealed class HttpServerConfiguration : IDisposable Inheritance object HttpServerConfiguration Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServerConfiguration() Creates an new HttpServerConfiguration instance with no parameters. Properties AccessLogsFormat Gets or sets the access logging format for incoming HTTP requests. AccessLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server access messages to. AsyncRequestProcessing Gets or sets whether the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. ConvertIAsyncEnumerableIntoEnumerable Gets or sets whether the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. DefaultCultureInfo Gets or sets the default CultureInfo object which the HTTP server will apply to the request handlers and callbacks thread. DisposeDisposableContextValues Gets or sets whether the HTTP server should dispose all IDisposable values in the HttpContext bag when an HTTP session is closed. ErrorsLogsStream Gets or sets the LogStream object which the HTTP server will write HTTP server error transcriptions to. ForceTrailingSlash Gets or sets whether the HTTP server should automatically rewrite GET requests to end their path with /. This is applyable only to non-Regex routes. ForwardingResolver Gets or sets an object that is responsible for resolving the client address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. IdleConnectionTimeout Gets or sets the maximum time allowed for an idle connection. IncludeRequestIdHeader Gets or sets whether the server should include the \"X-Request-Id\" header in response headers. KeepAlive Gets or sets whether the client should mantain an persistent connection with the HTTP server. ListeningHosts Gets or sets the listening hosts repository that the HttpServer instance will listen to. MaximumContentLength Gets or sets the maximum size of a request body before it is closed by the socket. NormalizeHeadersEncodings Gets or sets whether the HTTP server should convert request headers encoding to the content encoding. OptionsLogMode Gets or sets the log mode that the HTTP server should use to log OPTIONS requests. RemoteRequestsAction Gets or sets the server's action when it receives an HTTP request outside the localhost. SendSiskHeader Gets or sets whether the HTTP server should send the X-Powered-By header in all responses. ThrowExceptions Gets or sets whether the server should throw exceptions instead of reporting it on HttpServerExecutionStatus if any is thrown while processing requests. Methods Dispose() Frees the resources and invalidates this instance."
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Context.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Context.html",
    "title": "Property Context | Sisk",
    "keywords": "Property Context Namespace Sisk.Core.Http Assembly Sisk.Core.dll Context Gets the HttpContext of this execution result. public HttpContext Context { get; } Property Value HttpContext"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Elapsed.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Elapsed.html",
    "title": "Property Elapsed | Sisk",
    "keywords": "Property Elapsed Namespace Sisk.Core.Http Assembly Sisk.Core.dll Elapsed Gets the total processing time of the HTTP session. public TimeSpan Elapsed { get; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.IsSuccessStatus.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.IsSuccessStatus.html",
    "title": "Property IsSuccessStatus | Sisk",
    "keywords": "Property IsSuccessStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsSuccessStatus Gets an boolean indicating if this execution status is an success status. public bool IsSuccessStatus { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Request.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Request.html",
    "title": "Property Request | Sisk",
    "keywords": "Property Request Namespace Sisk.Core.Http Assembly Sisk.Core.dll Request Gets the HttpRequest received in this diagnosis. public HttpRequest Request { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.RequestSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.RequestSize.html",
    "title": "Property RequestSize | Sisk",
    "keywords": "Property RequestSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestSize Gets the estimated request size in bytes. public long RequestSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Response.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Response.html",
    "title": "Property Response | Sisk",
    "keywords": "Property Response Namespace Sisk.Core.Http Assembly Sisk.Core.dll Response Gets the resulted HttpResponse send by the router, if any. This object can be null if the server didn't sent any response to the client. public HttpResponse? Response { get; } Property Value HttpResponse"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.ResponseSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.ResponseSize.html",
    "title": "Property ResponseSize | Sisk",
    "keywords": "Property ResponseSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll ResponseSize Gets the estimated response size in bytes, if any. public long ResponseSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.ServerException.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.ServerException.html",
    "title": "Property ServerException | Sisk",
    "keywords": "Property ServerException Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServerException Gets the exception that was thrown when executing the route, if any. public Exception? ServerException { get; } Property Value Exception"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.Status.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.Status.html",
    "title": "Property Status | Sisk",
    "keywords": "Property Status Namespace Sisk.Core.Http Assembly Sisk.Core.dll Status Gets the status of server operation. public HttpServerExecutionStatus Status { get; } Property Value HttpServerExecutionStatus"
  },
  "api/Sisk.Core.Http.HttpServerExecutionResult.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionResult.html",
    "title": "Class HttpServerExecutionResult | Sisk",
    "keywords": "Class HttpServerExecutionResult Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the results of an request execution on the HTTP server. public sealed class HttpServerExecutionResult Inheritance object HttpServerExecutionResult Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Context Gets the HttpContext of this execution result. Elapsed Gets the total processing time of the HTTP session. IsSuccessStatus Gets an boolean indicating if this execution status is an success status. Request Gets the HttpRequest received in this diagnosis. RequestSize Gets the estimated request size in bytes. Response Gets the resulted HttpResponse send by the router, if any. This object can be null if the server didn't sent any response to the client. ResponseSize Gets the estimated response size in bytes, if any. ServerException Gets the exception that was thrown when executing the route, if any. Status Gets the status of server operation."
  },
  "api/Sisk.Core.Http.HttpServerExecutionStatus.html": {
    "href": "api/Sisk.Core.Http.HttpServerExecutionStatus.html",
    "title": "Enum HttpServerExecutionStatus | Sisk",
    "keywords": "Enum HttpServerExecutionStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the status of an execution of a request on an HttpServer. public enum HttpServerExecutionStatus Fields ConnectionClosed = 3 Represents that the connection stream was closed by the client. ContentServedOnIllegalMethod = 1 Represents that the request has sent an request body with an with a HTTP method that is not indicated for receiving request contents. ContentTooLarge = 2 Represents that the content of the request is too large than what was configured on the server, or it's bigger than the max supported size (2GB). [Obsolete(\"This field is now obsolete and is not used anywhere.\")] DnsFailed = 5 Represents that the client did not correctly specify a host in the request. DnsUnknownHost = 6 Represents that the client requested an host that's not been set up on this server. ExceptionThrown = 7 Indicates that the server encountered an exception while processing the request. Executed = 0 Represents that the request was closed by the HTTP server and executed by a router and its response was succesfully delivered. ListeningHostNotReady = 9 Indicates that the DNS was successful, however the matched ListeningHost does not have an valid initialized router. MalformedRequest = 10 Indicates that the server cannot or will not process the request due to something that is perceived to be a client error. NoResponse = 4 Represents that the router did not deliver a response to the received request. RemoteRequestDropped = 11 Indicates that the HTTP server closed an unwanted remote connection. UncaughtExceptionThrown = 8 Indicates that the router encontered an uncaught exception while calling it's action function."
  },
  "api/Sisk.Core.Http.HttpServerFlags.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.-ctor.html",
    "title": "Constructor HttpServerFlags | Sisk",
    "keywords": "Constructor HttpServerFlags Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpServerFlags() Creates an new HttpServerFlags instance with default flags values. public HttpServerFlags()"
  },
  "api/Sisk.Core.Http.HttpServerFlags.AsyncRequestProcessing.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.AsyncRequestProcessing.html",
    "title": "Field AsyncRequestProcessing | Sisk",
    "keywords": "Field AsyncRequestProcessing Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. Default value: true public bool AsyncRequestProcessing Returns bool Determines if the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.ConvertIAsyncEnumerableIntoEnumerable.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.ConvertIAsyncEnumerableIntoEnumerable.html",
    "title": "Field ConvertIAsyncEnumerableIntoEnumerable | Sisk",
    "keywords": "Field ConvertIAsyncEnumerableIntoEnumerable Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. Default value: true public bool ConvertIAsyncEnumerableIntoEnumerable Returns bool Determines if the HTTP server should convert object responses into an blocking . Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.EnableNewMultipartFormReader.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.EnableNewMultipartFormReader.html",
    "title": "Field EnableNewMultipartFormReader | Sisk",
    "keywords": "Field EnableNewMultipartFormReader Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the new span-based multipart form reader should be used. Default value: true public bool EnableNewMultipartFormReader Returns bool Determines if the new span-based multipart form reader should be used. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash.html",
    "title": "Field ForceTrailingSlash | Sisk",
    "keywords": "Field ForceTrailingSlash Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should automatically rewrite GET requests to end their path with /. This is non-applyable to Regex routes. Default value: false public bool ForceTrailingSlash Returns bool Determines if the HTTP server should automatically rewrite GET requests to end their path with /. This is non-applyable to Regex routes. Default value: false"
  },
  "api/Sisk.Core.Http.HttpServerFlags.HeaderNameRequestId.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.HeaderNameRequestId.html",
    "title": "Field HeaderNameRequestId | Sisk",
    "keywords": "Field HeaderNameRequestId Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines the HTTP header name of the request ID. Default value: \"X-Request-Id\" public string HeaderNameRequestId Returns string Determines the HTTP header name of the request ID. Default value: \"X-Request-Id\""
  },
  "api/Sisk.Core.Http.HttpServerFlags.IdleConnectionTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.IdleConnectionTimeout.html",
    "title": "Field IdleConnectionTimeout | Sisk",
    "keywords": "Field IdleConnectionTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines the maximum amount of time an connection can keep alive without sending or receiving any data. Default value: TimeSpan.FromSeconds(120) public TimeSpan IdleConnectionTimeout Returns TimeSpan Determines the maximum amount of time an connection can keep alive without sending or receiving any data. Default value: TimeSpan.FromSeconds(120)"
  },
  "api/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings.html",
    "title": "Field NormalizeHeadersEncodings | Sisk",
    "keywords": "Field NormalizeHeadersEncodings Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should convert request headers encoding to the content encoding. Default value: false public bool NormalizeHeadersEncodings Returns bool Determines if the HTTP server should convert request headers encoding to the content encoding. Default value: false"
  },
  "api/Sisk.Core.Http.HttpServerFlags.OptionsLogMode.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.OptionsLogMode.html",
    "title": "Field OptionsLogMode | Sisk",
    "keywords": "Field OptionsLogMode Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should write log to OPTIONS requests. Default value: LogOutput.Both public LogOutput OptionsLogMode Returns LogOutput Determines if the HTTP server should write log to OPTIONS requests. Default value: LogOutput.Both"
  },
  "api/Sisk.Core.Http.HttpServerFlags.PreventResponseContentsInProhibitedMethods.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.PreventResponseContentsInProhibitedMethods.html",
    "title": "Field PreventResponseContentsInProhibitedMethods | Sisk",
    "keywords": "Field PreventResponseContentsInProhibitedMethods Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should prevent sending body contents in responses when the HTTP request method prohibits it. Default value: true public bool PreventResponseContentsInProhibitedMethods Returns bool Determines if the HTTP server should prevent sending body contents in responses when the HTTP request method prohibits it. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.RequestStreamCopyBufferSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.RequestStreamCopyBufferSize.html",
    "title": "Field RequestStreamCopyBufferSize | Sisk",
    "keywords": "Field RequestStreamCopyBufferSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll Specifies the size, in bytes, of the copy buffer of both streams (inbound and outgoing) of the response stream. Default value: 81920 public int RequestStreamCopyBufferSize Returns int Specifies the size, in bytes, of the copy buffer of both streams (inbound and outgoing) of the response stream. Default value: 81920"
  },
  "api/Sisk.Core.Http.HttpServerFlags.SendCorsHeaders.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.SendCorsHeaders.html",
    "title": "Field SendCorsHeaders | Sisk",
    "keywords": "Field SendCorsHeaders Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server automatically should send CORS headers if set. Default value: true public bool SendCorsHeaders Returns bool Determines if the HTTP server automatically should send CORS headers if set. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.SendSiskHeader.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.SendSiskHeader.html",
    "title": "Field SendSiskHeader | Sisk",
    "keywords": "Field SendSiskHeader Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should send the X-Powered-By header in all responses. Default value: true public bool SendSiskHeader Returns bool Determines if the HTTP server should send the X-Powered-By header in all responses. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.ThrowContentOnNonSemanticMethods.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.ThrowContentOnNonSemanticMethods.html",
    "title": "Field ThrowContentOnNonSemanticMethods | Sisk",
    "keywords": "Field ThrowContentOnNonSemanticMethods Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should drop requests which has content body in GET, OPTIONS, HEAD and TRACE methods. Default value: true public bool ThrowContentOnNonSemanticMethods Returns bool Determines if the HTTP server should drop requests which has content body in GET, OPTIONS, HEAD and TRACE methods. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.TreatHeadAsGetMethod.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.TreatHeadAsGetMethod.html",
    "title": "Field TreatHeadAsGetMethod | Sisk",
    "keywords": "Field TreatHeadAsGetMethod Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines if the HTTP server should automatically send HTTP headers of an pre-processed GET response if the request is using HEAD method. Default value: true public bool TreatHeadAsGetMethod Returns bool Determines if the HTTP server should automatically send HTTP headers of an pre-processed GET response if the request is using HEAD method. Default value: true"
  },
  "api/Sisk.Core.Http.HttpServerFlags.WebSocketBufferSize.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.WebSocketBufferSize.html",
    "title": "Field WebSocketBufferSize | Sisk",
    "keywords": "Field WebSocketBufferSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll Determines the WebSocket buffer initial and max length. Default value: 1024 public int WebSocketBufferSize Returns int Determines the WebSocket buffer initial and max length. Default value: 1024"
  },
  "api/Sisk.Core.Http.HttpServerFlags.html": {
    "href": "api/Sisk.Core.Http.HttpServerFlags.html",
    "title": "Class HttpServerFlags | Sisk",
    "keywords": "Class HttpServerFlags Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides advanced fields for Sisk server behavior. public sealed class HttpServerFlags Inheritance object HttpServerFlags Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors HttpServerFlags() Creates an new HttpServerFlags instance with default flags values. Fields AsyncRequestProcessing Determines if the HTTP server should handle requests asynchronously or if it should limit the request processing to one request per time. Default value: true ConvertIAsyncEnumerableIntoEnumerable Determines if the HTTP server should convert IAsyncEnumerable<T> object responses into an blocking IEnumerable<T>. Default value: true EnableNewMultipartFormReader Determines if the new span-based multipart form reader should be used. Default value: true ForceTrailingSlash Determines if the HTTP server should automatically rewrite GET requests to end their path with /. This is non-applyable to Regex routes. Default value: false HeaderNameRequestId Determines the HTTP header name of the request ID. Default value: \"X-Request-Id\" IdleConnectionTimeout Determines the maximum amount of time an connection can keep alive without sending or receiving any data. Default value: TimeSpan.FromSeconds(120) NormalizeHeadersEncodings Determines if the HTTP server should convert request headers encoding to the content encoding. Default value: false OptionsLogMode Determines if the HTTP server should write log to OPTIONS requests. Default value: LogOutput.Both PreventResponseContentsInProhibitedMethods Determines if the HTTP server should prevent sending body contents in responses when the HTTP request method prohibits it. Default value: true RequestStreamCopyBufferSize Specifies the size, in bytes, of the copy buffer of both streams (inbound and outgoing) of the response stream. Default value: 81920 SendCorsHeaders Determines if the HTTP server automatically should send CORS headers if set. Default value: true SendSiskHeader Determines if the HTTP server should send the X-Powered-By header in all responses. Default value: true ThrowContentOnNonSemanticMethods Determines if the HTTP server should drop requests which has content body in GET, OPTIONS, HEAD and TRACE methods. Default value: true TreatHeadAsGetMethod Determines if the HTTP server should automatically send HTTP headers of an pre-processed GET response if the request is using HEAD method. Default value: true WebSocketBufferSize Determines the WebSocket buffer initial and max length. Default value: 1024"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.-ctor.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.-ctor.html",
    "title": "Constructor HttpStatusInformation | Sisk",
    "keywords": "Constructor HttpStatusInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpStatusInformation() Creates an new HttpStatusInformation with default parameters (200 OK) status. public HttpStatusInformation() HttpStatusInformation(int) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(int statusCode) Parameters statusCode int Sets the numeric HTTP status code of the HTTP message. HttpStatusInformation(HttpStatusCode) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode Sets the numeric HTTP status code of the HTTP message. HttpStatusInformation(int, string) Creates an new HttpStatusInformation instance with given parameters. public HttpStatusInformation(int statusCode, string description) Parameters statusCode int Sets the numeric HTTP status code of the HTTP message. description string Sets the short description of the HTTP message. Remarks Custom status descriptions is only supported for plain HTTP/1.1 and 1.0 transfers. Exceptions ArgumentNullException"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Accepted.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Accepted.html",
    "title": "Property Accepted | Sisk",
    "keywords": "Property Accepted Namespace Sisk.Core.Http Assembly Sisk.Core.dll Accepted Gets an HttpStatusInformation with an HTTP 202 Accepted status. public static HttpStatusInformation Accepted { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.AlreadyReported.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.AlreadyReported.html",
    "title": "Property AlreadyReported | Sisk",
    "keywords": "Property AlreadyReported Namespace Sisk.Core.Http Assembly Sisk.Core.dll AlreadyReported Gets an HttpStatusInformation with an HTTP 208 Already Reported status. public static HttpStatusInformation AlreadyReported { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.BadGateway.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.BadGateway.html",
    "title": "Property BadGateway | Sisk",
    "keywords": "Property BadGateway Namespace Sisk.Core.Http Assembly Sisk.Core.dll BadGateway Gets an HttpStatusInformation with an HTTP 502 Bad Gateway status. public static HttpStatusInformation BadGateway { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.BadRequest.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.BadRequest.html",
    "title": "Property BadRequest | Sisk",
    "keywords": "Property BadRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll BadRequest Gets an HttpStatusInformation with an HTTP 400 Bad Request status. public static HttpStatusInformation BadRequest { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Conflict.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Conflict.html",
    "title": "Property Conflict | Sisk",
    "keywords": "Property Conflict Namespace Sisk.Core.Http Assembly Sisk.Core.dll Conflict Gets an HttpStatusInformation with an HTTP 409 Conflict status. public static HttpStatusInformation Conflict { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Continue.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Continue.html",
    "title": "Property Continue | Sisk",
    "keywords": "Property Continue Namespace Sisk.Core.Http Assembly Sisk.Core.dll Continue Gets an HttpStatusInformation with an HTTP 100 Continue status. public static HttpStatusInformation Continue { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Created.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Created.html",
    "title": "Property Created | Sisk",
    "keywords": "Property Created Namespace Sisk.Core.Http Assembly Sisk.Core.dll Created Gets an HttpStatusInformation with an HTTP 201 Created status. public static HttpStatusInformation Created { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Description.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.Core.Http Assembly Sisk.Core.dll Description Gets the short description of the HTTP message. public string Description { get; } Property Value string Remarks Custom status descriptions is only supported for plain HTTP/1.1 and 1.0 transfers."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.EarlyHints.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.EarlyHints.html",
    "title": "Property EarlyHints | Sisk",
    "keywords": "Property EarlyHints Namespace Sisk.Core.Http Assembly Sisk.Core.dll EarlyHints Gets an HttpStatusInformation with an HTTP 103 Early Hints status. public static HttpStatusInformation EarlyHints { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ExpectationFailed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ExpectationFailed.html",
    "title": "Property ExpectationFailed | Sisk",
    "keywords": "Property ExpectationFailed Namespace Sisk.Core.Http Assembly Sisk.Core.dll ExpectationFailed Gets an HttpStatusInformation with an HTTP 417 Expectation Failed status. public static HttpStatusInformation ExpectationFailed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.FailedDependency.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.FailedDependency.html",
    "title": "Property FailedDependency | Sisk",
    "keywords": "Property FailedDependency Namespace Sisk.Core.Http Assembly Sisk.Core.dll FailedDependency Gets an HttpStatusInformation with an HTTP 424 Failed Dependency status. public static HttpStatusInformation FailedDependency { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Forbidden.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Forbidden.html",
    "title": "Property Forbidden | Sisk",
    "keywords": "Property Forbidden Namespace Sisk.Core.Http Assembly Sisk.Core.dll Forbidden Gets an HttpStatusInformation with an HTTP 403 Forbidden status. public static HttpStatusInformation Forbidden { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Found.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Found.html",
    "title": "Property Found | Sisk",
    "keywords": "Property Found Namespace Sisk.Core.Http Assembly Sisk.Core.dll Found Gets an HttpStatusInformation with an HTTP 302 Found status. public static HttpStatusInformation Found { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GatewayTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GatewayTimeout.html",
    "title": "Property GatewayTimeout | Sisk",
    "keywords": "Property GatewayTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll GatewayTimeout Gets an HttpStatusInformation with an HTTP 504 Gateway Timeout status. public static HttpStatusInformation GatewayTimeout { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GetHttpStatusCode.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GetHttpStatusCode.html",
    "title": "Method GetHttpStatusCode | Sisk",
    "keywords": "Method GetHttpStatusCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHttpStatusCode() Gets an HttpStatusCode corresponding to this instance, or null if the HTTP status does not match any value. public HttpStatusCode? GetHttpStatusCode() Returns HttpStatusCode? An HttpStatusCode or null if the HTTP status matches no entry on it."
  },
  "api/Sisk.Core.Http.HttpStatusInformation.GetStatusCodeDescription.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.GetStatusCodeDescription.html",
    "title": "Method GetStatusCodeDescription | Sisk",
    "keywords": "Method GetStatusCodeDescription Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetStatusCodeDescription(int) Gets the description of the HTTP status based on its description. public static string GetStatusCodeDescription(int statusCode) Parameters statusCode int The HTTP status code. Returns string GetStatusCodeDescription(HttpStatusCode) Gets the description of the HTTP status based on its description. public static string GetStatusCodeDescription(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode The HTTP status code. Returns string"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Gone.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Gone.html",
    "title": "Property Gone | Sisk",
    "keywords": "Property Gone Namespace Sisk.Core.Http Assembly Sisk.Core.dll Gone Gets an HttpStatusInformation with an HTTP 410 Gone status. public static HttpStatusInformation Gone { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.HttpVersionNotSupported.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.HttpVersionNotSupported.html",
    "title": "Property HttpVersionNotSupported | Sisk",
    "keywords": "Property HttpVersionNotSupported Namespace Sisk.Core.Http Assembly Sisk.Core.dll HttpVersionNotSupported Gets an HttpStatusInformation with an HTTP 505 HTTP Version Not Supported status. public static HttpStatusInformation HttpVersionNotSupported { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ImATeapot.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ImATeapot.html",
    "title": "Property ImATeapot | Sisk",
    "keywords": "Property ImATeapot Namespace Sisk.Core.Http Assembly Sisk.Core.dll ImATeapot Gets an HttpStatusInformation with an HTTP 418 I'm a teapot status. public static HttpStatusInformation ImATeapot { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ImUsed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ImUsed.html",
    "title": "Property ImUsed | Sisk",
    "keywords": "Property ImUsed Namespace Sisk.Core.Http Assembly Sisk.Core.dll ImUsed Gets an HttpStatusInformation with an HTTP 226 IM Used status. public static HttpStatusInformation ImUsed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.InsufficientStorage.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.InsufficientStorage.html",
    "title": "Property InsufficientStorage | Sisk",
    "keywords": "Property InsufficientStorage Namespace Sisk.Core.Http Assembly Sisk.Core.dll InsufficientStorage Gets an HttpStatusInformation with an HTTP 507 Insufficient Storage status. public static HttpStatusInformation InsufficientStorage { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.InternalServerError.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.InternalServerError.html",
    "title": "Property InternalServerError | Sisk",
    "keywords": "Property InternalServerError Namespace Sisk.Core.Http Assembly Sisk.Core.dll InternalServerError Gets an HttpStatusInformation with an HTTP 500 Internal Server Error status. public static HttpStatusInformation InternalServerError { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.LengthRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.LengthRequired.html",
    "title": "Property LengthRequired | Sisk",
    "keywords": "Property LengthRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll LengthRequired Gets an HttpStatusInformation with an HTTP 411 Length Required status. public static HttpStatusInformation LengthRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Locked.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Locked.html",
    "title": "Property Locked | Sisk",
    "keywords": "Property Locked Namespace Sisk.Core.Http Assembly Sisk.Core.dll Locked Gets an HttpStatusInformation with an HTTP 423 Locked status. public static HttpStatusInformation Locked { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.LoopDetected.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.LoopDetected.html",
    "title": "Property LoopDetected | Sisk",
    "keywords": "Property LoopDetected Namespace Sisk.Core.Http Assembly Sisk.Core.dll LoopDetected Gets an HttpStatusInformation with an HTTP 508 Loop Detected status. public static HttpStatusInformation LoopDetected { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MethodNotAllowed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MethodNotAllowed.html",
    "title": "Property MethodNotAllowed | Sisk",
    "keywords": "Property MethodNotAllowed Namespace Sisk.Core.Http Assembly Sisk.Core.dll MethodNotAllowed Gets an HttpStatusInformation with an HTTP 405 Method Not Allowed status. public static HttpStatusInformation MethodNotAllowed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MisdirectedRequest.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MisdirectedRequest.html",
    "title": "Property MisdirectedRequest | Sisk",
    "keywords": "Property MisdirectedRequest Namespace Sisk.Core.Http Assembly Sisk.Core.dll MisdirectedRequest Gets an HttpStatusInformation with an HTTP 421 Misdirected Request status. public static HttpStatusInformation MisdirectedRequest { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MovedPermanently.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MovedPermanently.html",
    "title": "Property MovedPermanently | Sisk",
    "keywords": "Property MovedPermanently Namespace Sisk.Core.Http Assembly Sisk.Core.dll MovedPermanently Gets an HttpStatusInformation with an HTTP 301 Moved Permanently status. public static HttpStatusInformation MovedPermanently { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MultiStatus.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MultiStatus.html",
    "title": "Property MultiStatus | Sisk",
    "keywords": "Property MultiStatus Namespace Sisk.Core.Http Assembly Sisk.Core.dll MultiStatus Gets an HttpStatusInformation with an HTTP 207 Multi-Status status. public static HttpStatusInformation MultiStatus { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.MultipleChoices.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.MultipleChoices.html",
    "title": "Property MultipleChoices | Sisk",
    "keywords": "Property MultipleChoices Namespace Sisk.Core.Http Assembly Sisk.Core.dll MultipleChoices Gets an HttpStatusInformation with an HTTP 300 Multiple Choices status. public static HttpStatusInformation MultipleChoices { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NoContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NoContent.html",
    "title": "Property NoContent | Sisk",
    "keywords": "Property NoContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll NoContent Gets an HttpStatusInformation with an HTTP 204 No Content status. public static HttpStatusInformation NoContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NonAuthoritativeInformation.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NonAuthoritativeInformation.html",
    "title": "Property NonAuthoritativeInformation | Sisk",
    "keywords": "Property NonAuthoritativeInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll NonAuthoritativeInformation Gets an HttpStatusInformation with an HTTP 203 Non-Authoritative Information status. public static HttpStatusInformation NonAuthoritativeInformation { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotAcceptable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotAcceptable.html",
    "title": "Property NotAcceptable | Sisk",
    "keywords": "Property NotAcceptable Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotAcceptable Gets an HttpStatusInformation with an HTTP 406 Not Acceptable status. public static HttpStatusInformation NotAcceptable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotExtended.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotExtended.html",
    "title": "Property NotExtended | Sisk",
    "keywords": "Property NotExtended Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotExtended Gets an HttpStatusInformation with an HTTP 510 Not Extended status. public static HttpStatusInformation NotExtended { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotFound.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotFound.html",
    "title": "Property NotFound | Sisk",
    "keywords": "Property NotFound Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotFound Gets an HttpStatusInformation with an HTTP 404 Not Found status. public static HttpStatusInformation NotFound { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotImplemented.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotImplemented.html",
    "title": "Property NotImplemented | Sisk",
    "keywords": "Property NotImplemented Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotImplemented Gets an HttpStatusInformation with an HTTP 501 Not Implemented status. public static HttpStatusInformation NotImplemented { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.NotModified.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.NotModified.html",
    "title": "Property NotModified | Sisk",
    "keywords": "Property NotModified Namespace Sisk.Core.Http Assembly Sisk.Core.dll NotModified Gets an HttpStatusInformation with an HTTP 304 Not Modified status. public static HttpStatusInformation NotModified { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Ok.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Ok.html",
    "title": "Property Ok | Sisk",
    "keywords": "Property Ok Namespace Sisk.Core.Http Assembly Sisk.Core.dll Ok Gets an HttpStatusInformation with an HTTP 200 OK status. public static HttpStatusInformation Ok { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PartialContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PartialContent.html",
    "title": "Property PartialContent | Sisk",
    "keywords": "Property PartialContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll PartialContent Gets an HttpStatusInformation with an HTTP 206 Partial Content status. public static HttpStatusInformation PartialContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PayloadTooLarge.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PayloadTooLarge.html",
    "title": "Property PayloadTooLarge | Sisk",
    "keywords": "Property PayloadTooLarge Namespace Sisk.Core.Http Assembly Sisk.Core.dll PayloadTooLarge Gets an HttpStatusInformation with an HTTP 413 Payload Too Large status. public static HttpStatusInformation PayloadTooLarge { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PaymentRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PaymentRequired.html",
    "title": "Property PaymentRequired | Sisk",
    "keywords": "Property PaymentRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll PaymentRequired Gets an HttpStatusInformation with an HTTP 402 Payment Required status. public static HttpStatusInformation PaymentRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PermanentRedirect.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PermanentRedirect.html",
    "title": "Property PermanentRedirect | Sisk",
    "keywords": "Property PermanentRedirect Namespace Sisk.Core.Http Assembly Sisk.Core.dll PermanentRedirect Gets an HttpStatusInformation with an HTTP 308 Permanent Redirect status. public static HttpStatusInformation PermanentRedirect { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PreconditionFailed.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PreconditionFailed.html",
    "title": "Property PreconditionFailed | Sisk",
    "keywords": "Property PreconditionFailed Namespace Sisk.Core.Http Assembly Sisk.Core.dll PreconditionFailed Gets an HttpStatusInformation with an HTTP 412 Precondition Failed status. public static HttpStatusInformation PreconditionFailed { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.PreconditionRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.PreconditionRequired.html",
    "title": "Property PreconditionRequired | Sisk",
    "keywords": "Property PreconditionRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll PreconditionRequired Gets an HttpStatusInformation with an HTTP 428 Precondition Required status. public static HttpStatusInformation PreconditionRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Processing.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Processing.html",
    "title": "Property Processing | Sisk",
    "keywords": "Property Processing Namespace Sisk.Core.Http Assembly Sisk.Core.dll Processing Gets an HttpStatusInformation with an HTTP 102 Processing status. public static HttpStatusInformation Processing { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ProxyAuthenticationRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ProxyAuthenticationRequired.html",
    "title": "Property ProxyAuthenticationRequired | Sisk",
    "keywords": "Property ProxyAuthenticationRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll ProxyAuthenticationRequired Gets an HttpStatusInformation with an HTTP 407 Proxy Authentication Required status. public static HttpStatusInformation ProxyAuthenticationRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RangeNotSatisfiable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RangeNotSatisfiable.html",
    "title": "Property RangeNotSatisfiable | Sisk",
    "keywords": "Property RangeNotSatisfiable Namespace Sisk.Core.Http Assembly Sisk.Core.dll RangeNotSatisfiable Gets an HttpStatusInformation with an HTTP 416 Range Not Satisfiable status. public static HttpStatusInformation RangeNotSatisfiable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RequestHeaderFieldsTooLarge.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RequestHeaderFieldsTooLarge.html",
    "title": "Property RequestHeaderFieldsTooLarge | Sisk",
    "keywords": "Property RequestHeaderFieldsTooLarge Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestHeaderFieldsTooLarge Gets an HttpStatusInformation with an HTTP 431 Request Header Fields Too Large status. public static HttpStatusInformation RequestHeaderFieldsTooLarge { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.RequestTimeout.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.RequestTimeout.html",
    "title": "Property RequestTimeout | Sisk",
    "keywords": "Property RequestTimeout Namespace Sisk.Core.Http Assembly Sisk.Core.dll RequestTimeout Gets an HttpStatusInformation with an HTTP 408 Request Timeout status. public static HttpStatusInformation RequestTimeout { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ResetContent.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ResetContent.html",
    "title": "Property ResetContent | Sisk",
    "keywords": "Property ResetContent Namespace Sisk.Core.Http Assembly Sisk.Core.dll ResetContent Gets an HttpStatusInformation with an HTTP 205 Reset Content status. public static HttpStatusInformation ResetContent { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SeeOther.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SeeOther.html",
    "title": "Property SeeOther | Sisk",
    "keywords": "Property SeeOther Namespace Sisk.Core.Http Assembly Sisk.Core.dll SeeOther Gets an HttpStatusInformation with an HTTP 303 See Other status. public static HttpStatusInformation SeeOther { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ServiceUnavailable.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ServiceUnavailable.html",
    "title": "Property ServiceUnavailable | Sisk",
    "keywords": "Property ServiceUnavailable Namespace Sisk.Core.Http Assembly Sisk.Core.dll ServiceUnavailable Gets an HttpStatusInformation with an HTTP 503 Service Unavailable status. public static HttpStatusInformation ServiceUnavailable { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.StatusCode.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.StatusCode.html",
    "title": "Property StatusCode | Sisk",
    "keywords": "Property StatusCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll StatusCode Gets the numeric HTTP status code of the HTTP message. public int StatusCode { get; } Property Value int"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SwitchProxy.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SwitchProxy.html",
    "title": "Property SwitchProxy | Sisk",
    "keywords": "Property SwitchProxy Namespace Sisk.Core.Http Assembly Sisk.Core.dll SwitchProxy Gets an HttpStatusInformation with an HTTP 306 Switch Proxy status. public static HttpStatusInformation SwitchProxy { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.SwitchingProtocols.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.SwitchingProtocols.html",
    "title": "Property SwitchingProtocols | Sisk",
    "keywords": "Property SwitchingProtocols Namespace Sisk.Core.Http Assembly Sisk.Core.dll SwitchingProtocols Gets an HttpStatusInformation with an HTTP 101 Switching Protocols status. public static HttpStatusInformation SwitchingProtocols { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.TemporaryRedirect.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.TemporaryRedirect.html",
    "title": "Property TemporaryRedirect | Sisk",
    "keywords": "Property TemporaryRedirect Namespace Sisk.Core.Http Assembly Sisk.Core.dll TemporaryRedirect Gets an HttpStatusInformation with an HTTP 307 Temporary Redirect status. public static HttpStatusInformation TemporaryRedirect { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.ToString.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this HTTP Status Code. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.TooManyRequests.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.TooManyRequests.html",
    "title": "Property TooManyRequests | Sisk",
    "keywords": "Property TooManyRequests Namespace Sisk.Core.Http Assembly Sisk.Core.dll TooManyRequests Gets an HttpStatusInformation with an HTTP 429 Too Many Requests status. public static HttpStatusInformation TooManyRequests { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.Unauthorized.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.Unauthorized.html",
    "title": "Property Unauthorized | Sisk",
    "keywords": "Property Unauthorized Namespace Sisk.Core.Http Assembly Sisk.Core.dll Unauthorized Gets an HttpStatusInformation with an HTTP 401 Unauthorized status. public static HttpStatusInformation Unauthorized { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnavailableForLegalReasons.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnavailableForLegalReasons.html",
    "title": "Property UnavailableForLegalReasons | Sisk",
    "keywords": "Property UnavailableForLegalReasons Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnavailableForLegalReasons Gets an HttpStatusInformation with an HTTP 451 Unavailable For Legal Reasons status. public static HttpStatusInformation UnavailableForLegalReasons { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnprocessableEntity.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnprocessableEntity.html",
    "title": "Property UnprocessableEntity | Sisk",
    "keywords": "Property UnprocessableEntity Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnprocessableEntity Gets an HttpStatusInformation with an HTTP 422 Unprocessable Entity status. public static HttpStatusInformation UnprocessableEntity { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UnsupportedMediaType.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UnsupportedMediaType.html",
    "title": "Property UnsupportedMediaType | Sisk",
    "keywords": "Property UnsupportedMediaType Namespace Sisk.Core.Http Assembly Sisk.Core.dll UnsupportedMediaType Gets an HttpStatusInformation with an HTTP 415 Unsupported Media Type status. public static HttpStatusInformation UnsupportedMediaType { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UpgradeRequired.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UpgradeRequired.html",
    "title": "Property UpgradeRequired | Sisk",
    "keywords": "Property UpgradeRequired Namespace Sisk.Core.Http Assembly Sisk.Core.dll UpgradeRequired Gets an HttpStatusInformation with an HTTP 426 Upgrade Required status. public static HttpStatusInformation UpgradeRequired { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UriTooLong.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UriTooLong.html",
    "title": "Property UriTooLong | Sisk",
    "keywords": "Property UriTooLong Namespace Sisk.Core.Http Assembly Sisk.Core.dll UriTooLong Gets an HttpStatusInformation with an HTTP 414 URI Too Long status. public static HttpStatusInformation UriTooLong { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.UseProxy.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.UseProxy.html",
    "title": "Property UseProxy | Sisk",
    "keywords": "Property UseProxy Namespace Sisk.Core.Http Assembly Sisk.Core.dll UseProxy Gets an HttpStatusInformation with an HTTP 305 Use Proxy status. public static HttpStatusInformation UseProxy { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.VariantAlsoNegotiates.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.VariantAlsoNegotiates.html",
    "title": "Property VariantAlsoNegotiates | Sisk",
    "keywords": "Property VariantAlsoNegotiates Namespace Sisk.Core.Http Assembly Sisk.Core.dll VariantAlsoNegotiates Gets an HttpStatusInformation with an HTTP 506 Variant Also Negotiates status. public static HttpStatusInformation VariantAlsoNegotiates { get; } Property Value HttpStatusInformation"
  },
  "api/Sisk.Core.Http.HttpStatusInformation.html": {
    "href": "api/Sisk.Core.Http.HttpStatusInformation.html",
    "title": "Struct HttpStatusInformation | Sisk",
    "keywords": "Struct HttpStatusInformation Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents a structure that holds an HTTP response status information, with it's status code and description. public readonly struct HttpStatusInformation : IEquatable<HttpStatusInformation>, IEquatable<HttpStatusCode>, IEquatable<int> Implements IEquatable<HttpStatusInformation> IEquatable<HttpStatusCode> IEquatable<int> Inherited Members ValueType.Equals(object) ValueType.GetHashCode() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors HttpStatusInformation() Creates an new HttpStatusInformation with default parameters (200 OK) status. HttpStatusInformation(int) Creates an new HttpStatusInformation instance with given parameters. HttpStatusInformation(int, string) Creates an new HttpStatusInformation instance with given parameters. HttpStatusInformation(HttpStatusCode) Creates an new HttpStatusInformation instance with given parameters. Properties Accepted Gets an HttpStatusInformation with an HTTP 202 Accepted status. AlreadyReported Gets an HttpStatusInformation with an HTTP 208 Already Reported status. BadGateway Gets an HttpStatusInformation with an HTTP 502 Bad Gateway status. BadRequest Gets an HttpStatusInformation with an HTTP 400 Bad Request status. Conflict Gets an HttpStatusInformation with an HTTP 409 Conflict status. Continue Gets an HttpStatusInformation with an HTTP 100 Continue status. Created Gets an HttpStatusInformation with an HTTP 201 Created status. Description Gets the short description of the HTTP message. EarlyHints Gets an HttpStatusInformation with an HTTP 103 Early Hints status. ExpectationFailed Gets an HttpStatusInformation with an HTTP 417 Expectation Failed status. FailedDependency Gets an HttpStatusInformation with an HTTP 424 Failed Dependency status. Forbidden Gets an HttpStatusInformation with an HTTP 403 Forbidden status. Found Gets an HttpStatusInformation with an HTTP 302 Found status. GatewayTimeout Gets an HttpStatusInformation with an HTTP 504 Gateway Timeout status. Gone Gets an HttpStatusInformation with an HTTP 410 Gone status. HttpVersionNotSupported Gets an HttpStatusInformation with an HTTP 505 HTTP Version Not Supported status. ImATeapot Gets an HttpStatusInformation with an HTTP 418 I'm a teapot status. ImUsed Gets an HttpStatusInformation with an HTTP 226 IM Used status. InsufficientStorage Gets an HttpStatusInformation with an HTTP 507 Insufficient Storage status. InternalServerError Gets an HttpStatusInformation with an HTTP 500 Internal Server Error status. LengthRequired Gets an HttpStatusInformation with an HTTP 411 Length Required status. Locked Gets an HttpStatusInformation with an HTTP 423 Locked status. LoopDetected Gets an HttpStatusInformation with an HTTP 508 Loop Detected status. MethodNotAllowed Gets an HttpStatusInformation with an HTTP 405 Method Not Allowed status. MisdirectedRequest Gets an HttpStatusInformation with an HTTP 421 Misdirected Request status. MovedPermanently Gets an HttpStatusInformation with an HTTP 301 Moved Permanently status. MultiStatus Gets an HttpStatusInformation with an HTTP 207 Multi-Status status. MultipleChoices Gets an HttpStatusInformation with an HTTP 300 Multiple Choices status. NoContent Gets an HttpStatusInformation with an HTTP 204 No Content status. NonAuthoritativeInformation Gets an HttpStatusInformation with an HTTP 203 Non-Authoritative Information status. NotAcceptable Gets an HttpStatusInformation with an HTTP 406 Not Acceptable status. NotExtended Gets an HttpStatusInformation with an HTTP 510 Not Extended status. NotFound Gets an HttpStatusInformation with an HTTP 404 Not Found status. NotImplemented Gets an HttpStatusInformation with an HTTP 501 Not Implemented status. NotModified Gets an HttpStatusInformation with an HTTP 304 Not Modified status. Ok Gets an HttpStatusInformation with an HTTP 200 OK status. PartialContent Gets an HttpStatusInformation with an HTTP 206 Partial Content status. PayloadTooLarge Gets an HttpStatusInformation with an HTTP 413 Payload Too Large status. PaymentRequired Gets an HttpStatusInformation with an HTTP 402 Payment Required status. PermanentRedirect Gets an HttpStatusInformation with an HTTP 308 Permanent Redirect status. PreconditionFailed Gets an HttpStatusInformation with an HTTP 412 Precondition Failed status. PreconditionRequired Gets an HttpStatusInformation with an HTTP 428 Precondition Required status. Processing Gets an HttpStatusInformation with an HTTP 102 Processing status. ProxyAuthenticationRequired Gets an HttpStatusInformation with an HTTP 407 Proxy Authentication Required status. RangeNotSatisfiable Gets an HttpStatusInformation with an HTTP 416 Range Not Satisfiable status. RequestHeaderFieldsTooLarge Gets an HttpStatusInformation with an HTTP 431 Request Header Fields Too Large status. RequestTimeout Gets an HttpStatusInformation with an HTTP 408 Request Timeout status. ResetContent Gets an HttpStatusInformation with an HTTP 205 Reset Content status. SeeOther Gets an HttpStatusInformation with an HTTP 303 See Other status. ServiceUnavailable Gets an HttpStatusInformation with an HTTP 503 Service Unavailable status. StatusCode Gets the numeric HTTP status code of the HTTP message. SwitchProxy Gets an HttpStatusInformation with an HTTP 306 Switch Proxy status. SwitchingProtocols Gets an HttpStatusInformation with an HTTP 101 Switching Protocols status. TemporaryRedirect Gets an HttpStatusInformation with an HTTP 307 Temporary Redirect status. TooManyRequests Gets an HttpStatusInformation with an HTTP 429 Too Many Requests status. Unauthorized Gets an HttpStatusInformation with an HTTP 401 Unauthorized status. UnavailableForLegalReasons Gets an HttpStatusInformation with an HTTP 451 Unavailable For Legal Reasons status. UnprocessableEntity Gets an HttpStatusInformation with an HTTP 422 Unprocessable Entity status. UnsupportedMediaType Gets an HttpStatusInformation with an HTTP 415 Unsupported Media Type status. UpgradeRequired Gets an HttpStatusInformation with an HTTP 426 Upgrade Required status. UriTooLong Gets an HttpStatusInformation with an HTTP 414 URI Too Long status. UseProxy Gets an HttpStatusInformation with an HTTP 305 Use Proxy status. VariantAlsoNegotiates Gets an HttpStatusInformation with an HTTP 506 Variant Also Negotiates status. Methods GetHttpStatusCode() Gets an HttpStatusCode corresponding to this instance, or null if the HTTP status does not match any value. GetStatusCodeDescription(int) Gets the description of the HTTP status based on its description. GetStatusCodeDescription(HttpStatusCode) Gets the description of the HTTP status based on its description. ToString() Gets an string representation of this HTTP Status Code."
  },
  "api/Sisk.Core.Http.ListeningHost.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.-ctor.html",
    "title": "Constructor ListeningHost | Sisk",
    "keywords": "Constructor ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHost() Creates an new empty ListeningHost instance. public ListeningHost() ListeningHost(params ListeningPort[]) Creates an new ListeningHost instance with given array of ListeningPort. public ListeningHost(params ListeningPort[] ports) Parameters ports ListeningPort[] The array of ListeningPort to listen in the ListeningHost. ListeningHost(string, Router) Creates an new ListeningHost instance with given URL. public ListeningHost(string uri, Router r) Parameters uri string The well formatted URL with scheme, hostname and port. r Router The router which will handle this listener requests."
  },
  "api/Sisk.Core.Http.ListeningHost.CanListen.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.CanListen.html",
    "title": "Property CanListen | Sisk",
    "keywords": "Property CanListen Namespace Sisk.Core.Http Assembly Sisk.Core.dll CanListen Gets whether this ListeningHost can be listened by it's host HttpServer. public bool CanListen { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningHost.CrossOriginResourceSharingPolicy.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.CrossOriginResourceSharingPolicy.html",
    "title": "Property CrossOriginResourceSharingPolicy | Sisk",
    "keywords": "Property CrossOriginResourceSharingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll CrossOriginResourceSharingPolicy Gets or sets the CORS sharing policy object. public CrossOriginResourceSharingHeaders CrossOriginResourceSharingPolicy { get; set; } Property Value CrossOriginResourceSharingHeaders"
  },
  "api/Sisk.Core.Http.ListeningHost.Equals.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) Determines if another object is equals to this class instance. public override bool Equals(object? obj) Parameters obj object The another object which will be used to compare. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHost.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() Gets the hash code for this listening host. public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.ListeningHost.Label.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Label.html",
    "title": "Property Label | Sisk",
    "keywords": "Property Label Namespace Sisk.Core.Http Assembly Sisk.Core.dll Label Gets or sets a label for this Listening Host. public string? Label { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningHost.Ports.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Ports.html",
    "title": "Property Ports | Sisk",
    "keywords": "Property Ports Namespace Sisk.Core.Http Assembly Sisk.Core.dll Ports Gets or sets the list of ListeningPort that this host will listen on. public IList<ListeningPort> Ports { get; set; } Property Value IList<ListeningPort>"
  },
  "api/Sisk.Core.Http.ListeningHost.Router.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.Core.Http Assembly Sisk.Core.dll Router Gets or sets the Router for this ListeningHost instance. public Router? Router { get; set; } Property Value Router"
  },
  "api/Sisk.Core.Http.ListeningHost.html": {
    "href": "api/Sisk.Core.Http.ListeningHost.html",
    "title": "Class ListeningHost | Sisk",
    "keywords": "Class ListeningHost Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a structure to contain the fields needed by an http server host. public sealed class ListeningHost Inheritance object ListeningHost Inherited Members object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ListeningHost() Creates an new empty ListeningHost instance. ListeningHost(params ListeningPort[]) Creates an new ListeningHost instance with given array of ListeningPort. ListeningHost(string, Router) Creates an new ListeningHost instance with given URL. Properties CanListen Gets whether this ListeningHost can be listened by it's host HttpServer. CrossOriginResourceSharingPolicy Gets or sets the CORS sharing policy object. Label Gets or sets a label for this Listening Host. Ports Gets or sets the list of ListeningPort that this host will listen on. Router Gets or sets the Router for this ListeningHost instance. Methods Equals(object?) Determines if another object is equals to this class instance. GetHashCode() Gets the hash code for this listening host."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.-ctor.html",
    "title": "Constructor ListeningHostRepository | Sisk",
    "keywords": "Constructor ListeningHostRepository Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningHostRepository() Creates a new instance of an empty ListeningHostRepository. public ListeningHostRepository() ListeningHostRepository(IEnumerable<ListeningHost>) Creates a new instance of an ListeningHostRepository copying the items from another collection of ListeningHost. public ListeningHostRepository(IEnumerable<ListeningHost> hosts) Parameters hosts IEnumerable<ListeningHost> The collection which stores the ListeningHost which will be copied to this repository."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Add.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.Core.Http Assembly Sisk.Core.dll Add(ListeningHost) Adds a listeninghost to this repository. If this listeninghost already exists in this class, an exception will be thrown. public void Add(ListeningHost item) Parameters item ListeningHost The ListeningHost to add to this collection."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Clear.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.Core.Http Assembly Sisk.Core.dll Clear() Removes all listeninghosts from this repository. public void Clear()"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Contains.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.Core.Http Assembly Sisk.Core.dll Contains(ListeningHost) Determines if an ListeningHost is present in this repository. public bool Contains(ListeningHost item) Parameters item ListeningHost The ListeningHost to check if is present in this repository. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.CopyTo.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.Core.Http Assembly Sisk.Core.dll CopyTo(ListeningHost[], int) Copies all elements from this repository to another compatible repository. public void CopyTo(ListeningHost[] array, int arrayIndex) Parameters array ListeningHost[] The one-dimensional System.Array that is the destination of the elements copied. arrayIndex int The zero-based index in array at which copying begins."
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Count.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.Core.Http Assembly Sisk.Core.dll Count Gets the number of elements contained in this ListeningHostRepository. public int Count { get; } Property Value int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.GetEnumerator.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetEnumerator() Returns an enumerator that iterates through this ListeningHostRepository. public IEnumerator<ListeningHost> GetEnumerator() Returns IEnumerator<ListeningHost>"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.IndexOf.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.IndexOf.html",
    "title": "Method IndexOf | Sisk",
    "keywords": "Method IndexOf Namespace Sisk.Core.Http Assembly Sisk.Core.dll IndexOf(ListeningHost) public int IndexOf(ListeningHost item) Parameters item ListeningHost Returns int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Insert.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Insert.html",
    "title": "Method Insert | Sisk",
    "keywords": "Method Insert Namespace Sisk.Core.Http Assembly Sisk.Core.dll Insert(int, ListeningHost) public void Insert(int index, ListeningHost item) Parameters index int item ListeningHost"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.IsReadOnly.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsReadOnly Gets an boolean indicating if this ListeningHostRepository is read only. This property always returns false. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Item.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.Core.Http Assembly Sisk.Core.dll this[int] public ListeningHost this[int index] { get; set; } Parameters index int Property Value ListeningHost"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.Remove.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.Core.Http Assembly Sisk.Core.dll Remove(ListeningHost) Try to remove a ListeningHost from this repository. If the item is removed, this methods returns true. public bool Remove(ListeningHost item) Parameters item ListeningHost The ListeningHost to be removed. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.RemoveAt.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.RemoveAt.html",
    "title": "Method RemoveAt | Sisk",
    "keywords": "Method RemoveAt Namespace Sisk.Core.Http Assembly Sisk.Core.dll RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/Sisk.Core.Http.ListeningHostRepository.html": {
    "href": "api/Sisk.Core.Http.ListeningHostRepository.html",
    "title": "Class ListeningHostRepository | Sisk",
    "keywords": "Class ListeningHostRepository Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents an fluent repository of ListeningHost that can add, modify, or remove listening hosts while an HttpServer is running. public sealed class ListeningHostRepository : IList<ListeningHost>, ICollection<ListeningHost>, IEnumerable<ListeningHost>, IEnumerable Inheritance object ListeningHostRepository Implements IList<ListeningHost> ICollection<ListeningHost> IEnumerable<ListeningHost> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors ListeningHostRepository() Creates a new instance of an empty ListeningHostRepository. ListeningHostRepository(IEnumerable<ListeningHost>) Creates a new instance of an ListeningHostRepository copying the items from another collection of ListeningHost. Properties Count Gets the number of elements contained in this ListeningHostRepository. IsReadOnly Gets an boolean indicating if this ListeningHostRepository is read only. This property always returns false. this[int] Methods Add(ListeningHost) Adds a listeninghost to this repository. If this listeninghost already exists in this class, an exception will be thrown. Clear() Removes all listeninghosts from this repository. Contains(ListeningHost) Determines if an ListeningHost is present in this repository. CopyTo(ListeningHost[], int) Copies all elements from this repository to another compatible repository. GetEnumerator() Returns an enumerator that iterates through this ListeningHostRepository. IndexOf(ListeningHost) Insert(int, ListeningHost) Remove(ListeningHost) Try to remove a ListeningHost from this repository. If the item is removed, this methods returns true. RemoveAt(int)"
  },
  "api/Sisk.Core.Http.ListeningPort.-ctor.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.-ctor.html",
    "title": "Constructor ListeningPort | Sisk",
    "keywords": "Constructor ListeningPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll ListeningPort() Creates an new ListeningPort instance with default parameters. public ListeningPort() ListeningPort(ushort) Creates an new ListeningPort instance with the specified port at the loopback host. public ListeningPort(ushort port) Parameters port ushort The port the server will listen on. If this port is the default HTTPS port (443), the class will have the property Secure to true. ListeningPort(ushort, bool) Creates an new ListeningPort instance with the specified port and secure context at the loopback host. public ListeningPort(ushort port, bool secure) Parameters port ushort The port the server will listen on. secure bool Indicates whether the server should listen to this port securely (SSL). ListeningPort(bool, string, ushort) Creates an new ListeningPort instance with the specified port, secure context and hostname. public ListeningPort(bool secure, string hostname, ushort port) Parameters secure bool Indicates whether the server should listen to this port securely (SSL). hostname string The hostname DNS pattern the server will listen to. port ushort The port the server will listen on. ListeningPort(bool, string, ushort, string) Creates an new ListeningPort instance with the specified port, secure context, hostname and path. public ListeningPort(bool secure, string hostname, ushort port, string path) Parameters secure bool Indicates whether the server should listen to this port securely (SSL). hostname string The hostname DNS pattern the server will listen to. port ushort The port the server will listen on. path string The prefix path. ListeningPort(string) Creates an new ListeningPort instance with the specified URI. public ListeningPort(string uri) Parameters uri string The URI component that will be parsed to the listening port format."
  },
  "api/Sisk.Core.Http.ListeningPort.Equals.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Equals.html",
    "title": "Method Equals | Sisk",
    "keywords": "Method Equals Namespace Sisk.Core.Http Assembly Sisk.Core.dll Equals(object?) Determines if another object is equals to this class instance. public override bool Equals(object? obj) Parameters obj object The another object which will be used to compare. Returns bool Equals(ListeningPort) Determines if this ListeningPort is equals to another ListeningPort. public bool Equals(ListeningPort other) Parameters other ListeningPort The another object which will be used to compare. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.GetHashCode.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.GetHashCode.html",
    "title": "Method GetHashCode | Sisk",
    "keywords": "Method GetHashCode Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetHashCode() Gets the hash code for this listening port. public override int GetHashCode() Returns int"
  },
  "api/Sisk.Core.Http.ListeningPort.GetRandomPort.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.GetRandomPort.html",
    "title": "Method GetRandomPort | Sisk",
    "keywords": "Method GetRandomPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll GetRandomPort() Gets an ListeningPort object with an random insecure port at the default loopback address. public static ListeningPort GetRandomPort() Returns ListeningPort"
  },
  "api/Sisk.Core.Http.ListeningPort.Hostname.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Hostname.html",
    "title": "Property Hostname | Sisk",
    "keywords": "Property Hostname Namespace Sisk.Core.Http Assembly Sisk.Core.dll Hostname Gets the DNS hostname pattern where this listening port will refer. public string Hostname { get; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningPort.IsPathRoot.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.IsPathRoot.html",
    "title": "Property IsPathRoot | Sisk",
    "keywords": "Property IsPathRoot Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsPathRoot Gets an boolean indicating if this listening port has an non-rooted path. public bool IsPathRoot { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningPort.Parse.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Parse.html",
    "title": "Method Parse | Sisk",
    "keywords": "Method Parse Namespace Sisk.Core.Http Assembly Sisk.Core.dll Parse(string) Parses a string into a ListeningPort. public static ListeningPort Parse(string s) Parameters s string The string to parse. Returns ListeningPort Parse(string, IFormatProvider?) Parses a string into a ListeningPort. static ListeningPort Parse(string s, IFormatProvider? provider) Parameters s string The string to parse. provider IFormatProvider An object that provides culture-specific formatting information about s. Returns ListeningPort"
  },
  "api/Sisk.Core.Http.ListeningPort.Path.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Http Assembly Sisk.Core.dll Path Gets where this listening port prefix is listening to. public string Path { get; } Property Value string"
  },
  "api/Sisk.Core.Http.ListeningPort.Port.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Port.html",
    "title": "Property Port | Sisk",
    "keywords": "Property Port Namespace Sisk.Core.Http Assembly Sisk.Core.dll Port Gets the port where this listening port will refer. public ushort Port { get; } Property Value ushort"
  },
  "api/Sisk.Core.Http.ListeningPort.Secure.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.Secure.html",
    "title": "Property Secure | Sisk",
    "keywords": "Property Secure Namespace Sisk.Core.Http Assembly Sisk.Core.dll Secure Gets whether the server should listen to this port securely (SSL). public bool Secure { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.ListeningPort.ToString.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Http Assembly Sisk.Core.dll ToString() Gets an string representation of this ListeningPort. public override string ToString() Returns string ToString(bool) Gets an string representation of this ListeningPort. public string ToString(bool includePath = true) Parameters includePath bool Optional. Defines whether the path should be included in the result string. Returns string"
  },
  "api/Sisk.Core.Http.ListeningPort.TryParse.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.TryParse.html",
    "title": "Method TryParse | Sisk",
    "keywords": "Method TryParse Namespace Sisk.Core.Http Assembly Sisk.Core.dll TryParse(string?, IFormatProvider?, out ListeningPort) Tries to parse a string into a ListeningPort. static bool TryParse(string? s, IFormatProvider? provider, out ListeningPort result) Parameters s string The string to parse. provider IFormatProvider An object that provides culture-specific formatting information about s. result ListeningPort When this method returns, contains the result of successfully parsing s or an undefined value on failure. Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.html",
    "title": "Struct ListeningPort | Sisk",
    "keywords": "Struct ListeningPort Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a structure to contain a listener port for an ListeningHost instance. public readonly struct ListeningPort : IEquatable<ListeningPort>, IParsable<ListeningPort> Implements IEquatable<ListeningPort> IParsable<ListeningPort> Inherited Members object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Examples A listener port represents an access point on the HTTP server. It consists of an indicator that it should use a secure connection (HTTPS), its hostname and port. It must start with https:// or http://, and must terminate with an /. It is represented by the syntax: [http|https]://[hostname]:[port]/ Examples: http://localhost:80/ https://subdomain.domain.net:443/ http://182.32.112.223:5251/ Constructors ListeningPort() Creates an new ListeningPort instance with default parameters. ListeningPort(bool, string, ushort) Creates an new ListeningPort instance with the specified port, secure context and hostname. ListeningPort(bool, string, ushort, string) Creates an new ListeningPort instance with the specified port, secure context, hostname and path. ListeningPort(string) Creates an new ListeningPort instance with the specified URI. ListeningPort(ushort) Creates an new ListeningPort instance with the specified port at the loopback host. ListeningPort(ushort, bool) Creates an new ListeningPort instance with the specified port and secure context at the loopback host. Properties Hostname Gets the DNS hostname pattern where this listening port will refer. IsPathRoot Gets an boolean indicating if this listening port has an non-rooted path. Path Gets where this listening port prefix is listening to. Port Gets the port where this listening port will refer. Secure Gets whether the server should listen to this port securely (SSL). Methods Equals(ListeningPort) Determines if this ListeningPort is equals to another ListeningPort. Equals(object?) Determines if another object is equals to this class instance. GetHashCode() Gets the hash code for this listening port. GetRandomPort() Gets an ListeningPort object with an random insecure port at the default loopback address. Parse(string) Parses a string into a ListeningPort. ToString() Gets an string representation of this ListeningPort. ToString(bool) Gets an string representation of this ListeningPort. Operators operator ==(ListeningPort, ListeningPort) operator !=(ListeningPort, ListeningPort) Explicit Interface Implementations Parse(string, IFormatProvider?) Parses a string into a ListeningPort. TryParse(string?, IFormatProvider?, out ListeningPort) Tries to parse a string into a ListeningPort."
  },
  "api/Sisk.Core.Http.ListeningPort.op_Equality.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.op_Equality.html",
    "title": "Operator operator == | Sisk",
    "keywords": "Operator operator == Namespace Sisk.Core.Http Assembly Sisk.Core.dll operator ==(ListeningPort, ListeningPort) public static bool operator ==(ListeningPort left, ListeningPort right) Parameters left ListeningPort right ListeningPort Returns bool"
  },
  "api/Sisk.Core.Http.ListeningPort.op_Inequality.html": {
    "href": "api/Sisk.Core.Http.ListeningPort.op_Inequality.html",
    "title": "Operator operator != | Sisk",
    "keywords": "Operator operator != Namespace Sisk.Core.Http Assembly Sisk.Core.dll operator !=(ListeningPort, ListeningPort) public static bool operator !=(ListeningPort left, ListeningPort right) Parameters left ListeningPort right ListeningPort Returns bool"
  },
  "api/Sisk.Core.Http.LogStream.-ctor.html": {
    "href": "api/Sisk.Core.Http.LogStream.-ctor.html",
    "title": "Constructor LogStream | Sisk",
    "keywords": "Constructor LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll LogStream() Creates an new LogStream instance with no predefined outputs. public LogStream() LogStream(TextWriter) Creates an new LogStream instance with the given TextWriter object. public LogStream(TextWriter tw) Parameters tw TextWriter The TextWriter instance which this instance will write log to. LogStream(string) Creates an new LogStream instance with the given relative or absolute file path. public LogStream(string filename) Parameters filename string The file path where this instance will write log to. LogStream(string?, TextWriter?) Creates an new LogStream instance which writes text to an file and an TextWriter. public LogStream(string? filename, TextWriter? tw) Parameters filename string The file path where this instance will write log to. tw TextWriter The text writer which this instance will write log to."
  },
  "api/Sisk.Core.Http.LogStream.Close.html": {
    "href": "api/Sisk.Core.Http.LogStream.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http Assembly Sisk.Core.dll Close() Writes all pending logs from the queue and closes all resources used by this object. public virtual void Close()"
  },
  "api/Sisk.Core.Http.LogStream.ConfigureRotatingPolicy.html": {
    "href": "api/Sisk.Core.Http.LogStream.ConfigureRotatingPolicy.html",
    "title": "Method ConfigureRotatingPolicy | Sisk",
    "keywords": "Method ConfigureRotatingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConfigureRotatingPolicy(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. This method is an shortcut for calling Configure(long, TimeSpan) of this defined RotatingPolicy method. public LogStream ConfigureRotatingPolicy(long maximumSize, TimeSpan dueTime) Parameters maximumSize long The non-negative size threshold of the log file size in byte count. dueTime TimeSpan The time interval between checks. Returns LogStream Remarks The first run is performed immediately after calling this method."
  },
  "api/Sisk.Core.Http.LogStream.ConsoleOutput.html": {
    "href": "api/Sisk.Core.Http.LogStream.ConsoleOutput.html",
    "title": "Property ConsoleOutput | Sisk",
    "keywords": "Property ConsoleOutput Namespace Sisk.Core.Http Assembly Sisk.Core.dll ConsoleOutput Gets a LogStream that writes its output to the Out stream. public static LogStream ConsoleOutput { get; } Property Value LogStream"
  },
  "api/Sisk.Core.Http.LogStream.Dispose.html": {
    "href": "api/Sisk.Core.Http.LogStream.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose(bool) Writes all pending logs from the queue and closes all resources used by this object. protected virtual void Dispose(bool disposing) Parameters disposing bool Dispose() Writes all pending logs from the queue and closes all resources used by this object. public void Dispose()"
  },
  "api/Sisk.Core.Http.LogStream.Disposed.html": {
    "href": "api/Sisk.Core.Http.LogStream.Disposed.html",
    "title": "Property Disposed | Sisk",
    "keywords": "Property Disposed Namespace Sisk.Core.Http Assembly Sisk.Core.dll Disposed Gets an boolean indicating if this LogStream was disposed. public bool Disposed { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.Encoding.html": {
    "href": "api/Sisk.Core.Http.LogStream.Encoding.html",
    "title": "Property Encoding | Sisk",
    "keywords": "Property Encoding Namespace Sisk.Core.Http Assembly Sisk.Core.dll Encoding Gets or sets the encoding used for writting data to the output file. This property is only appliable if this instance is using an file-based output. public Encoding Encoding { get; set; } Property Value Encoding"
  },
  "api/Sisk.Core.Http.LogStream.FilePath.html": {
    "href": "api/Sisk.Core.Http.LogStream.FilePath.html",
    "title": "Property FilePath | Sisk",
    "keywords": "Property FilePath Namespace Sisk.Core.Http Assembly Sisk.Core.dll FilePath Gets or sets the absolute path to the file where the log is being written to. public string? FilePath { get; set; } Property Value string Remarks When setting this method, if the file directory doens't exists, it is created."
  },
  "api/Sisk.Core.Http.LogStream.Finalize.html": {
    "href": "api/Sisk.Core.Http.LogStream.Finalize.html",
    "title": "Method ~LogStream | Sisk",
    "keywords": "Method ~LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll ~LogStream() protected ~LogStream()"
  },
  "api/Sisk.Core.Http.LogStream.Flush.html": {
    "href": "api/Sisk.Core.Http.LogStream.Flush.html",
    "title": "Method Flush | Sisk",
    "keywords": "Method Flush Namespace Sisk.Core.Http Assembly Sisk.Core.dll Flush() Clears the current log queue and blocks the current thread until all content is written to the underlying streams. public void Flush()"
  },
  "api/Sisk.Core.Http.LogStream.IsBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.IsBuffering.html",
    "title": "Property IsBuffering | Sisk",
    "keywords": "Property IsBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll IsBuffering Gets an boolean indicating if this LogStream is buffering output messages to their internal message buffer. public bool IsBuffering { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.NormalizeEntries.html": {
    "href": "api/Sisk.Core.Http.LogStream.NormalizeEntries.html",
    "title": "Property NormalizeEntries | Sisk",
    "keywords": "Property NormalizeEntries Namespace Sisk.Core.Http Assembly Sisk.Core.dll NormalizeEntries Gets or sets a boolean that indicates that every input must be trimmed and have their line endings normalized before being written to the output stream. public bool NormalizeEntries { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.LogStream.Peek.html": {
    "href": "api/Sisk.Core.Http.LogStream.Peek.html",
    "title": "Method Peek | Sisk",
    "keywords": "Method Peek Namespace Sisk.Core.Http Assembly Sisk.Core.dll Peek() Reads the output buffer. To use this method, it's required to set this LogStream buffering with StartBuffering(int). public string Peek() Returns string Exceptions InvalidOperationException Thrown when this LogStream is not buffering."
  },
  "api/Sisk.Core.Http.LogStream.RotatingPolicy.html": {
    "href": "api/Sisk.Core.Http.LogStream.RotatingPolicy.html",
    "title": "Property RotatingPolicy | Sisk",
    "keywords": "Property RotatingPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll RotatingPolicy Gets the defined RotatingLogPolicy for this LogStream. public RotatingLogPolicy RotatingPolicy { get; } Property Value RotatingLogPolicy"
  },
  "api/Sisk.Core.Http.LogStream.StartBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.StartBuffering.html",
    "title": "Method StartBuffering | Sisk",
    "keywords": "Method StartBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll StartBuffering(int) Start buffering all output to an alternate stream in memory for readability with Peek() later. public void StartBuffering(int lines) Parameters lines int The amount of lines to store in the buffer."
  },
  "api/Sisk.Core.Http.LogStream.StopBuffering.html": {
    "href": "api/Sisk.Core.Http.LogStream.StopBuffering.html",
    "title": "Method StopBuffering | Sisk",
    "keywords": "Method StopBuffering Namespace Sisk.Core.Http Assembly Sisk.Core.dll StopBuffering() Stops buffering output to the alternative stream. public void StopBuffering()"
  },
  "api/Sisk.Core.Http.LogStream.TextWriter.html": {
    "href": "api/Sisk.Core.Http.LogStream.TextWriter.html",
    "title": "Property TextWriter | Sisk",
    "keywords": "Property TextWriter Namespace Sisk.Core.Http Assembly Sisk.Core.dll TextWriter Gets the TextWriter object where the log is being written to. public TextWriter? TextWriter { get; set; } Property Value TextWriter"
  },
  "api/Sisk.Core.Http.LogStream.WriteException.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteException.html",
    "title": "Method WriteException | Sisk",
    "keywords": "Method WriteException Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteException(Exception) Writes an exception description in the log. public virtual void WriteException(Exception exp) Parameters exp Exception The exception which will be written. WriteException(Exception, string?) Writes an exception description in the log. public virtual void WriteException(Exception exp, string? extraContext = null) Parameters exp Exception The exception which will be written. extraContext string Extra context message to append to the exception message."
  },
  "api/Sisk.Core.Http.LogStream.WriteLine.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLine.html",
    "title": "Method WriteLine | Sisk",
    "keywords": "Method WriteLine Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLine() Writes an line-break at the end of the output. public void WriteLine() WriteLine(object?) Writes the text and concats an line-break at the end into the output. public void WriteLine(object? message) Parameters message object The text that will be written in the output. WriteLine(string) Writes the text and concats an line-break at the end into the output. public void WriteLine(string message) Parameters message string The text that will be written in the output. WriteLine(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. public void WriteLine(string format, params object?[] args) Parameters format string The string format that represents the arguments positions. args object[] An array of objects that represents the string format slots values."
  },
  "api/Sisk.Core.Http.LogStream.WriteLineInternal.html": {
    "href": "api/Sisk.Core.Http.LogStream.WriteLineInternal.html",
    "title": "Method WriteLineInternal | Sisk",
    "keywords": "Method WriteLineInternal Namespace Sisk.Core.Http Assembly Sisk.Core.dll WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing. protected virtual void WriteLineInternal(string line) Parameters line string The line which will be written to the log stream."
  },
  "api/Sisk.Core.Http.LogStream.html": {
    "href": "api/Sisk.Core.Http.LogStream.html",
    "title": "Class LogStream | Sisk",
    "keywords": "Class LogStream Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a managed, asynchronous log writer which supports writing safe data to log files or text streams. public class LogStream : IDisposable Inheritance object LogStream Implements IDisposable Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors LogStream() Creates an new LogStream instance with no predefined outputs. LogStream(TextWriter) Creates an new LogStream instance with the given TextWriter object. LogStream(string) Creates an new LogStream instance with the given relative or absolute file path. LogStream(string?, TextWriter?) Creates an new LogStream instance which writes text to an file and an TextWriter. Properties ConsoleOutput Gets a LogStream that writes its output to the Out stream. Disposed Gets an boolean indicating if this LogStream was disposed. Encoding Gets or sets the encoding used for writting data to the output file. This property is only appliable if this instance is using an file-based output. FilePath Gets or sets the absolute path to the file where the log is being written to. IsBuffering Gets an boolean indicating if this LogStream is buffering output messages to their internal message buffer. NormalizeEntries Gets or sets a boolean that indicates that every input must be trimmed and have their line endings normalized before being written to the output stream. RotatingPolicy Gets the defined RotatingLogPolicy for this LogStream. TextWriter Gets the TextWriter object where the log is being written to. Methods Close() Writes all pending logs from the queue and closes all resources used by this object. ConfigureRotatingPolicy(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. This method is an shortcut for calling Configure(long, TimeSpan) of this defined RotatingPolicy method. Dispose() Writes all pending logs from the queue and closes all resources used by this object. Dispose(bool) Writes all pending logs from the queue and closes all resources used by this object. ~LogStream() Flush() Clears the current log queue and blocks the current thread until all content is written to the underlying streams. Peek() Reads the output buffer. To use this method, it's required to set this LogStream buffering with StartBuffering(int). StartBuffering(int) Start buffering all output to an alternate stream in memory for readability with Peek() later. StopBuffering() Stops buffering output to the alternative stream. WriteException(Exception) Writes an exception description in the log. WriteException(Exception, string?) Writes an exception description in the log. WriteLine() Writes an line-break at the end of the output. WriteLine(object?) Writes the text and concats an line-break at the end into the output. WriteLine(string) Writes the text and concats an line-break at the end into the output. WriteLine(string, params object?[]) Writes the text format and arguments and concats an line-break at the end into the output. WriteLineInternal(string) Represents the method that intercepts the line that will be written to an output log before being queued for writing."
  },
  "api/Sisk.Core.Http.RequestListenAction.html": {
    "href": "api/Sisk.Core.Http.RequestListenAction.html",
    "title": "Enum RequestListenAction | Sisk",
    "keywords": "Enum RequestListenAction Namespace Sisk.Core.Http Assembly Sisk.Core.dll Represents the HTTP server action when receiving an request. public enum RequestListenAction Fields Accept = 1 The server must accept and route the request. Drop = 2 The server must reject the request and close the connection with the client."
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.-ctor.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.-ctor.html",
    "title": "Constructor RotatingLogPolicy | Sisk",
    "keywords": "Constructor RotatingLogPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll RotatingLogPolicy(LogStream) Creates an new RotatingLogPolicy instance with the given LogStream object to watch. public RotatingLogPolicy(LogStream ls) Parameters ls LogStream"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Configure.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Configure.html",
    "title": "Method Configure | Sisk",
    "keywords": "Method Configure Namespace Sisk.Core.Http Assembly Sisk.Core.dll Configure(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. public void Configure(long maximumSize, TimeSpan due) Parameters maximumSize long The non-negative size threshold of the log file size in byte count. due TimeSpan The time interval between checks. Remarks The first run is performed immediately after calling this method."
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Dispose.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http Assembly Sisk.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.Due.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.Due.html",
    "title": "Property Due | Sisk",
    "keywords": "Property Due Namespace Sisk.Core.Http Assembly Sisk.Core.dll Due Gets the time interval between checks. public TimeSpan Due { get; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.MaximumSize.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.MaximumSize.html",
    "title": "Property MaximumSize | Sisk",
    "keywords": "Property MaximumSize Namespace Sisk.Core.Http Assembly Sisk.Core.dll MaximumSize Gets the file size threshold in bytes for when the file will be compressed and then cleared. public long MaximumSize { get; } Property Value long"
  },
  "api/Sisk.Core.Http.RotatingLogPolicy.html": {
    "href": "api/Sisk.Core.Http.RotatingLogPolicy.html",
    "title": "Class RotatingLogPolicy | Sisk",
    "keywords": "Class RotatingLogPolicy Namespace Sisk.Core.Http Assembly Sisk.Core.dll Provides a managed utility for rotating log files by their file size. public sealed class RotatingLogPolicy : IDisposable Inheritance object RotatingLogPolicy Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RotatingLogPolicy(LogStream) Creates an new RotatingLogPolicy instance with the given LogStream object to watch. Properties Due Gets the time interval between checks. MaximumSize Gets the file size threshold in bytes for when the file will be compressed and then cleared. Methods Configure(long, TimeSpan) Defines the time interval and size threshold for starting the task, and then starts the task. Dispose()"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.-ctor.html",
    "title": "Constructor EventSourceRegistrationHandler | Sisk",
    "keywords": "Constructor EventSourceRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EventSourceRegistrationHandler(object, nint) public EventSourceRegistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpRequestEventSource eventSource, AsyncCallback callback, object @object) Parameters sender object eventSource HttpRequestEventSource callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpRequestEventSource) public virtual void Invoke(object sender, HttpRequestEventSource eventSource) Parameters sender object eventSource HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceRegistrationHandler.html",
    "title": "Delegate EventSourceRegistrationHandler | Sisk",
    "keywords": "Delegate EventSourceRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpEventSourceCollection registers an new event source connection. public delegate void EventSourceRegistrationHandler(object sender, HttpRequestEventSource eventSource) Parameters sender object Represents the caller HttpEventSourceCollection object. eventSource HttpRequestEventSource Represents the registered HttpRequestEventSource event source connection. Constructors EventSourceRegistrationHandler(object, nint) Methods BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpRequestEventSource)"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.-ctor.html",
    "title": "Constructor EventSourceUnregistrationHandler | Sisk",
    "keywords": "Constructor EventSourceUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EventSourceUnregistrationHandler(object, nint) public EventSourceUnregistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpRequestEventSource eventSource, AsyncCallback callback, object @object) Parameters sender object eventSource HttpRequestEventSource callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpRequestEventSource) public virtual void Invoke(object sender, HttpRequestEventSource eventSource) Parameters sender object eventSource HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.EventSourceUnregistrationHandler.html",
    "title": "Delegate EventSourceUnregistrationHandler | Sisk",
    "keywords": "Delegate EventSourceUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpEventSourceCollection is removed and had their connection closed. public delegate void EventSourceUnregistrationHandler(object sender, HttpRequestEventSource eventSource) Parameters sender object Represents the caller HttpEventSourceCollection object. eventSource HttpRequestEventSource Represents the closed HttpRequestEventSource event source connection. Constructors EventSourceUnregistrationHandler(object, nint) Methods BeginInvoke(object, HttpRequestEventSource, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpRequestEventSource)"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.ActiveConnections.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.ActiveConnections.html",
    "title": "Property ActiveConnections | Sisk",
    "keywords": "Property ActiveConnections Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ActiveConnections Gets an number indicating the amount of active event source connections. public int ActiveConnections { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All.html",
    "title": "Method All | Sisk",
    "keywords": "Method All Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll All() Gets all actives HttpRequestEventSource instances. public HttpRequestEventSource[] All() Returns HttpRequestEventSource[]"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.DropAll.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.DropAll.html",
    "title": "Method DropAll | Sisk",
    "keywords": "Method DropAll Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DropAll() Closes and disposes all registered and active HttpRequestEventSource in this collections. public void DropAll()"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Find.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.Find.html",
    "title": "Method Find | Sisk",
    "keywords": "Method Find Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Find(Func<string, bool>) Gets all actives HttpRequestEventSource instances that matches their identifier predicate. public HttpRequestEventSource[] Find(Func<string, bool> predicate) Parameters predicate Func<string, bool> The expression on the an non-empty event source identifier. Returns HttpRequestEventSource[]"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetByIdentifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.GetByIdentifier.html",
    "title": "Method GetByIdentifier | Sisk",
    "keywords": "Method GetByIdentifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetByIdentifier(string) Gets the event source connection for the specified identifier. public HttpRequestEventSource? GetByIdentifier(string identifier) Parameters identifier string The event source identifier. Returns HttpRequestEventSource"
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceRegistered.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceRegistered.html",
    "title": "Event OnEventSourceRegistered | Sisk",
    "keywords": "Event OnEventSourceRegistered Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpRequestEventSource is registered in this collection. public event EventSourceRegistrationHandler? OnEventSourceRegistered Returns EventSourceRegistrationHandler Represents an event that is fired when an is registered in this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceUnregistration.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.OnEventSourceUnregistration.html",
    "title": "Event OnEventSourceUnregistration | Sisk",
    "keywords": "Event OnEventSourceUnregistration Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpRequestEventSource is closed and removed from this collection. public event EventSourceUnregistrationHandler? OnEventSourceUnregistration Returns EventSourceUnregistrationHandler Represents an event that is fired when an is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpEventSourceCollection.html",
    "title": "Class HttpEventSourceCollection | Sisk",
    "keywords": "Class HttpEventSourceCollection Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides a managed object to manage HttpRequestEventSource connections. public sealed class HttpEventSourceCollection Inheritance object HttpEventSourceCollection Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ActiveConnections Gets an number indicating the amount of active event source connections. Methods All() Gets all actives HttpRequestEventSource instances. DropAll() Closes and disposes all registered and active HttpRequestEventSource in this collections. Find(Func<string, bool>) Gets all actives HttpRequestEventSource instances that matches their identifier predicate. GetByIdentifier(string) Gets the event source connection for the specified identifier. Events OnEventSourceRegistered Represents an event that is fired when an HttpRequestEventSource is registered in this collection. OnEventSourceUnregistration Represents an event that is fired when an HttpRequestEventSource is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader.html",
    "title": "Method AppendHeader | Sisk",
    "keywords": "Method AppendHeader Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll AppendHeader(string, string) Sends an header to the streaming context. public void AppendHeader(string name, string value) Parameters name string The header name. value string The header value."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Cancel.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Cancel.html",
    "title": "Method Cancel | Sisk",
    "keywords": "Method Cancel Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Cancel() Cancels the sending queue from sending pending messages and clears the queue. public void Cancel()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes the event listener and it's connection. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Dispose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Dispose() Flushes and releases the used resources of this class instance. public void Dispose()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.HttpRequest.html",
    "title": "Property HttpRequest | Sisk",
    "keywords": "Property HttpRequest Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll HttpRequest Gets the HttpRequest object which created this Event Source instance. public HttpRequest HttpRequest { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Identifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Identifier.html",
    "title": "Property Identifier | Sisk",
    "keywords": "Property Identifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Identifier Gets an unique identifier label to this EventStream connection, useful for finding this connection's reference later. public string? Identifier { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.IsActive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.IsActive.html",
    "title": "Property IsActive | Sisk",
    "keywords": "Property IsActive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsActive Gets an boolean indicating if this connection is open and this instance can send messages. public bool IsActive { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.KeepAlive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.KeepAlive.html",
    "title": "Method KeepAlive | Sisk",
    "keywords": "Method KeepAlive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll KeepAlive() Asynchronously waits for the connection to close before continuing execution. This method is released when either the client or the server reaches an sending failure. public void KeepAlive()"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.PingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.PingPolicy.html",
    "title": "Property PingPolicy | Sisk",
    "keywords": "Property PingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll PingPolicy Gets the HttpStreamPingPolicy for this HTTP event source connection. public HttpStreamPingPolicy PingPolicy { get; } Property Value HttpStreamPingPolicy"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Send.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.Send.html",
    "title": "Method Send | Sisk",
    "keywords": "Method Send Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Send(string) Writes a event message with their data to the event listener and returns an boolean indicating if the message was delivered to the client. public bool Send(string data) Parameters data string The message text. Returns bool Send(object?) Writes a event message with their data to the event listener and returns an boolean indicating if the message was delivered to the client. public bool Send(object? data) Parameters data object The message object. Returns bool"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SentContentLength.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.SentContentLength.html",
    "title": "Property SentContentLength | Sisk",
    "keywords": "Property SentContentLength Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SentContentLength Gets an integer indicating the total bytes sent by this instance to the client. public int SentContentLength { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail.html",
    "title": "Method WaitForFail | Sisk",
    "keywords": "Method WaitForFail Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitForFail(TimeSpan) Asynchronously waits for the connection to close before continuing execution with an maximum keep alive timeout. This method is released when either the client or the server reaches an sending failure. public void WaitForFail(TimeSpan maximumIdleTolerance) Parameters maximumIdleTolerance TimeSpan The maximum timeout interval for an idle connection to automatically release this method."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WithPing.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.WithPing.html",
    "title": "Method WithPing | Sisk",
    "keywords": "Method WithPing Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Event Source. public void WithPing(Action<HttpStreamPingPolicy> act) Parameters act Action<HttpStreamPingPolicy> The method that runs on the ping policy for this HTTP Event Source."
  },
  "api/Sisk.Core.Http.Streams.HttpRequestEventSource.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpRequestEventSource.html",
    "title": "Class HttpRequestEventSource | Sisk",
    "keywords": "Class HttpRequestEventSource Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll An HttpRequestEventSource instance opens a persistent connection to the request, which sends events in text/event-stream format. public sealed class HttpRequestEventSource : IDisposable Inheritance object HttpRequestEventSource Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpRequest Gets the HttpRequest object which created this Event Source instance. Identifier Gets an unique identifier label to this EventStream connection, useful for finding this connection's reference later. IsActive Gets an boolean indicating if this connection is open and this instance can send messages. PingPolicy Gets the HttpStreamPingPolicy for this HTTP event source connection. SentContentLength Gets an integer indicating the total bytes sent by this instance to the client. Methods AppendHeader(string, string) Sends an header to the streaming context. Cancel() Cancels the sending queue from sending pending messages and clears the queue. Close() Closes the event listener and it's connection. Dispose() Flushes and releases the used resources of this class instance. KeepAlive() Asynchronously waits for the connection to close before continuing execution. This method is released when either the client or the server reaches an sending failure. Send(object?) Writes a event message with their data to the event listener and returns an boolean indicating if the message was delivered to the client. Send(string) Writes a event message with their data to the event listener and returns an boolean indicating if the message was delivered to the client. WaitForFail(TimeSpan) Asynchronously waits for the connection to close before continuing execution with an maximum keep alive timeout. This method is released when either the client or the server reaches an sending failure. WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Event Source."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes this HTTP response stream connection between the server and the client and returns an empty HttpResponse to finish the HTTP server context. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.ResponseStream.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.ResponseStream.html",
    "title": "Property ResponseStream | Sisk",
    "keywords": "Property ResponseStream Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ResponseStream Gets the Stream that represents the HTTP response output stream. public Stream ResponseStream { get; } Property Value Stream"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.SendChunked.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.SendChunked.html",
    "title": "Property SendChunked | Sisk",
    "keywords": "Property SendChunked Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SendChunked Gets or sets whether this HTTP response stream should use chunked transfer encoding. public bool SendChunked { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.SetContentLength.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.SetContentLength.html",
    "title": "Method SetContentLength | Sisk",
    "keywords": "Method SetContentLength Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetContentLength(long) Sets the Content-Length header of this response stream. If this response stream is using chunked transfer encoding, this method will do nothing. public void SetContentLength(long contentLength) Parameters contentLength long The length in bytes of the content stream."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.SetCookie.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.SetCookie.html",
    "title": "Method SetCookie | Sisk",
    "keywords": "Method SetCookie Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(Cookie cookie) Parameters cookie Cookie The cookie object. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value) Parameters name string The cookie name. value string The cookie value. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. public void SetCookie(string name, string value, DateTime? expires = null, TimeSpan? maxAge = null, string? domain = null, string? path = null, bool? secure = null, bool? httpOnly = null, string? sameSite = null) Parameters name string The cookie name. value string The cookie value. expires DateTime? The cookie expirity date. maxAge TimeSpan? The cookie max duration after being set. domain string The domain where the cookie will be valid. path string The path where the cookie will be valid. secure bool? Determines if the cookie will only be stored in an secure context. httpOnly bool? Determines if the cookie will be only available in the HTTP context. sameSite string The cookie SameSite parameter."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.SetHeader.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.SetHeader.html",
    "title": "Method SetHeader | Sisk",
    "keywords": "Method SetHeader Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetHeader(string, object?) Sets the specific HTTP header into this response stream. public void SetHeader(string headerName, object? value) Parameters headerName string The HTTP header name. value object The HTTP header value. Remarks Headers are sent immediately, along with the HTTP response code, after starting to send content or closing this stream."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.SetStatus.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.SetStatus.html",
    "title": "Method SetStatus | Sisk",
    "keywords": "Method SetStatus Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SetStatus(int) Sets the HTTP status code for this response stream. public void SetStatus(int httpStatusCode) Parameters httpStatusCode int The HTTP status code. SetStatus(HttpStatusCode) Sets the HTTP status code for this response stream. public void SetStatus(HttpStatusCode statusCode) Parameters statusCode HttpStatusCode The HTTP status code. SetStatus(HttpStatusInformation) Sets the HTTP status code and description for this response stream. public void SetStatus(HttpStatusInformation statusCode) Parameters statusCode HttpStatusInformation The custom HTTP status code information."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.Write.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.Write.html",
    "title": "Method Write | Sisk",
    "keywords": "Method Write Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Write(ReadOnlySpan<byte>) Writes an sequence of bytes to the HTTP response stream. public void Write(ReadOnlySpan<byte> buffer) Parameters buffer ReadOnlySpan<byte> The read only memory that includes the buffer which will be written to the HTTP response. Write(byte[]) Writes an sequence of bytes to the HTTP response stream. public void Write(byte[] buffer) Parameters buffer byte[] The byte array that includes the buffer which will be written to the HTTP response."
  },
  "api/Sisk.Core.Http.Streams.HttpResponseStream.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpResponseStream.html",
    "title": "Class HttpResponseStream | Sisk",
    "keywords": "Class HttpResponseStream Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents a way to manage HTTP requests with their output streams, without relying on synchronous content. public sealed class HttpResponseStream Inheritance object HttpResponseStream Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ResponseStream Gets the Stream that represents the HTTP response output stream. SendChunked Gets or sets whether this HTTP response stream should use chunked transfer encoding. Methods Close() Closes this HTTP response stream connection between the server and the client and returns an empty HttpResponse to finish the HTTP server context. SetContentLength(long) Sets the Content-Length header of this response stream. If this response stream is using chunked transfer encoding, this method will do nothing. SetCookie(Cookie) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string) Sets a cookie and sends it in the response to be set by the client. SetCookie(string, string, DateTime?, TimeSpan?, string?, string?, bool?, bool?, string?) Sets a cookie and sends it in the response to be set by the client. SetHeader(string, object?) Sets the specific HTTP header into this response stream. SetStatus(HttpStatusInformation) Sets the HTTP status code and description for this response stream. SetStatus(int) Sets the HTTP status code for this response stream. SetStatus(HttpStatusCode) Sets the HTTP status code for this response stream. Write(byte[]) Writes an sequence of bytes to the HTTP response stream. Write(ReadOnlySpan<byte>) Writes an sequence of bytes to the HTTP response stream."
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.DataMessage.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.DataMessage.html",
    "title": "Property DataMessage | Sisk",
    "keywords": "Property DataMessage Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DataMessage Gets or sets the payload message that is sent to the server as a ping message. public string DataMessage { get; set; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Interval.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Interval.html",
    "title": "Property Interval | Sisk",
    "keywords": "Property Interval Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Interval Gets or sets the sending interval for each ping message. public TimeSpan Interval { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Start.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Start() Starts sending periodic pings to the client. public void Start() Start(string, TimeSpan) Configures and starts sending periodic pings to the client. public void Start(string dataMessage, TimeSpan interval) Parameters dataMessage string The payload message that is sent to the server as a ping message. interval TimeSpan The sending interval for each ping message."
  },
  "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpStreamPingPolicy.html",
    "title": "Class HttpStreamPingPolicy | Sisk",
    "keywords": "Class HttpStreamPingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides an automatic ping sender for HTTP Event Source connections. public sealed class HttpStreamPingPolicy Inheritance object HttpStreamPingPolicy Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties DataMessage Gets or sets the payload message that is sent to the server as a ping message. Interval Gets or sets the sending interval for each ping message. Methods Start() Starts sending periodic pings to the client. Start(string, TimeSpan) Configures and starts sending periodic pings to the client."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Close.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Close.html",
    "title": "Method Close | Sisk",
    "keywords": "Method Close Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Close() Closes the connection between the client and the server and returns an HTTP response indicating that the connection has been terminated. This method will not throw an exception if the connection is already closed. public HttpResponse Close() Returns HttpResponse"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.HttpRequest.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.HttpRequest.html",
    "title": "Property HttpRequest | Sisk",
    "keywords": "Property HttpRequest Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll HttpRequest Gets the HttpRequest object which created this Web Socket instance. public HttpRequest HttpRequest { get; } Property Value HttpRequest"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Identifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Identifier.html",
    "title": "Property Identifier | Sisk",
    "keywords": "Property Identifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Identifier Gets an unique identifier label to this Web Socket connection, useful for finding this connection's reference later. public string? Identifier { get; } Property Value string"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.IsClosed.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.IsClosed.html",
    "title": "Property IsClosed | Sisk",
    "keywords": "Property IsClosed Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsClosed Gets an boolean indicating if this Web Socket connection is closed. public bool IsClosed { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.MaxAttempts.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.MaxAttempts.html",
    "title": "Property MaxAttempts | Sisk",
    "keywords": "Property MaxAttempts Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll MaxAttempts Gets or sets the maximum number of attempts to send a failed message before the server closes the connection. Set it to -1 to don't close the connection on failed attempts. public int MaxAttempts { get; set; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.OnReceive.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.OnReceive.html",
    "title": "Event OnReceive | Sisk",
    "keywords": "Event OnReceive Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents the event which is called when this web socket receives an message from remote origin. public event WebSocketMessageReceivedEventHandler? OnReceive Returns WebSocketMessageReceivedEventHandler Represents the event which is called when this web socket receives an message from remote origin."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.PingPolicy.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.PingPolicy.html",
    "title": "Property PingPolicy | Sisk",
    "keywords": "Property PingPolicy Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll PingPolicy Gets the HttpStreamPingPolicy for this HTTP web socket connection. public HttpStreamPingPolicy PingPolicy { get; } Property Value HttpStreamPingPolicy"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.Send.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.Send.html",
    "title": "Method Send | Sisk",
    "keywords": "Method Send Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Send(object) Sends an text message to the remote point. public bool Send(object message) Parameters message object The target message which will be as an encoded UTF-8 string. Returns bool Send(string) Sends an text message to the remote point. public bool Send(string message) Parameters message string The target message which will be as an encoded using the request preferred encoding. Returns bool Send(byte[]) Sends an binary message to the remote point. public bool Send(byte[] buffer) Parameters buffer byte[] The target byte array. Returns bool Send(byte[], int, int) Sends an binary message to the remote point. public bool Send(byte[] buffer, int start, int length) Parameters buffer byte[] The target byte array. start int The index at which to begin the memory. length int The number of items in the memory. Returns bool Send(ReadOnlyMemory<byte>) Sends an binary message to the remote point. public bool Send(ReadOnlyMemory<byte> buffer) Parameters buffer ReadOnlyMemory<byte> The target byte memory. Returns bool"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.SendAsync.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.SendAsync.html",
    "title": "Method SendAsync | Sisk",
    "keywords": "Method SendAsync Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll SendAsync(object) Asynchronously sends an message to the remote point. public Task<bool> SendAsync(object message) Parameters message object The target message which will be as an encoded UTF-8 string. Returns Task<bool> SendAsync(string) Asynchronously sends an text message to the remote point. public Task<bool> SendAsync(string message) Parameters message string The target message which will be as an encoded UTF-8 string. Returns Task<bool> SendAsync(byte[]) Asynchronously sends an binary message to the remote point. public Task<bool> SendAsync(byte[] buffer) Parameters buffer byte[] The target message which will be as an encoded UTF-8 string. Returns Task<bool>"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.State.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.State.html",
    "title": "Property State | Sisk",
    "keywords": "Property State Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll State Gets or sets an object linked with this WebSocket session. public object? State { get; set; } Property Value object"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitForClose.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitForClose.html",
    "title": "Method WaitForClose | Sisk",
    "keywords": "Method WaitForClose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitForClose(TimeSpan) Blocks the current call stack until the connection is terminated by the client or the server, limited to the maximum timeout. public void WaitForClose(TimeSpan timeout) Parameters timeout TimeSpan Defines the timeout timer before the connection expires without any message. WaitForClose() Blocks the current call stack until the connection is terminated by either the client or the server. public void WaitForClose()"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitNext.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitNext.html",
    "title": "Method WaitNext | Sisk",
    "keywords": "Method WaitNext Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitNext() Blocks the current thread and waits the next incoming message from this web socket instance. public WebSocketMessage? WaitNext() Returns WebSocketMessage Remarks Null is returned if a connection error is thrown. WaitNext(TimeSpan) Blocks the current thread and waits the next incoming message from this web socket instance within the maximum defined timeout. public WebSocketMessage? WaitNext(TimeSpan timeout) Parameters timeout TimeSpan The maximum time to wait until the next message. Returns WebSocketMessage Remarks Null is returned if a connection error is thrown."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitTimeout.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WaitTimeout.html",
    "title": "Property WaitTimeout | Sisk",
    "keywords": "Property WaitTimeout Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WaitTimeout Gets or sets the maximum wait time for synchronous listener methods like WaitNext(). public TimeSpan WaitTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.WithPing.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.WithPing.html",
    "title": "Method WithPing | Sisk",
    "keywords": "Method WithPing Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Web Socket. public HttpWebSocket WithPing(Action<HttpStreamPingPolicy> act) Parameters act Action<HttpStreamPingPolicy> The method that runs on the ping policy for this HTTP Web Socket. Returns HttpWebSocket WithPing(string, TimeSpan) Configures the ping policy for this instance of HTTP Web Socket. public HttpWebSocket WithPing(string probeMessage, TimeSpan interval) Parameters probeMessage string The payload/probe message that is sent to the client. interval TimeSpan The sending interval for each probe message. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocket.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocket.html",
    "title": "Class HttpWebSocket | Sisk",
    "keywords": "Class HttpWebSocket Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides an persistent bi-directional socket between the client and the HTTP server. public sealed class HttpWebSocket Inheritance object HttpWebSocket Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpRequest Gets the HttpRequest object which created this Web Socket instance. Identifier Gets an unique identifier label to this Web Socket connection, useful for finding this connection's reference later. IsClosed Gets an boolean indicating if this Web Socket connection is closed. MaxAttempts Gets or sets the maximum number of attempts to send a failed message before the server closes the connection. Set it to -1 to don't close the connection on failed attempts. PingPolicy Gets the HttpStreamPingPolicy for this HTTP web socket connection. State Gets or sets an object linked with this WebSocket session. WaitTimeout Gets or sets the maximum wait time for synchronous listener methods like WaitNext(). Methods Close() Closes the connection between the client and the server and returns an HTTP response indicating that the connection has been terminated. This method will not throw an exception if the connection is already closed. Send(byte[]) Sends an binary message to the remote point. Send(byte[], int, int) Sends an binary message to the remote point. Send(object) Sends an text message to the remote point. Send(ReadOnlyMemory<byte>) Sends an binary message to the remote point. Send(string) Sends an text message to the remote point. SendAsync(byte[]) Asynchronously sends an binary message to the remote point. SendAsync(object) Asynchronously sends an message to the remote point. SendAsync(string) Asynchronously sends an text message to the remote point. WaitForClose() Blocks the current call stack until the connection is terminated by either the client or the server. WaitForClose(TimeSpan) Blocks the current call stack until the connection is terminated by the client or the server, limited to the maximum timeout. WaitNext() Blocks the current thread and waits the next incoming message from this web socket instance. WaitNext(TimeSpan) Blocks the current thread and waits the next incoming message from this web socket instance within the maximum defined timeout. WithPing(Action<HttpStreamPingPolicy>) Configures the ping policy for this instance of HTTP Web Socket. WithPing(string, TimeSpan) Configures the ping policy for this instance of HTTP Web Socket. Events OnReceive Represents the event which is called when this web socket receives an message from remote origin."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.ActiveConnections.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.ActiveConnections.html",
    "title": "Property ActiveConnections | Sisk",
    "keywords": "Property ActiveConnections Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll ActiveConnections Gets an number indicating the amount of active web socket connections. public int ActiveConnections { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.All.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.All.html",
    "title": "Method All | Sisk",
    "keywords": "Method All Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll All() Gets all actives HttpWebSocket instances. public HttpWebSocket[] All() Returns HttpWebSocket[]"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.DropAll.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.DropAll.html",
    "title": "Method DropAll | Sisk",
    "keywords": "Method DropAll Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll DropAll() Closes all registered and active HttpWebSocket in this collections. public void DropAll()"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Find.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.Find.html",
    "title": "Method Find | Sisk",
    "keywords": "Method Find Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Find(Func<string, bool>) Gets all actives HttpWebSocket instances that matches their identifier predicate. public HttpWebSocket[] Find(Func<string, bool> predicate) Parameters predicate Func<string, bool> The expression on the an non-empty Web Socket identifier. Returns HttpWebSocket[]"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetByIdentifier.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.GetByIdentifier.html",
    "title": "Method GetByIdentifier | Sisk",
    "keywords": "Method GetByIdentifier Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetByIdentifier(string) Gets the Web Sockect connection for the specified identifier. public HttpWebSocket? GetByIdentifier(string identifier) Parameters identifier string The Web Socket identifier. Returns HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketRegister.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketRegister.html",
    "title": "Event OnWebSocketRegister | Sisk",
    "keywords": "Event OnWebSocketRegister Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpWebSocket is registered in this collection. public event WebSocketRegistrationHandler? OnWebSocketRegister Returns WebSocketRegistrationHandler Represents an event that is fired when an is registered in this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketUnregister.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.OnWebSocketUnregister.html",
    "title": "Event OnWebSocketUnregister | Sisk",
    "keywords": "Event OnWebSocketUnregister Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an event that is fired when an HttpWebSocket is closed and removed from this collection. public event WebSocketRegistrationHandler? OnWebSocketUnregister Returns WebSocketRegistrationHandler Represents an event that is fired when an is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.html": {
    "href": "api/Sisk.Core.Http.Streams.HttpWebSocketConnectionCollection.html",
    "title": "Class HttpWebSocketConnectionCollection | Sisk",
    "keywords": "Class HttpWebSocketConnectionCollection Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Provides a managed object to manage HttpWebSocket connections. public sealed class HttpWebSocketConnectionCollection Inheritance object HttpWebSocketConnectionCollection Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties ActiveConnections Gets an number indicating the amount of active web socket connections. Methods All() Gets all actives HttpWebSocket instances. DropAll() Closes all registered and active HttpWebSocket in this collections. Find(Func<string, bool>) Gets all actives HttpWebSocket instances that matches their identifier predicate. GetByIdentifier(string) Gets the Web Sockect connection for the specified identifier. Events OnWebSocketRegister Represents an event that is fired when an HttpWebSocket is registered in this collection. OnWebSocketUnregister Represents an event that is fired when an HttpWebSocket is closed and removed from this collection."
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.GetString.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.GetString.html",
    "title": "Method GetString | Sisk",
    "keywords": "Method GetString Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll GetString(Encoding) Reads the message bytes as string using the specified encoding. public string GetString(Encoding encoding) Parameters encoding Encoding The encoding which will be used to decode the message. Returns string GetString() Reads the message bytes as string using the HTTP request encoding. public string GetString() Returns string"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.IsClose.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.IsClose.html",
    "title": "Property IsClose | Sisk",
    "keywords": "Property IsClose Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsClose Gets an boolean indicating that this message is an remote closing message. public bool IsClose { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.IsEnd.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.IsEnd.html",
    "title": "Property IsEnd | Sisk",
    "keywords": "Property IsEnd Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll IsEnd Gets an boolean indicating that this message is the last chunk of the message. public bool IsEnd { get; } Property Value bool"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.Length.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.Length.html",
    "title": "Property Length | Sisk",
    "keywords": "Property Length Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Length Gets the message length in byte count. public int Length { get; } Property Value int"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.MessageBytes.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.MessageBytes.html",
    "title": "Property MessageBytes | Sisk",
    "keywords": "Property MessageBytes Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll MessageBytes Gets an byte array with the message contents. public byte[] MessageBytes { get; } Property Value byte[]"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.Sender.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.Sender.html",
    "title": "Property Sender | Sisk",
    "keywords": "Property Sender Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Sender Gets the sender HttpWebSocket object instance which received this message. public HttpWebSocket Sender { get; } Property Value HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessage.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessage.html",
    "title": "Class WebSocketMessage | Sisk",
    "keywords": "Class WebSocketMessage Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an websocket request message received by an websocket server. public sealed class WebSocketMessage Inheritance object WebSocketMessage Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties IsClose Gets an boolean indicating that this message is an remote closing message. IsEnd Gets an boolean indicating that this message is the last chunk of the message. Length Gets the message length in byte count. MessageBytes Gets an byte array with the message contents. Sender Gets the sender HttpWebSocket object instance which received this message. Methods GetString() Reads the message bytes as string using the HTTP request encoding. GetString(Encoding) Reads the message bytes as string using the specified encoding."
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.-ctor.html",
    "title": "Constructor WebSocketMessageReceivedEventHandler | Sisk",
    "keywords": "Constructor WebSocketMessageReceivedEventHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WebSocketMessageReceivedEventHandler(object, nint) public WebSocketMessageReceivedEventHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object?, WebSocketMessage, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object? sender, WebSocketMessage message, AsyncCallback callback, object @object) Parameters sender object message WebSocketMessage callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object?, WebSocketMessage) public virtual void Invoke(object? sender, WebSocketMessage message) Parameters sender object message WebSocketMessage"
  },
  "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketMessageReceivedEventHandler.html",
    "title": "Delegate WebSocketMessageReceivedEventHandler | Sisk",
    "keywords": "Delegate WebSocketMessageReceivedEventHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents the void that is called when the Web Socket receives an message. public delegate void WebSocketMessageReceivedEventHandler(object? sender, WebSocketMessage message) Parameters sender object The HttpWebSocket object which fired the event. message WebSocketMessage The Web Socket message information. Constructors WebSocketMessageReceivedEventHandler(object, nint) Methods BeginInvoke(object?, WebSocketMessage, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object?, WebSocketMessage)"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.-ctor.html",
    "title": "Constructor WebSocketRegistrationHandler | Sisk",
    "keywords": "Constructor WebSocketRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WebSocketRegistrationHandler(object, nint) public WebSocketRegistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpWebSocket, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpWebSocket ws, AsyncCallback callback, object @object) Parameters sender object ws HttpWebSocket callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpWebSocket) public virtual void Invoke(object sender, HttpWebSocket ws) Parameters sender object ws HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketRegistrationHandler.html",
    "title": "Delegate WebSocketRegistrationHandler | Sisk",
    "keywords": "Delegate WebSocketRegistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpWebSocketConnectionCollection registers an new web socket connection. public delegate void WebSocketRegistrationHandler(object sender, HttpWebSocket ws) Parameters sender object Represents the caller HttpWebSocketConnectionCollection object. ws HttpWebSocket Represents the registered HttpWebSocket web socket connection. Constructors WebSocketRegistrationHandler(object, nint) Methods BeginInvoke(object, HttpWebSocket, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpWebSocket)"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.-ctor.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.-ctor.html",
    "title": "Constructor WebSocketUnregistrationHandler | Sisk",
    "keywords": "Constructor WebSocketUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll WebSocketUnregistrationHandler(object, nint) public WebSocketUnregistrationHandler(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.BeginInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll BeginInvoke(object, HttpWebSocket, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(object sender, HttpWebSocket ws, AsyncCallback callback, object @object) Parameters sender object ws HttpWebSocket callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.EndInvoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual void EndInvoke(IAsyncResult result) Parameters result IAsyncResult"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.Invoke.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Invoke(object, HttpWebSocket) public virtual void Invoke(object sender, HttpWebSocket ws) Parameters sender object ws HttpWebSocket"
  },
  "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.html": {
    "href": "api/Sisk.Core.Http.Streams.WebSocketUnregistrationHandler.html",
    "title": "Delegate WebSocketUnregistrationHandler | Sisk",
    "keywords": "Delegate WebSocketUnregistrationHandler Namespace Sisk.Core.Http.Streams Assembly Sisk.Core.dll Represents an function that is called when an HttpWebSocketConnectionCollection is removed and had it's connection closed. public delegate void WebSocketUnregistrationHandler(object sender, HttpWebSocket ws) Parameters sender object Represents the caller HttpWebSocketConnectionCollection object. ws HttpWebSocket Represents the closed HttpWebSocket web socket connection. Constructors WebSocketUnregistrationHandler(object, nint) Methods BeginInvoke(object, HttpWebSocket, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(object, HttpWebSocket)"
  },
  "api/Sisk.Core.Http.Streams.html": {
    "href": "api/Sisk.Core.Http.Streams.html",
    "title": "Namespace Sisk.Core.Http.Streams | Sisk",
    "keywords": "Namespace Sisk.Core.Http.Streams Classes HttpEventSourceCollection Provides a managed object to manage HttpRequestEventSource connections. HttpRequestEventSource An HttpRequestEventSource instance opens a persistent connection to the request, which sends events in text/event-stream format. HttpResponseStream Represents a way to manage HTTP requests with their output streams, without relying on synchronous content. HttpStreamPingPolicy Provides an automatic ping sender for HTTP Event Source connections. HttpWebSocket Provides an persistent bi-directional socket between the client and the HTTP server. HttpWebSocketConnectionCollection Provides a managed object to manage HttpWebSocket connections. WebSocketMessage Represents an websocket request message received by an websocket server. Delegates EventSourceRegistrationHandler Represents an function that is called when an HttpEventSourceCollection registers an new event source connection. EventSourceUnregistrationHandler Represents an function that is called when an HttpEventSourceCollection is removed and had their connection closed. WebSocketMessageReceivedEventHandler Represents the void that is called when the Web Socket receives an message. WebSocketRegistrationHandler Represents an function that is called when an HttpWebSocketConnectionCollection registers an new web socket connection. WebSocketUnregistrationHandler Represents an function that is called when an HttpWebSocketConnectionCollection is removed and had it's connection closed."
  },
  "api/Sisk.Core.Http.html": {
    "href": "api/Sisk.Core.Http.html",
    "title": "Namespace Sisk.Core.Http | Sisk",
    "keywords": "Namespace Sisk.Core.Http Namespaces Sisk.Core.Http.Handlers Sisk.Core.Http.Hosting Sisk.Core.Http.Streams Classes BrotliContent Represents an HTTP content that is compressed using the Brotli algorithm. CompressedContent Represents a base class for HTTP contents served over an compressing stream. DefaultMessagePage Provides methods for creating informative static pages used by Sisk. DeflateContent Represents an HTTP content that is compressed using the Deflate algorithm. ForwardingResolver Provides HTTP forwarding resolving methods that can be used to resolving the client remote address, host and protocol of a proxy, load balancer or CDN, through the HTTP request. GZipContent Represents an HTTP content that is compressed using the GZip algorithm. HtmlContent Provides HTTP content based on HTML contents. HttpContext Represents an context that is shared in a entire HTTP session. HttpKnownHeaderNames Provides most of the most commonly known HTTP headers for constants. HttpRequest Represents an HTTP request received by a Sisk server. HttpRequestException Represents an exception that is thrown while a request is being interpreted by the HTTP server. HttpResponse Represents an HTTP Response. HttpResponseExtensions Provides useful extensions for HttpResponse objects. HttpServer Provides an lightweight HTTP server powered by Sisk. HttpServerConfiguration Provides execution parameters for an HttpServer. HttpServerExecutionResult Represents the results of an request execution on the HTTP server. ListeningHost Provides a structure to contain the fields needed by an http server host. ListeningHostRepository Represents an fluent repository of ListeningHost that can add, modify, or remove listening hosts while an HttpServer is running. LogStream Provides a managed, asynchronous log writer which supports writing safe data to log files or text streams. RotatingLogPolicy Provides a managed utility for rotating log files by their file size. Structs HttpStatusInformation Represents a structure that holds an HTTP response status information, with it's status code and description. ListeningPort Provides a structure to contain a listener port for an ListeningHost instance. Enums HttpServerExecutionStatus Represents the status of an execution of a request on an HttpServer. RequestListenAction Represents the HTTP server action when receiving an request."
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.-ctor.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.-ctor.html",
    "title": "Constructor AsyncRequestHandler | Sisk",
    "keywords": "Constructor AsyncRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll AsyncRequestHandler() protected AsyncRequestHandler()"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.Create.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>>, RequestHandlerExecutionMode) Gets an inline AsyncRequestHandler that resolves to the specified function. public static AsyncRequestHandler Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>> execute, RequestHandlerExecutionMode executionMode = RequestHandlerExecutionMode.BeforeResponse) Parameters execute Func<HttpRequest, HttpContext, Task<HttpResponse>> The function that the AsyncRequestHandler will run. executionMode RequestHandlerExecutionMode Optional. Determines where the request handler will be executed. Returns AsyncRequestHandler"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.ExecuteAsync.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.ExecuteAsync.html",
    "title": "Method ExecuteAsync | Sisk",
    "keywords": "Method ExecuteAsync Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecuteAsync(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. public abstract Task<HttpResponse?> ExecuteAsync(HttpRequest request, HttpContext context) Parameters request HttpRequest The entry HTTP request. context HttpContext The HTTP request context. It may contain information from other IRequestHandler. Returns Task<HttpResponse>"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecutionMode Gets or sets when this RequestHandler should run. public virtual RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.Next.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.Next.html",
    "title": "Method Next | Sisk",
    "keywords": "Method Next Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Next() Returns an null HttpResponse reference, which points to the next request handler or route action. public HttpResponse? Next() Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.AsyncRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.AsyncRequestHandler.html",
    "title": "Class AsyncRequestHandler | Sisk",
    "keywords": "Class AsyncRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a class that implements IRequestHandler and its execution method is asynchronous. public abstract class AsyncRequestHandler : IRequestHandler Inheritance object AsyncRequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors AsyncRequestHandler() Properties ExecutionMode Gets or sets when this RequestHandler should run. Methods Create(Func<HttpRequest, HttpContext, Task<HttpResponse?>>, RequestHandlerExecutionMode) Gets an inline AsyncRequestHandler that resolves to the specified function. ExecuteAsync(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. Next() Returns an null HttpResponse reference, which points to the next request handler or route action."
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.-ctor.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.-ctor.html",
    "title": "Constructor ExceptionErrorCallback | Sisk",
    "keywords": "Constructor ExceptionErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExceptionErrorCallback(object, nint) public ExceptionErrorCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(Exception, HttpContext, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(Exception ex, HttpContext context, AsyncCallback callback, object @object) Parameters ex Exception context HttpContext callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.Invoke.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(Exception, HttpContext) public virtual HttpResponse Invoke(Exception ex, HttpContext context) Parameters ex Exception context HttpContext Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.ExceptionErrorCallback.html": {
    "href": "api/Sisk.Core.Routing.ExceptionErrorCallback.html",
    "title": "Delegate ExceptionErrorCallback | Sisk",
    "keywords": "Delegate ExceptionErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route action threw an exception. public delegate HttpResponse ExceptionErrorCallback(Exception ex, HttpContext context) Parameters ex Exception Represents the function that is called after the route action threw an exception. context HttpContext Represents the function that is called after the route action threw an exception. Returns HttpResponse Represents the function that is called after the route action threw an exception. Constructors ExceptionErrorCallback(object, nint) Methods BeginInvoke(Exception, HttpContext, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(Exception, HttpContext)"
  },
  "api/Sisk.Core.Routing.IRequestHandler.Execute.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.Execute.html",
    "title": "Method Execute | Sisk",
    "keywords": "Method Execute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued. HttpResponse? Execute(HttpRequest request, HttpContext context) Parameters request HttpRequest The entry HTTP request. context HttpContext The HTTP request context. It may contain information from other IRequestHandler. Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.IRequestHandler.ExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.ExecutionMode.html",
    "title": "Property ExecutionMode | Sisk",
    "keywords": "Property ExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ExecutionMode Gets or sets when this RequestHandler should run. RequestHandlerExecutionMode ExecutionMode { get; init; } Property Value RequestHandlerExecutionMode"
  },
  "api/Sisk.Core.Routing.IRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.IRequestHandler.html",
    "title": "Interface IRequestHandler | Sisk",
    "keywords": "Interface IRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an interface that is executed before a request. public interface IRequestHandler Properties ExecutionMode Gets or sets when this RequestHandler should run. Methods Execute(HttpRequest, HttpContext) This method is called by the Router before executing a request when the Route instantiates an object that implements this interface. If it returns a HttpResponse object, the route action is not called and all execution of the route is stopped. If it returns \"null\", the execution is continued."
  },
  "api/Sisk.Core.Routing.LogOutput.html": {
    "href": "api/Sisk.Core.Routing.LogOutput.html",
    "title": "Enum LogOutput | Sisk",
    "keywords": "Enum LogOutput Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Determines the way the server can write log messages. This enumerator is for giving permissions for certain contexts to be able or not to write to the server logs, such as AccessLogsStream and ErrorsLogsStream. [Flags] public enum LogOutput Fields AccessLog = 2 Determines that the context or the route can write log messages only to the access logs through AccessLogsStream. Both = AccessLog | ErrorLog Determines that the context or the route can write log messages to both error and access logs. ErrorLog = 4 Determines that the context or the route can write error messages only to the error logs through ErrorsLogsStream. None = 0 Determines that the context or the route cannot write any log messages."
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.-ctor.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.-ctor.html",
    "title": "Constructor ParameterlessRouteAction | Sisk",
    "keywords": "Constructor ParameterlessRouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ParameterlessRouteAction(object, nint) public ParameterlessRouteAction(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(AsyncCallback, object) public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object @object) Parameters callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual object EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns object"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.Invoke.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke() public virtual object Invoke() Returns object"
  },
  "api/Sisk.Core.Routing.ParameterlessRouteAction.html": {
    "href": "api/Sisk.Core.Routing.ParameterlessRouteAction.html",
    "title": "Delegate ParameterlessRouteAction | Sisk",
    "keywords": "Delegate ParameterlessRouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route is matched with the request. public delegate object ParameterlessRouteAction() Returns object Represents the function that is called after the route is matched with the request. Constructors ParameterlessRouteAction(object, nint) Methods BeginInvoke(AsyncCallback, object) EndInvoke(IAsyncResult) Invoke()"
  },
  "api/Sisk.Core.Routing.RegexRoute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RegexRoute.-ctor.html",
    "title": "Constructor RegexRoute | Sisk",
    "keywords": "Constructor RegexRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegexRoute(RouteMethod, string, RouteAction) Initializes a new instance of the RegexRoute class. public RegexRoute(RouteMethod method, string pattern, RouteAction action) Parameters method RouteMethod The HTTP method for this route. pattern string The regular expression pattern for this route. action RouteAction The action to be executed when this route is matched. RegexRoute(RouteMethod, string, string?, RouteAction, IRequestHandler[]?) Initializes a new instance of the RegexRoute class. public RegexRoute(RouteMethod method, string pattern, string? name, RouteAction action, IRequestHandler[]? beforeCallback) Parameters method RouteMethod The HTTP method for this route. pattern string The regular expression pattern for this route. name string The name of this route. action RouteAction The action to be executed when this route is matched. beforeCallback IRequestHandler[] The callback to be executed before the action."
  },
  "api/Sisk.Core.Routing.RegexRoute.html": {
    "href": "api/Sisk.Core.Routing.RegexRoute.html",
    "title": "Class RegexRoute | Sisk",
    "keywords": "Class RegexRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an Route which it's implementation already enables UseRegex. public sealed class RegexRoute : Route Inheritance object Route RegexRoute Inherited Members Route.AnyPath Route.ToString() Route.Get(string, RouteAction) Route.Post(string, RouteAction) Route.Put(string, RouteAction) Route.Patch(string, RouteAction) Route.Head(string, RouteAction) Route.Any(string, RouteAction) Route.Delete(string, RouteAction) Route.Options(string, RouteAction) Route.Bag Route.IsAsync Route.LogMode Route.UseRegex Route.UseCors Route.Method Route.Path Route.Name Route.Action Route.RequestHandlers Route.BypassGlobalRequestHandlers object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RegexRoute(RouteMethod, string, RouteAction) Initializes a new instance of the RegexRoute class. RegexRoute(RouteMethod, string, string?, RouteAction, IRequestHandler[]?) Initializes a new instance of the RegexRoute class."
  },
  "api/Sisk.Core.Routing.RegexRouteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RegexRouteAttribute.-ctor.html",
    "title": "Constructor RegexRouteAttribute | Sisk",
    "keywords": "Constructor RegexRouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegexRouteAttribute(RouteMethod, string) Creates an new RouteGetAttribute attribute instance with given path. public RegexRouteAttribute(RouteMethod method, string pattern) Parameters method RouteMethod The route entry point method. pattern string The Regex pattern which will match the route."
  },
  "api/Sisk.Core.Routing.RegexRouteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RegexRouteAttribute.html",
    "title": "Class RegexRouteAttribute | Sisk",
    "keywords": "Class RegexRouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an route, which it's path is defined by an regular expression. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RegexRouteAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RegexRouteAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RegexRouteAttribute(RouteMethod, string) Creates an new RouteGetAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RequestHandler.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.-ctor.html",
    "title": "Constructor RequestHandler | Sisk",
    "keywords": "Constructor RequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandler() protected RequestHandler()"
  },
  "api/Sisk.Core.Routing.RequestHandler.Create.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.Create.html",
    "title": "Method Create | Sisk",
    "keywords": "Method Create Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Create(Func<HttpRequest, HttpContext, HttpResponse?>, RequestHandlerExecutionMode) Gets an inline RequestHandler that resolves to the specified function. public static RequestHandler Create(Func<HttpRequest, HttpContext, HttpResponse?> execute, RequestHandlerExecutionMode executionMode = RequestHandlerExecutionMode.BeforeResponse) Parameters execute Func<HttpRequest, HttpContext, HttpResponse> The function that the RequestHandler will run. executionMode RequestHandlerExecutionMode Optional. Determines where the request handler will be executed. Returns RequestHandler"
  },
  "api/Sisk.Core.Routing.RequestHandler.Next.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.Next.html",
    "title": "Method Next | Sisk",
    "keywords": "Method Next Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Next() Returns an null HttpResponse reference, which points to the next request handler or route action. public HttpResponse? Next() Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RequestHandler.html": {
    "href": "api/Sisk.Core.Routing.RequestHandler.html",
    "title": "Class RequestHandler | Sisk",
    "keywords": "Class RequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an abstract class which implements IRequestHandler. public abstract class RequestHandler : IRequestHandler Inheritance object RequestHandler Implements IRequestHandler Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RequestHandler() Methods Create(Func<HttpRequest, HttpContext, HttpResponse?>, RequestHandlerExecutionMode) Gets an inline RequestHandler that resolves to the specified function. Next() Returns an null HttpResponse reference, which points to the next request handler or route action."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute-1.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute-1.-ctor.html",
    "title": "Constructor RequestHandlerAttribute | Sisk",
    "keywords": "Constructor RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerAttribute() Creates an new instance of this RequestHandlerAttribute<T> class. public RequestHandlerAttribute() RequestHandlerAttribute(params object?[]) Creates an new instance of this RequestHandlerAttribute<T> class with the specified constructor arguments for T. public RequestHandlerAttribute(params object?[] constructorArguments) Parameters constructorArguments object[] An optional array of objects which is passed to the request handler constructor."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute-1.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute-1.html",
    "title": "Class RequestHandlerAttribute<T> | Sisk",
    "keywords": "Class RequestHandlerAttribute<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. public class RequestHandlerAttribute<T> : RequestHandlerAttribute where T : IRequestHandler Type Parameters T Inheritance object Attribute RequestHandlerAttribute RequestHandlerAttribute<T> Inherited Members RequestHandlerAttribute.RequestHandlerType RequestHandlerAttribute.ConstructorArguments Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RequestHandlerAttribute() Creates an new instance of this RequestHandlerAttribute<T> class. RequestHandlerAttribute(params object?[]) Creates an new instance of this RequestHandlerAttribute<T> class with the specified constructor arguments for T."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.-ctor.html",
    "title": "Constructor RequestHandlerAttribute | Sisk",
    "keywords": "Constructor RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerAttribute(Type) Creates a new instance of this attribute with the informed parameters. public RequestHandlerAttribute(Type handledBy) Parameters handledBy Type The type that implements IRequestHandler which will be instantiated."
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments.html",
    "title": "Property ConstructorArguments | Sisk",
    "keywords": "Property ConstructorArguments Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ConstructorArguments Specifies parameters for the given type's constructor. public object?[] ConstructorArguments { get; set; } Property Value object[]"
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.RequestHandlerType.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.RequestHandlerType.html",
    "title": "Property RequestHandlerType | Sisk",
    "keywords": "Property RequestHandlerType Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlerType Gets or sets the type that implements IRequestHandler which will be instantiated. public Type RequestHandlerType { get; set; } Property Value Type"
  },
  "api/Sisk.Core.Routing.RequestHandlerAttribute.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerAttribute.html",
    "title": "Class RequestHandlerAttribute | Sisk",
    "keywords": "Class RequestHandlerAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true)] public class RequestHandlerAttribute : Attribute Inheritance object Attribute RequestHandlerAttribute Derived RequestHandlerAttribute<T> Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RequestHandlerAttribute(Type) Creates a new instance of this attribute with the informed parameters. Properties ConstructorArguments Specifies parameters for the given type's constructor. RequestHandlerType Gets or sets the type that implements IRequestHandler which will be instantiated."
  },
  "api/Sisk.Core.Routing.RequestHandlerExecutionMode.html": {
    "href": "api/Sisk.Core.Routing.RequestHandlerExecutionMode.html",
    "title": "Enum RequestHandlerExecutionMode | Sisk",
    "keywords": "Enum RequestHandlerExecutionMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Defines when the IRequestHandler object should be executed. public enum RequestHandlerExecutionMode Fields AfterResponse = 1 Indicates that the handler must be executed after the route action execution. BeforeResponse = 0 Indicates that the handler must be executed before the router calls the route action and after request contents is loaded."
  },
  "api/Sisk.Core.Routing.Route.-ctor.html": {
    "href": "api/Sisk.Core.Routing.Route.-ctor.html",
    "title": "Constructor Route | Sisk",
    "keywords": "Constructor Route Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Route(RouteMethod, string, Delegate?) Creates an new Route instance with given parameters. public Route(RouteMethod method, string path, Delegate? action) Parameters method RouteMethod The matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. path string The path expression that will be interpreted by the router and validated by the requests. action Delegate The function that is called after the route is matched with the request. Route(RouteMethod, string, string?, Delegate?, IRequestHandler[]?) Creates an new Route instance with given parameters. public Route(RouteMethod method, string path, string? name, Delegate? action, IRequestHandler[]? beforeCallback) Parameters method RouteMethod The matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. path string The path expression that will be interpreted by the router and validated by the requests. name string The route name. It allows it to be found by other routes and makes it easier to create links. action Delegate The function that is called after the route is matched with the request. beforeCallback IRequestHandler[] The RequestHandlers to run before the route's Action. Route() Creates an new Route instance with no parameters. public Route()"
  },
  "api/Sisk.Core.Routing.Route.Action.html": {
    "href": "api/Sisk.Core.Routing.Route.Action.html",
    "title": "Property Action | Sisk",
    "keywords": "Property Action Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Action Gets or sets the function that is called after the route is matched with the request. public Delegate? Action { get; set; } Property Value Delegate"
  },
  "api/Sisk.Core.Routing.Route.Any.html": {
    "href": "api/Sisk.Core.Routing.Route.Any.html",
    "title": "Method Any | Sisk",
    "keywords": "Method Any Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Any(string, RouteAction) Creates a route that responds to any HTTP request method. public static Route Any(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for any request method."
  },
  "api/Sisk.Core.Routing.Route.AnyPath.html": {
    "href": "api/Sisk.Core.Routing.Route.AnyPath.html",
    "title": "Field AnyPath | Sisk",
    "keywords": "Field AnyPath Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an route path which captures any URL path. public const string AnyPath = \"/<<ANY>>\" Returns string Represents an route path which captures any URL path."
  },
  "api/Sisk.Core.Routing.Route.Bag.html": {
    "href": "api/Sisk.Core.Routing.Route.Bag.html",
    "title": "Property Bag | Sisk",
    "keywords": "Property Bag Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Bag Gets or sets an TypedValueDictionary for this route, which can hold contextual variables for this Route object. public TypedValueDictionary Bag { get; set; } Property Value TypedValueDictionary"
  },
  "api/Sisk.Core.Routing.Route.BypassGlobalRequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Route.BypassGlobalRequestHandlers.html",
    "title": "Property BypassGlobalRequestHandlers | Sisk",
    "keywords": "Property BypassGlobalRequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BypassGlobalRequestHandlers Gets or sets the global request handlers instances that will not run on this route. public IRequestHandler[] BypassGlobalRequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Route.Delete.html": {
    "href": "api/Sisk.Core.Routing.Route.Delete.html",
    "title": "Method Delete | Sisk",
    "keywords": "Method Delete Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Delete(string, RouteAction) Creates a route that responds to HTTP DELETE requests. public static Route Delete(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for DELETE requests."
  },
  "api/Sisk.Core.Routing.Route.Get.html": {
    "href": "api/Sisk.Core.Routing.Route.Get.html",
    "title": "Method Get | Sisk",
    "keywords": "Method Get Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Get(string, RouteAction) Creates a route that responds to HTTP GET requests. public static Route Get(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for GET requests."
  },
  "api/Sisk.Core.Routing.Route.Head.html": {
    "href": "api/Sisk.Core.Routing.Route.Head.html",
    "title": "Method Head | Sisk",
    "keywords": "Method Head Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Head(string, RouteAction) Creates a route that responds to HTTP HEAD requests. public static Route Head(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for HEAD requests."
  },
  "api/Sisk.Core.Routing.Route.IsAsync.html": {
    "href": "api/Sisk.Core.Routing.Route.IsAsync.html",
    "title": "Property IsAsync | Sisk",
    "keywords": "Property IsAsync Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsAsync Gets an boolean indicating if this Route action return is an asynchronous Task. public bool IsAsync { get; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.LogMode.html": {
    "href": "api/Sisk.Core.Routing.Route.LogMode.html",
    "title": "Property LogMode | Sisk",
    "keywords": "Property LogMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll LogMode Gets or sets how this route can write messages to log files on the server. public LogOutput LogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Routing.Route.Method.html": {
    "href": "api/Sisk.Core.Routing.Route.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Method Gets or sets the matching HTTP method. public RouteMethod Method { get; set; } Property Value RouteMethod"
  },
  "api/Sisk.Core.Routing.Route.Name.html": {
    "href": "api/Sisk.Core.Routing.Route.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Name Gets or sets the route name. public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Route.Options.html": {
    "href": "api/Sisk.Core.Routing.Route.Options.html",
    "title": "Method Options | Sisk",
    "keywords": "Method Options Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Options(string, RouteAction) Creates a route that responds to HTTP OPTIONS requests. public static Route Options(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for OPTIONS requests."
  },
  "api/Sisk.Core.Routing.Route.Patch.html": {
    "href": "api/Sisk.Core.Routing.Route.Patch.html",
    "title": "Method Patch | Sisk",
    "keywords": "Method Patch Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Patch(string, RouteAction) Creates a route that responds to HTTP PATCH requests. public static Route Patch(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for PATCH requests."
  },
  "api/Sisk.Core.Routing.Route.Path.html": {
    "href": "api/Sisk.Core.Routing.Route.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. public string Path { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Route.Post.html": {
    "href": "api/Sisk.Core.Routing.Route.Post.html",
    "title": "Method Post | Sisk",
    "keywords": "Method Post Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Post(string, RouteAction) Creates a route that responds to HTTP POST requests. public static Route Post(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for POST requests."
  },
  "api/Sisk.Core.Routing.Route.Put.html": {
    "href": "api/Sisk.Core.Routing.Route.Put.html",
    "title": "Method Put | Sisk",
    "keywords": "Method Put Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Put(string, RouteAction) Creates a route that responds to HTTP PUT requests. public static Route Put(string path, RouteAction action) Parameters path string The URL path for the route. action RouteAction The action to be executed when the route is matched. Returns Route A Route object configured for PUT requests."
  },
  "api/Sisk.Core.Routing.Route.RequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Route.RequestHandlers.html",
    "title": "Property RequestHandlers | Sisk",
    "keywords": "Property RequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlers Gets or sets the request handlers instances to run before the route's Action. public IRequestHandler[] RequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Route.ToString.html": {
    "href": "api/Sisk.Core.Routing.Route.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ToString() Gets an string notation for this Route object. public override string ToString() Returns string"
  },
  "api/Sisk.Core.Routing.Route.UseCors.html": {
    "href": "api/Sisk.Core.Routing.Route.UseCors.html",
    "title": "Property UseCors | Sisk",
    "keywords": "Property UseCors Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. public bool UseCors { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.UseRegex.html": {
    "href": "api/Sisk.Core.Routing.Route.UseRegex.html",
    "title": "Property UseRegex | Sisk",
    "keywords": "Property UseRegex Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. public bool UseRegex { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Route.html": {
    "href": "api/Sisk.Core.Routing.Route.html",
    "title": "Class Route | Sisk",
    "keywords": "Class Route Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an HTTP route to be matched by an Router. public class Route Inheritance object Route Derived RegexRoute Inherited Members object.GetType() object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors Route() Creates an new Route instance with no parameters. Route(RouteMethod, string, Delegate?) Creates an new Route instance with given parameters. Route(RouteMethod, string, string?, Delegate?, IRequestHandler[]?) Creates an new Route instance with given parameters. Fields AnyPath Represents an route path which captures any URL path. Properties Action Gets or sets the function that is called after the route is matched with the request. Bag Gets or sets an TypedValueDictionary for this route, which can hold contextual variables for this Route object. BypassGlobalRequestHandlers Gets or sets the global request handlers instances that will not run on this route. IsAsync Gets an boolean indicating if this Route action return is an asynchronous Task. LogMode Gets or sets how this route can write messages to log files on the server. Method Gets or sets the matching HTTP method. Name Gets or sets the route name. Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. RequestHandlers Gets or sets the request handlers instances to run before the route's Action. UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. Methods Any(string, RouteAction) Creates a route that responds to any HTTP request method. Delete(string, RouteAction) Creates a route that responds to HTTP DELETE requests. Get(string, RouteAction) Creates a route that responds to HTTP GET requests. Head(string, RouteAction) Creates a route that responds to HTTP HEAD requests. Options(string, RouteAction) Creates a route that responds to HTTP OPTIONS requests. Patch(string, RouteAction) Creates a route that responds to HTTP PATCH requests. Post(string, RouteAction) Creates a route that responds to HTTP POST requests. Put(string, RouteAction) Creates a route that responds to HTTP PUT requests. ToString() Gets an string notation for this Route object."
  },
  "api/Sisk.Core.Routing.RouteAction.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.-ctor.html",
    "title": "Constructor RouteAction | Sisk",
    "keywords": "Constructor RouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteAction(object, nint) public RouteAction(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RouteAction.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(HttpRequest, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(HttpRequest request, AsyncCallback callback, object @object) Parameters request HttpRequest callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RouteAction.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual object EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns object"
  },
  "api/Sisk.Core.Routing.RouteAction.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(HttpRequest) public virtual object Invoke(HttpRequest request) Parameters request HttpRequest Returns object"
  },
  "api/Sisk.Core.Routing.RouteAction.html": {
    "href": "api/Sisk.Core.Routing.RouteAction.html",
    "title": "Delegate RouteAction | Sisk",
    "keywords": "Delegate RouteAction Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called after the route is matched with the request. public delegate object RouteAction(HttpRequest request) Parameters request HttpRequest The received request on the router. Returns object Represents the function that is called after the route is matched with the request. Constructors RouteAction(object, nint) Methods BeginInvoke(HttpRequest, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(HttpRequest)"
  },
  "api/Sisk.Core.Routing.RouteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.-ctor.html",
    "title": "Constructor RouteAttribute | Sisk",
    "keywords": "Constructor RouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteAttribute(RouteMethod, string) Creates an new RouteAttribute instance with given route method and path pattern. public RouteAttribute(RouteMethod method, string path) Parameters method RouteMethod The route entry point method. path string The route path."
  },
  "api/Sisk.Core.Routing.RouteAttribute.LogMode.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.LogMode.html",
    "title": "Property LogMode | Sisk",
    "keywords": "Property LogMode Namespace Sisk.Core.Routing Assembly Sisk.Core.dll LogMode Gets or sets how this route can write messages to log files on the server. public LogOutput LogMode { get; set; } Property Value LogOutput"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Method.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Method Gets or sets the matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. public RouteMethod Method { get; set; } Property Value RouteMethod"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Name.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Name Gets or sets the route name. It allows it to be found by other routes and makes it easier to create links. public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouteAttribute.Path.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.Path.html",
    "title": "Property Path | Sisk",
    "keywords": "Property Path Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. public string Path { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouteAttribute.UseCors.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.UseCors.html",
    "title": "Property UseCors | Sisk",
    "keywords": "Property UseCors Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. public bool UseCors { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.RouteAttribute.UseRegex.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.UseRegex.html",
    "title": "Property UseRegex | Sisk",
    "keywords": "Property UseRegex Namespace Sisk.Core.Routing Assembly Sisk.Core.dll UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates. public bool UseRegex { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.RouteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteAttribute.html",
    "title": "Class RouteAttribute | Sisk",
    "keywords": "Class RouteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an class that, when applied to a method, will be recognized by a router as a route. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public class RouteAttribute : Attribute Inheritance object Attribute RouteAttribute Derived RegexRouteAttribute RouteDeleteAttribute RouteGetAttribute RoutePatchAttribute RoutePostAttribute RoutePutAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteAttribute(RouteMethod, string) Creates an new RouteAttribute instance with given route method and path pattern. Properties LogMode Gets or sets how this route can write messages to log files on the server. Method Gets or sets the matching HTTP method. If it is \"Any\", the route will just use the path expression to be matched, not the HTTP method. Name Gets or sets the route name. It allows it to be found by other routes and makes it easier to create links. Path Gets or sets the path expression that will be interpreted by the router and validated by the requests. UseCors Gets or sets whether this route should send Cross-Origin Resource Sharing headers in the response. UseRegex Get or sets if this route should use regex to be interpreted instead of predefined templates."
  },
  "api/Sisk.Core.Routing.RouteDeleteAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteDeleteAttribute.-ctor.html",
    "title": "Constructor RouteDeleteAttribute | Sisk",
    "keywords": "Constructor RouteDeleteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteDeleteAttribute(string) Creates an new RouteDeleteAttribute attribute instance with given path. public RouteDeleteAttribute(string path) Parameters path string The DELETE route path. RouteDeleteAttribute() Creates an new RouteDeleteAttribute attribute instance with an root path (/). public RouteDeleteAttribute()"
  },
  "api/Sisk.Core.Routing.RouteDeleteAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteDeleteAttribute.html",
    "title": "Class RouteDeleteAttribute | Sisk",
    "keywords": "Class RouteDeleteAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP DELETE route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RouteDeleteAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RouteDeleteAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteDeleteAttribute() Creates an new RouteDeleteAttribute attribute instance with an root path (/). RouteDeleteAttribute(string) Creates an new RouteDeleteAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RouteGetAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouteGetAttribute.-ctor.html",
    "title": "Constructor RouteGetAttribute | Sisk",
    "keywords": "Constructor RouteGetAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouteGetAttribute(string) Creates an new RouteGetAttribute attribute instance with given path. public RouteGetAttribute(string path) Parameters path string The GET route path. RouteGetAttribute() Creates an new RouteGetAttribute attribute instance with an root path (/). public RouteGetAttribute()"
  },
  "api/Sisk.Core.Routing.RouteGetAttribute.html": {
    "href": "api/Sisk.Core.Routing.RouteGetAttribute.html",
    "title": "Class RouteGetAttribute | Sisk",
    "keywords": "Class RouteGetAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP GET route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RouteGetAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RouteGetAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RouteGetAttribute() Creates an new RouteGetAttribute attribute instance with an root path (/). RouteGetAttribute(string) Creates an new RouteGetAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RouteMethod.html": {
    "href": "api/Sisk.Core.Routing.RouteMethod.html",
    "title": "Enum RouteMethod | Sisk",
    "keywords": "Enum RouteMethod Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an HTTP method to be matched in an Route. [Flags] public enum RouteMethod Fields Any = Get | Post | Put | Patch | Delete | Head | Options Represents any HTTP method. Delete = 32 Represents the HTTP DELETE method. Get = 2 Represents the HTTP GET method. Head = 128 Represents the HTTP HEAD method. Options = 256 Represents the HTTP OPTIONS method. Patch = 16 Represents the HTTP PATCH method. Post = 4 Represents the HTTP POST method. Put = 8 Represents the HTTP PUT method."
  },
  "api/Sisk.Core.Routing.RoutePatchAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePatchAttribute.-ctor.html",
    "title": "Constructor RoutePatchAttribute | Sisk",
    "keywords": "Constructor RoutePatchAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePatchAttribute(string) Creates an new RoutePatchAttribute attribute instance with given path. public RoutePatchAttribute(string path) Parameters path string The PATCH route path. RoutePatchAttribute() Creates an new RoutePatchAttribute attribute instance with an root path (/). public RoutePatchAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePatchAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePatchAttribute.html",
    "title": "Class RoutePatchAttribute | Sisk",
    "keywords": "Class RoutePatchAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP PATCH route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePatchAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePatchAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePatchAttribute() Creates an new RoutePatchAttribute attribute instance with an root path (/). RoutePatchAttribute(string) Creates an new RoutePatchAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RoutePostAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePostAttribute.-ctor.html",
    "title": "Constructor RoutePostAttribute | Sisk",
    "keywords": "Constructor RoutePostAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePostAttribute(string) Creates an new RoutePostAttribute attribute instance with given path. public RoutePostAttribute(string path) Parameters path string The POST route path. RoutePostAttribute() Creates an new RoutePostAttribute attribute instance with an root path (/). public RoutePostAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePostAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePostAttribute.html",
    "title": "Class RoutePostAttribute | Sisk",
    "keywords": "Class RoutePostAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP POST route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePostAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePostAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePostAttribute() Creates an new RoutePostAttribute attribute instance with an root path (/). RoutePostAttribute(string) Creates an new RoutePostAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.-ctor.html",
    "title": "Constructor RoutePrefixAttribute | Sisk",
    "keywords": "Constructor RoutePrefixAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePrefixAttribute(string) Initializes an new RoutePrefixAttribute with given prefix. public RoutePrefixAttribute(string prefix) Parameters prefix string"
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.Prefix.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the route prefix. public string Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RoutePrefixAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePrefixAttribute.html",
    "title": "Class RoutePrefixAttribute | Sisk",
    "keywords": "Class RoutePrefixAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents an attribute that, when applied to an class containing routes, all child routes will start with the specified prefix. [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)] public sealed class RoutePrefixAttribute : Attribute Inheritance object Attribute RoutePrefixAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePrefixAttribute(string) Initializes an new RoutePrefixAttribute with given prefix. Properties Prefix Gets or sets the route prefix."
  },
  "api/Sisk.Core.Routing.RoutePutAttribute.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutePutAttribute.-ctor.html",
    "title": "Constructor RoutePutAttribute | Sisk",
    "keywords": "Constructor RoutePutAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutePutAttribute(string) Creates an new RoutePutAttribute attribute instance with given path. public RoutePutAttribute(string path) Parameters path string The PUT route path. RoutePutAttribute() Creates an new RoutePutAttribute attribute instance with an root path (/). public RoutePutAttribute()"
  },
  "api/Sisk.Core.Routing.RoutePutAttribute.html": {
    "href": "api/Sisk.Core.Routing.RoutePutAttribute.html",
    "title": "Class RoutePutAttribute | Sisk",
    "keywords": "Class RoutePutAttribute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mapping to an HTTP PUT route. This attribute is an shorthand from RouteAttribute. [AttributeUsage(AttributeTargets.Method, AllowMultiple = true, Inherited = true)] public sealed class RoutePutAttribute : RouteAttribute Inheritance object Attribute RouteAttribute RoutePutAttribute Inherited Members RouteAttribute.Method RouteAttribute.Path RouteAttribute.Name RouteAttribute.UseCors RouteAttribute.LogMode RouteAttribute.UseRegex Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors RoutePutAttribute() Creates an new RoutePutAttribute attribute instance with an root path (/). RoutePutAttribute(string) Creates an new RoutePutAttribute attribute instance with given path."
  },
  "api/Sisk.Core.Routing.Router.-ctor.html": {
    "href": "api/Sisk.Core.Routing.Router.-ctor.html",
    "title": "Constructor Router | Sisk",
    "keywords": "Constructor Router Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Router() Creates an new Router instance with default values. public Router() Router(IEnumerable<Route>) Creates an new Router instance with given route collection. public Router(IEnumerable<Route> routes) Parameters routes IEnumerable<Route> The route collection to import in this router."
  },
  "api/Sisk.Core.Routing.Router.AutoScanModules.html": {
    "href": "api/Sisk.Core.Routing.Router.AutoScanModules.html",
    "title": "Method AutoScanModules | Sisk",
    "keywords": "Method AutoScanModules Namespace Sisk.Core.Routing Assembly Sisk.Core.dll AutoScanModules(Type, Assembly) Scans for all types that implements the specified module type and associates an instance of each type to the router. public void AutoScanModules(Type moduleType, Assembly searchAssembly) Parameters moduleType Type An class which implements RouterModule, or the router module itself. searchAssembly Assembly The assembly to search the module type in. AutoScanModules<TModule>(Assembly) Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. public void AutoScanModules<TModule>(Assembly assembly) where TModule : RouterModule Parameters assembly Assembly The assembly to search TModule in. Type Parameters TModule An class which implements RouterModule, or the router module itself. AutoScanModules<TModule>() Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. public void AutoScanModules<TModule>() where TModule : RouterModule Type Parameters TModule An class which implements RouterModule, or the router module itself."
  },
  "api/Sisk.Core.Routing.Router.CallbackErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.CallbackErrorHandler.html",
    "title": "Property CallbackErrorHandler | Sisk",
    "keywords": "Property CallbackErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll CallbackErrorHandler Gets or sets the Router action exception handler. The response handler for this property will send an HTTP response to the client when an exception is caught during execution. This property is only called when ThrowExceptions is disabled. public ExceptionErrorCallback? CallbackErrorHandler { get; set; } Property Value ExceptionErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.CheckForRouteCollisions.html": {
    "href": "api/Sisk.Core.Routing.Router.CheckForRouteCollisions.html",
    "title": "Property CheckForRouteCollisions | Sisk",
    "keywords": "Property CheckForRouteCollisions Namespace Sisk.Core.Routing Assembly Sisk.Core.dll CheckForRouteCollisions Gets or sets whether this Router should check for possible routing collisions before starting the HTTP server. public bool CheckForRouteCollisions { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.GetDefinedRoutes.html": {
    "href": "api/Sisk.Core.Routing.Router.GetDefinedRoutes.html",
    "title": "Method GetDefinedRoutes | Sisk",
    "keywords": "Method GetDefinedRoutes Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetDefinedRoutes() Gets all routes defined on this router instance. public Route[] GetDefinedRoutes() Returns Route[]"
  },
  "api/Sisk.Core.Routing.Router.GetRouteFromName.html": {
    "href": "api/Sisk.Core.Routing.Router.GetRouteFromName.html",
    "title": "Method GetRouteFromName | Sisk",
    "keywords": "Method GetRouteFromName Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetRouteFromName(string) Gets an defined Route by their name property. public Route? GetRouteFromName(string name) Parameters name string The route name. Returns Route"
  },
  "api/Sisk.Core.Routing.Router.GetRouteFromPath.html": {
    "href": "api/Sisk.Core.Routing.Router.GetRouteFromPath.html",
    "title": "Method GetRouteFromPath | Sisk",
    "keywords": "Method GetRouteFromPath Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GetRouteFromPath(RouteMethod, string) Gets the first matched Route by their HTTP method and path. public Route? GetRouteFromPath(RouteMethod method, string uri) Parameters method RouteMethod The HTTP method to match. uri string The URL expression. Returns Route GetRouteFromPath(string) Gets the first matched Route by their URL path. public Route? GetRouteFromPath(string uri) Parameters uri string The URL expression. Returns Route"
  },
  "api/Sisk.Core.Routing.Router.GlobalRequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.Router.GlobalRequestHandlers.html",
    "title": "Property GlobalRequestHandlers | Sisk",
    "keywords": "Property GlobalRequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll GlobalRequestHandlers Gets or sets the global requests handlers that will be executed in all matched routes. public IRequestHandler[] GlobalRequestHandlers { get; set; } Property Value IRequestHandler[]"
  },
  "api/Sisk.Core.Routing.Router.IsDefined.html": {
    "href": "api/Sisk.Core.Routing.Router.IsDefined.html",
    "title": "Method IsDefined | Sisk",
    "keywords": "Method IsDefined Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsDefined(RouteMethod, string) Gets an boolean indicating if there are any route that matches the specified method and route path. public bool IsDefined(RouteMethod method, string path) Parameters method RouteMethod The route method. path string The route path. Returns bool"
  },
  "api/Sisk.Core.Routing.Router.IsReadOnly.html": {
    "href": "api/Sisk.Core.Routing.Router.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.Core.Routing Assembly Sisk.Core.dll IsReadOnly Gets an boolean indicating where this Router is read-only or not. public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.MapAny.html": {
    "href": "api/Sisk.Core.Routing.Router.MapAny.html",
    "title": "Method MapAny | Sisk",
    "keywords": "Method MapAny Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapAny(string, RouteAction) Maps an route which matches any HTTP method, using the specified path and action function. public void MapAny(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapDelete.html": {
    "href": "api/Sisk.Core.Routing.Router.MapDelete.html",
    "title": "Method MapDelete | Sisk",
    "keywords": "Method MapDelete Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapDelete(string, RouteAction) Maps an DELETE route using the specified path and action function. public void MapDelete(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapGet.html": {
    "href": "api/Sisk.Core.Routing.Router.MapGet.html",
    "title": "Method MapGet | Sisk",
    "keywords": "Method MapGet Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapGet(string, RouteAction) Maps an GET route using the specified path and action function. public void MapGet(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPatch.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPatch.html",
    "title": "Method MapPatch | Sisk",
    "keywords": "Method MapPatch Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPatch(string, RouteAction) Maps an PATCH route using the specified path and action function. public void MapPatch(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPost.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPost.html",
    "title": "Method MapPost | Sisk",
    "keywords": "Method MapPost Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPost(string, RouteAction) Maps an POST route using the specified path and action function. public void MapPost(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MapPut.html": {
    "href": "api/Sisk.Core.Routing.Router.MapPut.html",
    "title": "Method MapPut | Sisk",
    "keywords": "Method MapPut Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MapPut(string, RouteAction) Maps an PUT route using the specified path and action function. public void MapPut(string path, RouteAction action) Parameters path string The route path. action RouteAction The route function to be called after matched."
  },
  "api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase.html": {
    "href": "api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase.html",
    "title": "Property MatchRoutesIgnoreCase | Sisk",
    "keywords": "Property MatchRoutesIgnoreCase Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MatchRoutesIgnoreCase Gets or sets whether this Router will match routes ignoring case. public bool MatchRoutesIgnoreCase { get; set; } Property Value bool"
  },
  "api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler.html",
    "title": "Property MethodNotAllowedErrorHandler | Sisk",
    "keywords": "Property MethodNotAllowedErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll MethodNotAllowedErrorHandler Gets or sets the Router \"405 Method Not Allowed\" handler. public RoutingErrorCallback? MethodNotAllowedErrorHandler { get; set; } Property Value RoutingErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.NotFoundErrorHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.NotFoundErrorHandler.html",
    "title": "Property NotFoundErrorHandler | Sisk",
    "keywords": "Property NotFoundErrorHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll NotFoundErrorHandler Gets or sets the Router \"404 Not Found\" handler. public RoutingErrorCallback? NotFoundErrorHandler { get; set; } Property Value RoutingErrorCallback"
  },
  "api/Sisk.Core.Routing.Router.Prefix.html": {
    "href": "api/Sisk.Core.Routing.Router.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the prefix which will be applied to all next defining routes in this router. public string? Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.Router.RegisterValueHandler.html": {
    "href": "api/Sisk.Core.Routing.Router.RegisterValueHandler.html",
    "title": "Method RegisterValueHandler | Sisk",
    "keywords": "Method RegisterValueHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RegisterValueHandler<T>(RouterActionHandlerCallback<T>) Register an type handling association to converting it to an HttpResponse object. public void RegisterValueHandler<T>(RouterActionHandlerCallback<T> actionHandler) where T : notnull Parameters actionHandler RouterActionHandlerCallback<T> The function that receives an object of the T and returns an HttpResponse response from the informed object. Type Parameters T"
  },
  "api/Sisk.Core.Routing.Router.ResolveActionResult.html": {
    "href": "api/Sisk.Core.Routing.Router.ResolveActionResult.html",
    "title": "Method ResolveActionResult | Sisk",
    "keywords": "Method ResolveActionResult Namespace Sisk.Core.Routing Assembly Sisk.Core.dll ResolveActionResult(object?) Resolves the specified object into an valid HttpResponse using the defined value handlers or throws an exception if not possible. public HttpResponse ResolveActionResult(object? result) Parameters result object The object that will be converted to an valid HttpResponse. Returns HttpResponse Remarks This method can throw exceptions. To avoid exceptions while trying to convert the specified object into an HttpResponse, consider using TryResolveActionResult(object?, out HttpResponse?)."
  },
  "api/Sisk.Core.Routing.Router.Rewrite.html": {
    "href": "api/Sisk.Core.Routing.Router.Rewrite.html",
    "title": "Method Rewrite | Sisk",
    "keywords": "Method Rewrite Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Rewrite(string, string) Maps a rewrite route, which redirects all requests that match the given path to another path, keeping the body and headers of the original request. public void Rewrite(string rewritePath, string rewriteInto) Parameters rewritePath string The incoming HTTP request path. rewriteInto string The rewrited URL."
  },
  "api/Sisk.Core.Routing.Router.SetObject.html": {
    "href": "api/Sisk.Core.Routing.Router.SetObject.html",
    "title": "Method SetObject | Sisk",
    "keywords": "Method SetObject Namespace Sisk.Core.Routing Assembly Sisk.Core.dll SetObject(object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(object attrClassInstance) Parameters attrClassInstance object The instance of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature. SetObject(Type) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(Type attrClassType) Parameters attrClassType Type The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. SetObject(Type, object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject(Type attrClassType, object instance) Parameters attrClassType Type The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. instance object The instance of the object where the route methods are. SetObject<TObject>() Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject<TObject>() Type Parameters TObject The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature. SetObject<TObject>(TObject) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. public void SetObject<TObject>(TObject instance) where TObject : notnull Parameters instance TObject The instance of TObject to invoke the instance methods on. Type Parameters TObject The type of the class where the methods are. The routing methods must be marked with any RouteAttribute. Exceptions Exception An exception is thrown when a method has an erroneous signature."
  },
  "api/Sisk.Core.Routing.Router.SetRoute.html": {
    "href": "api/Sisk.Core.Routing.Router.SetRoute.html",
    "title": "Method SetRoute | Sisk",
    "keywords": "Method SetRoute Namespace Sisk.Core.Routing Assembly Sisk.Core.dll SetRoute(RouteMethod, string, RouteAction) Defines an route with their method, path and action function. public void SetRoute(RouteMethod method, string path, RouteAction action) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action RouteAction The route function to be called after matched. SetRoute(RouteMethod, string, Delegate) Defines an route with their method, path and action function. public void SetRoute(RouteMethod method, string path, Delegate action) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action Delegate The route function to be called after matched. SetRoute(RouteMethod, string, Delegate, string?) Defines an route with their method, path, action function and name. public void SetRoute(RouteMethod method, string path, Delegate action, string? name) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action Delegate The route function to be called after matched. name string The route name. SetRoute(RouteMethod, string, RouteAction, string?, IRequestHandler[]) Defines an route with their method, path, action function, name and request handlers. public void SetRoute(RouteMethod method, string path, RouteAction action, string? name, IRequestHandler[] middlewares) Parameters method RouteMethod The route method to be matched. \"Any\" means any method that matches their path. path string The route path. action RouteAction The route function to be called after matched. name string The route name. middlewares IRequestHandler[] Handlers that run before calling your route action. SetRoute(Route) Defines an route in this Router instance. public void SetRoute(Route r) Parameters r Route The route to be defined in the Router."
  },
  "api/Sisk.Core.Routing.Router.TryResolveActionResult.html": {
    "href": "api/Sisk.Core.Routing.Router.TryResolveActionResult.html",
    "title": "Method TryResolveActionResult | Sisk",
    "keywords": "Method TryResolveActionResult Namespace Sisk.Core.Routing Assembly Sisk.Core.dll TryResolveActionResult(object?, out HttpResponse?) Tries to resolve the specified object into an valid HttpResponse using the defined value handlers. public bool TryResolveActionResult(object? result, out HttpResponse? response) Parameters result object The object that will be converted to an valid HttpResponse. response HttpResponse When this method returns, the response object. This parameter is not initialized. Returns bool When this method returns, the HttpResponse object."
  },
  "api/Sisk.Core.Routing.Router.html": {
    "href": "api/Sisk.Core.Routing.Router.html",
    "title": "Class Router | Sisk",
    "keywords": "Class Router Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a collection of Route and main executor of actions in the HttpServer. public sealed class Router Inheritance object Router Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors Router() Creates an new Router instance with default values. Router(IEnumerable<Route>) Creates an new Router instance with given route collection. Properties CallbackErrorHandler Gets or sets the Router action exception handler. The response handler for this property will send an HTTP response to the client when an exception is caught during execution. This property is only called when ThrowExceptions is disabled. CheckForRouteCollisions Gets or sets whether this Router should check for possible routing collisions before starting the HTTP server. GlobalRequestHandlers Gets or sets the global requests handlers that will be executed in all matched routes. IsReadOnly Gets an boolean indicating where this Router is read-only or not. MatchRoutesIgnoreCase Gets or sets whether this Router will match routes ignoring case. MethodNotAllowedErrorHandler Gets or sets the Router \"405 Method Not Allowed\" handler. NotFoundErrorHandler Gets or sets the Router \"404 Not Found\" handler. Prefix Gets or sets the prefix which will be applied to all next defining routes in this router. Methods AutoScanModules(Type, Assembly) Scans for all types that implements the specified module type and associates an instance of each type to the router. AutoScanModules<TModule>() Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. AutoScanModules<TModule>(Assembly) Scans for all types that implements TModule and associates an instance of each type to the router. Note that, TModule must be an RouterModule type and an accessible constructor for each type must be present. GetDefinedRoutes() Gets all routes defined on this router instance. GetRouteFromName(string) Gets an defined Route by their name property. GetRouteFromPath(RouteMethod, string) Gets the first matched Route by their HTTP method and path. GetRouteFromPath(string) Gets the first matched Route by their URL path. IsDefined(RouteMethod, string) Gets an boolean indicating if there are any route that matches the specified method and route path. MapAny(string, RouteAction) Maps an route which matches any HTTP method, using the specified path and action function. MapDelete(string, RouteAction) Maps an DELETE route using the specified path and action function. MapGet(string, RouteAction) Maps an GET route using the specified path and action function. MapPatch(string, RouteAction) Maps an PATCH route using the specified path and action function. MapPost(string, RouteAction) Maps an POST route using the specified path and action function. MapPut(string, RouteAction) Maps an PUT route using the specified path and action function. RegisterValueHandler<T>(RouterActionHandlerCallback<T>) Register an type handling association to converting it to an HttpResponse object. ResolveActionResult(object?) Resolves the specified object into an valid HttpResponse using the defined value handlers or throws an exception if not possible. Rewrite(string, string) Maps a rewrite route, which redirects all requests that match the given path to another path, keeping the body and headers of the original request. SetObject(object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject(Type) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject(Type, object) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject<TObject>() Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetObject<TObject>(TObject) Searches for all instance and static methods that are marked with an attribute of type RouteAttribute in the specified object and creates routes for these methods. SetRoute(Route) Defines an route in this Router instance. SetRoute(RouteMethod, string, RouteAction) Defines an route with their method, path and action function. SetRoute(RouteMethod, string, RouteAction, string?, IRequestHandler[]) Defines an route with their method, path, action function, name and request handlers. SetRoute(RouteMethod, string, Delegate) Defines an route with their method, path and action function. SetRoute(RouteMethod, string, Delegate, string?) Defines an route with their method, path, action function and name. TryResolveActionResult(object?, out HttpResponse?) Tries to resolve the specified object into an valid HttpResponse using the defined value handlers. Operators operator +(Router, Route) Defines an route to an router."
  },
  "api/Sisk.Core.Routing.Router.op_Addition.html": {
    "href": "api/Sisk.Core.Routing.Router.op_Addition.html",
    "title": "Operator operator + | Sisk",
    "keywords": "Operator operator + Namespace Sisk.Core.Routing Assembly Sisk.Core.dll operator +(Router, Route) Defines an route to an router. public static Router operator +(Router r, Route route) Parameters r Router The router instance which the route is being set. route Route The route to be defined in the router. Returns Router"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.-ctor.html",
    "title": "Constructor RouterActionHandlerCallback | Sisk",
    "keywords": "Constructor RouterActionHandlerCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouterActionHandlerCallback(object, nint) public RouterActionHandlerCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(T, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(T input, AsyncCallback callback, object @object) Parameters input T callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(T) public virtual HttpResponse Invoke(T input) Parameters input T Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.html": {
    "href": "api/Sisk.Core.Routing.RouterActionHandlerCallback-1.html",
    "title": "Delegate RouterActionHandlerCallback<T> | Sisk",
    "keywords": "Delegate RouterActionHandlerCallback<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that receives an object of the T and returns an HttpResponse response from the informed object. public delegate HttpResponse RouterActionHandlerCallback<T>(T input) where T : notnull Parameters input T The result router object. Returns HttpResponse Represents the function that receives an object of the T and returns an response from the informed object. Type Parameters T The input object type. Cannot be nullable. Constructors RouterActionHandlerCallback(object, nint) Methods BeginInvoke(T, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(T)"
  },
  "api/Sisk.Core.Routing.RouterModule.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.-ctor.html",
    "title": "Constructor RouterModule | Sisk",
    "keywords": "Constructor RouterModule Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RouterModule() protected RouterModule()"
  },
  "api/Sisk.Core.Routing.RouterModule.HasRequestHandler.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.HasRequestHandler.html",
    "title": "Method HasRequestHandler | Sisk",
    "keywords": "Method HasRequestHandler Namespace Sisk.Core.Routing Assembly Sisk.Core.dll HasRequestHandler(IRequestHandler) Registers an IRequestHandler on all routes defined by this module. protected void HasRequestHandler(IRequestHandler handler) Parameters handler IRequestHandler The IRequestHandler instance which will be applied to all registered routes of this class."
  },
  "api/Sisk.Core.Routing.RouterModule.OnRouteCreating.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.OnRouteCreating.html",
    "title": "Method OnRouteCreating | Sisk",
    "keywords": "Method OnRouteCreating Namespace Sisk.Core.Routing Assembly Sisk.Core.dll OnRouteCreating(Route) This method is called before a route is defined in the router and after it is created in this class, so its attributes and parameters can be modified. This method must be overloaded in the extending class and must not be called directly. protected virtual void OnRouteCreating(Route configuringRoute) Parameters configuringRoute Route The route being defined on the router."
  },
  "api/Sisk.Core.Routing.RouterModule.OnSetup.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.OnSetup.html",
    "title": "Method OnSetup | Sisk",
    "keywords": "Method OnSetup Namespace Sisk.Core.Routing Assembly Sisk.Core.dll OnSetup(Router) Method that is called when an Router is defining routes from the current RouterModule. protected virtual void OnSetup(Router parentRouter) Parameters parentRouter Router The Router which is defining routes from the current RouterModule. Remarks The base method OnSetup(Router) is mandatory to be called on all derived methods."
  },
  "api/Sisk.Core.Routing.RouterModule.Prefix.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.Prefix.html",
    "title": "Property Prefix | Sisk",
    "keywords": "Property Prefix Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Prefix Gets or sets the router prefix for this class. This property overrides any value defined by RoutePrefixAttribute set in this class. public string? Prefix { get; set; } Property Value string"
  },
  "api/Sisk.Core.Routing.RouterModule.RequestHandlers.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.RequestHandlers.html",
    "title": "Property RequestHandlers | Sisk",
    "keywords": "Property RequestHandlers Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RequestHandlers Gets or sets an list of IRequestHandler this RouterModule runs. public IList<IRequestHandler> RequestHandlers { get; set; } Property Value IList<IRequestHandler>"
  },
  "api/Sisk.Core.Routing.RouterModule.html": {
    "href": "api/Sisk.Core.Routing.RouterModule.html",
    "title": "Class RouterModule | Sisk",
    "keywords": "Class RouterModule Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Indicates that extended class supports router modules, which allows the management of routes, request handlers and prefixes. public abstract class RouterModule Inheritance object RouterModule Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors RouterModule() Properties Prefix Gets or sets the router prefix for this class. This property overrides any value defined by RoutePrefixAttribute set in this class. RequestHandlers Gets or sets an list of IRequestHandler this RouterModule runs. Methods HasRequestHandler(IRequestHandler) Registers an IRequestHandler on all routes defined by this module. OnRouteCreating(Route) This method is called before a route is defined in the router and after it is created in this class, so its attributes and parameters can be modified. This method must be overloaded in the extending class and must not be called directly. OnSetup(Router) Method that is called when an Router is defining routes from the current RouterModule."
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.-ctor.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.-ctor.html",
    "title": "Constructor RoutingErrorCallback | Sisk",
    "keywords": "Constructor RoutingErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll RoutingErrorCallback(object, nint) public RoutingErrorCallback(object @object, nint method) Parameters object object method nint"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.BeginInvoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.BeginInvoke.html",
    "title": "Method BeginInvoke | Sisk",
    "keywords": "Method BeginInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll BeginInvoke(HttpContext, AsyncCallback, object) public virtual IAsyncResult BeginInvoke(HttpContext context, AsyncCallback callback, object @object) Parameters context HttpContext callback AsyncCallback object object Returns IAsyncResult"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.EndInvoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.EndInvoke.html",
    "title": "Method EndInvoke | Sisk",
    "keywords": "Method EndInvoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll EndInvoke(IAsyncResult) public virtual HttpResponse EndInvoke(IAsyncResult result) Parameters result IAsyncResult Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.Invoke.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.Invoke.html",
    "title": "Method Invoke | Sisk",
    "keywords": "Method Invoke Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Invoke(HttpContext) public virtual HttpResponse Invoke(HttpContext context) Parameters context HttpContext Returns HttpResponse"
  },
  "api/Sisk.Core.Routing.RoutingErrorCallback.html": {
    "href": "api/Sisk.Core.Routing.RoutingErrorCallback.html",
    "title": "Delegate RoutingErrorCallback | Sisk",
    "keywords": "Delegate RoutingErrorCallback Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents the function that is called when an request reaches an error on the router. public delegate HttpResponse RoutingErrorCallback(HttpContext context) Parameters context HttpContext Represents the function that is called when an request reaches an error on the router. Returns HttpResponse Represents the function that is called when an request reaches an error on the router. Constructors RoutingErrorCallback(object, nint) Methods BeginInvoke(HttpContext, AsyncCallback, object) EndInvoke(IAsyncResult) Invoke(HttpContext)"
  },
  "api/Sisk.Core.Routing.ValueResult-1.html": {
    "href": "api/Sisk.Core.Routing.ValueResult-1.html",
    "title": "Class ValueResult<T> | Sisk",
    "keywords": "Class ValueResult<T> Namespace Sisk.Core.Routing Assembly Sisk.Core.dll Represents a mutable type for boxing objects by value or reference in a response from a router. public sealed class ValueResult<T> where T : notnull Type Parameters T The type of object to be boxed. Inheritance object ValueResult<T> Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode()"
  },
  "api/Sisk.Core.Routing.html": {
    "href": "api/Sisk.Core.Routing.html",
    "title": "Namespace Sisk.Core.Routing | Sisk",
    "keywords": "Namespace Sisk.Core.Routing Classes AsyncRequestHandler Represents a class that implements IRequestHandler and its execution method is asynchronous. RegexRoute Represents an Route which it's implementation already enables UseRegex. RegexRouteAttribute Represents a mapping to an route, which it's path is defined by an regular expression. This attribute is an shorthand from RouteAttribute. RequestHandler Represents an abstract class which implements IRequestHandler. RequestHandlerAttribute Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. RequestHandlerAttribute<T> Specifies that the method or class, when used on this attribute, will instantiate the type and call the IRequestHandler with given parameters. Route Represents an HTTP route to be matched by an Router. RouteAttribute Represents an class that, when applied to a method, will be recognized by a router as a route. RouteDeleteAttribute Represents a mapping to an HTTP DELETE route. This attribute is an shorthand from RouteAttribute. RouteGetAttribute Represents a mapping to an HTTP GET route. This attribute is an shorthand from RouteAttribute. RoutePatchAttribute Represents a mapping to an HTTP PATCH route. This attribute is an shorthand from RouteAttribute. RoutePostAttribute Represents a mapping to an HTTP POST route. This attribute is an shorthand from RouteAttribute. RoutePrefixAttribute Represents an attribute that, when applied to an class containing routes, all child routes will start with the specified prefix. RoutePutAttribute Represents a mapping to an HTTP PUT route. This attribute is an shorthand from RouteAttribute. Router Represents a collection of Route and main executor of actions in the HttpServer. RouterModule Indicates that extended class supports router modules, which allows the management of routes, request handlers and prefixes. ValueResult<T> Represents a mutable type for boxing objects by value or reference in a response from a router. Interfaces IRequestHandler Represents an interface that is executed before a request. Enums LogOutput Determines the way the server can write log messages. This enumerator is for giving permissions for certain contexts to be able or not to write to the server logs, such as AccessLogsStream and ErrorsLogsStream. RequestHandlerExecutionMode Defines when the IRequestHandler object should be executed. RouteMethod Represents an HTTP method to be matched in an Route. Delegates ExceptionErrorCallback Represents the function that is called after the route action threw an exception. ParameterlessRouteAction Represents the function that is called after the route is matched with the request. RouteAction Represents the function that is called after the route is matched with the request. RouterActionHandlerCallback<T> Represents the function that receives an object of the T and returns an HttpResponse response from the informed object. RoutingErrorCallback Represents the function that is called when an request reaches an error on the router."
  },
  "api/Sisk.Core.html": {
    "href": "api/Sisk.Core.html",
    "title": "Namespace Sisk.Core | Sisk",
    "keywords": "Namespace Sisk.Core Namespaces Sisk.Core.Entity Sisk.Core.Helpers Sisk.Core.Http Sisk.Core.Routing"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.-ctor.html",
    "title": "Constructor IniDocument | Sisk",
    "keywords": "Constructor IniDocument Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IniDocument(IEnumerable<IniSection>) Creates an new IniDocument instance from the specified IniSection collection. public IniDocument(IEnumerable<IniSection> sections) Parameters sections IEnumerable<IniSection> The list of IniSection. IniDocument() Creates an new empty IniDocument instance with no INI sections added to it. public IniDocument()"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.Empty.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.Empty.html",
    "title": "Field Empty | Sisk",
    "keywords": "Field Empty Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an empty IniDocument with no entry on it. public static readonly IniDocument Empty Returns IniDocument Represents an empty with no entry on it."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromFile.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromFile.html",
    "title": "Method FromFile | Sisk",
    "keywords": "Method FromFile Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromFile(string, Encoding?, bool) Creates an new IniDocument document from the specified file using the specified encoding. public static IniDocument FromFile(string filePath, Encoding? encoding = null, bool throwIfNotExists = true) Parameters filePath string The absolute or relative file path to the INI document. encoding Encoding Optional. The encoding used to read the file. Defaults to UTF-8. throwIfNotExists bool Optional. Defines whether this method should throw if the specified file doens't exists or return an empty INI document. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromStream.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromStream.html",
    "title": "Method FromStream | Sisk",
    "keywords": "Method FromStream Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. public static IniDocument FromStream(Stream stream, Encoding? encoding = null) Parameters stream Stream The input stream where the INI document is. encoding Encoding Optional. The encoding used to read the stream. Defaults to UTF-8. Returns IniDocument FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. public static IniDocument FromStream(TextReader reader) Parameters reader TextReader The TextReader instance. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.FromString.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.FromString.html",
    "title": "Method FromString | Sisk",
    "keywords": "Method FromString Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. public static IniDocument FromString(string iniConfiguration) Parameters iniConfiguration string The UTF-8 string. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.GetSection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.GetSection.html",
    "title": "Method GetSection | Sisk",
    "keywords": "Method GetSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetSection(string) Gets an defined INI section from this document. The search is case-insensitive. public IniSection? GetSection(string sectionName) Parameters sectionName string The section name. Returns IniSection The IniSection object if found, or null if not defined."
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.Global.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.Global.html",
    "title": "Property Global | Sisk",
    "keywords": "Property Global Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Global Gets the global INI section, which is the primary section in the document. public IniSection Global { get; } Property Value IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.Sections.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.Sections.html",
    "title": "Property Sections | Sisk",
    "keywords": "Property Sections Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Sections Gets all INI sections defined in this INI document. public IniSectionCollection Sections { get; } Property Value IniSectionCollection"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.ToString.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.ToString.html",
    "title": "Method ToString | Sisk",
    "keywords": "Method ToString Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll ToString() Gets the INI document string from this IniDocument. public override string ToString() Returns string"
  },
  "api/Sisk.IniConfiguration.Core.IniDocument.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniDocument.html",
    "title": "Class IniDocument | Sisk",
    "keywords": "Class IniDocument Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an INI document. public sealed class IniDocument Inheritance object IniDocument Inherited Members object.GetType() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniDocument() Creates an new empty IniDocument instance with no INI sections added to it. IniDocument(IEnumerable<IniSection>) Creates an new IniDocument instance from the specified IniSection collection. Fields Empty Represents an empty IniDocument with no entry on it. Properties Global Gets the global INI section, which is the primary section in the document. Sections Gets all INI sections defined in this INI document. Methods FromFile(string, Encoding?, bool) Creates an new IniDocument document from the specified file using the specified encoding. FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. GetSection(string) Gets an defined INI section from this document. The search is case-insensitive. ToString() Gets the INI document string from this IniDocument."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.-ctor.html",
    "title": "Constructor IniSection | Sisk",
    "keywords": "Constructor IniSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IniSection(string) Initializes a new instance of the IniSection class with the specified name. public IniSection(string name) Parameters name string The name of the INI section. IniSection(string, IEnumerable<KeyValuePair<string, string>>) Initializes a new instance of the IniSection class with the specified name and items. public IniSection(string name, IEnumerable<KeyValuePair<string, string>> items) Parameters name string The name of the INI section. items IEnumerable<KeyValuePair<string, string>> A collection of key-value pairs to be added to the section."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Add.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Add(string, string[]) public void Add(string key, string[] value) Parameters key string value string[] Add(string, string?) Adds a new key-value pair to the INI section. public void Add(string key, string? value) Parameters key string The key to be added. value string The value associated with the key, or null to set an empty value. Add(KeyValuePair<string, string[]>) public void Add(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Clear.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Clear() public void Clear()"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Contains.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Contains(KeyValuePair<string, string[]>) public bool Contains(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.ContainsKey.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. public bool ContainsKey(string key) Parameters key string The property name. Returns bool An bool indicating if the specified property name is defined or not."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.CopyTo.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll CopyTo(KeyValuePair<string, string[]>[], int) This method is not supported and will throw an NotSupportedException. public void CopyTo(KeyValuePair<string, string[]>[] array, int arrayIndex) Parameters array KeyValuePair<string, string[]>[] arrayIndex int"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Count.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Count Gets the number of properties in this INI section. public int Count { get; } Property Value int"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetEnumerator.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEnumerator() public IEnumerator<KeyValuePair<string, string[]>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, string[]>>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetMany.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetMany.html",
    "title": "Method GetMany | Sisk",
    "keywords": "Method GetMany Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetMany(string) Gets all values defined in this INI section by their property name. public string[] GetMany(string key) Parameters key string The property name. Returns string[] All values associated with the specified property name."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.GetOne.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.GetOne.html",
    "title": "Method GetOne | Sisk",
    "keywords": "Method GetOne Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetOne(string) Gets the last value defined in this INI section by their property name. public string? GetOne(string key) Parameters key string The property name. Returns string The last value associated with the specified property name, or null if nothing is found."
  },
  "api/Sisk.IniConfiguration.Core.IniSection.IsReadOnly.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IsReadOnly public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Item.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll this[string] Gets all values associated with the specified property name, performing an case-insensitive search. public string[] this[string key] { get; } Parameters key string The property name. Property Value string[]"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Keys.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Keys Gets all keys defined in this INI section, without duplicates. public ICollection<string> Keys { get; } Property Value ICollection<string>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Name.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Name Gets the INI section name. public string Name { get; } Property Value string"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Remove.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Remove(string) public bool Remove(string key) Parameters key string Returns bool Remove(KeyValuePair<string, string[]>) public bool Remove(KeyValuePair<string, string[]> item) Parameters item KeyValuePair<string, string[]> Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.TryGetValue.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll TryGetValue(string, out string[]) public bool TryGetValue(string key, out string[] value) Parameters key string value string[] Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.Values.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Values Gets all values defined in this INI section. public ICollection<string[]> Values { get; } Property Value ICollection<string[]>"
  },
  "api/Sisk.IniConfiguration.Core.IniSection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSection.html",
    "title": "Class IniSection | Sisk",
    "keywords": "Class IniSection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an INI section, which contains it's own properties. public sealed class IniSection : IDictionary<string, string[]>, ICollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object IniSection Implements IDictionary<string, string[]> ICollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniSection(string) Initializes a new instance of the IniSection class with the specified name. IniSection(string, IEnumerable<KeyValuePair<string, string>>) Initializes a new instance of the IniSection class with the specified name and items. Properties Count Gets the number of properties in this INI section. IsReadOnly this[string] Gets all values associated with the specified property name, performing an case-insensitive search. Keys Gets all keys defined in this INI section, without duplicates. Name Gets the INI section name. Values Gets all values defined in this INI section. Methods Add(KeyValuePair<string, string[]>) Add(string, string?) Adds a new key-value pair to the INI section. Add(string, string[]) Clear() Contains(KeyValuePair<string, string[]>) ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. CopyTo(KeyValuePair<string, string[]>[], int) This method is not supported and will throw an NotSupportedException. GetEnumerator() GetMany(string) Gets all values defined in this INI section by their property name. GetOne(string) Gets the last value defined in this INI section by their property name. Remove(KeyValuePair<string, string[]>) Remove(string) TryGetValue(string, out string[])"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Add.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Add.html",
    "title": "Method Add | Sisk",
    "keywords": "Method Add Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Add(IniSection) public void Add(IniSection item) Parameters item IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Clear.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Clear.html",
    "title": "Method Clear | Sisk",
    "keywords": "Method Clear Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Clear() public void Clear()"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Contains.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Contains.html",
    "title": "Method Contains | Sisk",
    "keywords": "Method Contains Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Contains(IniSection) public bool Contains(IniSection item) Parameters item IniSection Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.CopyTo.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.CopyTo.html",
    "title": "Method CopyTo | Sisk",
    "keywords": "Method CopyTo Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll CopyTo(IniSection[], int) public void CopyTo(IniSection[] array, int arrayIndex) Parameters array IniSection[] arrayIndex int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Count.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Count public int Count { get; } Property Value int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetEnumerator.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetEnumerator() public IEnumerator<IniSection> GetEnumerator() Returns IEnumerator<IniSection>"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetGlobal.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.GetGlobal.html",
    "title": "Method GetGlobal | Sisk",
    "keywords": "Method GetGlobal Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll GetGlobal() Gets the global IniSection in this collection or creates a new one if it doens't exists. public IniSection GetGlobal() Returns IniSection The global IniSection."
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.IndexOf.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.IndexOf.html",
    "title": "Method IndexOf | Sisk",
    "keywords": "Method IndexOf Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IndexOf(IniSection) public int IndexOf(IniSection item) Parameters item IniSection Returns int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Insert.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Insert.html",
    "title": "Method Insert | Sisk",
    "keywords": "Method Insert Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Insert(int, IniSection) public void Insert(int index, IniSection item) Parameters index int item IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.IsReadOnly.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.IsReadOnly.html",
    "title": "Property IsReadOnly | Sisk",
    "keywords": "Property IsReadOnly Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll IsReadOnly public bool IsReadOnly { get; } Property Value bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Item.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll this[int] public IniSection this[int index] { get; set; } Parameters index int Property Value IniSection"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.Remove.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.Remove.html",
    "title": "Method Remove | Sisk",
    "keywords": "Method Remove Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Remove(IniSection) public bool Remove(IniSection item) Parameters item IniSection Returns bool"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.RemoveAt.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.RemoveAt.html",
    "title": "Method RemoveAt | Sisk",
    "keywords": "Method RemoveAt Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll RemoveAt(int) public void RemoveAt(int index) Parameters index int"
  },
  "api/Sisk.IniConfiguration.Core.IniSectionCollection.html": {
    "href": "api/Sisk.IniConfiguration.Core.IniSectionCollection.html",
    "title": "Class IniSectionCollection | Sisk",
    "keywords": "Class IniSectionCollection Namespace Sisk.IniConfiguration.Core Assembly Sisk.IniConfiguration.Core.dll Represents an collection of IniSection. public sealed class IniSectionCollection : IList<IniSection>, ICollection<IniSection>, IEnumerable<IniSection>, IEnumerable Inheritance object IniSectionCollection Implements IList<IniSection> ICollection<IniSection> IEnumerable<IniSection> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Count IsReadOnly this[int] Methods Add(IniSection) Clear() Contains(IniSection) CopyTo(IniSection[], int) GetEnumerator() GetGlobal() Gets the global IniSection in this collection or creates a new one if it doens't exists. IndexOf(IniSection) Insert(int, IniSection) Remove(IniSection) RemoveAt(int)"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.-ctor.html",
    "title": "Constructor IniReader | Sisk",
    "keywords": "Constructor IniReader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniReader(TextReader) Creates an new IniReader with the specified text reader. public IniReader(TextReader reader) Parameters reader TextReader The TextReader instace to read the INI document."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Dispose.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Dispose() public void Dispose()"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.IniNamingComparer.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.IniNamingComparer.html",
    "title": "Property IniNamingComparer | Sisk",
    "keywords": "Property IniNamingComparer Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniNamingComparer Gets or sets the default StringComparer used by the INI reader and instances to compare key names. public static StringComparer IniNamingComparer { get; set; } Property Value StringComparer"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Read.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Read.html",
    "title": "Method Read | Sisk",
    "keywords": "Method Read Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Read() Reads the INI document from the input stream. public IniDocument Read() Returns IniDocument An IniDocument file containing all properties and data from the input stream."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Reader.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.Reader.html",
    "title": "Property Reader | Sisk",
    "keywords": "Property Reader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Reader Gets the TextReader which is providing data to this INI reader. public TextReader Reader { get; } Property Value TextReader"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniReader.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniReader.html",
    "title": "Class IniReader | Sisk",
    "keywords": "Class IniReader Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Provides an INI-document reader and parser. public sealed class IniReader : IDisposable Inheritance object IniReader Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniReader(TextReader) Creates an new IniReader with the specified text reader. Properties IniNamingComparer Gets or sets the default StringComparer used by the INI reader and instances to compare key names. Reader Gets the TextReader which is providing data to this INI reader. Methods Dispose() Read() Reads the INI document from the input stream."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.-ctor.html",
    "title": "Constructor IniWriter | Sisk",
    "keywords": "Constructor IniWriter Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll IniWriter(TextWriter) Initializes a new instance of the IniWriter class. public IniWriter(TextWriter writer) Parameters writer TextWriter The underlying text writer."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.CommentChar.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.CommentChar.html",
    "title": "Property CommentChar | Sisk",
    "keywords": "Property CommentChar Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll CommentChar Gets or sets the default comment character. public char CommentChar { get; set; } Property Value char"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Dispose.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Dispose() Releases all resources used by the IniWriter object. public void Dispose()"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.NewLineBehavior.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.NewLineBehavior.html",
    "title": "Property NewLineBehavior | Sisk",
    "keywords": "Property NewLineBehavior Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll NewLineBehavior Gets or sets the behavior for writing new lines. public IniWritingNewLineBehavior NewLineBehavior { get; set; } Property Value IniWritingNewLineBehavior"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Write.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Write.html",
    "title": "Method Write | Sisk",
    "keywords": "Method Write Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Write(string, string?) Writes a key-value pair to the INI file. public void Write(string key, string? value) Parameters key string The key to write. value string The value to write. Write(in KeyValuePair<string, string[]>) Writes a key-value pair to the INI file, where the value is an array of strings. public void Write(in KeyValuePair<string, string[]> value) Parameters value KeyValuePair<string, string[]> The key-value pair to write. Write(IniSection) Writes an INI section to the INI file. public void Write(IniSection section) Parameters section IniSection The section to write. Write(IniDocument) Writes an INI document to the INI file. public void Write(IniDocument document) Parameters document IniDocument The document to write."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.WriteComment.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.WriteComment.html",
    "title": "Method WriteComment | Sisk",
    "keywords": "Method WriteComment Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll WriteComment(string) Writes a comment to the INI file. public void WriteComment(string commentString) Parameters commentString string The comment to write."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Writer.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.Writer.html",
    "title": "Property Writer | Sisk",
    "keywords": "Property Writer Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Writer Gets the underlying text writer. public TextWriter Writer { get; } Property Value TextWriter"
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWriter.html",
    "title": "Class IniWriter | Sisk",
    "keywords": "Class IniWriter Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Represents a writer for INI files. public sealed class IniWriter : IDisposable Inheritance object IniWriter Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniWriter(TextWriter) Initializes a new instance of the IniWriter class. Properties CommentChar Gets or sets the default comment character. NewLineBehavior Gets or sets the behavior for writing new lines. Writer Gets the underlying text writer. Methods Dispose() Releases all resources used by the IniWriter object. Write(IniDocument) Writes an INI document to the INI file. Write(IniSection) Writes an INI section to the INI file. Write(in KeyValuePair<string, string[]>) Writes a key-value pair to the INI file, where the value is an array of strings. Write(string, string?) Writes a key-value pair to the INI file. WriteComment(string) Writes a comment to the INI file."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.IniWritingNewLineBehavior.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.IniWritingNewLineBehavior.html",
    "title": "Enum IniWritingNewLineBehavior | Sisk",
    "keywords": "Enum IniWritingNewLineBehavior Namespace Sisk.IniConfiguration.Core.Serialization Assembly Sisk.IniConfiguration.Core.dll Specifies the behavior for writing new lines in an INI file. [Flags] public enum IniWritingNewLineBehavior Fields Escape = 4 Escapes the new line characters when writing new lines. Quote = 1 Quotes the value when writing new lines. Split = 2 Splits the value into multiple lines when writing new lines."
  },
  "api/Sisk.IniConfiguration.Core.Serialization.html": {
    "href": "api/Sisk.IniConfiguration.Core.Serialization.html",
    "title": "Namespace Sisk.IniConfiguration.Core.Serialization | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration.Core.Serialization Classes IniReader Provides an INI-document reader and parser. IniWriter Represents a writer for INI files. Enums IniWritingNewLineBehavior Specifies the behavior for writing new lines in an INI file."
  },
  "api/Sisk.IniConfiguration.Core.html": {
    "href": "api/Sisk.IniConfiguration.Core.html",
    "title": "Namespace Sisk.IniConfiguration.Core | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration.Core Namespaces Sisk.IniConfiguration.Core.Serialization Classes IniDocument Represents an INI document. IniSection Represents an INI section, which contains it's own properties. IniSectionCollection Represents an collection of IniSection."
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.-ctor.html",
    "title": "Constructor IniConfigurationReader | Sisk",
    "keywords": "Constructor IniConfigurationReader Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll IniConfigurationReader() public IniConfigurationReader()"
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.ReadConfiguration.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.ReadConfiguration.html",
    "title": "Method ReadConfiguration | Sisk",
    "keywords": "Method ReadConfiguration Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file. public void ReadConfiguration(ConfigurationContext context) Parameters context ConfigurationContext The configuration context object."
  },
  "api/Sisk.IniConfiguration.IniConfigurationReader.html": {
    "href": "api/Sisk.IniConfiguration.IniConfigurationReader.html",
    "title": "Class IniConfigurationReader | Sisk",
    "keywords": "Class IniConfigurationReader Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Provides an INI-Document based configuration-reader pipeline. public sealed class IniConfigurationReader : IConfigurationReader Inheritance object IniConfigurationReader Implements IConfigurationReader Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniConfigurationReader() Methods ReadConfiguration(ConfigurationContext) Represents the method that reads and applies settings from a settings file."
  },
  "api/Sisk.IniConfiguration.IniDocument.Empty.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.Empty.html",
    "title": "Field Empty | Sisk",
    "keywords": "Field Empty Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll public static readonly IniDocument Empty Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.IniDocument.FromFile.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.FromFile.html",
    "title": "Method FromFile | Sisk",
    "keywords": "Method FromFile Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll FromFile(string, Encoding?, bool) public static IniDocument FromFile(string filePath, Encoding? encoding = null, bool throwIfNotExists = true) Parameters filePath string encoding Encoding throwIfNotExists bool Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.IniDocument.FromStream.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.FromStream.html",
    "title": "Method FromStream | Sisk",
    "keywords": "Method FromStream Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. public static IniDocument FromStream(Stream stream, Encoding? encoding = null) Parameters stream Stream The input stream where the INI document is. encoding Encoding Optional. The encoding used to read the stream. Defaults to UTF-8. Returns IniDocument FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. public static IniDocument FromStream(TextReader reader) Parameters reader TextReader The TextReader instance. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.IniDocument.FromString.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.FromString.html",
    "title": "Method FromString | Sisk",
    "keywords": "Method FromString Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. public static IniDocument FromString(string iniConfiguration) Parameters iniConfiguration string The UTF-8 string. Returns IniDocument"
  },
  "api/Sisk.IniConfiguration.IniDocument.GetSection.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.GetSection.html",
    "title": "Method GetSection | Sisk",
    "keywords": "Method GetSection Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll GetSection(string) Gets an defined INI section from this document. The search is case-insensitive. public IniSection? GetSection(string sectionName) Parameters sectionName string The section name. Returns IniSection The IniSection object if found, or null if not defined."
  },
  "api/Sisk.IniConfiguration.IniDocument.Global.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.Global.html",
    "title": "Property Global | Sisk",
    "keywords": "Property Global Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Global Gets the global INI section, which is the primary section in the document. public IniSection Global { get; } Property Value IniSection"
  },
  "api/Sisk.IniConfiguration.IniDocument.Sections.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.Sections.html",
    "title": "Property Sections | Sisk",
    "keywords": "Property Sections Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Sections Gets all INI sections defined in this INI document. public IList<IniSection> Sections { get; } Property Value IList<IniSection>"
  },
  "api/Sisk.IniConfiguration.IniDocument.html": {
    "href": "api/Sisk.IniConfiguration.IniDocument.html",
    "title": "Class IniDocument | Sisk",
    "keywords": "Class IniDocument Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Represents an INI configuration document. public sealed class IniDocument Inheritance object IniDocument Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Fields Empty Properties Global Gets the global INI section, which is the primary section in the document. Sections Gets all INI sections defined in this INI document. Methods FromFile(string, Encoding?, bool) FromStream(Stream, Encoding?) Creates an new IniDocument document from the specified stream using the specified encoding. FromStream(TextReader) Creates an new IniDocument document from the specified TextReader. FromString(string) Creates an new IniDocument document from the specified string, reading it as an UTF-8 string. GetSection(string) Gets an defined INI section from this document. The search is case-insensitive."
  },
  "api/Sisk.IniConfiguration.IniSection.ContainsKey.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.ContainsKey.html",
    "title": "Method ContainsKey | Sisk",
    "keywords": "Method ContainsKey Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. public bool ContainsKey(string key) Parameters key string The property name. Returns bool An bool indicating if the specified property name is defined or not."
  },
  "api/Sisk.IniConfiguration.IniSection.Count.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.Count.html",
    "title": "Property Count | Sisk",
    "keywords": "Property Count Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Count Gets the number of properties in this INI section. public int Count { get; } Property Value int"
  },
  "api/Sisk.IniConfiguration.IniSection.GetEnumerator.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.GetEnumerator.html",
    "title": "Method GetEnumerator | Sisk",
    "keywords": "Method GetEnumerator Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll GetEnumerator() public IEnumerator<KeyValuePair<string, string[]>> GetEnumerator() Returns IEnumerator<KeyValuePair<string, string[]>>"
  },
  "api/Sisk.IniConfiguration.IniSection.GetMany.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.GetMany.html",
    "title": "Method GetMany | Sisk",
    "keywords": "Method GetMany Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll GetMany(string) Gets all values defined in this INI section by their property name. public string[] GetMany(string key) Parameters key string The property name. Returns string[] All values associated with the specified property name."
  },
  "api/Sisk.IniConfiguration.IniSection.GetOne.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.GetOne.html",
    "title": "Method GetOne | Sisk",
    "keywords": "Method GetOne Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll GetOne(string) Gets the last value defined in this INI section by their property name. public string? GetOne(string key) Parameters key string The property name. Returns string The last value associated with the specified property name, or null if nothing is found."
  },
  "api/Sisk.IniConfiguration.IniSection.Item.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.Item.html",
    "title": "Property this | Sisk",
    "keywords": "Property this Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll this[string] Gets all values associated with the specified property name, performing an case-insensitive search. public string[] this[string key] { get; } Parameters key string The property name. Property Value string[]"
  },
  "api/Sisk.IniConfiguration.IniSection.Keys.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.Keys.html",
    "title": "Property Keys | Sisk",
    "keywords": "Property Keys Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Keys Gets all keys defined in this INI section, without duplicates. public IEnumerable<string> Keys { get; } Property Value IEnumerable<string>"
  },
  "api/Sisk.IniConfiguration.IniSection.Name.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Name Gets the INI section name. public string Name { get; } Property Value string"
  },
  "api/Sisk.IniConfiguration.IniSection.TryGetValue.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.TryGetValue.html",
    "title": "Method TryGetValue | Sisk",
    "keywords": "Method TryGetValue Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll TryGetValue(string, out string[]) public bool TryGetValue(string key, out string[] value) Parameters key string value string[] Returns bool"
  },
  "api/Sisk.IniConfiguration.IniSection.Values.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.Values.html",
    "title": "Property Values | Sisk",
    "keywords": "Property Values Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Values Gets all values defined in this INI section. public IEnumerable<string[]> Values { get; } Property Value IEnumerable<string[]>"
  },
  "api/Sisk.IniConfiguration.IniSection.html": {
    "href": "api/Sisk.IniConfiguration.IniSection.html",
    "title": "Class IniSection | Sisk",
    "keywords": "Class IniSection Namespace Sisk.IniConfiguration Assembly Sisk.IniConfiguration.dll Represents an INI section, which contains it's own properties. public sealed class IniSection : IReadOnlyDictionary<string, string[]>, IReadOnlyCollection<KeyValuePair<string, string[]>>, IEnumerable<KeyValuePair<string, string[]>>, IEnumerable Inheritance object IniSection Implements IReadOnlyDictionary<string, string[]> IReadOnlyCollection<KeyValuePair<string, string[]>> IEnumerable<KeyValuePair<string, string[]>> IEnumerable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Count Gets the number of properties in this INI section. this[string] Gets all values associated with the specified property name, performing an case-insensitive search. Keys Gets all keys defined in this INI section, without duplicates. Name Gets the INI section name. Values Gets all values defined in this INI section. Methods ContainsKey(string) Gets an boolean indicating if the specified key/property name is defined in this IniSection. GetEnumerator() GetMany(string) Gets all values defined in this INI section by their property name. GetOne(string) Gets the last value defined in this INI section by their property name. TryGetValue(string, out string[])"
  },
  "api/Sisk.IniConfiguration.Serializer.IniReader.-ctor.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.IniReader.-ctor.html",
    "title": "Constructor IniReader | Sisk",
    "keywords": "Constructor IniReader Namespace Sisk.IniConfiguration.Serializer Assembly Sisk.IniConfiguration.dll IniReader(TextReader) Creates an new IniReader with the specified text reader. public IniReader(TextReader reader) Parameters reader TextReader The TextReader instace to read the INI document."
  },
  "api/Sisk.IniConfiguration.Serializer.IniReader.Dispose.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.IniReader.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.IniConfiguration.Serializer Assembly Sisk.IniConfiguration.dll Dispose() public void Dispose()"
  },
  "api/Sisk.IniConfiguration.Serializer.IniReader.Read.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.IniReader.Read.html",
    "title": "Method Read | Sisk",
    "keywords": "Method Read Namespace Sisk.IniConfiguration.Serializer Assembly Sisk.IniConfiguration.dll Read() Reads the INI document from the input stream. public IniDocument Read() Returns IniDocument An IniDocument file containing all properties and data from the input stream."
  },
  "api/Sisk.IniConfiguration.Serializer.IniReader.Reader.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.IniReader.Reader.html",
    "title": "Property Reader | Sisk",
    "keywords": "Property Reader Namespace Sisk.IniConfiguration.Serializer Assembly Sisk.IniConfiguration.dll Reader Gets the TextReader which is providing data to this INI reader. public TextReader Reader { get; } Property Value TextReader"
  },
  "api/Sisk.IniConfiguration.Serializer.IniReader.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.IniReader.html",
    "title": "Class IniReader | Sisk",
    "keywords": "Class IniReader Namespace Sisk.IniConfiguration.Serializer Assembly Sisk.IniConfiguration.dll Provides an INI-document reader and parser. public sealed class IniReader : IDisposable Inheritance object IniReader Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors IniReader(TextReader) Creates an new IniReader with the specified text reader. Properties Reader Gets the TextReader which is providing data to this INI reader. Methods Dispose() Read() Reads the INI document from the input stream."
  },
  "api/Sisk.IniConfiguration.Serializer.html": {
    "href": "api/Sisk.IniConfiguration.Serializer.html",
    "title": "Namespace Sisk.IniConfiguration.Serializer | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration.Serializer Classes IniReader Provides an INI-document reader and parser."
  },
  "api/Sisk.IniConfiguration.html": {
    "href": "api/Sisk.IniConfiguration.html",
    "title": "Namespace Sisk.IniConfiguration | Sisk",
    "keywords": "Namespace Sisk.IniConfiguration Namespaces Sisk.IniConfiguration.Core Classes IniConfigurationReader Provides an INI-Document based configuration-reader pipeline."
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.-ctor.html",
    "title": "Constructor MethodDescriptionAttribute | Sisk",
    "keywords": "Constructor MethodDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll MethodDescriptionAttribute(string) public MethodDescriptionAttribute(string description) Parameters description string"
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Category.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Category.html",
    "title": "Property Category | Sisk",
    "keywords": "Property Category Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Category public string? Category { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Description.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Description public string Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.MethodDescriptionAttribute.html",
    "title": "Class MethodDescriptionAttribute | Sisk",
    "keywords": "Class MethodDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = false)] public sealed class MethodDescriptionAttribute : Attribute Inheritance object Attribute MethodDescriptionAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors MethodDescriptionAttribute(string) Properties Category Description"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.-ctor.html",
    "title": "Constructor ParamDescriptionAttribute | Sisk",
    "keywords": "Constructor ParamDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll ParamDescriptionAttribute(string, string) public ParamDescriptionAttribute(string paramName, string description) Parameters paramName string description string"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.Description.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Description public string Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.ParameterName.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.ParameterName.html",
    "title": "Property ParameterName | Sisk",
    "keywords": "Property ParameterName Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll ParameterName public string ParameterName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.ParamDescriptionAttribute.html",
    "title": "Class ParamDescriptionAttribute | Sisk",
    "keywords": "Class ParamDescriptionAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)] public sealed class ParamDescriptionAttribute : Attribute Inheritance object Attribute ParamDescriptionAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors ParamDescriptionAttribute(string, string) Properties Description ParameterName"
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.-ctor.html",
    "title": "Constructor WebMethodAttribute | Sisk",
    "keywords": "Constructor WebMethodAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll WebMethodAttribute() public WebMethodAttribute() WebMethodAttribute(string) public WebMethodAttribute(string methodName) Parameters methodName string"
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.Name.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Name public string? Name { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebMethodAttribute.html",
    "title": "Class WebMethodAttribute | Sisk",
    "keywords": "Class WebMethodAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll [AttributeUsage(AttributeTargets.Method, AllowMultiple = false, Inherited = false)] public sealed class WebMethodAttribute : Attribute Inheritance object Attribute WebMethodAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors WebMethodAttribute() WebMethodAttribute(string) Properties Name"
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.-ctor.html",
    "title": "Constructor WebNameAttribute | Sisk",
    "keywords": "Constructor WebNameAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll WebNameAttribute(string) public WebNameAttribute(string name) Parameters name string"
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.Name.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.Name.html",
    "title": "Property Name | Sisk",
    "keywords": "Property Name Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll Name public string Name { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Annotations.WebNameAttribute.html": {
    "href": "api/Sisk.JsonRPC.Annotations.WebNameAttribute.html",
    "title": "Class WebNameAttribute | Sisk",
    "keywords": "Class WebNameAttribute Namespace Sisk.JsonRPC.Annotations Assembly Sisk.JsonRPC.dll [AttributeUsage(AttributeTargets.Class)] public sealed class WebNameAttribute : Attribute Inheritance object Attribute WebNameAttribute Inherited Members Attribute.GetCustomAttributes(MemberInfo, Type) Attribute.GetCustomAttributes(MemberInfo, Type, bool) Attribute.GetCustomAttributes(MemberInfo) Attribute.GetCustomAttributes(MemberInfo, bool) Attribute.IsDefined(MemberInfo, Type) Attribute.IsDefined(MemberInfo, Type, bool) Attribute.GetCustomAttribute(MemberInfo, Type) Attribute.GetCustomAttribute(MemberInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo) Attribute.GetCustomAttributes(ParameterInfo, Type) Attribute.GetCustomAttributes(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(ParameterInfo, bool) Attribute.IsDefined(ParameterInfo, Type) Attribute.IsDefined(ParameterInfo, Type, bool) Attribute.GetCustomAttribute(ParameterInfo, Type) Attribute.GetCustomAttribute(ParameterInfo, Type, bool) Attribute.GetCustomAttributes(Module, Type) Attribute.GetCustomAttributes(Module) Attribute.GetCustomAttributes(Module, bool) Attribute.GetCustomAttributes(Module, Type, bool) Attribute.IsDefined(Module, Type) Attribute.IsDefined(Module, Type, bool) Attribute.GetCustomAttribute(Module, Type) Attribute.GetCustomAttribute(Module, Type, bool) Attribute.GetCustomAttributes(Assembly, Type) Attribute.GetCustomAttributes(Assembly, Type, bool) Attribute.GetCustomAttributes(Assembly) Attribute.GetCustomAttributes(Assembly, bool) Attribute.IsDefined(Assembly, Type) Attribute.IsDefined(Assembly, Type, bool) Attribute.GetCustomAttribute(Assembly, Type) Attribute.GetCustomAttribute(Assembly, Type, bool) Attribute.Equals(object) Attribute.GetHashCode() Attribute.Match(object) Attribute.IsDefaultAttribute() Attribute.TypeId object.GetType() object.ToString() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors WebNameAttribute(string) Properties Name"
  },
  "api/Sisk.JsonRPC.Annotations.html": {
    "href": "api/Sisk.JsonRPC.Annotations.html",
    "title": "Namespace Sisk.JsonRPC.Annotations | Sisk",
    "keywords": "Namespace Sisk.JsonRPC.Annotations Classes MethodDescriptionAttribute ParamDescriptionAttribute WebMethodAttribute WebNameAttribute"
  },
  "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation Returns byte[]"
  },
  "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.html": {
    "href": "api/Sisk.JsonRPC.Documentation.IJsonRpcDocumentationExporter.html",
    "title": "Interface IJsonRpcDocumentationExporter | Sisk",
    "keywords": "Interface IJsonRpcDocumentationExporter Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public interface IJsonRpcDocumentationExporter Methods ExportDocumentBytes(JsonRpcDocumentation)"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Export.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Export.html",
    "title": "Method Export | Sisk",
    "keywords": "Method Export Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Export(IJsonRpcDocumentationExporter) public byte[] Export(IJsonRpcDocumentationExporter exporter) Parameters exporter IJsonRpcDocumentationExporter Returns byte[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.ExportToJson.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.ExportToJson.html",
    "title": "Method ExportToJson | Sisk",
    "keywords": "Method ExportToJson Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportToJson(JsonOptions) public string ExportToJson(JsonOptions options) Parameters options JsonOptions Returns string ExportToJson() public string ExportToJson() Returns string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Metadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Metadata.html",
    "title": "Property Metadata | Sisk",
    "keywords": "Property Metadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Metadata public JsonRpcDocumentationMetadata? Metadata { get; } Property Value JsonRpcDocumentationMetadata"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Methods.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.Methods.html",
    "title": "Property Methods | Sisk",
    "keywords": "Property Methods Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Methods public JsonRpcDocumentationMethod[] Methods { get; } Property Value JsonRpcDocumentationMethod[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentation.html",
    "title": "Class JsonRpcDocumentation | Sisk",
    "keywords": "Class JsonRpcDocumentation Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public sealed class JsonRpcDocumentation Inheritance object JsonRpcDocumentation Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Metadata Methods Methods Export(IJsonRpcDocumentationExporter) ExportToJson() ExportToJson(JsonOptions)"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.-ctor.html",
    "title": "Constructor JsonRpcDocumentationMetadata | Sisk",
    "keywords": "Constructor JsonRpcDocumentationMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcDocumentationMetadata() public JsonRpcDocumentationMetadata()"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.AllowedMethods.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.AllowedMethods.html",
    "title": "Property AllowedMethods | Sisk",
    "keywords": "Property AllowedMethods Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll AllowedMethods public string[] AllowedMethods { get; set; } Property Value string[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationDescription.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationDescription.html",
    "title": "Property ApplicationDescription | Sisk",
    "keywords": "Property ApplicationDescription Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ApplicationDescription public string? ApplicationDescription { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ApplicationName.html",
    "title": "Property ApplicationName | Sisk",
    "keywords": "Property ApplicationName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ApplicationName public string? ApplicationName { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ServicePath.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.ServicePath.html",
    "title": "Property ServicePath | Sisk",
    "keywords": "Property ServicePath Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ServicePath public string? ServicePath { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMetadata.html",
    "title": "Class JsonRpcDocumentationMetadata | Sisk",
    "keywords": "Class JsonRpcDocumentationMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public sealed class JsonRpcDocumentationMetadata Inheritance object JsonRpcDocumentationMetadata Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcDocumentationMetadata() Properties AllowedMethods ApplicationDescription ApplicationName ServicePath"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Category.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Category.html",
    "title": "Property Category | Sisk",
    "keywords": "Property Category Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Category public string? Category { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Description.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Description public string? Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.MethodName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.MethodName.html",
    "title": "Property MethodName | Sisk",
    "keywords": "Property MethodName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll MethodName public string MethodName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Parameters.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Parameters public JsonRpcDocumentationParameter[] Parameters { get; } Property Value JsonRpcDocumentationParameter[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.ReturnType.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.ReturnType.html",
    "title": "Property ReturnType | Sisk",
    "keywords": "Property ReturnType Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ReturnType public Type ReturnType { get; } Property Value Type"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationMethod.html",
    "title": "Class JsonRpcDocumentationMethod | Sisk",
    "keywords": "Class JsonRpcDocumentationMethod Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public sealed class JsonRpcDocumentationMethod Inheritance object JsonRpcDocumentationMethod Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Category Description MethodName Parameters ReturnType"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.Description.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.Description.html",
    "title": "Property Description | Sisk",
    "keywords": "Property Description Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Description public string? Description { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.IsOptional.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.IsOptional.html",
    "title": "Property IsOptional | Sisk",
    "keywords": "Property IsOptional Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll IsOptional public bool IsOptional { get; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterName.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterName.html",
    "title": "Property ParameterName | Sisk",
    "keywords": "Property ParameterName Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ParameterName public string ParameterName { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterType.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.ParameterType.html",
    "title": "Property ParameterType | Sisk",
    "keywords": "Property ParameterType Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ParameterType public Type ParameterType { get; } Property Value Type"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcDocumentationParameter.html",
    "title": "Class JsonRpcDocumentationParameter | Sisk",
    "keywords": "Class JsonRpcDocumentationParameter Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public sealed class JsonRpcDocumentationParameter Inheritance object JsonRpcDocumentationParameter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Description IsOptional ParameterName ParameterType"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.-ctor.html",
    "title": "Constructor JsonRpcHtmlExport | Sisk",
    "keywords": "Constructor JsonRpcHtmlExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcHtmlExport() public JsonRpcHtmlExport()"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.EncodeDocumentationHtml.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.EncodeDocumentationHtml.html",
    "title": "Method EncodeDocumentationHtml | Sisk",
    "keywords": "Method EncodeDocumentationHtml Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll EncodeDocumentationHtml(JsonRpcDocumentation) protected string EncodeDocumentationHtml(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation Returns string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) public byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation Returns byte[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportMetadata.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportMetadata.html",
    "title": "Property ExportMetadata | Sisk",
    "keywords": "Property ExportMetadata Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportMetadata public bool ExportMetadata { get; set; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportSummary.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.ExportSummary.html",
    "title": "Property ExportSummary | Sisk",
    "keywords": "Property ExportSummary Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportSummary public bool ExportSummary { get; set; } Property Value bool"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Header.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Header.html",
    "title": "Property Header | Sisk",
    "keywords": "Property Header Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Header public object? Header { get; set; } Property Value object"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Style.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.Style.html",
    "title": "Property Style | Sisk",
    "keywords": "Property Style Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll Style public string? Style { get; set; } Property Value string"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcHtmlExport.html",
    "title": "Class JsonRpcHtmlExport | Sisk",
    "keywords": "Class JsonRpcHtmlExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public class JsonRpcHtmlExport : IJsonRpcDocumentationExporter Inheritance object JsonRpcHtmlExport Implements IJsonRpcDocumentationExporter Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcHtmlExport() Properties ExportMetadata ExportSummary Header Style Methods EncodeDocumentationHtml(JsonRpcDocumentation) ExportDocumentBytes(JsonRpcDocumentation)"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.-ctor.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.-ctor.html",
    "title": "Constructor JsonRpcJsonExport | Sisk",
    "keywords": "Constructor JsonRpcJsonExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonRpcJsonExport() public JsonRpcJsonExport() JsonRpcJsonExport(JsonOptions) public JsonRpcJsonExport(JsonOptions options) Parameters options JsonOptions"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.EncodeDocumentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.EncodeDocumentation.html",
    "title": "Method EncodeDocumentation | Sisk",
    "keywords": "Method EncodeDocumentation Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll EncodeDocumentation(JsonRpcDocumentation) public JsonValue EncodeDocumentation(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation Returns JsonValue"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.ExportDocumentBytes.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.ExportDocumentBytes.html",
    "title": "Method ExportDocumentBytes | Sisk",
    "keywords": "Method ExportDocumentBytes Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll ExportDocumentBytes(JsonRpcDocumentation) public byte[] ExportDocumentBytes(JsonRpcDocumentation documentation) Parameters documentation JsonRpcDocumentation Returns byte[]"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.JsonOptions.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.JsonOptions.html",
    "title": "Property JsonOptions | Sisk",
    "keywords": "Property JsonOptions Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll JsonOptions public JsonOptions JsonOptions { get; set; } Property Value JsonOptions"
  },
  "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.html": {
    "href": "api/Sisk.JsonRPC.Documentation.JsonRpcJsonExport.html",
    "title": "Class JsonRpcJsonExport | Sisk",
    "keywords": "Class JsonRpcJsonExport Namespace Sisk.JsonRPC.Documentation Assembly Sisk.JsonRPC.dll public sealed class JsonRpcJsonExport : IJsonRpcDocumentationExporter Inheritance object JsonRpcJsonExport Implements IJsonRpcDocumentationExporter Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcJsonExport() JsonRpcJsonExport(JsonOptions) Properties JsonOptions Methods EncodeDocumentation(JsonRpcDocumentation) ExportDocumentBytes(JsonRpcDocumentation)"
  },
  "api/Sisk.JsonRPC.Documentation.html": {
    "href": "api/Sisk.JsonRPC.Documentation.html",
    "title": "Namespace Sisk.JsonRPC.Documentation | Sisk",
    "keywords": "Namespace Sisk.JsonRPC.Documentation Classes JsonRpcDocumentation JsonRpcDocumentationMetadata JsonRpcDocumentationMethod JsonRpcDocumentationParameter JsonRpcHtmlExport JsonRpcJsonExport Interfaces IJsonRpcDocumentationExporter"
  },
  "api/Sisk.JsonRPC.JsonRpcError.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.-ctor.html",
    "title": "Constructor JsonRpcError | Sisk",
    "keywords": "Constructor JsonRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcError() public JsonRpcError() JsonRpcError(int, string) public JsonRpcError(int code, string message) Parameters code int message string JsonRpcError(int, string, JsonValue) public JsonRpcError(int code, string message, JsonValue data) Parameters code int message string data JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcError.Code.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Code.html",
    "title": "Property Code | Sisk",
    "keywords": "Property Code Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Code public int Code { get; } Property Value int"
  },
  "api/Sisk.JsonRPC.JsonRpcError.Data.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Data.html",
    "title": "Property Data | Sisk",
    "keywords": "Property Data Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Data public JsonValue Data { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcError.Message.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.Message.html",
    "title": "Property Message | Sisk",
    "keywords": "Property Message Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Message public string Message { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcError.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcError.html",
    "title": "Struct JsonRpcError | Sisk",
    "keywords": "Struct JsonRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public readonly struct JsonRpcError Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Constructors JsonRpcError() JsonRpcError(int, string) JsonRpcError(int, string, JsonValue) Properties Code Data Message"
  },
  "api/Sisk.JsonRPC.JsonRpcException.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.-ctor.html",
    "title": "Constructor JsonRpcException | Sisk",
    "keywords": "Constructor JsonRpcException Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcException(string) public JsonRpcException(string message) Parameters message string JsonRpcException(string, int, object?) public JsonRpcException(string message, int code, object? data) Parameters message string code int data object"
  },
  "api/Sisk.JsonRPC.JsonRpcException.AsRpcError.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.AsRpcError.html",
    "title": "Method AsRpcError | Sisk",
    "keywords": "Method AsRpcError Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AsRpcError() public JsonRpcError AsRpcError() Returns JsonRpcError"
  },
  "api/Sisk.JsonRPC.JsonRpcException.Code.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.Code.html",
    "title": "Property Code | Sisk",
    "keywords": "Property Code Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Code public int Code { get; } Property Value int"
  },
  "api/Sisk.JsonRPC.JsonRpcException.Data.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.Data.html",
    "title": "Property Data | Sisk",
    "keywords": "Property Data Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Data public object? Data { get; } Property Value object"
  },
  "api/Sisk.JsonRPC.JsonRpcException.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcException.html",
    "title": "Class JsonRpcException | Sisk",
    "keywords": "Class JsonRpcException Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public class JsonRpcException : Exception, ISerializable Inheritance object Exception JsonRpcException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.ToString() Exception.GetType() Exception.TargetSite Exception.Message Exception.InnerException Exception.HelpLink Exception.Source Exception.HResult Exception.StackTrace Exception.SerializeObjectState object.MemberwiseClone() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcException(string) JsonRpcException(string, int, object?) Properties Code Data Methods AsRpcError()"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.-ctor.html",
    "title": "Constructor JsonRpcHandler | Sisk",
    "keywords": "Constructor JsonRpcHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcHandler(HttpServer) public JsonRpcHandler(HttpServer parentServer) Parameters parentServer HttpServer"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.GetDocumentation.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.GetDocumentation.html",
    "title": "Method GetDocumentation | Sisk",
    "keywords": "Method GetDocumentation Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll GetDocumentation() public JsonRpcDocumentation GetDocumentation() Returns JsonRpcDocumentation GetDocumentation(JsonRpcDocumentationMetadata) public JsonRpcDocumentation GetDocumentation(JsonRpcDocumentationMetadata metadata) Parameters metadata JsonRpcDocumentationMetadata Returns JsonRpcDocumentation"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.JsonSerializerOptions.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.JsonSerializerOptions.html",
    "title": "Property JsonSerializerOptions | Sisk",
    "keywords": "Property JsonSerializerOptions Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonSerializerOptions public JsonOptions JsonSerializerOptions { get; } Property Value JsonOptions"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.Methods.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.Methods.html",
    "title": "Property Methods | Sisk",
    "keywords": "Property Methods Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Methods public JsonRpcMethodCollection Methods { get; } Property Value JsonRpcMethodCollection"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.Transport.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.Transport.html",
    "title": "Property Transport | Sisk",
    "keywords": "Property Transport Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Transport public JsonRpcTransportLayer Transport { get; } Property Value JsonRpcTransportLayer"
  },
  "api/Sisk.JsonRPC.JsonRpcHandler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcHandler.html",
    "title": "Class JsonRpcHandler | Sisk",
    "keywords": "Class JsonRpcHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcHandler Inheritance object JsonRpcHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcHandler(HttpServer) Properties JsonSerializerOptions Methods Transport Methods GetDocumentation() GetDocumentation(JsonRpcDocumentationMetadata)"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.-ctor.html",
    "title": "Constructor JsonRpcMethodCollection | Sisk",
    "keywords": "Constructor JsonRpcMethodCollection Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcMethodCollection() public JsonRpcMethodCollection()"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethod.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethod.html",
    "title": "Method AddMethod | Sisk",
    "keywords": "Method AddMethod Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AddMethod(string, Delegate) public void AddMethod(string name, Delegate method) Parameters name string method Delegate"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethodsFromType.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.AddMethodsFromType.html",
    "title": "Method AddMethodsFromType | Sisk",
    "keywords": "Method AddMethodsFromType Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll AddMethodsFromType<T>(T, bool) public void AddMethodsFromType<T>(T target, bool prefixTypes = false) where T : notnull Parameters target T prefixTypes bool Type Parameters T AddMethodsFromType(Type, object?, bool) public void AddMethodsFromType(Type type, object? target, bool prefixTypes) Parameters type Type target object prefixTypes bool AddMethodsFromType(Type, object?) public void AddMethodsFromType(Type type, object? target) Parameters type Type target object AddMethodsFromType(Type) public void AddMethodsFromType(Type type) Parameters type Type"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.RemoveMethod.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.RemoveMethod.html",
    "title": "Method RemoveMethod | Sisk",
    "keywords": "Method RemoveMethod Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll RemoveMethod(string) public void RemoveMethod(string name) Parameters name string"
  },
  "api/Sisk.JsonRPC.JsonRpcMethodCollection.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcMethodCollection.html",
    "title": "Class JsonRpcMethodCollection | Sisk",
    "keywords": "Class JsonRpcMethodCollection Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcMethodCollection Inheritance object JsonRpcMethodCollection Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcMethodCollection() Methods AddMethod(string, Delegate) AddMethodsFromType(Type) AddMethodsFromType(Type, object?) AddMethodsFromType(Type, object?, bool) AddMethodsFromType<T>(T, bool) RemoveMethod(string)"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Id.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Id.html",
    "title": "Property Id | Sisk",
    "keywords": "Property Id Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Id public JsonValue Id { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Method.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Method.html",
    "title": "Property Method | Sisk",
    "keywords": "Property Method Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Method public string Method { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Parameters.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Parameters.html",
    "title": "Property Parameters | Sisk",
    "keywords": "Property Parameters Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Parameters public JsonValue Parameters { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.Version.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.Version.html",
    "title": "Property Version | Sisk",
    "keywords": "Property Version Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Version public string Version { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcRequest.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcRequest.html",
    "title": "Class JsonRpcRequest | Sisk",
    "keywords": "Class JsonRpcRequest Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcRequest Inheritance object JsonRpcRequest Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Id Method Parameters Version"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.CreateErrorResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.CreateErrorResponse.html",
    "title": "Method CreateErrorResponse | Sisk",
    "keywords": "Method CreateErrorResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll CreateErrorResponse(JsonValue, JsonRpcError) public static JsonRpcResponse CreateErrorResponse(JsonValue id, JsonRpcError error) Parameters id JsonValue error JsonRpcError Returns JsonRpcResponse"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.CreateSuccessResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.CreateSuccessResponse.html",
    "title": "Method CreateSuccessResponse | Sisk",
    "keywords": "Method CreateSuccessResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll CreateSuccessResponse(JsonValue, JsonValue) public static JsonRpcResponse CreateSuccessResponse(JsonValue id, JsonValue result) Parameters id JsonValue result JsonValue Returns JsonRpcResponse"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Error.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Error.html",
    "title": "Property Error | Sisk",
    "keywords": "Property Error Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Error public JsonRpcError? Error { get; } Property Value JsonRpcError?"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Id.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Id.html",
    "title": "Property Id | Sisk",
    "keywords": "Property Id Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Id public JsonValue Id { get; } Property Value JsonValue"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Result.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Result.html",
    "title": "Property Result | Sisk",
    "keywords": "Property Result Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Result public JsonValue? Result { get; } Property Value JsonValue?"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.Version.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.Version.html",
    "title": "Property Version | Sisk",
    "keywords": "Property Version Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Version public string Version { get; } Property Value string"
  },
  "api/Sisk.JsonRPC.JsonRpcResponse.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcResponse.html",
    "title": "Class JsonRpcResponse | Sisk",
    "keywords": "Class JsonRpcResponse Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcResponse Inheritance object JsonRpcResponse Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Error Id Result Version Methods CreateErrorResponse(JsonValue, JsonRpcError) CreateSuccessResponse(JsonValue, JsonValue)"
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Handler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Handler.html",
    "title": "Property Handler | Sisk",
    "keywords": "Property Handler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Handler public JsonRpcHandler Handler { get; } Property Value JsonRpcHandler"
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Router.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.Router.html",
    "title": "Property Router | Sisk",
    "keywords": "Property Router Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll Router public Router Router { get; } Property Value Router"
  },
  "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerConfigurationEventArgs.html",
    "title": "Class JsonRpcServerConfigurationEventArgs | Sisk",
    "keywords": "Class JsonRpcServerConfigurationEventArgs Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcServerConfigurationEventArgs : EventArgs Inheritance object EventArgs JsonRpcServerConfigurationEventArgs Inherited Members EventArgs.Empty object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties Handler Router"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.-ctor.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.-ctor.html",
    "title": "Constructor JsonRpcServerHandler | Sisk",
    "keywords": "Constructor JsonRpcServerHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll JsonRpcServerHandler() public JsonRpcServerHandler()"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.ConfigureAction.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.ConfigureAction.html",
    "title": "Event ConfigureAction | Sisk",
    "keywords": "Event ConfigureAction Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public event EventHandler<JsonRpcServerConfigurationEventArgs>? ConfigureAction Returns EventHandler<JsonRpcServerConfigurationEventArgs>"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.OnServerStarting.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.OnServerStarting.html",
    "title": "Method OnServerStarting | Sisk",
    "keywords": "Method OnServerStarting Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. protected override void OnServerStarting(HttpServer server) Parameters server HttpServer The HTTP server entity which is starting."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.OnSetupRouter.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.OnSetupRouter.html",
    "title": "Method OnSetupRouter | Sisk",
    "keywords": "Method OnSetupRouter Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. protected override void OnSetupRouter(Router router) Parameters router Router The router entity which is binded."
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandler.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandler.html",
    "title": "Class JsonRpcServerHandler | Sisk",
    "keywords": "Class JsonRpcServerHandler Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcServerHandler : HttpServerHandler Inheritance object HttpServerHandler JsonRpcServerHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors JsonRpcServerHandler() Methods OnServerStarting(HttpServer) Event that is called immediately before starting the HttpServer. OnSetupRouter(Router) Event that is called when an Router is binded to the HTTP server. Events ConfigureAction"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.UseJsonRPC.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.UseJsonRPC.html",
    "title": "Method UseJsonRPC | Sisk",
    "keywords": "Method UseJsonRPC Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll UseJsonRPC(HttpServerHostContextBuilder, EventHandler<JsonRpcServerConfigurationEventArgs>) public static HttpServerHostContextBuilder UseJsonRPC(this HttpServerHostContextBuilder builder, EventHandler<JsonRpcServerConfigurationEventArgs> configure) Parameters builder HttpServerHostContextBuilder configure EventHandler<JsonRpcServerConfigurationEventArgs> Returns HttpServerHostContextBuilder"
  },
  "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcServerHandlerExtensions.html",
    "title": "Class JsonRpcServerHandlerExtensions | Sisk",
    "keywords": "Class JsonRpcServerHandlerExtensions Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public static class JsonRpcServerHandlerExtensions Inheritance object JsonRpcServerHandlerExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods UseJsonRPC(HttpServerHostContextBuilder, EventHandler<JsonRpcServerConfigurationEventArgs>)"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpGet.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpGet.html",
    "title": "Property HttpGet | Sisk",
    "keywords": "Property HttpGet Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll HttpGet public RouteAction HttpGet { get; } Property Value RouteAction"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpPost.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.HttpPost.html",
    "title": "Property HttpPost | Sisk",
    "keywords": "Property HttpPost Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll HttpPost public RouteAction HttpPost { get; } Property Value RouteAction"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.WebSocket.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.WebSocket.html",
    "title": "Property WebSocket | Sisk",
    "keywords": "Property WebSocket Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll WebSocket public WebSocketMessageReceivedEventHandler WebSocket { get; } Property Value WebSocketMessageReceivedEventHandler"
  },
  "api/Sisk.JsonRPC.JsonRpcTransportLayer.html": {
    "href": "api/Sisk.JsonRPC.JsonRpcTransportLayer.html",
    "title": "Class JsonRpcTransportLayer | Sisk",
    "keywords": "Class JsonRpcTransportLayer Namespace Sisk.JsonRPC Assembly Sisk.JsonRPC.dll public sealed class JsonRpcTransportLayer Inheritance object JsonRpcTransportLayer Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Properties HttpGet HttpPost WebSocket"
  },
  "api/Sisk.JsonRPC.html": {
    "href": "api/Sisk.JsonRPC.html",
    "title": "Namespace Sisk.JsonRPC | Sisk",
    "keywords": "Namespace Sisk.JsonRPC Namespaces Sisk.JsonRPC.Annotations Sisk.JsonRPC.Documentation Classes JsonRpcException JsonRpcHandler JsonRpcMethodCollection JsonRpcRequest JsonRpcResponse JsonRpcServerConfigurationEventArgs JsonRpcServerHandler JsonRpcServerHandlerExtensions JsonRpcTransportLayer Structs JsonRpcError"
  },
  "api/Sisk.Ssl.CertificateUtil.CreateDevelopmentCertificate.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.CreateDevelopmentCertificate.html",
    "title": "Method CreateDevelopmentCertificate | Sisk",
    "keywords": "Method CreateDevelopmentCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CreateDevelopmentCertificate(string[]) Creates a self-signed certificate for the specified DNS names. public static X509Certificate2 CreateDevelopmentCertificate(string[] dnsNames) Parameters dnsNames string[] The certificate DNS names. Returns X509Certificate2"
  },
  "api/Sisk.Ssl.CertificateUtil.CreateTrustedDevelopmentCertificate.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.CreateTrustedDevelopmentCertificate.html",
    "title": "Method CreateTrustedDevelopmentCertificate | Sisk",
    "keywords": "Method CreateTrustedDevelopmentCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CreateTrustedDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names and adds them to the local user's certificate store. public static X509Certificate2 CreateTrustedDevelopmentCertificate(params string[] dnsNames) Parameters dnsNames string[] The certificate DNS names. Returns X509Certificate2"
  },
  "api/Sisk.Ssl.CertificateUtil.html": {
    "href": "api/Sisk.Ssl.CertificateUtil.html",
    "title": "Class CertificateUtil | Sisk",
    "keywords": "Class CertificateUtil Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides a set of useful functions to issue development certificates for the SslProxy. public static class CertificateUtil Inheritance object CertificateUtil Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods CreateDevelopmentCertificate(string[]) Creates a self-signed certificate for the specified DNS names. CreateTrustedDevelopmentCertificate(params string[]) Creates a self-signed certificate for the specified DNS names and adds them to the local user's certificate store."
  },
  "api/Sisk.Ssl.SslProxy.-ctor.html": {
    "href": "api/Sisk.Ssl.SslProxy.-ctor.html",
    "title": "Constructor SslProxy | Sisk",
    "keywords": "Constructor SslProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SslProxy(int, X509Certificate, IPEndPoint) Initializes a new instance of the SslProxy class. public SslProxy(int sslListeningPort, X509Certificate certificate, IPEndPoint remoteEndpoint) Parameters sslListeningPort int The port number on which the proxy server listens for incoming connections. certificate X509Certificate The SSL/TLS certificate used by the proxy server. remoteEndpoint IPEndPoint The remote endpoint to which the proxy server forwards traffic."
  },
  "api/Sisk.Ssl.SslProxy.AllowedProtocols.html": {
    "href": "api/Sisk.Ssl.SslProxy.AllowedProtocols.html",
    "title": "Property AllowedProtocols | Sisk",
    "keywords": "Property AllowedProtocols Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. public SslProtocols AllowedProtocols { get; set; } Property Value SslProtocols"
  },
  "api/Sisk.Ssl.SslProxy.CheckCertificateRevocation.html": {
    "href": "api/Sisk.Ssl.SslProxy.CheckCertificateRevocation.html",
    "title": "Property CheckCertificateRevocation | Sisk",
    "keywords": "Property CheckCertificateRevocation Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. public bool CheckCertificateRevocation { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.ClientCertificateRequired.html": {
    "href": "api/Sisk.Ssl.SslProxy.ClientCertificateRequired.html",
    "title": "Property ClientCertificateRequired | Sisk",
    "keywords": "Property ClientCertificateRequired Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. public bool ClientCertificateRequired { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.Dispose.html": {
    "href": "api/Sisk.Ssl.SslProxy.Dispose.html",
    "title": "Method Dispose | Sisk",
    "keywords": "Method Dispose Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Dispose() public void Dispose()"
  },
  "api/Sisk.Ssl.SslProxy.GatewayEndpoint.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayEndpoint.html",
    "title": "Property GatewayEndpoint | Sisk",
    "keywords": "Property GatewayEndpoint Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayEndpoint Gets the proxy endpoint. public IPEndPoint GatewayEndpoint { get; } Property Value IPEndPoint"
  },
  "api/Sisk.Ssl.SslProxy.GatewayHostname.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayHostname.html",
    "title": "Property GatewayHostname | Sisk",
    "keywords": "Property GatewayHostname Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayHostname Gets or sets an fixed proxy host header value for incoming requests. public string? GatewayHostname { get; set; } Property Value string"
  },
  "api/Sisk.Ssl.SslProxy.GatewayTimeout.html": {
    "href": "api/Sisk.Ssl.SslProxy.GatewayTimeout.html",
    "title": "Property GatewayTimeout | Sisk",
    "keywords": "Property GatewayTimeout Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll GatewayTimeout Gets or sets the maximum time that the gateway should take to respond to a connection or message from the proxy. public TimeSpan GatewayTimeout { get; set; } Property Value TimeSpan"
  },
  "api/Sisk.Ssl.SslProxy.KeepAliveEnabled.html": {
    "href": "api/Sisk.Ssl.SslProxy.KeepAliveEnabled.html",
    "title": "Property KeepAliveEnabled | Sisk",
    "keywords": "Property KeepAliveEnabled Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll KeepAliveEnabled Gets or sets whether keep-alive connections should be used. public bool KeepAliveEnabled { get; set; } Property Value bool"
  },
  "api/Sisk.Ssl.SslProxy.MaxOpenConnections.html": {
    "href": "api/Sisk.Ssl.SslProxy.MaxOpenConnections.html",
    "title": "Property MaxOpenConnections | Sisk",
    "keywords": "Property MaxOpenConnections Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll MaxOpenConnections Gets or sets the maximum of open TCP connections this SslProxy can mantain open at the same time. public int MaxOpenConnections { get; set; } Property Value int"
  },
  "api/Sisk.Ssl.SslProxy.ProxyAuthorization.html": {
    "href": "api/Sisk.Ssl.SslProxy.ProxyAuthorization.html",
    "title": "Property ProxyAuthorization | Sisk",
    "keywords": "Property ProxyAuthorization Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ProxyAuthorization Gets or sets the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. public string? ProxyAuthorization { get; set; } Property Value string"
  },
  "api/Sisk.Ssl.SslProxy.ServerCertificate.html": {
    "href": "api/Sisk.Ssl.SslProxy.ServerCertificate.html",
    "title": "Property ServerCertificate | Sisk",
    "keywords": "Property ServerCertificate Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll ServerCertificate Gets the SSL certificate used by the proxy server. public X509Certificate ServerCertificate { get; } Property Value X509Certificate"
  },
  "api/Sisk.Ssl.SslProxy.Start.html": {
    "href": "api/Sisk.Ssl.SslProxy.Start.html",
    "title": "Method Start | Sisk",
    "keywords": "Method Start Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Start() Starts the SslProxy and start routing traffic to the set remote endpoint. public void Start()"
  },
  "api/Sisk.Ssl.SslProxy.html": {
    "href": "api/Sisk.Ssl.SslProxy.html",
    "title": "Class SslProxy | Sisk",
    "keywords": "Class SslProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Represents a HTTP/1.1 proxy server that forwards traffic over SSL/HTTPS into an insecure HTTP gateway. public sealed class SslProxy : IDisposable Inheritance object SslProxy Implements IDisposable Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SslProxy(int, X509Certificate, IPEndPoint) Initializes a new instance of the SslProxy class. Properties AllowedProtocols Gets or sets the SSL/HTTPS protocols allowed for connections. CheckCertificateRevocation Gets or sets a value indicating whether to check for certificate revocation. ClientCertificateRequired Gets or sets a value indicating whether client certificates are required for authentication. GatewayEndpoint Gets the proxy endpoint. GatewayHostname Gets or sets an fixed proxy host header value for incoming requests. GatewayTimeout Gets or sets the maximum time that the gateway should take to respond to a connection or message from the proxy. KeepAliveEnabled Gets or sets whether keep-alive connections should be used. MaxOpenConnections Gets or sets the maximum of open TCP connections this SslProxy can mantain open at the same time. ProxyAuthorization Gets or sets the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. ServerCertificate Gets the SSL certificate used by the proxy server. Methods Dispose() Start() Starts the SslProxy and start routing traffic to the set remote endpoint."
  },
  "api/Sisk.Ssl.SslProxyExtensions.UseSsl.html": {
    "href": "api/Sisk.Ssl.SslProxyExtensions.UseSsl.html",
    "title": "Method UseSsl | Sisk",
    "keywords": "Method UseSsl Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll UseSsl(HttpServerHostContextBuilder, short, X509Certificate?, SslProtocols, bool, object?, bool) Configures the HttpServerHostContext to use SslProxy with the specified parameters. public static HttpServerHostContextBuilder UseSsl(this HttpServerHostContextBuilder builder, short sslListeningPort, X509Certificate? certificate = null, SslProtocols allowedProtocols = SslProtocols.Tls12 | SslProtocols.Tls13, bool clientCertificateRequired = false, object? proxyAuthorization = null, bool onlyUseIPv4 = false) Parameters builder HttpServerHostContextBuilder The HttpServerHostContextBuilder instance to configure. sslListeningPort short The port number on which the server will listen for SSL/HTTPS connections. certificate X509Certificate Optional. The SSL/HTTPS certificate to use for encrypting communications. allowedProtocols SslProtocols Optional. The SSL/HTTPS protocols allowed for the connection. Defaults to Tls12 and Tls13. clientCertificateRequired bool Optional. Specifies whether a client certificate is required for authentication. Defaults to false. proxyAuthorization object Optional. Specifies the Proxy-Authorization header value for creating an trusted gateway between the application and the proxy. onlyUseIPv4 bool Optional. Specifies whether DNS Resolve may also use IPv6 addresses or should only use IPv4 addresses Returns HttpServerHostContextBuilder The configured HttpServerHostContextBuilder instance."
  },
  "api/Sisk.Ssl.SslProxyExtensions.html": {
    "href": "api/Sisk.Ssl.SslProxyExtensions.html",
    "title": "Class SslProxyExtensions | Sisk",
    "keywords": "Class SslProxyExtensions Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides extension methods for SslProxy. public static class SslProxyExtensions Inheritance object SslProxyExtensions Inherited Members object.GetType() object.MemberwiseClone() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Methods UseSsl(HttpServerHostContextBuilder, short, X509Certificate?, SslProtocols, bool, object?, bool) Configures the HttpServerHostContext to use SslProxy with the specified parameters."
  },
  "api/Sisk.Ssl.SslProxyServerHandler.-ctor.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.-ctor.html",
    "title": "Constructor SslProxyServerHandler | Sisk",
    "keywords": "Constructor SslProxyServerHandler Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SslProxyServerHandler(SslProxy) Creates an new SslProxyServerHandler instance with the specified SslProxy instance. public SslProxyServerHandler(SslProxy secureProxy) Parameters secureProxy SslProxy The SslProxy instance."
  },
  "api/Sisk.Ssl.SslProxyServerHandler.SecureProxy.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.SecureProxy.html",
    "title": "Property SecureProxy | Sisk",
    "keywords": "Property SecureProxy Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll SecureProxy Gets the SslProxy instance used in this server handler. public SslProxy SecureProxy { get; } Property Value SslProxy"
  },
  "api/Sisk.Ssl.SslProxyServerHandler.html": {
    "href": "api/Sisk.Ssl.SslProxyServerHandler.html",
    "title": "Class SslProxyServerHandler | Sisk",
    "keywords": "Class SslProxyServerHandler Namespace Sisk.Ssl Assembly Sisk.SslProxy.dll Provides event handlers and hooks for SslProxy. public sealed class SslProxyServerHandler : HttpServerHandler Inheritance object HttpServerHandler SslProxyServerHandler Inherited Members object.GetType() object.ToString() object.Equals(object) object.Equals(object, object) object.ReferenceEquals(object, object) object.GetHashCode() Constructors SslProxyServerHandler(SslProxy) Creates an new SslProxyServerHandler instance with the specified SslProxy instance. Properties SecureProxy Gets the SslProxy instance used in this server handler."
  },
  "api/Sisk.Ssl.html": {
    "href": "api/Sisk.Ssl.html",
    "title": "Namespace Sisk.Ssl | Sisk",
    "keywords": "Namespace Sisk.Ssl Classes CertificateUtil Provides a set of useful functions to issue development certificates for the SslProxy. SslProxy Represents a HTTP/1.1 proxy server that forwards traffic over SSL/HTTPS into an insecure HTTP gateway. SslProxyExtensions Provides extension methods for SslProxy. SslProxyServerHandler Provides event handlers and hooks for SslProxy."
  },
  "api/Sisk.html": {
    "href": "api/Sisk.html",
    "title": "Namespace Sisk | Sisk",
    "keywords": "Namespace Sisk Namespaces Sisk.BasicAuth Sisk.Core Sisk.IniConfiguration Sisk.JsonRPC Sisk.Ssl"
  },
  "docs/advanced/forwarding-resolvers.html": {
    "href": "docs/advanced/forwarding-resolvers.html",
    "title": "Forwarding Resolvers | Sisk",
    "keywords": "Forwarding Resolvers A Forwarding Resolver is a helper that helps decode information that identifies the client through a request, proxy, CDN or load-balancers. When your Sisk service runs through a reverse or forward proxy, the client's IP address, host and protocol may be different from the original request as it is a forwarding from one service to another. This Sisk functionality allows you to control and resolve this information before working with the request. These proxies usually provide useful headers to identify their client. Currently, with the ForwardingResolver class, it is possible to resolve the client IP address, host, and HTTP protocol used. After version 1.0 of Sisk, the server no longer has a standard implementation to decode these headers for security reasons that vary from service to service. For example, the X-Forwarded-For header includes information about the IP addresses that forwarded the request. This header is used by proxies to carry a chain of information to the final service and includes the IP of all proxies used, including the client's real address. The problem is: sometimes it is challenging to identify the client's remote IP and there is no specific rule to identify this header. It is highly recommended to read the documentation for the headers you are about to implement below: Read about the X-Forwarded-For header here. Read about the X-Forwarded-Host header here. Read about the X-Forwarded-Proto header here. The ForwardingResolver class This class has three virtual methods that allow the most appropriate implementation for each service. Each method is responsible for resolving information from the request through a proxy: the client's IP address, the host of the request and the security protocol used. By default, Sisk will always use the information from the original request, without resolving any headers. The example below shows how this implementation can be used. This example resolves the client's IP through the X-Forwarded-For header and throws an error when more than one IP was forwarded in the request. Important Do not use this example in production code. Always check if the implementation is appropriate for use. Read the header documentation before implementing it. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"The X-Forwarded-For header is missing.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Too many addresses in the X-Forwarded-For header.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/advanced/http-server-handlers.html": {
    "href": "docs/advanced/http-server-handlers.html",
    "title": "Http server handlers | Sisk",
    "keywords": "Http server handlers In Sisk version 0.16, we've introduced the HttpServerHandler class, which aims to extend the overral Sisk behavior and provide additional event handlers to Sisk, such as handling Http requests, routers, context bags and more. The class concentrates events that occur during the lifetime of the entire HTTP server and also of a request. The Http protocol does not have sessions, and therefore it is not possible to preserve information from one request to another. Sisk for now provides a way for you to implement sessions, contexts, database connections and other useful providers to help your work. Please refer to this page to read where each event is triggered and what its purpose is. You can also view the lifecycle of an HTTP request to understand what happens with a request and where events are fired. The HTTP server allows you to use multiple handlers at the same time. Each event call is synchronous, that is, it will blocked the current thread for each request or context until all handlers associated with that function are executed and completed. Unlike RequestHandlers, they cannot be applied to some route groups or specific routes. Instead, they are applied to the entire HTTP server. You can apply conditions within your Http Server Handler. Furthermore, singletons of each HttpServerHandler are defined for every Sisk application, so only one instance per HttpServerHandler is defined. A practical example of using HttpServerHandler is to automatically dispose a database connection at the end of the request. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // checks if the request has defined an DbContext // in it's context bag if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // allows the user to create an dbcontext from an http request // and store it in its request bag public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } With the code above, the GetDbContext extension allows a connection context to be created directly from the HttpRequest object. An undisposed connection can cause problems when running with the database, so it is terminated in OnHttpRequestClose. You can register a handler on an Http server in your builder or directly with HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } With this, the UsersController class can make use of the database context as: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } The code above uses methods like JsonOk and JsonMessage that are built into ApiController, which is inherited from a RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Developers can implement sessions, contexts, and database connections using this class. The provided code showcases a practical example with the DatabaseConnectionHandler, automating database connection disposal at the end of each request. Integration is straightforward, with handlers registered during server setup. The HttpServerHandler class offers a powerful toolset for managing resources and extending Sisk behavior in HTTP applications."
  },
  "docs/advanced/manual-setup.html": {
    "href": "docs/advanced/manual-setup.html",
    "title": "Manual (advanced) setup | Sisk",
    "keywords": "Manual (advanced) setup In this section, we will create our HTTP server without any predefined standards, in a completely abstract way. Here, you can manually build how your HTTP server will function. Each ListeningHost has a router, and an HTTP server can have multiple ListeningHosts, each pointing to a different host on a different port. First, we need to understand the request/response concept. It is quite simple: for every request, there must be a response. Sisk follows this principle as well. Let's create a method that responds with a \"Hello, World!\" message in HTML, specifying the status code and headers. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hello, world!</h1> </body> </html> \") }; return indexResponse; } The next step is to associate this method with an HTTP route. Routers Routers are abstractions of request routes and serve as the bridge between requests and responses for the service. Routers manage service routes, functions, and errors. A router can have several routes, and each route can perform different operations on that path, such as executing a function, serving a page, or providing a resource from the server. Let's create our first router and associate our IndexPage method with the index path. Router mainRouter = new Router(); // SetRoute will associate all index routes with our method. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Now our router can receive requests and send responses. However, mainRouter is not tied to a host or a server, so it will not work on its own. The next step is to create our ListeningHost. Listening Hosts and Ports A ListeningHost can host a router and multiple listening ports for the same router. A ListeningPort is a prefix where the HTTP server will listen. Here, we can create a ListeningHost that points to two endpoints for our router: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Now our HTTP server will listen to the specified endpoints and redirect its requests to our router. Server Configuration Server configuration is responsible for most of the behavior of the HTTP server itself. In this configuration, we can associate ListeningHosts with our server. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Add our ListeningHost to this server configuration Next, we can create our HTTP server: HttpServer server = new HttpServer(config); server.Start(); // Starts the server Console.ReadKey(); // Prevents the application from exiting Now we can compile our executable and run our HTTP server with the command: dotnet watch At runtime, open your browser and navigate to the server path, and you should see:"
  },
  "docs/advanced/multi-host-setup.html": {
    "href": "docs/advanced/multi-host-setup.html",
    "title": "Multiple listening hosts per server | Sisk",
    "keywords": "Multiple listening hosts per server The Sisk Framework has always supported the use of more than one host per server, that is, a single HTTP server can listen on multiple ports and each port has its own router and its own service running on it. This way, it is easy to separate responsibilities and manage services on a single HTTP server with Sisk. The example below shows the creation of two ListeningHosts, each listening to a different port, with different routers and actions. Read manually creating your app to understand the details about this abstraction. static void Main(string[] args) { // create two listening hosts, which each one has it's own router and // listens to it's own port // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hello from the host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hello from the host B!\")); // create an server configuration and adds both // listening hosts on it // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // creates an http server which uses the specified // configuration // HttpServer server = new HttpServer(configuration); // starts the server server.Start(); Console.WriteLine(\"Try to reach host A in {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Try to reach host B in {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/advanced/request-lifecycle.html": {
    "href": "docs/advanced/request-lifecycle.html",
    "title": "Request lifecycle | Sisk",
    "keywords": "Request lifecycle This diagram explains the life process of an HTTP request from the moment it arrives at the server until it is delivered to the client."
  },
  "docs/changelogs.html": {
    "href": "docs/changelogs.html",
    "title": "Changelogs | Sisk",
    "keywords": "Changelogs Every change made to Sisk is recorded through the changelog. You can view the changelogs for all Sisk versions here."
  },
  "docs/cn/advanced/forwarding-resolvers.html": {
    "href": "docs/cn/advanced/forwarding-resolvers.html",
    "title": "转发解析器 | Sisk",
    "keywords": "转发解析器 转发解析器是一个帮助器，帮助解码通过请求、代理、CDN 或负载均衡器识别客户端的信息。当您的 Sisk 服务运行通过反向或正向代理时，客户端的 IP 地址、主机和协议可能与原始请求不同，因为这是从一个服务到另一个服务的转发。这个 Sisk 功能允许您在处理请求之前控制和解析此信息。这些代理通常提供有用的头部来识别其客户端。 目前，使用 ForwardingResolver 类，可以解析客户端 IP 地址、主机和使用的 HTTP 协议。在 Sisk 1.0 版本之后，服务器不再有标准实现来解码这些头部，因为安全原因从服务到服务不同。 例如，X-Forwarded-For 头部包含有关转发请求的 IP 地址的信息。这个头部由代理使用，以携带一系列信息到最终服务，并包括所有使用的代理的 IP 地址，包括客户端的真实地址。问题是：有时很难识别客户端的远程 IP 地址，并且没有特定的规则来识别这个头部。强烈推荐阅读以下头部的文档： 阅读关于 X-Forwarded-For 头部的信息 这里。 阅读关于 X-Forwarded-Host 头部的信息 这里。 阅读关于 X-Forwarded-Proto 头部的信息 这里。 ForwardingResolver 类 这个类有三个虚拟方法，允许为每个服务实现最合适的解决方案。每个方法负责通过代理解析请求的信息：客户端的 IP 地址、请求的主机和使用的安全协议。默认情况下，Sisk 将始终使用原始请求的信息，而不解析任何头部。 下面的例子展示了如何使用这个实现。这个例子通过 X-Forwarded-For 头部解析客户端的 IP 地址，并在请求中转发多个 IP 地址时抛出错误。 Important 不要在生产代码中使用这个例子。始终检查实现是否适合使用。在实现之前阅读头部文档。 class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"X-Forwarded-For 头部缺失.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"X-Forwarded-For 头部中有太多地址.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/cn/advanced/http-server-handlers.html": {
    "href": "docs/cn/advanced/http-server-handlers.html",
    "title": "HTTP 服务器处理器 | Sisk",
    "keywords": "HTTP 服务器处理器 在 Sisk 0.16 版本中，我们引入了 HttpServerHandler 类，该类旨在扩展 Sisk 的整体行为，并为 Sisk 提供额外的事件处理程序，例如处理 HTTP 请求、路由器、上下文包等。 该类集中了整个 HTTP 服务器和请求的生命周期中发生的事件。HTTP 协议没有会话，因此无法在请求之间保留信息。Sisk 目前提供了一种方式，允许您实现会话、上下文、数据库连接和其他有用的提供程序，以帮助您的工作。 请参阅 此页面 以了解每个事件的触发位置和其目的。你也可以查看 HTTP 请求的生命周期 以了解请求发生了什么以及事件在哪里触发。HTTP 服务器允许你同时使用多个处理程序。每个事件调用都是同步的，即它将阻塞当前线程，直到与该函数关联的所有处理程序都执行并完成。 与 RequestHandlers 不同，它们不能应用于某些路由组或特定路由。相反，它们应用于整个 HTTP 服务器。你可以在你的 HTTP 服务器处理程序中应用条件。此外，每个 Sisk 应用程序都定义了每个 HttpServerHandler 的单例，因此每个 HttpServerHandler 只有一个实例。 使用 HttpServerHandler 的一个实用示例是自动在请求结束时释放数据库连接。 // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // 检查请求是否在其上下文包中定义了 DbContext if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // 允许用户从 HTTP 请求创建 DbContext 并将其存储在其请求包中 public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } 上面的代码中，GetDbContext 扩展方法允许直接从 HttpRequest 对象创建连接上下文并将其存储在其请求包中。未释放的连接可能会在运行数据库时引起问题，因此在 OnHttpRequestClose 中终止它。 你可以在你的构建器中或直接使用 HttpServer.RegisterHandler 注册处理程序到 HTTP 服务器。 // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } 这样，UsersController 类就可以使用数据库上下文： // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } 上面的代码使用了 ApiController 中的 JsonOk 和 JsonMessage 方法，该方法继承自 RouterController： // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } 开发人员可以使用此类实现会话、上下文和数据库连接。提供的代码展示了一个使用 DatabaseConnectionHandler 的实用示例，自动在每个请求结束时释放数据库连接。 集成非常简单，处理程序在服务器设置期间注册。HttpServerHandler 类提供了一个强大的工具集，用于在 HTTP 应用程序中管理资源和扩展 Sisk 行为。"
  },
  "docs/cn/advanced/manual-setup.html": {
    "href": "docs/cn/advanced/manual-setup.html",
    "title": "手动（高级）设置 | Sisk",
    "keywords": "手动（高级）设置 在本节中，我们将创建一个没有任何预定义标准的 HTTP 服务器，以完全抽象的方式。这里，您可以手动构建您的 HTTP 服务器的功能。每个 ListeningHost 都有一个路由器，一个 HTTP 服务器可以有多个 ListeningHost，每个 ListeningHost 指向不同的主机和端口。 首先，我们需要了解请求/响应概念。它非常简单：对于每个请求，必须有一个响应。Sisk 也遵循这个原则。让我们创建一个方法，响应一个“Hello, World！”消息，指定状态代码和头部。 // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hello, world!</h1> </body> </html> \") }; return indexResponse; } 下一步是将此方法与一个 HTTP 路由关联起来。 路由器 路由器是请求路由的抽象，作为服务的请求和响应之间的桥梁。路由器管理服务路由、函数和错误。 一个路由器可以有多个路由，每个路由可以在该路径上执行不同的操作，例如执行函数、提供页面或提供服务器资源。 让我们创建我们的第一个路由器，并将我们的 IndexPage 方法与索引路径关联起来。 Router mainRouter = new Router(); // SetRoute 将所有索引路由与我们的方法关联起来。 mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); 现在我们的路由器可以接收请求并发送响应。然而，mainRouter 不绑定到任何主机或服务器，因此它不能单独工作。下一步是创建我们的 ListeningHost。 Listening Hosts 和 Ports 一个 ListeningHost 可以托管一个路由器和多个监听端口，用于同一个路由器。一个 ListeningPort 是 HTTP 服务器将监听的前缀。 这里，我们可以创建一个 ListeningHost，它指向两个端点，用于我们的路由器： ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; 现在我们的 HTTP 服务器将监听指定的端点，并将其请求重定向到我们的路由器。 服务器配置 服务器配置负责大部分 HTTP 服务器自身的行为。在此配置中，我们可以将 ListeningHosts 关联到我们的服务器。 HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // 将我们的 ListeningHost 添加到此服务器配置 接下来，我们可以创建我们的 HTTP 服务器： HttpServer server = new HttpServer(config); server.Start(); // 启动服务器 Console.ReadKey(); // 防止应用程序退出 现在我们可以编译我们的可执行文件，并使用以下命令运行我们的 HTTP 服务器： dotnet watch 在运行时，打开您的浏览器，并导航到服务器路径，您应该会看到："
  },
  "docs/cn/advanced/multi-host-setup.html": {
    "href": "docs/cn/advanced/multi-host-setup.html",
    "title": "每个服务器多个监听主机 | Sisk",
    "keywords": "每个服务器多个监听主机 Sisk Framework一直支持在每个服务器上使用多个主机，即单个HTTP服务器可以监听多个端口，每个端口都有自己的路由器和服务运行在上面。 这样，使用Sisk就可以轻松地分离责任并管理单个HTTP服务器上的服务。下面的例子展示了创建两个ListeningHosts，每个监听不同的端口，具有不同的路由器和动作。 阅读手动创建您的应用以了解有关此抽象的详细信息。 static void Main(string[] args) { // 创建两个监听主机，每个都有自己的路由器和监听端口 // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"来自主机A的问候！\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"来自主机B的问候！\")); // 创建一个服务器配置并添加两个监听主机 // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // 创建一个使用指定配置的HTTP服务器 // HttpServer server = new HttpServer(configuration); // 启动服务器 server.Start(); Console.WriteLine(\"尝试访问主机A在 {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"尝试访问主机B在 {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/cn/advanced/request-lifecycle.html": {
    "href": "docs/cn/advanced/request-lifecycle.html",
    "title": "请求生命周期 | Sisk",
    "keywords": "请求生命周期 该图解释了HTTP请求从到达服务器的那一刻到被送达客户端的整个生命周期过程."
  },
  "docs/cn/changelogs.html": {
    "href": "docs/cn/changelogs.html",
    "title": "变更日志 | Sisk",
    "keywords": "变更日志 每对 Sisk 进行的更改都会通过变更日志记录。你可以在 这里 查看所有 Sisk 版本的变更日志。"
  },
  "docs/cn/deploying.html": {
    "href": "docs/cn/deploying.html",
    "title": "部署 Sisk 应用 | Sisk",
    "keywords": "部署 Sisk 应用 部署 Sisk 应用的过程包括将您的项目发布到生产环境中。虽然这个过程相对简单，但有一些细节需要注意，以避免对部署的基础设施造成安全和稳定性的问题。 理想情况下，在进行所有可能的测试后，您应该准备好将应用程序部署到云端。 发布您的应用 发布 Sisk 应用或服务是生成适合生产环境的二进制文件。在这个例子中，我们将编译二进制文件以便在安装了 .NET Runtime 的机器上运行。 您需要在机器上安装 .NET SDK 来构建应用程序，并在目标服务器上安装 .NET Runtime 来运行应用程序。您可以在 这里 学习如何在 Linux 服务器上安装 .NET Runtime，这里 学习如何在 Windows 上安装，这里 学习如何在 Mac OS 上安装。 在项目所在的文件夹中，打开终端并使用 .NET 发布命令： $ dotnet publish -r linux-x64 -c Release 这将在 bin/Release/publish/linux-x64 中生成二进制文件。 Note 如果您的应用程序使用 Sisk.ServiceProvider 包，您应该将 service-config.json 文件复制到主机服务器中，连同 dotnet publish 生成的所有二进制文件。 您可以预先配置文件，包括环境变量、监听端口和主机，以及其他服务器配置。 下一步是将这些文件传输到将要托管应用程序的服务器。 之后，给二进制文件授予执行权限。假设我们的项目名称是 \"my-app\"： $ cd /home/htdocs $ chmod +x my-app $ ./my-app 运行应用程序后，检查是否有任何错误消息。如果没有产生错误消息，那么您的应用程序正在运行。 此时，应用程序可能无法从外部网络访问，因为尚未配置访问规则，例如防火墙。我们将在下一步中考虑这一点。 您应该有应用程序监听的虚拟主机地址。这是手动在应用程序中设置的，并取决于您如何实例化 Sisk 服务。 如果您 不 使用 Sisk.ServiceProvider 包，您应该在定义 HttpServer 实例的地方找到它： HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk 应该监听 http://localhost:5000/ 手动关联 ListeningHost： config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); 或者，如果您使用 Sisk.ServiceProvider 包，在您的 service-config.json 中： { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } 从这里，我们可以创建一个反向代理来监听您的服务并使流量在开放网络上可用。 代理您的应用 代理您的服务意味着不直接将 Sisk 服务暴露在外部网络中。这是一种常见的服务器部署做法，因为： 允许您在应用程序中关联 SSL 证书； 创建访问规则以避免过载； 控制带宽和请求限制； 为您的应用程序分离负载均衡器； 防止基础设施故障造成的安全损害。 您可以通过反向代理服务器，如 Nginx 或 Apache，或使用 HTTP-over-DNS 隧道，如 Cloudflared，来提供您的应用程序。 另外，请记得正确解析代理的转发头，以便通过 转发解析器 获取客户端信息，例如 IP 地址和主机。 创建隧道、配置防火墙并运行应用程序后，下一步是为您的应用程序创建一个服务。 Note 在非 Windows 系统上，直接在 Sisk 服务中使用 SSL 证书是不可能的。这是 HttpListener 的实现方式，这是 Sisk 中 HTTP 队列管理的核心模块，这种实现方式在操作系统之间有所不同。如果您 将证书与 IIS 中的虚拟主机关联，则可以在 Sisk 服务中使用 SSL。对于其他系统，强烈推荐使用反向代理。 创建服务 创建服务将使您的应用程序始终可用，即使在服务器实例重启或发生不可恢复的崩溃后。 在这个简单的教程中，我们将使用前一个教程的内容作为示例，以保持服务始终活跃。 访问服务配置文件所在的文件夹： cd /etc/systemd/system 创建您的 my-app.service 文件并包含以下内容： my-app.service INI [Unit] Description=<description about your app> [Service] # 设置将启动服务的用户 User=<user which will launch the service> # ExecStart 路径不是相对于 WorkingDirectory 的。 # 将其设置为可执行文件的完整路径 WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # 设置服务在崩溃后始终重启 Restart=always RestartSec=3 [Install] WantedBy=multi-user.target 重启服务管理器模块： $ sudo systemctl daemon-reload 从文件名启动新创建的服务并检查是否正在运行： $ sudo systemctl start my-app $ sudo systemctl status my-app 现在，如果您的应用程序正在运行 (\"Active: active\")，请启用服务以便在系统重启后继续运行： $ sudo systemctl enable my-app 现在，您已经准备好向所有人展示您的 Sisk 应用。"
  },
  "docs/cn/extensions/basic-auth.html": {
    "href": "docs/cn/extensions/basic-auth.html",
    "title": "基本身份验证 | Sisk",
    "keywords": "基本身份验证 基本身份验证包添加了一个请求处理程序，能够处理基本身份验证方案，并且只需进行很少的配置和努力即可在您的 Sisk 应用程序中使用。 基本 HTTP 身份验证是一种最小的输入形式，通过用户 ID 和密码对请求进行身份验证，会话完全由客户端控制，并且没有身份验证或访问令牌。 更多关于基本身份验证方案的信息，请参阅 MDN 规范。 安装 要开始使用，请在您的项目中安装 Sisk.BasicAuth 包： > dotnet add package Sisk.BasicAuth 您可以在 Nuget 存储库 中查看更多关于如何在您的项目中安装它的信息。 创建身份验证处理程序 您可以控制整个模块或个别路由的身份验证方案。为此，让我们首先编写第一个基本身份验证处理程序。 在以下示例中，连接到数据库，检查用户是否存在以及密码是否有效，然后将用户存储在上下文包中。 public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"要进入此页面，请提供您的凭据。\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // 在这种情况下，我们使用电子邮件作为用户 ID 字段，因此我们将使用电子邮件查找用户。 User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"抱歉！没有找到此电子邮件的用户。\"); } // 验证此用户的凭据密码是否有效。 if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"无效的凭据。\"); } // 将已登录的用户添加到 HTTP 上下文中 // 并继续执行 context.Bag.Add(\"loggedUser\", user); return null; } } 因此，只需将此请求处理程序与我们的路由或类关联即可。 public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"您好，\" + loggedUser.Name + \"!\"; } } 或者使用 RouterModule 类： public class UsersController : RouterModule { public ClientModule() { // 现在此类中的所有路由都将由 UserAuthHandler 处理。 base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"您好，\" + loggedUser.Name + \"!\"; } } 备注 基本身份验证的主要责任由客户端承担。存储、缓存控制和加密都在客户端本地处理。服务器只接收凭据并验证是否允许访问。 请注意，此方法不是最安全的，因为它将大量责任放在客户端上，客户端可能难以跟踪和维护其凭据的安全性。另外，密码必须在安全连接上下文（SSL）中传输，因为它们没有内置加密。请求头的简短拦截可能会暴露用户的访问凭据。 对于生产环境中的应用程序，请选择更强大的身份验证解决方案，并避免使用太多现成的组件，因为它们可能无法适应项目的需求，最终会使其暴露于安全风险之中。"
  },
  "docs/cn/extensions/ini-configuration.html": {
    "href": "docs/cn/extensions/ini-configuration.html",
    "title": "INI 配置提供程序 | Sisk",
    "keywords": "INI 配置提供程序 Sisk 有一种方法可以获取启动配置，而不仅仅是 JSON。事实上，任何实现 IConfigurationReader 的管道都可以与 PortableConfigurationBuilder.WithConfigurationPipeline一起使用，从任何文件类型中读取服务器配置。 Sisk.IniConfiguration 包提供了一个基于流的 INI 文件读取器，它不会为常见的语法错误抛出异常，并且具有简单的配置语法。这个包可以在 Sisk 框架之外使用，为需要高效 INI 文档读取器的项目提供了灵活性。 安装 要安装包，可以从以下开始： $ dotnet add package Sisk.IniConfiguration 你也可以安装核心包，它不包括 INI IConfigurationReader，也不包括 Sisk 依赖项，只包括 INI 序列化器： $ dotnet add package Sisk.IniConfiguration.Core 使用主包，你可以在代码中使用它，如下面的示例所示： class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // 使用 IniConfigurationReader 配置读取器 config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } 上面的代码将在进程的当前目录（CurrentDirectory）中查找一个 app.ini 文件。INI 文件的内容如下： [Server] # 支持多个监听地址 Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI 风格和语法 当前实现风格： 属性和节名是 大小写不敏感 的。 属性名和值是 修剪 的，除非值被引号括起来。 值可以用单引号或双引号括起来。引号内可以包含换行符。 支持使用 # 和 ; 的注释。尾随注释也是允许的。 属性可以有多个值。 详细信息，Sisk 中使用的 INI 解析器的“风格”文档可以在 这里 找到。 使用以下 INI 代码作为示例： One = 1 Value = 这是一个值 Another value = \"这个值 有一个换行符\" ; 下面的代码有一些颜色 [some section] Color = Red Color = Blue Color = Yellow ; 不要使用黄色 解析它： // 从字符串解析 INI 文本 IniDocument doc = IniDocument.FromString(iniText); // 获取一个值 string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // 获取多个值 string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); 配置参数 节和名称 允许多个值 描述 Server.Listen 是 服务器监听地址/端口。 Server.Encoding 否 服务器默认编码。 Server.MaximumContentLength 否 服务器最大内容长度（以字节为单位）。 Server.IncludeRequestIdHeader 否 指定是否应发送 X-Request-Id 标头。 Server.ThrowExceptions 否 指定是否应抛出未处理的异常。 Server.AccessLogsStream 否 指定访问日志输出流。 Server.ErrorsLogsStream 否 指定错误日志输出流。 Cors.AllowMethods 否 指定 CORS Allow-Methods 标头值。 Cors.AllowHeaders 否 指定 CORS Allow-Headers 标头值。 Cors.AllowOrigins 否 指定多个 Allow-Origin 标头，逗号分隔。AllowOrigins 有更多信息。 Cors.AllowOrigin 否 指定一个 Allow-Origin 标头。 Cors.ExposeHeaders 否 指定 CORS Expose-Headers 标头值。 Cors.AllowCredentials 否 指定 CORS Allow-Credentials 标头值。 Cors.MaxAge 否 指定 CORS Max-Age 标头值。"
  },
  "docs/cn/extensions/json-rpc.html": {
    "href": "docs/cn/extensions/json-rpc.html",
    "title": "JSON-RPC 扩展 | Sisk",
    "keywords": "JSON-RPC 扩展 Sisk 有一个实验性的 JSON-RPC 2.0 API 模块，允许您创建更简单的应用程序。该扩展严格实现了 JSON-RPC 2.0 传输接口，并提供通过 HTTP GET、POST 请求和 WebSockets 的传输。 您可以通过 Nuget 安装该扩展，使用以下命令。请注意，在实验/测试版本中，您需要在 Visual Studio 中启用搜索预发布包的选项。 dotnet add package Sisk.JsonRpc 传输接口 JSON-RPC 是一种无状态、异步的远程过程调用（RDP）协议，使用 JSON 进行单向数据通信。JSON-RPC 请求通常由一个 ID 标识，响应由相同的 ID 发送。并非所有请求都需要响应，这些被称为“通知”。 JSON-RPC 2.0 规范 详细解释了传输的工作原理。该传输与其使用位置无关。Sisk 通过 HTTP 实现该协议，遵循 JSON-RPC over HTTP 的规定，部分支持 GET 请求，完全支持 POST 请求。WebSockets 也被支持，提供异步消息通信。 JSON-RPC 请求类似于： { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } 成功响应类似于： { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC 方法 以下示例显示如何使用 Sisk 创建 JSON-RPC API。一个数学运算类执行远程操作并将序列化的响应发送给客户端。 Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // 添加所有标记为 WebMethod 的方法到 JSON-RPC 处理器 args.Handler.Methods.AddMethodsFromType(new MathOperations()); // 将 /service 路由映射到处理 JSON-RPC POST 和 GET 请求 args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // 在 GET /ws 创建一个 WebSocket 处理器 args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } 上面的示例将 Sum 和 Sqrt 方法映射到 JSON-RPC 处理器，这些方法将在 GET /service、POST /service 和 GET /ws 中可用。方法名称不区分大小写。 方法参数将自动反序列化为其特定类型。使用带有命名参数的请求也是支持的。JSON 序列化由 LightJson 库执行。当类型不能正确反序列化时，您可以为该类型创建一个特定的 JSON 转换器 并稍后将其与 JsonSerializerOptions 关联起来。 您还可以直接在方法中获取 JSON-RPC 请求的原始 $.params 对象。 MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } 为此，@params 必须是方法中唯一的参数，且名称必须为 params（在 C# 中，@ 用于转义此参数名称）。 参数反序列化适用于命名对象和位置数组。例如，以下方法可以通过以下两种请求调用： [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } 对于数组，参数的顺序必须遵循。 { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } 自定义序列化器 您可以在 JsonRpcHandler.JsonSerializerOptions 属性中自定义 JSON 序列化器。在此属性中，您可以启用 JSON5 以用于反序列化消息。虽然这不是 JSON-RPC 2.0 的一部分，但 JSON5 是 JSON 的一个扩展，允许更易读和更具可读性的写作。 Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // 使用一个标准化的名称比较器。该比较器仅比较名称中的字母和数字，并丢弃其他符号。例如： // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // 启用 JSON5 以用于 JSON 解释器。即使激活此选项，普通 JSON 仍然被允许 e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // 将 POST /service 路由映射到 JSON-RPC 处理器 e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/cn/extensions/service-providers.html": {
    "href": "docs/cn/extensions/service-providers.html",
    "title": "服务提供者 | Sisk",
    "keywords": "服务提供者 服务提供者是一种将 Sisk 应用程序移植到不同环境的方式，使用一个可移植的配置文件。该功能允许您在不修改应用程序代码的情况下更改服务器的端口、参数和其他选项。该模块依赖于 Sisk 构造语法，可以通过 UsePortableConfiguration 方法进行配置。 一个配置提供者是通过 IConfigurationProvider 实现的，它提供了一个配置读取器，可以接受任何实现。默认情况下，Sisk 提供了一个 JSON 配置读取器，但也存在一个用于 INI 文件的包。您也可以创建自己的配置提供者并将其注册为： using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); 如前所述，默认的提供者是一个 JSON 文件。默认情况下，文件名为 service-config.json，并在运行进程的当前目录中搜索，而不是可执行文件目录。 您可以选择更改文件名，以及 Sisk 应该在哪里查找配置文件，使用： using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); 上面的代码将在运行进程的当前目录中查找 config.toml 文件。如果找不到，它将在可执行文件所在的目录中搜索。如果文件不存在，createIfDontExists 参数将被尊重，创建一个空文件在最后测试的路径（基于 lookupDirectories），并在控制台中抛出一个错误，防止应用程序初始化。 Tip 您可以查看 INI 配置读取器和 JSON 配置读取器的源代码，以了解如何实现 IConfigurationProvider。 从 JSON 文件读取配置 默认情况下，Sisk 提供了一个配置提供者，用于从 JSON 文件读取配置。该文件遵循一个固定的结构，包含以下参数： { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // 配置文件也支持注释 ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // 新增于 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } 从配置文件创建的参数可以在服务器构造函数中访问： using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); 每个配置读取器提供了一种读取服务器初始化参数的方式。一些属性被指示在进程环境中而不是在配置文件中定义，例如敏感的 API 数据、API 密钥等。 配置文件结构 JSON 配置文件由以下属性组成： 属性 必需 描述 Server 必需 代表服务器本身及其设置。 Server.AccessLogsStream 可选 默认为 console。指定访问日志输出流。可以是文件名、null 或 console。 Server.ErrorsLogsStream 可选 默认为 null。指定错误日志输出流。可以是文件名、null 或 console。 Server.MaximumContentLength 可选 默认为 0。指定最大内容长度（以字节为单位）。零表示无限。 Server.IncludeRequestIdHeader 可选 默认为 false。指定是否应发送 X-Request-Id 标头。 Server.ThrowExceptions 可选 默认为 true。指定是否应抛出未处理的异常。设置为 false 时为生产环境，true 时为调试环境。 ListeningHost 必需 代表服务器监听主机。 ListeningHost.Label 可选 代表应用程序标签。 ListeningHost.Ports 必需 代表一个字符串数组，匹配 ListeningPort 语法。 ListeningHost.CrossOriginResourceSharingPolicy 可选 设置应用程序的 CORS 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials 可选 默认为 false。指定 Allow-Credentials 标头。 ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders 可选 默认为 null。此属性期望一个字符串数组。指定 Expose-Headers 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin 可选 默认为 null。此属性期望一个字符串。指定 Allow-Origin 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins 可选 默认为 null。此属性期望一个字符串数组。指定多个 Allow-Origin 标头。请参阅 AllowOrigins 以获取更多信息。 ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods 可选 默认为 null。此属性期望一个字符串数组。指定 Allow-Methods 标头。 ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders 可选 默认为 null。此属性期望一个字符串数组。指定 Allow-Headers 标头。 ListeningHost.CrossOriginResourceSharingPolicy.MaxAge 可选 默认为 null。此属性期望一个整数。指定 Max-Age 标头（以秒为单位）。 ListeningHost.Parameters 可选 指定提供给应用程序设置方法的属性。"
  },
  "docs/cn/extensions/ssl-proxy.html": {
    "href": "docs/cn/extensions/ssl-proxy.html",
    "title": "SSL 代理 | Sisk",
    "keywords": "SSL 代理 Warning 此功能是实验性的，不应在生产环境中使用。如果您想让 Sisk 与 SSL 协作，请参阅 此文档。 Sisk SSL 代理是一个模块，提供了一个 HTTPS 连接，用于 Sisk 中的 ListeningHost，并将 HTTPS 消息路由到不安全的 HTTP 上下文。该模块是为使用 HttpListener 运行的服务提供 SSL 连接而构建的，因为 HttpListener 不支持 SSL。 代理在同一应用程序中运行，并监听 HTTP/1.1 消息，将它们以相同的协议转发给 Sisk。目前，此功能是高度实验性的，可能不稳定到不能在生产环境中使用。 目前，SslProxy 支持几乎所有 HTTP/1.1 功能，例如 keep-alive、分块编码、WebSockets 等。对于打开到 SSL 代理的连接，会创建一个到目标服务器的 TCP 连接，并将代理转发到已建立的连接。 SslProxy 可以与 HttpServer.CreateBuilder 一起使用，如下所示： using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // 添加 SSL 到项目 .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); 您必须为代理提供一个有效的 SSL 证书。为了确保证书被浏览器接受，请记得将其导入到操作系统中，以便它能够正常工作。"
  },
  "docs/cn/features/discard-syntax.html": {
    "href": "docs/cn/features/discard-syntax.html",
    "title": "放弃语法 | Sisk",
    "keywords": "放弃语法 HTTP 服务器可以用于监听来自操作的回调请求，例如 OAuth 身份验证，并在接收到该请求后可以被丢弃。这在需要后台操作但不想为其设置整个 HTTP 应用的情况下非常有用。 以下示例展示了如何在端口 5555 上创建一个监听 HTTP 服务器，并等待下一个上下文： using (var server = HttpServer.CreateListener(5555)) { // 等待下一个 HTTP 请求 var context = await server.WaitNextAsync(); Console.WriteLine($\"请求路径: {context.Request.Path}\"); } WaitNext 函数等待下一个已完成的请求处理上下文。一旦获得此操作的结果，服务器已经完全处理了请求并将响应发送给客户端。"
  },
  "docs/cn/features/instancing.html": {
    "href": "docs/cn/features/instancing.html",
    "title": "依赖注入 | Sisk",
    "keywords": "依赖注入 通常，会为请求的生命周期内持续存在的成员和实例分配内存，例如数据库连接、已验证的用户或会话令牌。实现这一点的一种可能方法是通过 HttpContext.RequestBag ，它创建一个在整个请求生命周期内持续存在的字典。 该字典可以被 请求处理程序 访问，并在整个请求过程中定义变量。例如，验证用户的请求处理程序将用户设置在 HttpContext.RequestBag 中，在请求逻辑中，可以通过 HttpContext.RequestBag.Get<User>() 来检索该用户。 以下是一个示例： RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } 这是对此操作的初步示例。User 实例是在专门用于身份验证的请求处理程序中创建的，并且所有使用此请求处理程序的路由都保证在其 HttpContext.RequestBag 实例中将有一个 User。 可以通过诸如 GetOrAdd 或 GetOrAddAsync 之类的方法来定义获取实例的逻辑，当实例尚未在 RequestBag 中定义时。 从 1.3 版本开始，引入了静态属性 HttpContext.Current ，允许访问当前执行的 HttpContext 的请求上下文。这使得可以在当前请求之外暴露 HttpContext 的成员，并在路由对象中定义实例。 以下示例定义了一个控制器，该控制器具有通常由请求上下文访问的成员。 Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // 创建一个 DbContext 或获取现有的一个 return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // 如果属性在请求包中没有定义 User 时访问，将抛出异常 public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // 也支持暴露 HttpRequest 实例 public HttpRequest Request { get => HttpContext.Current.Request; } } 并定义继承自控制器的类型： Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } 对于上面的示例，您需要在路由器中配置一个 值处理程序 ，以便路由器返回的对象转换为有效的 HttpResponse。 请注意，方法不带有 HttpRequest request 参数，如其他方法中所示。这是因为，从 1.3 版本开始，路由器支持两种类型的委托用于路由响应：RouteAction ，这是默认的委托，它接收一个 HttpRequest 参数，以及 ParameterlessRouteAction 。HttpRequest 对象仍然可以通过静态 HttpContext 的 Request 属性访问。 在上面的示例中，我们定义了一个可处置对象 DbContext ，并且我们需要确保在 HTTP 会话结束时处置所有在 DbContext 中创建的实例。为此，我们可以使用两种方法来实现这一点。一种方法是创建一个在路由器操作之后执行的 请求处理程序 ，另一种方法是通过自定义 服务器处理程序。 对于第一种方法，我们可以直接在继承自 RouterModule 的 OnSetup 方法中内联创建请求处理程序： Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // 获取请求处理程序上下文中定义的 DbContext 并处置它 ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip 从 Sisk 1.4 版本开始，引入了属性 HttpServerConfiguration.DisposeDisposableContextValues ，它默认启用，用于定义 HTTP 服务器是否应在 HTTP 会话关闭时处置上下文包中的所有 IDisposable 值。 上述方法将确保在 HTTP 会话结束时处置 DbContext。您可以为需要在响应结束时处置的其他成员执行此操作。 对于第二种方法，您可以创建一个自定义的 服务器处理程序 ，它将在 HTTP 会话结束时处置 DbContext。 Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } 并在应用程序生成器中使用它： Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); 这是处理代码清理并将请求的依赖项与将使用的模块类型分离的一种方法，减少了路由器操作中重复的代码量。这是一种类似于在 ASP.NET 等框架中使用依赖注入的做法。"
  },
  "docs/cn/features/logging.html": {
    "href": "docs/cn/features/logging.html",
    "title": "日志记录 | Sisk",
    "keywords": "日志记录 您可以配置 Sisk 自动写入访问和错误日志。它也可以定义日志轮换、扩展和频率。 LogStream 类提供了一种异步写入日志和保持可等待写入队列的方式。 在本文中，我们将向您展示如何为您的应用程序配置日志记录。 基于文件的访问日志 日志写入文件时，会打开文件，写入行文本，然后为每行写入关闭文件。这种过程是为了保持日志的写入响应性。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } 上面的代码将写入所有传入的请求到 logs/access.log 文件。注意，如果文件不存在，它将自动创建，但是文件夹不会自动创建。您不需要创建 logs/ 目录，因为 LogStream 类会自动创建它。 基于流的日志记录 您可以将日志文件写入 TextWriter 对象实例，例如 Console.Out，通过在构造函数中传递 TextWriter 对象： Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); 对于流式日志记录中的每个消息，TextWriter.Flush() 方法都会被调用。 访问日志格式 您可以通过预定义变量自定义访问日志格式。考虑以下行： config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; 它将写入一条消息，如下所示： 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] 您可以通过表格中描述的格式格式化日志文件： 值 代表什么 示例 %dd 月份中的某一天（以两位数字格式化） 05 %dmmm 月份的全名 July %dmm 月份的缩写（三个字母） Jul %dm 月份号（以两位数字格式化） 07 %dy 年份（以四位数字格式化） 2023 %th 12 小时格式的小时 03 %tH 24 小时格式的小时（HH） 15 %ti 分钟（以两位数字格式化） 30 %ts 秒（以两位数字格式化） 45 %tm 毫秒（以三位数字格式化） 123 %tz 时区偏移（以 UTC 为单位的总小时） +03:00 %ri 客户端的远程 IP 地址 192.168.1.100 %rm HTTP 方法（大写） GET %rs URI 方案（http/https） https %ra URI 权威（域） example.com %rh 请求的主机 www.example.com %rp 请求的端口 443 %rz 请求的路径 /path/to/resource %rq 查询字符串 ?key=value&another=123 %sc HTTP 响应状态代码 200 %sd HTTP 响应状态描述 OK %lin 请求的可读大小 1.2 KB %linr 请求的原始大小（字节） 1234 %lou 响应的可读大小 2.5 KB %lour 响应的原始大小（字节） 2560 %lms 耗时的毫秒数 120 %ls 执行状态 Executed 日志轮换 Tip 在 Sisk 0.15 及更早版本中，此功能仅在 Sisk.ServiceProvider 包中可用。在 Sisk 0.16 及更高版本中，此功能已在核心包中实现。 您可以配置 HTTP 服务器，当日志文件达到一定大小时，将其轮换到压缩的 .gz 文件。大小是由您定义的阈值周期性检查的。 config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); 上面的代码将每 6 小时检查一次 LogStream 的文件是否达到 1MB 限制。如果达到限制，文件将被压缩到 .gz 文件，然后 access.log 将被清空。 在此过程中，写入文件将被锁定，直到文件被压缩和清空。在此期间，所有要写入的行将在队列中等待压缩完成。 此功能仅适用于基于文件的 LogStreams。 错误日志记录 当服务器不将错误抛给调试器时，它会将错误转发到日志写入器。您可以使用以下代码配置错误写入： config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); 此属性仅在错误未被回调或 Router.CallbackErrorHandler 属性捕获时写入日志。 服务器写入的错误始终包含日期和时间、请求头（不包括正文）、错误跟踪和内部异常跟踪（如果有）。 其他日志实例 您的应用程序可以有零个或多个 LogStreams，没有限制。因此，您可以将应用程序的日志定向到其他文件，而不是默认的 AccessLog 或 ErrorLog。 LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"应用程序在 {0} 启动\", DateTime.Now); 扩展 LogStream 您可以扩展 LogStream 类以写入自定义格式，兼容当前的 Sisk 日志引擎。以下示例允许通过 Spectre.Console 库将彩色消息写入控制台： CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } 另一种自动为每个请求/响应写入自定义日志的方法是创建 HttpServerHandler。以下示例更为完整。它将请求和响应的正文以 JSON 格式写入控制台。它可以用于调试请求。这个示例使用了 ContextBag 和 HttpServerHandler。 Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // 在此时，连接已经打开，客户端已经发送了指定内容为 JSON 的头。 // 下一行读取内容并将其存储在请求中。 // // 如果在请求操作中不读取内容，GC 可能会在发送响应给客户端后收集内容，因此内容可能在响应关闭后不可用。 // _ = request.RawBody; // 在上下文中添加提示，指示此请求具有 JSON 正文 request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // 使用 CypherPotato.LightJson 库重新格式化 JSON var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // 检查响应是否为 JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // 获取内部服务器处理状态 responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/cn/features/server-sent-events.html": {
    "href": "docs/cn/features/server-sent-events.html",
    "title": "服务器发送事件 | Sisk",
    "keywords": "服务器发送事件 Sisk 支持通过服务器发送事件（Server Sent Events）发送消息。您可以创建可抛弃和持久的连接，在运行时获取这些连接并使用它们。 此功能有一些限制，例如只能发送文本消息，无法永久关闭连接。服务器端关闭的连接将导致客户端每 5 秒（某些浏览器为 3 秒）尝试重新连接一次。 这些连接对于从服务器向客户端发送事件而无需客户端每次请求信息非常有用。 创建 SSE 连接 SSE 连接的工作方式与普通 HTTP 请求类似，但不是发送响应并立即关闭连接，而是保持连接打开以发送消息。 调用 HttpRequest.GetEventSource() 方法，请求将被置于等待状态，同时创建 SSE 实例。 r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.Send(\"Hello, world!\"); return sse.Close(); }); 在上面的代码中，我们创建一个 SSE 连接并发送一个“Hello, world”消息，然后我们从服务器端关闭 SSE 连接。 Note 当关闭服务器端连接时，客户端将默认尝试重新连接，并且连接将被重启，方法将被再次执行，直到永远。 通常，当连接从服务器端关闭时，会从服务器发送终止消息以防止客户端尝试重新连接。 添加头部 如果需要发送头部，可以使用 HttpRequestEventSource.AppendHeader 方法，在发送任何消息之前。 r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hello!\"); return sse.Close(); }); 注意，必须在发送任何消息之前发送头部。 等待失败连接 连接通常在服务器无法发送消息时终止，可能是由于客户端断开连接。这样，连接将被自动终止，类的实例将被丢弃。 即使重新连接，类的实例也将不起作用，因为它与之前的连接相关联。在某些情况下，您可能需要稍后使用此连接，并且不希望通过路由的回调方法来管理它。 为此，我们可以使用标识符来标识 SSE 连接，并稍后使用它来获取连接，即使在路由的回调方法之外。另外，我们将连接标记为 WaitForFail，以防止路由自动终止连接。 SSE 连接在 KeepAlive 时将等待发送错误（由断开连接引起）以恢复方法执行。也可以为此设置超时时间。超时后，如果没有发送任何消息，连接将被终止，执行将恢复。 r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // 等待 15 秒内没有任何消息发送后终止连接 return sse.Close(); }); 上面的方法将创建连接，处理它，并等待断开连接或错误。 HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // 连接仍然活着 evs.Send(\"Hello again!\"); } 上面的代码片段将尝试查找新创建的连接，如果它存在，则向其发送消息。 所有活动的服务器连接都将在 HttpServer.EventSources 集合中可用。该集合仅存储活动的和标识的连接。已关闭的连接将从集合中删除。 Note 需要注意的是，保持活动有一个由可能以不可控方式连接到 Sisk 的组件（如 Web 代理、HTTP 内核或网络驱动程序）建立的限制，这些组件在一段时间后会关闭空闲连接。 因此，保持连接打开非常重要，可以通过发送周期性的 ping 消息或延长连接关闭前的最大时间来实现。阅读下一节以更好地理解发送周期性的 ping 消息。 设置连接 ping 策略 Ping 策略是一种自动向客户端发送周期性消息的方法。该功能允许服务器在不需要保持连接打开的情况下了解客户端是否断开了连接。 [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } 在上面的代码中，每 5 秒将向客户端发送一个新的 ping 消息。这将保持 TCP 连接打开，并防止它由于不活动而被关闭。另外，当消息发送失败时，连接将被自动关闭，释放连接使用的资源。 查询连接 可以使用连接标识符的谓词来搜索活动连接，以便广播。 HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcasting to all event sources that starts with 'my-connection-'\"); } 也可以使用 All 方法来获取所有活动的 SSE 连接。"
  },
  "docs/cn/features/websockets.html": {
    "href": "docs/cn/features/websockets.html",
    "title": "Web 套接字 | Sisk",
    "keywords": "Web 套接字 Sisk 同时支持 Web 套接字，例如接收和发送消息到客户端。 此功能在大多数浏览器中工作正常，但在 Sisk 中仍然是实验性的。如果您发现任何错误，请在 GitHub 上报告。 异步接受和接收消息 下面的示例展示了 Web 套接字在实践中的工作方式，包括打开连接、接收消息和在控制台中显示消息的示例。 所有通过 Web 套接字接收的消息都是以字节形式接收的，因此您需要在接收时对其进行解码。 默认情况下，消息被分成块，并且最后一块被发送为消息的最后一个数据包。您可以使用 WebSocketBufferSize 标志配置数据包大小。此缓冲对于发送和接收消息是相同的。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // 获取接收消息的 HttpWebSocket 上下文 HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } 同步接受和接收消息 下面的示例包含了一种使用同步 Web 套接字的方法，无需异步上下文，您可以接收消息、处理它们并完成使用套接字。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/connect\", (req) => { var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } 发送消息 Send 方法有三个重载，允许您发送文本、字节数组或字节跨度。如果服务器的 WebSocketBufferSize 标志大于总有效负载大小，则所有这些方法都会将消息分块。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // 将被编码为 UTF-8 字节数组 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } 等待 Web 套接字关闭 WaitForClose() 方法会阻塞当前调用堆栈，直到连接由客户端或服务器终止。 通过此方法，请求的回调执行将被阻塞，直到客户端或服务器断开连接。 您也可以使用 Close() 方法手动关闭连接。此方法返回一个空 HttpResponse 对象，该对象不会发送到客户端，但作为从接收 HTTP 请求的函数返回。 static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // 等待客户端关闭连接 ws.WaitForClose(); // 等待 60 秒内没有消息交换或任一方关闭连接 ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Ping 策略 与服务器端事件中的 Ping 策略类似，您也可以配置 Ping 策略以保持 TCP 连接在空闲时保持打开。 ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/cn/fundamentals/request-handlers.html": {
    "href": "docs/cn/fundamentals/request-handlers.html",
    "title": "请求处理 | Sisk",
    "keywords": "请求处理 请求处理器，也称为“中间件”，是运行在请求在路由器上执行之前或之后的函数。它们可以为每个路由或每个路由器定义。 请求处理器有两种类型： BeforeResponse：定义请求处理器将在调用路由器操作之前执行。 AfterResponse：定义请求处理器将在调用路由器操作之后执行。在此上下文中发送 HTTP 响应将覆盖路由器操作的响应。 两种请求处理器都可以覆盖实际路由器回调函数的响应。另外，请求处理器可以用于验证请求，例如身份验证、内容或其他信息，例如存储信息、日志或可以在响应之前或之后执行的其他步骤。 这样，请求处理器可以中断整个执行过程并返回响应，而不必完成整个周期，并丢弃过程中的所有其他内容。 例子：假设用户身份验证请求处理器未能身份验证用户。它将阻止请求生命周期继续并挂起。如果这发生在请求处理器的第二个位置，第三个及以后的处理器将不会被评估。 创建请求处理器 要创建请求处理器，我们可以创建一个继承 IRequestHandler 接口的类，以以下格式： public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // 返回 null 表示请求周期可以继续 return null; } else { // 返回 HttpResponse 对象表示此响应将覆盖相邻的响应。 return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 在上面的示例中，我们指示如果请求中存在 Authorization 标头，则应继续并调用下一个请求处理器或路由器回调函数，具体取决于哪一个先发生。如果请求处理器在响应之后执行并返回非 null 值，则将覆盖路由器的响应。 每当请求处理器返回 null 时，均表示请求必须继续并调用下一个对象或以路由器的响应结束周期。 将请求处理器与单个路由关联 您可以为路由定义一个或多个请求处理器。 mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // 请求之前的处理器 new ValidateJsonContentRequestHandler(), // 请求之前的处理器 // -- 方法 IndexPage 将在此处执行 new WriteToLogRequestHandler() // 响应之后的处理器 }); 或者创建一个 Route 对象： Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); 将请求处理器与路由器关联 您可以为路由器定义一个全局请求处理器，该处理器将在路由器上的所有路由上运行。 mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; 将请求处理器与属性关联 您可以将请求处理器定义为方法属性，连同路由属性。 public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() .WithContent(new StringContent(\"Hello world!\")); } } 请注意，需要传递所需的请求处理器类型，而不是对象实例。这样，请求处理器将由路由器解析器实例化。您可以使用 ConstructorArguments 属性在类构造函数中传递参数。 示例： [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } 您还可以创建自己的属性，该属性实现 RequestHandler： public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } 并使用它： [Authenticate] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } 跳过全局请求处理器 在路由器上定义全局请求处理器后，您可以在特定路由上忽略此请求处理器。 var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok：与全局请求处理器中相同的实例 new AuthenticateUserRequestHandler() // wrong：不会跳过全局请求处理器 } }); Note 如果您要跳过请求处理器，则必须使用与之前实例化的相同引用来跳过。创建另一个请求处理器实例将不会跳过全局请求处理器，因为其引用将更改。请记住在 GlobalRequestHandlers 和 BypassGlobalRequestHandlers 中使用相同的请求处理器引用。"
  },
  "docs/cn/fundamentals/requests.html": {
    "href": "docs/cn/fundamentals/requests.html",
    "title": "请求 | Sisk",
    "keywords": "请求 请求是代表 HTTP 请求消息的结构。 HttpRequest 对象包含处理 HTTP 消息的有用函数，适用于整个应用程序。 一个 HTTP 请求由方法、路径、版本、头部和正文组成。 在本文档中，我们将教您如何获取这些元素。 获取请求方法 要获取接收到的请求的方法，可以使用 Method 属性： static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } 该属性返回请求的方法，表示为 HttpMethod 对象。 Note 与路由方法不同，该属性不提供 RouteMethod.Any 项。相反，它返回实际的请求方法。 获取请求 URL 组件 您可以通过请求的某些属性从 URL 中获取各种组件。对于此示例，让我们考虑以下 URL： http://localhost:5000/user/login?email=foo@bar.com 组件名称 描述 组件值 Path 获取请求路径。 /user/login FullPath 获取请求路径和查询字符串。 /user/login?email=foo@bar.com FullUrl 获取整个 URL 请求字符串。 http://localhost:5000/user/login?email=foo@bar.com Host 获取请求主机。 localhost Authority 获取请求主机和端口。 localhost:5000 QueryString 获取请求查询。 ?email=foo@bar.com Query 获取请求查询作为命名值集合。 {StringValueCollection 对象} IsSecure 确定请求是否使用 SSL（true）或不使用（false）。 false 您也可以使用 HttpRequest.Uri 属性，该属性包含上述所有内容。 获取请求正文 一些请求包含正文，例如表单、文件或 API 事务。您可以从以下属性获取请求正文： // 以字符串形式获取请求正文，使用请求编码作为编码器 string body = request.Body; // 或以字节数组形式获取 byte[] bodyBytes = request.RawBody; // 或者，您可以将其作为流进行处理。 Stream requestStream = request.GetRequestStream(); 还可以使用 HasContents 和 IsContentAvailable 属性确定请求是否包含正文以及是否已加载。 无法多次通过 GetRequestStream 方法读取请求内容。如果使用此方法读取，则 RawBody 和 Body 的值也将不可用。无需在请求上下文中释放请求流，因为它将在创建的 HTTP 会话结束时释放。还可以使用 HttpRequest.RequestEncoding 属性获取解码请求的最佳编码。 服务器对读取请求内容有限制，这适用于 HttpRequest.Body 和 HttpRequest.RawBody。这些属性将整个输入流复制到一个与 HttpRequest.ContentLength 相同大小的本地缓冲区中。 如果客户端发送的内容大于 HttpServerConfiguration.MaximumContentLength（在用户配置中定义），则返回状态代码 413 的响应给客户端。另外，如果没有配置限制或限制太大，则当客户端发送的内容超过 Int32.MaxValue（2 GB）时，服务器将在尝试通过上述属性之一访问内容时抛出 OutOfMemoryException。仍然可以通过流处理内容。 Note 虽然 Sisk 允许这样做，但为了创建应用程序，始终遵循 HTTP 语义是一个好主意，不要在不允许的方法中获取或提供内容。请阅读有关 RFC 9110“HTTP 语义” 的信息。 获取请求上下文 HTTP 上下文是 Sisk 的一个独特对象，存储 HTTP 服务器、路由、路由器和请求处理程序信息。您可以使用它来组织自己在这些对象难以组织的环境中。 RequestBag 对象包含存储的信息，可以从一个请求处理程序传递到另一个点，并可以在最终目标中使用。此对象也可以由在路由回调之后运行的请求处理程序使用。 Tip 此属性也可以通过 HttpRequest.Bag 属性访问。 public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers[\"Authorization\"] != null) { context.RequestBag.Add(\"AuthenticatedUser\", \"Bob\"); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } 上面的请求处理程序将在请求包中定义 AuthenticatedUser，并可以稍后在最终回调中使用： public class MyController { [Route(RouteMethod.Get, \"/\")] [RequestHandler(typeof(AuthenticateUserRequestHandler))] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); string authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; res.Content = new StringContent($\"Hello, {authUser}!\"); return res; } } 您还可以使用 Bag.Set() 和 Bag.Get() 帮助器方法按类型单例获取或设置对象。 public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse Test(HttpRequest request) { var user = request.Bag.Get<User>(); } 获取表单数据 您可以使用以下示例在 NameValueCollection 中获取表单数据的值： static HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password) == true) { ... } } 获取多部分表单数据 Sisk 的 HTTP 请求允许您获取上传的多部分内容，例如文件、表单字段或任何二进制内容。 static HttpResponse Index(HttpRequest request) { // 以下方法将整个请求输入读入 MultipartObject 数组 var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // 多部分表单数据对象的文件名。 // 如果对象不是文件，则返回 null。 Console.WriteLine(\"文件名 : \" + uploadedObject.Filename); // 多部分表单数据对象的字段名。 Console.WriteLine(\"字段名 : \" + uploadedObject.Name); // 多部分表单数据内容长度。 Console.WriteLine(\"内容长度 : \" + uploadedObject.ContentLength); // 根据文件头确定每个已知内容类型的图像格式。 // 如果内容不是已知的常见文件格式，则此方法将返回 MultipartObjectCommonFormat.Unknown Console.WriteLine(\"常见格式 : \" + uploadedObject.GetCommonFileFormat()); } } 您可以阅读更多关于 Sisk 多部分表单对象及其方法、属性和功能的信息。 服务器发送事件支持 Sisk 支持 服务器发送事件，允许将块作为流发送并保持服务器和客户端之间的连接。 调用 HttpRequest.GetEventSource 方法将使 HttpRequest 进入其监听状态。从此，HTTP 请求的上下文将不再期望 HttpResponse，因为服务器发送的事件将重叠数据包。 发送所有数据包后，回调必须返回 Close 方法，该方法将发送最终响应给服务器并指示流媒体已结束。 无法预测将发送的所有数据包的总长度，因此无法使用 Content-Length 标头确定连接的末尾。 大多数浏览器的默认设置不支持服务器发送事件发送 HTTP 标头或除 GET 方法以外的方法。因此，在使用需要特定请求标头的请求处理程序处理事件源请求时要小心，因为它们可能没有这些标头。 此外，大多数浏览器如果客户端在接收到所有数据包后未调用 EventSource.close 方法，则会重新启动流媒体，从而导致服务器端无限增加额外处理。为了避免此类问题，通常会发送一个最终数据包，指示事件源已完成发送所有数据包。 以下示例显示浏览器如何与支持服务器发送事件的服务器进行通信。 <html> <body> <b>水果:</b> <ul></ul> </body> <script> const evtSource = new EventSource('/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> 并逐渐将消息发送给客户端： public class MyController { [Route(RouteMethod.Get, \"/event-source\")] static HttpResponse ServerEventsResponse(HttpRequest request) { var serverEvents = request.GetEventSource(); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { serverEvents.Send(fruit); Thread.Sleep(1500); } return serverEvents.Close(); } } 运行此代码时，我们期望得到类似以下的结果： 解析代理 IP 和主机 Sisk 可以与代理一起使用，因此 IP 地址可以在客户端到代理的交易中被代理端点替换。 您可以在 Sisk 中使用 转发解析器 定义自己的解析器。 标头编码 标头编码可能是某些实现的问题。在 Windows 上，不支持 UTF-8 标头，因此使用 ASCII。Sisk 具有内置的编码转换器，可以用于解码不正确编码的标头。 此操作代价高昂，默认情况下禁用，但可以在 NormalizeHeadersEncodings 标志下启用。"
  },
  "docs/cn/fundamentals/responses.html": {
    "href": "docs/cn/fundamentals/responses.html",
    "title": "响应 | Sisk",
    "keywords": "响应 响应代表对象，它们是 HTTP 请求的 HTTP 响应。它们由服务器发送到客户端，表示请求资源、页面、文档、文件或其他对象。 HTTP 响应由状态、头部和内容组成。 在本文档中，我们将教您如何使用 Sisk 架构 HTTP 响应。 设置 HTTP 状态 HTTP 状态列表自 HTTP/1.0 以来一直保持不变，Sisk 支持所有这些状态。 HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 或者使用流式语法： new HttpResponse() .WithStatus(200) // 或 .WithStatus(HttpStatusCode.Ok) // 或 .WithStatus(HttpStatusInformation.Ok); 您可以在 这里 查看所有可用的 HttpStatusCode。您也可以使用 HttpStatusInformation 结构提供自己的状态代码。 正文和内容类型 Sisk 支持本地 .NET 内容对象来发送响应正文。您可以使用 StringContent 类来发送 JSON 响应，例如： HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); 服务器将始终尝试从您定义的内容中计算 Content-Length，如果您没有在头部中显式定义它。如果服务器无法从响应内容中隐式获取 Content-Length 头，响应将以分块编码发送。 您还可以通过发送 StreamContent 或使用 GetResponseStream 方法来流式传输响应。 响应头 您可以添加、编辑或删除发送在响应中的头。以下示例显示如何向客户端发送重定向响应。 HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); 或者使用流式语法： new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); 当您使用 Add 方法添加头时，您是在不修改已发送头的前提下添加一个头。Set 方法用指定值替换同名头。HttpHeaderCollection 的索引器内部调用 Set 方法替换头。 发送 Cookie Sisk 有方法可以方便地在客户端定义 Cookie。使用此方法设置的 Cookie 已经是 URL 编码的，并符合 RFC-6265 标准。 HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); 或者使用流式语法： new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); 还有其他 更完整的版本 的同一方法。 分块响应 您可以将传输编码设置为分块来发送大型响应。 HttpResponse res = new HttpResponse(); res.SendChunked = true; 使用分块编码时，Content-Length 头将被自动省略。 响应流 响应流是一种管理方式，允许您分段发送响应。它比使用 HttpResponse 对象更低级，因为您需要手动发送头和内容，然后关闭连接。 以下示例打开一个文件的只读流，将流复制到响应输出流，并且不将整个文件加载到内存中。这对于提供中型或大型文件很有用。 // 获取响应输出流 using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // 设置响应编码以使用分块编码 // 同时，您不应该在使用分块编码时发送内容长度头 responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // 将文件流复制到响应输出流 fileStream.CopyTo(responseStream.ResponseStream); // 关闭流 return responseStream.Close(); GZip、Deflate 和 Brotli 压缩 您可以使用 Sisk 发送压缩内容的 HTTP 响应。首先，将您的 HttpContent 对象封装在以下压缩器之一中，以发送压缩响应到客户端。 router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // 或 Content = new BrotliContent(new HtmlContent(myHtml)), // 或 Content = new DeflateContent(new HtmlContent(myHtml)), }; }); 您还可以将这些压缩内容与流一起使用。 router.MapGet(\"/archive.zip\", request => { // 不要在这里使用“using”。HttpServer 将在发送响应后丢弃您的内容 var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); 使用这些内容时，Content-Encoding 头将被自动设置。 隐式响应类型 从版本 0.15 开始，您可以使用除 HttpResponse 之外的其他返回类型，但需要配置路由器如何处理每种类型的对象。 概念是始终返回一个引用类型并将其转换为有效的 HttpResponse 对象。返回 HttpResponse 的路由不经历任何转换。 值类型（结构）不能用作返回类型，因为它们与 RouterCallback 不兼容，因此必须将它们封装在 ValueResult 中才能在处理程序中使用。 考虑以下示例来自不在返回类型中使用 HttpResponse 的路由器模块： [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } 这样，现在需要在路由器中定义如何处理每种类型的对象。对象始终是处理程序的第一个参数，输出类型必须是有效的 HttpResponse。路由的输出对象永远不应为 null。 对于 ValueResult 类型，不需要指出输入对象是 ValueResult，只需要 T，因为 ValueResult 是其原始组件的反射。 类型关联不检查注册的类型与路由器回调返回的类型是否匹配。相反，它检查路由器结果的类型是否可以分配给注册的类型。 注册类型 Object 将回退到所有以前未验证的类型。值处理程序的插入顺序也很重要，因此注册 Object 处理程序将忽略所有其他特定类型的处理程序。始终先注册特定值处理程序，以确保顺序。 Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<bool>(bolVal => { HttpResponse res = new HttpResponse(); res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest; return res; }); r.RegisterValueHandler<IEnumerable>(enumerableValue => { return new HttpResponse(); // 在这里执行某些操作 }); // 注册 Object 值处理程序必须是最后一个值处理程序 // 它将被用作回退 r.RegisterValueHandler<object>(fallback => { HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.OK; res.Content = JsonContent.Create(fallback); return res; });"
  },
  "docs/cn/fundamentals/routing.html": {
    "href": "docs/cn/fundamentals/routing.html",
    "title": "路由 | Sisk",
    "keywords": "路由 路由器 是构建服务器的第一步。它负责存储 路由 对象，这些对象是将 URL 和其方法映射到服务器执行的操作的端点。每个操作负责接收请求并将响应发送回客户端。 路由是路径表达式（“路径模式”）和它们可以监听的 HTTP 方法的对。当请求发送到服务器时，它将尝试找到匹配接收到的请求的路由，然后调用该路由的操作并将结果响应发送回客户端。 在 Sisk 中，有多种方式来定义路由：它们可以是静态的、动态的或自动扫描的，可以使用属性定义，也可以直接在路由器对象中定义。 Router mainRouter = new Router(); // 将 GET / 映射到以下操作 mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); 要了解路由可以做什么，我们需要了解请求可以做什么。 HttpRequest 将包含您需要的所有内容。 Sisk 还包括一些额外的功能，可以加快整体开发速度。 对于服务器接收到的每个操作，都会调用类型为 RouteAction 的委托。该委托包含一个参数，持有 HttpRequest 对象，该对象包含有关请求的所有必要信息。该委托的返回对象必须是 HttpResponse 或通过 隐式响应类型 映射到它的对象。 匹配路由 当请求发送到 HTTP 服务器时，Sisk 搜索满足请求路径表达式的路由。该表达式始终在路由和请求路径之间进行测试，而不考虑查询字符串。 此测试没有优先级，并且仅限于单个路由。当没有路由与该请求匹配时，返回 Router.NotFoundErrorHandler 响应给客户端。当路径模式匹配，但 HTTP 方法不匹配时，发送 Router.MethodNotAllowedErrorHandler 响应回客户端。 Sisk 检查路由碰撞的可能性，以避免这些问题。在定义路由时，Sisk 将查找可能与要定义的路由碰撞的可能路由。该测试包括检查路由的路径和方法。 使用路径模式创建路由 您可以使用各种 SetRoute 方法定义路由。 // SetRoute 方式 mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // Map* 方式 mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 空 200 OK }); // Route.* 帮助方法 mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // StreamContent 内部 // 流在发送响应后被释放。 Content = new StreamContent(imageStream) }; }); // 多个参数 mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); RouteParameters 属性包含有关请求路径变量的所有信息。 每个发送到服务器的路径在执行路径模式测试之前都会被规范化，遵循以下规则： 所有空段都从路径中删除，例如：////foo//bar 变为 /foo/bar。 路径匹配是 区分大小写 的，除非 Router.MatchRoutesIgnoreCase 设置为 true。 Query 和 RouteParameters 属性返回 StringValueCollection 对象，其中每个索引属性返回非空 StringValue 对象，可以用作选项/单子将其原始值转换为托管对象。 以下示例读取路由参数“id”并从中获取 Guid。如果参数不是有效的 Guid，则抛出异常，并在服务器不处理 Router.CallbackErrorHandler 时返回 500 错误给客户端。 mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note 路径的尾部 / 在请求和路由路径中都会被忽略，即，如果您尝试访问定义为 /index/page 的路由，您也可以使用 /index/page/ 来访问。 您还可以通过启用 ForceTrailingSlash 标志强制 URL 以 / 结尾。 使用类实例创建路由 您还可以使用反射和 RouteAttribute 属性动态定义路由。这样，具有此属性的类的实例将在目标路由器中定义其路由。 要将方法定义为路由，它必须标记有 RouteAttribute 属性，例如该属性本身或 RouteGetAttribute。该方法可以是静态的、实例的、公共的或私有的。当使用 SetObject(type) 或 SetObject<TType>() 方法时，实例方法将被忽略。 public class MyController { // 将匹配 GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // 静态方法也可以 [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } 以下行将定义 MyController 类的 Index 和 Hello 方法作为路由，因为它们都标记为路由，并且提供了类的实例，而不是其类型。如果提供的是类型而不是实例，则仅定义静态方法。 var myController = new MyController(); mainRouter.SetObject(myController); 从 Sisk 0.16 版开始，可以启用 AutoScan，它将搜索实现 RouterModule 的用户定义类，并将其自动关联到路由器。这不支持 AOT 编译。 mainRouter.AutoScanModules<ApiController>(); 上述指令将搜索所有实现 ApiController 的类型，但不包括该类型本身。两个可选参数指示方法将如何搜索这些类型。第一个参数表示将在其中搜索类型的程序集，第二个参数表示定义类型的方式。 正则路由 可以将路由标记为使用正则表达式进行解释，而不是使用默认的 HTTP 路径匹配方法。 Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); 或者使用 RegexRoute 类： RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); }); mainRouter.SetRoute(indexRoute); 还可以从正则表达式模式中捕获组到 HttpRequest.RouteParameters 内容中： [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } 任意方法路由 可以定义路由仅匹配其路径并跳过 HTTP 方法。这可以用于在路由回调内执行方法验证。 // 将匹配任何 HTTP 方法的 / mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); 任意路径路由 任意路径路由测试从 HTTP 服务器接收的任何路径，受路由方法的约束。如果路由方法为 RouteMethod.Any 且路由使用 Route.AnyPath 作为其路径表达式，则此路由将监听所有来自 HTTP 服务器的请求，并且不能定义其他路由。 // 将匹配所有 POST 请求 mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); 忽略大小写路由匹配 默认情况下，路由与请求的解释是区分大小写的。要使其忽略大小写，可以启用此选项： mainRouter.MatchRoutesIgnoreCase = true; 这还将为使用正则表达式匹配的路由启用 RegexOptions.IgnoreCase 选项。 未找到（404）回调处理程序 可以为没有匹配任何已知路由的请求创建自定义回调。 mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // 自 v0.14 起 Content = new HtmlContent(\"<h1>Not found</h1>\") // 旧版本 Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; 方法不允许（405）回调处理程序 还可以为匹配其路径但不匹配方法的请求创建自定义回调。 mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; 内部错误处理程序 路由回调可以在服务器执行期间抛出错误。如果不正确处理，可能会终止 HTTP 服务器的整体功能。路由器具有一个回调，当路由回调失败并防止服务中断时将被调用。 此方法仅在 ThrowExceptions 设置为 false 时可达。 mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/cn/getting-started.html": {
    "href": "docs/cn/getting-started.html",
    "title": "开始使用 Sisk | Sisk",
    "keywords": "开始使用 Sisk Sisk 可以在任何 .NET 环境中运行。在本指南中，我们将教您如何使用 .NET 创建一个 Sisk 应用程序。如果您尚未安装它，请从 这里 下载 SDK。 在本教程中，我们将介绍如何创建项目结构、接收请求、获取 URL 参数和发送响应。本指南将重点介绍使用 C# 构建一个简单的服务器。您也可以使用您喜欢的编程语言。 Note 您可能对快速入门项目感兴趣。请查看 此仓库 以获取更多信息。 创建项目 让我们将我们的项目命名为\"My Sisk Application\"。一旦您设置了 .NET，您可以使用以下命令创建您的项目： dotnet new console -n my-sisk-application 接下来，导航到您的项目目录并使用 .NET 实用工具安装 Sisk： cd my-sisk-application dotnet add package Sisk.HttpServer 您可以在 这里 找到在项目中安装 Sisk 的其他方法。 现在，让我们创建一个 HTTP 服务器实例。对于这个示例，我们将配置它以监听端口 5000。 构建 HTTP 服务器 Sisk 允许您一步一步地手动构建您的应用程序，因为它路由到 HttpServer 对象。然而，这对于大多数项目来说可能不是很方便。因此，我们可以使用构建器方法，它使得让我们的应用程序启动变得更容易。 Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } 了解 Sisk 的每个重要组件至关重要。稍后在本文档中，您将了解更多关于 Sisk 的工作原理。 手动（高级）设置 您可以在文档的 此部分 中学习每个 Sisk 机制的工作原理，它解释了 HttpServer、Router、ListeningPort 和其他组件之间的行为和关系。"
  },
  "docs/cn/installing.html": {
    "href": "docs/cn/installing.html",
    "title": "安装 | Sisk",
    "keywords": "安装 您可以通过 Nuget、dotnet cli 或 其他选项 安装 Sisk。您可以通过在开发者控制台中运行以下命令轻松设置 Sisk 环境： Warning Sisk 的最新版本与 .NET 8 和即将发布的 .NET 9 兼容。Sisk 的旧版本（适用于 .NET 6 和 .NET 7）将在 2024 年 11 月 30 日之前维护，在 \"legacy\" 分支中仅接收安全补丁和修复。请将使用 Sisk 的项目更新到 .NET 8。 dotnet add package Sisk.HttpServer 此命令将在您的项目中安装 Sisk 的最新版本。"
  },
  "docs/cn/native-aot.html": {
    "href": "docs/cn/native-aot.html",
    "title": "原生 AOT 支持 | Sisk",
    "keywords": "原生 AOT 支持 在 .NET 7 中，原生 AOT 被引入，这是一种 .NET 编译模式，允许您在任何支持的平台上导出准备好的二进制文件，而无需在目标机器上安装 .NET 运行时。 使用原生 AOT，您的代码被编译为本机代码，并且已经包含了执行所需的一切。Sisk 从 0.9.1 版本开始尝试使用此功能，并通过提供定义动态路由的功能而不影响编译的警告消息来改进对原生 AOT 的支持。 Sisk 使用反射来获取将从类型和对象定义的方法。此外，Sisk 使用反射来获取诸如 RequestHandlerAttribute 之类的属性，这些属性从类型初始化。为了正常工作，AOT 编译使用修剪，其中动态类型应指定将在最终程序集中使用什么。 考虑以下示例，它是一个调用 RequestHandler 的路由。 [Route(RouteMethod.Get, \"/\", LogMode = LogOutput.None)] [RequestHandler(typeof(MyRequestHandler))] static HttpResponse IndexPage(HttpRequest request) { HttpResponse htmlResponse = new HttpResponse(); htmlResponse.Content = new StringContent(\"Hello, world!\", System.Text.Encoding.UTF8, \"text/plain\"); return htmlResponse; } 此 RequestHandler 在运行时动态调用，并且此调用必须被分段，并且此分段必须被显式地。 为了更好地理解编译器将从 MyRequestHandler 中保留什么内容以便在最终编译中使用： 公共属性； 公共和私有字段； 公共和私有构造函数； 公共和私有方法_; 您在 RequestHandler 中的任何内容如果不在上述列表中，都将被编译器删除。 请记住，您在应用程序中使用的所有其他组件、类和包都应与 AOT 修剪兼容，否则您的代码将无法按预期运行。另外，Sisk 将不会让您如果想要构建一个性能优先的东西。 您可以在官方的 Microsoft 文档 中阅读更多关于原生 AOT 和其工作原理的信息。"
  },
  "docs/cn/registering-namespace.html": {
    "href": "docs/cn/registering-namespace.html",
    "title": "在 Windows 上配置命名空间预留 | Sisk",
    "keywords": "在 Windows 上配置命名空间预留 Sisk 与 HttpListener 网络接口一起工作，将虚拟主机绑定到系统以侦听请求。 在 Windows 上，此绑定有一些限制，只允许将 localhost 绑定为有效主机。当尝试侦听另一个主机时，服务器会抛出访问被拒绝错误。此教程解释了如何授予在系统上侦听任何主机的授权。 Namespace Setup.bat BATCH @echo off :: 在这里插入前缀，不要包含空格或引号 SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause 在 PREFIX 中，是服务器将要侦听的前缀（“侦听主机->端口”）。它必须以 URL 方案、主机、端口和末尾斜杠的格式编写，例如： Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ 这样，您就可以通过以下方式在应用程序中侦听： Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/cn/ssl.html": {
    "href": "docs/cn/ssl.html",
    "title": "使用 SSL | Sisk",
    "keywords": "使用 SSL 在需要安全的开发环境中，例如大多数 Web 开发场景，使用 SSL 可能是必要的。Sisk 构建在 HttpListener 之上，HttpListener 不支持本地 HTTPS，只支持 HTTP。然而，有一些变通方法可以让你在 Sisk 中使用 SSL。请参见以下内容： 通过 IIS 在 Windows 上 支持平台：Windows 难度：中等 如果你在 Windows 上，你可以使用 IIS 来启用 HTTP 服务器的 SSL。为了使其生效，建议你先按照 此教程 进行操作，如果你想让你的应用程序监听其他主机而不是 \"localhost\"。 要使其生效，你必须通过 Windows 功能安装 IIS。IIS 对 Windows 和 Windows Server 用户免费。要在你的应用程序中配置 SSL，请准备好 SSL 证书，即使它是自签名的。接下来，你可以查看 如何在 IIS 7 或更高版本上设置 SSL。 通过 mitmproxy 支持平台：Linux、macOS、Windows 难度：简单 mitmproxy 是一个拦截代理工具，允许开发人员和安全测试人员检查、修改和记录客户端（如 Web 浏览器）和服务器之间的 HTTP 和 HTTPS 流量。你可以使用 mitmdump 实用程序在客户端和 Sisk 应用程序之间启动反向 SSL 代理。 首先，在你的机器上安装 mitmproxy。 启动你的 Sisk 应用程序。对于这个示例，我们将使用 8000 端口作为不安全的 HTTP 端口。 启动 mitmproxy 服务器以监听安全端口 8001： mitmdump --mode reverse:http://localhost:8000/ -p 8001 就这样！你可以通过 https://localhost:8001/ 访问你的应用程序。你的应用程序不需要运行才能启动 mitmdump。 通过 Sisk.SslProxy 包 支持平台：Linux、macOS、Windows 难度：简单 Sisk.SslProxy 包是启用 Sisk 应用程序 SSL 的一种简单方法。然而，它是一个 非常实验性 的包。使用这个包可能会不稳定，但你可以成为少数为使这个包可行和稳定做出贡献的人之一。要开始使用，你可以使用以下命令安装 Sisk.SslProxy 包： dotnet add package Sisk.SslProxy Note 你必须在 Visual Studio 包管理器中启用 \"启用预发布包\" 以安装 Sisk.SslProxy。 再次提醒，这是一个实验项目，所以不要考虑将其投入生产。 目前，Sisk.SslProxy 可以处理大多数 HTTP/1.1 功能，包括 HTTP Continue、Chunked-Encoding、WebSockets 和 SSE。请参阅 这里 了解更多关于 SslProxy 的信息。"
  },
  "docs/deploying.html": {
    "href": "docs/deploying.html",
    "title": "Deploying your Sisk Application | Sisk",
    "keywords": "Deploying your Sisk Application The process of deploying a Sisk application consists of publishing your project into production. Although the process is relatively simple, it is worth noting details that can be lethal to the security and stability of the deployment's infrastructure. Ideally, you should be ready to deploy your application to the cloud, after carrying out all possible tests to have your application ready. Publishing your app Publishing your Sisk application or service is generating binaries ready and optimized for production. In this example, we will compile the binaries for production to run on a machine that has the .NET Runtime installed on the machine. You will need .NET SDK installed in your machine in order to build your app, and .NET Runtime installed on the target server to run your app. You can learn how to install .NET Runtime in your Linux server here, Windows and Mac OS. In the folder where your project is located, open a terminal and use the .NET publish command: $ dotnet publish -r linux-x64 -c Release This will generate your binaries inside bin/Release/publish/linux-x64. Note If your app is running using Sisk.ServiceProvider package, you should copy your service-config.json into your host server along all binaries generated by dotnet publish. You can leave the file preconfigured, with environment variables, listening ports and hosts, and additional server configurations. The next step is to take these files to the server where your application will be hosted. After that, give execution permissions to your binary file. In this case, let's consider that our project name is \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app After running your application, check to see if it produces any error messages. If it didn't produce, it's because your application is running. At this point, it will probably not be possible to access your application by external net ouside your server, as access rules such as Firewall have not been configured. We will consider this in the next steps. You should have the address of the virtual host where your application is listening to. This is set manually in the application, and depends on how you are instantiating your Sisk service. If you're not using the Sisk.ServiceProvider package, you should find it where you defined your HttpServer instance: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk should listen on http://localhost:5000/ Associating an ListeningHost manually: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Or if you're using the Sisk.ServiceProvider package, in your service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } From this, we can create a reverse proxy to listen to your service and make the traffic available over the open network. Proxying your application Proxying your service means not directly exposing your Sisk service to an external network. This practice is very common for server deployments because: Allows you to associate an SSL certificate in your application; Create access rules before accessing the service and avoid overloads; Control bandwidth and request limits; Separate load-balancers for your application; Prevent security damage to failing infrastructure. You can serve your application through a reverse proxy like Nginx or Apache, or you can use an http-over-dns tunnel like Cloudflared. Also, remember to correctly resolve your proxy's forwarding headers to obtain your client's information, such as IP address and host, through forwarding resolvers. The next step after creating your tunnel, firewall configuration and having your application running, is to create a service for your application. Note Using SSL certificates directly in the Sisk service on non-Windows systems is not possible. This is a point of the implementation of HttpListener, which is the central module for how HTTP queue management is done in Sisk, and this implementation varies from operating system to operating system. You can use SSL in your Sisk service if you associate a certificate with the virtual host with IIS. For other systems, using a reverse proxy is highly recommended. Creating an service Creating a service will make your application always available, even after restarting your server instance or a non-recoverable crash. In this simple tutorial, we will use the content from the previous tutorial as a showcase to keep your service always active. Access the folder where the service configuration files are located: cd /etc/systemd/system Create your my-app.service file and include the contents: my-app.service INI [Unit] Description=<description about your app> [Service] # set the user which will launch the service on User=<user which will launch the service> # the ExecStart path is not relative to WorkingDirectory. # set it as the full path to the executeable file WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # set the service to always restart on crash Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Restart your service manager module: $ sudo systemctl daemon-reload Start your new created service from the name of the file you set and check if they are running: $ sudo systemctl start my-app $ sudo systemctl status my-app Now if your app is running (\"Active: active\"), enable your service to keep run after an system reboot: $ sudo systemctl enable my-app Now you're ready to go and present your Sisk application to everyone."
  },
  "docs/es/advanced/forwarding-resolvers.html": {
    "href": "docs/es/advanced/forwarding-resolvers.html",
    "title": "Resolutores de Reenvío | Sisk",
    "keywords": "Resolutores de Reenvío Un Resolutor de Reenvío es un ayudante que ayuda a decodificar la información que identifica al cliente a través de una solicitud, proxy, CDN o balanceadores de carga. Cuando su servicio Sisk se ejecuta a través de un proxy inverso o directo, la dirección IP del cliente, el host y el protocolo pueden ser diferentes de la solicitud original, ya que es un reenvío de un servicio a otro. Esta funcionalidad de Sisk le permite controlar y resolver esta información antes de trabajar con la solicitud. Estos proxies suelen proporcionar encabezados útiles para identificar a su cliente. Actualmente, con la clase ForwardingResolver, es posible resolver la dirección IP del cliente, el host y el protocolo HTTP utilizado. Después de la versión 1.0 de Sisk, el servidor ya no tiene una implementación estándar para decodificar estos encabezados por razones de seguridad que varían de servicio a servicio. Por ejemplo, el encabezado X-Forwarded-For incluye información sobre las direcciones IP que reenviaron la solicitud. Este encabezado es utilizado por los proxies para transportar una cadena de información al servicio final e incluye la dirección IP de todos los proxies utilizados, incluyendo la dirección real del cliente. El problema es: a veces es difícil identificar la dirección IP remota del cliente y no hay una regla específica para identificar este encabezado. Se recomienda encarecidamente leer la documentación de los encabezados que se van a implementar a continuación: Lea sobre el encabezado X-Forwarded-For aquí. Lea sobre el encabezado X-Forwarded-Host aquí. Lea sobre el encabezado X-Forwarded-Proto aquí. La clase ForwardingResolver Esta clase tiene tres métodos virtuales que permiten la implementación más adecuada para cada servicio. Cada método es responsable de resolver la información de la solicitud a través de un proxy: la dirección IP del cliente, el host de la solicitud y el protocolo de seguridad utilizado. Por defecto, Sisk siempre utilizará la información de la solicitud original, sin resolver ningún encabezado. El ejemplo a continuación muestra cómo se puede utilizar esta implementación. Este ejemplo resuelve la dirección IP del cliente a través del encabezado X-Forwarded-For y lanza un error cuando se reenvían más de una dirección IP en la solicitud. Important No utilice este ejemplo en código de producción. Siempre verifique si la implementación es adecuada para su uso. Lea la documentación del encabezado antes de implementarlo. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"El encabezado X-Forwarded-For está ausente.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Demasiadas direcciones en el encabezado X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/es/advanced/http-server-handlers.html": {
    "href": "docs/es/advanced/http-server-handlers.html",
    "title": "Controladores de servidor HTTP | Sisk",
    "keywords": "Controladores de servidor HTTP En la versión 0.16 de Sisk, se ha introducido la clase HttpServerHandler, que tiene como objetivo ampliar el comportamiento general de Sisk y proporcionar controladores de eventos adicionales a Sisk, como el manejo de solicitudes HTTP, enrutadores, bolsas de contexto y más. La clase concentra los eventos que ocurren durante la vida útil de todo el servidor HTTP y también de una solicitud. El protocolo HTTP no tiene sesiones, y por lo tanto no es posible conservar información de una solicitud a otra. Sisk proporciona por ahora una forma de implementar sesiones, contextos, conexiones de base de datos y otros proveedores útiles para ayudar en su trabajo. Consulte esta página para leer dónde se desencadena cada evento y cuál es su propósito. También puede ver el ciclo de vida de una solicitud HTTP para entender qué sucede con una solicitud y dónde se disparan los eventos. El servidor HTTP permite utilizar varios controladores al mismo tiempo. Cada llamada a un evento es síncrona, es decir, bloqueará el subproceso actual para cada solicitud o contexto hasta que todos los controladores asociados con esa función se ejecuten y completen. A diferencia de los controladores de solicitudes, no se pueden aplicar a grupos de rutas o rutas específicas. En su lugar, se aplican a todo el servidor HTTP. Puede aplicar condiciones dentro de su controlador de servidor HTTP. Además, se definen singletones de cada HttpServerHandler para cada aplicación Sisk, por lo que solo se define una instancia por HttpServerHandler. Un ejemplo práctico de uso de HttpServerHandler es para desechar automáticamente una conexión de base de datos al final de la solicitud. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // comprueba si la solicitud ha definido un DbContext // en su bolsa de contexto if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // permite al usuario crear un contexto de base de datos a partir de una solicitud HTTP // y almacenarlo en su bolsa de contexto public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } Con el código anterior, la extensión GetDbContext permite crear un contexto de conexión directamente desde el objeto HttpRequest. Una conexión no desechar puede causar problemas al ejecutar con la base de datos, por lo que se termina en OnHttpRequestClose. Puede registrar un controlador en un servidor HTTP en su constructor o directamente con HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } Con esto, la clase UsersController puede utilizar el contexto de base de datos como: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Usuario agregado.\"); } } El código anterior utiliza métodos como JsonOk y JsonMessage que están integrados en ApiController, que hereda de RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Los desarrolladores pueden implementar sesiones, contextos y conexiones de base de datos utilizando esta clase. El código proporcionado muestra un ejemplo práctico con el DatabaseConnectionHandler, automatizando el descarte de la conexión de base de datos al final de cada solicitud. La integración es sencilla, con controladores registrados durante la configuración del servidor. La clase HttpServerHandler ofrece un conjunto de herramientas poderosas para administrar recursos y ampliar el comportamiento de Sisk en aplicaciones HTTP."
  },
  "docs/es/advanced/manual-setup.html": {
    "href": "docs/es/advanced/manual-setup.html",
    "title": "Configuración manual (avanzada) | Sisk",
    "keywords": "Configuración manual (avanzada) En esta sección, crearemos nuestro servidor HTTP sin ningún estándar predefinido, de una manera completamente abstracta. Aquí, puedes construir manualmente cómo funcionará tu servidor HTTP. Cada ListeningHost tiene un enrutador, y un servidor HTTP puede tener varios ListeningHosts, cada uno apuntando a un host diferente en un puerto diferente. Primero, necesitamos entender el concepto de solicitud/respuesta. Es bastante simple: para cada solicitud, debe haber una respuesta. Sisk sigue este principio también. Creemos un método que responda con un mensaje \"Hola, mundo!\" en HTML, especificando el código de estado y los encabezados. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Hola, mundo!</h1> </body> </html> \") }; return indexResponse; } El siguiente paso es asociar este método con una ruta HTTP. Enrutadores Los enrutadores son abstracciones de rutas de solicitud y sirven como el puente entre solicitudes y respuestas para el servicio. Los enrutadores gestionan las rutas del servicio, las funciones y los errores. Un enrutador puede tener varias rutas, y cada ruta puede realizar diferentes operaciones en esa ruta, como ejecutar una función, servir una página o proporcionar un recurso desde el servidor. Creemos nuestro primer enrutador y asociemos nuestro método IndexPage con la ruta de índice. Router mainRouter = new Router(); // SetRoute asociará todas las rutas de índice con nuestro método. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Ahora nuestro enrutador puede recibir solicitudes y enviar respuestas. Sin embargo, mainRouter no está vinculado a un host o un servidor, por lo que no funcionará por sí solo. El siguiente paso es crear nuestro ListeningHost. Hosts y puertos de escucha Un ListeningHost puede hospedar un enrutador y varios puertos de escucha para el mismo enrutador. Un ListeningPort es un prefijo donde el servidor HTTP escuchará. Aquí, podemos crear un ListeningHost que apunte a dos puntos finales para nuestro enrutador: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Ahora nuestro servidor HTTP escuchará en los puntos finales especificados y redirigirá sus solicitudes a nuestro enrutador. Configuración del servidor La configuración del servidor es responsable de la mayoría del comportamiento del servidor HTTP en sí. En esta configuración, podemos asociar ListeningHosts con nuestro servidor. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Agregue nuestro ListeningHost a esta configuración del servidor A continuación, podemos crear nuestro servidor HTTP: HttpServer server = new HttpServer(config); server.Start(); // Inicia el servidor Console.ReadKey(); // Evita que la aplicación se cierre Ahora podemos compilar nuestro ejecutable y ejecutar nuestro servidor HTTP con el comando: dotnet watch En tiempo de ejecución, abra su navegador y navegue hasta la ruta del servidor, y debería ver:"
  },
  "docs/es/advanced/multi-host-setup.html": {
    "href": "docs/es/advanced/multi-host-setup.html",
    "title": "Varios hosts de escucha por servidor | Sisk",
    "keywords": "Varios hosts de escucha por servidor El Framework Sisk siempre ha soportado el uso de más de un host por servidor, es decir, un solo servidor HTTP puede escuchar en varios puertos y cada puerto tiene su propio enrutador y su propio servicio ejecutándose en él. De esta manera, es fácil separar responsabilidades y gestionar servicios en un solo servidor HTTP con Sisk. El ejemplo a continuación muestra la creación de dos ListeningHosts, cada uno escuchando en un puerto diferente, con diferentes enrutadores y acciones. Lea creación manual de su aplicación para entender los detalles sobre esta abstracción. static void Main(string[] args) { // crea dos hosts de escucha, cada uno con su propio enrutador y // escuchando en su propio puerto // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hola desde el host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Hola desde el host B!\")); // crea una configuración de servidor y agrega ambos // hosts de escucha en ella // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // crea un servidor HTTP que utiliza la configuración // especificada // HttpServer server = new HttpServer(configuration); // inicia el servidor server.Start(); Console.WriteLine(\"Intente llegar al host A en {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Intente llegar al host B en {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/es/advanced/request-lifecycle.html": {
    "href": "docs/es/advanced/request-lifecycle.html",
    "title": "Ciclo de solicitud | Sisk",
    "keywords": "Ciclo de solicitud Este diagrama explica el proceso de vida de una solicitud HTTP desde el momento en que llega al servidor hasta que se entrega al cliente."
  },
  "docs/es/changelogs.html": {
    "href": "docs/es/changelogs.html",
    "title": "Registros de cambios | Sisk",
    "keywords": "Registros de cambios Cada cambio realizado en Sisk se registra a través del registro de cambios. Puedes ver los registros de cambios para todas las versiones de Sisk aquí."
  },
  "docs/es/deploying.html": {
    "href": "docs/es/deploying.html",
    "title": "Desplegando tu Aplicación Sisk | Sisk",
    "keywords": "Desplegando tu Aplicación Sisk El proceso de desplegar una aplicación Sisk consiste en publicar tu proyecto en producción. Aunque el proceso es relativamente simple, es importante tener en cuenta detalles que pueden ser letales para la seguridad y la estabilidad de la infraestructura de despliegue. Idealmente, debes estar listo para desplegar tu aplicación en la nube, después de realizar todas las pruebas posibles para tener tu aplicación lista. Publicando tu aplicación Publicar tu aplicación o servicio Sisk es generar binarios listos y optimizados para producción. En este ejemplo, compilaremos los binarios para producción para ejecutarlos en una máquina que tenga el tiempo de ejecución de .NET instalado. Necesitarás tener el SDK de .NET instalado en tu máquina para compilar tu aplicación, y el tiempo de ejecución de .NET instalado en el servidor objetivo para ejecutar tu aplicación. Puedes aprender a instalar el tiempo de ejecución de .NET en tu servidor Linux aquí, Windows y Mac OS. En la carpeta donde se encuentra tu proyecto, abre una terminal y utiliza el comando de publicación de .NET: $ dotnet publish -r linux-x64 -c Release Esto generará tus binarios dentro de bin/Release/publish/linux-x64. Note Si tu aplicación se ejecuta utilizando el paquete Sisk.ServiceProvider, debes copiar tu archivo service-config.json en tu servidor de host junto con todos los binarios generados por dotnet publish. Puedes dejar el archivo preconfigurado, con variables de entorno, puertos y hosts de escucha, y configuraciones de servidor adicionales. El siguiente paso es trasladar estos archivos al servidor donde se hospedará tu aplicación. Después de eso, da permisos de ejecución a tu archivo binario. En este caso, consideremos que el nombre de nuestro proyecto es \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app Después de ejecutar tu aplicación, verifica si produce algún mensaje de error. Si no produce ninguno, es porque tu aplicación se está ejecutando. En este punto, es probable que no sea posible acceder a tu aplicación desde la red externa fuera de tu servidor, ya que no se han configurado las reglas de acceso como el Firewall. Consideraremos esto en los siguientes pasos. Debes tener la dirección del host virtual donde tu aplicación está escuchando. Esto se establece manualmente en la aplicación y depende de cómo estás instanciando tu servicio Sisk. Si no estás utilizando el paquete Sisk.ServiceProvider, debes encontrarla donde definiste tu instancia de HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk debe escuchar en http://localhost:5000/ Asociando un ListeningHost manualmente: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); O si estás utilizando el paquete Sisk.ServiceProvider, en tu archivo service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } A partir de esto, podemos crear un proxy inverso para escuchar a tu servicio y hacer que el tráfico esté disponible en la red abierta. Proxyando tu aplicación Proxyar tu servicio significa no exponer directamente tu servicio Sisk a una red externa. Esta práctica es muy común para despliegues de servidor porque: Permite asociar un certificado SSL en tu aplicación; Crea reglas de acceso antes de acceder al servicio y evita sobrecargas; Controla el ancho de banda y los límites de solicitudes; Separa los equilibradores de carga para tu aplicación; Evita daños de seguridad a la infraestructura fallida. Puedes servir tu aplicación a través de un proxy inverso como Nginx o Apache, o puedes utilizar un túnel http-over-dns como Cloudflared. También recuerda resolver correctamente los encabezados de reenvío de tu proxy para obtener la información del cliente, como la dirección IP y el host, a través de resolutores de reenvío. El siguiente paso después de crear tu túnel, configurar el firewall y tener tu aplicación en ejecución, es crear un servicio para tu aplicación. Note Utilizar certificados SSL directamente en el servicio Sisk en sistemas no Windows no es posible. Esto es un punto de la implementación de HttpListener, que es el módulo central para la gestión de la cola de HTTP en Sisk, y esta implementación varía de un sistema operativo a otro. Puedes utilizar SSL en tu servicio Sisk si asocias un certificado con el host virtual con IIS. Para otros sistemas, se recomienda altamente utilizar un proxy inverso. Creando un servicio Crear un servicio hará que tu aplicación esté siempre disponible, incluso después de reiniciar tu instancia de servidor o un bloqueo no recuperable. En este tutorial simple, utilizaremos el contenido del tutorial anterior como una demostración para mantener tu servicio siempre activo. Accede a la carpeta donde se encuentran los archivos de configuración del servicio: cd /etc/systemd/system Crea tu archivo my-app.service e incluye el contenido: my-app.service INI [Unit] Description=<descripción sobre tu aplicación> [Service] # establece el usuario que lanzará el servicio User=<usuario que lanzará el servicio> # la ruta de ExecStart no es relativa a WorkingDirectory. # establecela como la ruta completa al archivo ejecutable WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # establece el servicio para que siempre se reinicie en caso de bloqueo Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Reinicia el módulo de administración de servicios: $ sudo systemctl daemon-reload Inicia tu servicio recién creado desde el nombre del archivo que estableciste y verifica si se está ejecutando: $ sudo systemctl start my-app $ sudo systemctl status my-app Ahora, si tu aplicación se está ejecutando (\"Active: active\"), habilita tu servicio para que se mantenga en ejecución después de un reinicio del sistema: $ sudo systemctl enable my-app Ahora estás listo para presentar tu aplicación Sisk a todos."
  },
  "docs/es/extensions/basic-auth.html": {
    "href": "docs/es/extensions/basic-auth.html",
    "title": "Autenticación Básica | Sisk",
    "keywords": "Autenticación Básica El paquete de Autenticación Básica agrega un controlador de solicitudes capaz de manejar el esquema de autenticación básica en su aplicación Sisk con muy poca configuración y esfuerzo. La autenticación HTTP básica es una forma minimalista de autenticar solicitudes mediante un identificador de usuario y una contraseña, donde la sesión es controlada exclusivamente por el cliente y no hay tokens de autenticación o acceso. Lea más sobre el esquema de autenticación básica en la especificación de MDN. Instalación Para empezar, instale el paquete Sisk.BasicAuth en su proyecto: > dotnet add package Sisk.BasicAuth Puede ver más formas de instalarlo en su proyecto en el repositorio de Nuget. Creación de su controlador de autenticación Puede controlar el esquema de autenticación para un módulo completo o para rutas individuales. Para ello, primero escribamos nuestro primer controlador de autenticación básica. En el ejemplo a continuación, se establece una conexión con la base de datos, se verifica si el usuario existe y si la contraseña es válida, y después de eso, se almacena el usuario en la bolsa de contexto. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Para entrar en esta página, por favor, informe sus credenciales.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // en este caso, estamos utilizando el correo electrónico como el campo de identificador de usuario, así que // vamos a buscar un usuario utilizando su correo electrónico. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Lo sentimos, no se encontró ningún usuario con este correo electrónico.\"); } // valida que la contraseña de las credenciales sea válida para este usuario. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Credenciales inválidas.\"); } // agrega el usuario conectado a la bolsa de contexto // y continúa la ejecución context.Bag.Add(\"loggedUser\", user); return null; } } Así que solo asocie este controlador de solicitudes con nuestra ruta o clase. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hola, \" + loggedUser.Name + \"!\"; } } O utilizando la clase RouterModule: public class UsersController : RouterModule { public ClientModule() { // ahora todas las rutas dentro de esta clase serán manejadas por // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hola, \" + loggedUser.Name + \"!\"; } } Observaciones La responsabilidad principal de la autenticación básica se lleva a cabo en el lado del cliente. El almacenamiento, el control de caché, y el cifrado se manejan localmente en el cliente. El servidor solo recibe las credenciales y valida si se permite o no el acceso. Tenga en cuenta que este método no es uno de los más seguros porque coloca una gran responsabilidad en el cliente, lo que puede ser difícil de rastrear y mantener la seguridad de sus credenciales. Además, es fundamental que las contraseñas se transmitan en un contexto de conexión segura (SSL), ya que no tienen cifrado inherente. Una breve intercepción en los encabezados de una solicitud puede exponer las credenciales de acceso de su usuario. Opte por soluciones de autenticación más robustas para aplicaciones en producción y evite utilizar demasiados componentes prefabricados, ya que pueden no adaptarse a las necesidades de su proyecto y terminar exponiéndolo a riesgos de seguridad."
  },
  "docs/es/extensions/ini-configuration.html": {
    "href": "docs/es/extensions/ini-configuration.html",
    "title": "Proveedor de configuración INI | Sisk",
    "keywords": "Proveedor de configuración INI Sisk tiene un método para obtener configuraciones de inicio diferentes a JSON. De hecho, cualquier canal que implemente IConfigurationReader se puede utilizar con PortableConfigurationBuilder.WithConfigurationPipeline, leyendo la configuración del servidor desde cualquier tipo de archivo. El paquete Sisk.IniConfiguration proporciona un lector de archivos INI basado en flujo que no lanza excepciones por errores de sintaxis comunes y tiene una sintaxis de configuración simple. Este paquete se puede utilizar fuera del marco de Sisk, ofreciendo flexibilidad para proyectos que requieren un lector de documentos INI eficiente. Instalación Para instalar el paquete, puede comenzar con: $ dotnet add package Sisk.IniConfiguration También puede instalar el paquete principal, que no incluye el lector de configuración INI IConfigurationReader, ni la dependencia de Sisk, solo los serializadores INI: $ dotnet add package Sisk.IniConfiguration.Core Con el paquete principal, puede utilizarlo en su código como se muestra en el ejemplo a continuación: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // utiliza el lector de configuración IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } El código anterior buscará un archivo app.ini en el directorio actual del proceso (CurrentDirectory). El archivo INI se ve así: [Server] # Se admiten varias direcciones de escucha Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Sabor y sintaxis INI Implementación actual del sabor: Los nombres de propiedades y secciones son insensibles a mayúsculas y minúsculas. Los nombres de propiedades y valores son recortados, a menos que los valores estén entre comillas. Los valores pueden estar entre comillas simples o dobles. Las comillas pueden tener saltos de línea dentro de ellas. Se admiten comentarios con # y ;. También se admiten comentarios al final. Las propiedades pueden tener varios valores. En detalle, la documentación para el \"sabor\" del analizador INI utilizado en Sisk está disponible en este documento. Utilizando el siguiente código INI como ejemplo: One = 1 Value = this is an value Another value = \"this value has an line break on it\" ; el código a continuación tiene algunos colores [some section] Color = Red Color = Blue Color = Yellow ; no use yellow Analícelo con: // analice el texto INI desde la cadena IniDocument doc = IniDocument.FromString(iniText); // obtenga un valor string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // obtenga varios valores string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Parámetros de configuración Sección y nombre Admite varios valores Descripción Server.Listen Sí Las direcciones/puertos de escucha del servidor. Server.Encoding No La codificación predeterminada del servidor. Server.MaximumContentLength No El tamaño máximo de contenido en bytes del servidor. Server.IncludeRequestIdHeader No Especifica si el servidor HTTP debe enviar el encabezado X-Request-Id. Server.ThrowExceptions No Especifica si las excepciones no controladas deben lanzarse. Server.AccessLogsStream No Especifica la secuencia de salida de registros de acceso. Server.ErrorsLogsStream No Especifica la secuencia de salida de registros de errores. Cors.AllowMethods No Especifica el valor del encabezado CORS Allow-Methods. Cors.AllowHeaders No Especifica el valor del encabezado CORS Allow-Headers. Cors.AllowOrigins No Especifica varios encabezados Allow-Origin, separados por comas. AllowOrigins para más información. Cors.AllowOrigin No Especifica un encabezado Allow-Origin. Cors.ExposeHeaders No Especifica el valor del encabezado CORS Expose-Headers. Cors.AllowCredentials No Especifica el valor del encabezado CORS Allow-Credentials. Cors.MaxAge No Especifica el valor del encabezado CORS Max-Age."
  },
  "docs/es/extensions/json-rpc.html": {
    "href": "docs/es/extensions/json-rpc.html",
    "title": "Extensión JSON-RPC | Sisk",
    "keywords": "Extensión JSON-RPC Sisk tiene un módulo experimental para una API JSON-RPC 2.0, que te permite crear aplicaciones aún más simples. Esta extensión implementa estrictamente la interfaz de transporte JSON-RPC 2.0 y ofrece transporte a través de HTTP GET, solicitudes POST y también web-sockets con Sisk. Puedes instalar la extensión a través de Nuget con el comando siguiente. Ten en cuenta que, en versiones experimentales/beta, debes habilitar la opción para buscar paquetes prelanzamiento en Visual Studio. dotnet add package Sisk.JsonRpc Interfaz de transporte JSON-RPC es un protocolo de ejecución remota de procedimientos (RDP) sin estado y asíncrono que utiliza JSON para la comunicación de datos unidireccional. Una solicitud JSON-RPC se identifica típicamente por un ID, y una respuesta se entrega con el mismo ID que se envió en la solicitud. No todas las solicitudes requieren una respuesta, que se llaman \"notificaciones\". La especificación JSON-RPC 2.0 explica en detalle cómo funciona el transporte. Este transporte es agnóstico de dónde se utilizará. Sisk implementa este protocolo a través de HTTP, siguiendo las conformidades de JSON-RPC sobre HTTP, que admite parcialmente las solicitudes GET, pero admite completamente las solicitudes POST. También se admiten los web-sockets, que proporcionan una comunicación de mensajes asíncrona. Una solicitud JSON-RPC se parece a: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } Y una respuesta exitosa se parece a: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Métodos JSON-RPC El siguiente ejemplo muestra cómo crear una API JSON-RPC utilizando Sisk. Una clase de operaciones matemáticas realiza las operaciones remotas y entrega la respuesta serializada al cliente. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // agregar todos los métodos con la etiqueta WebMethod al controlador JSON-RPC args.Handler.Methods.AddMethodsFromType(new MathOperations()); // asigna la ruta /service para manejar solicitudes JSON-RPC POST y GET args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // crea un controlador de web-sockets en GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } El ejemplo anterior asignará los métodos Sum y Sqrt al controlador JSON-RPC, y estos métodos estarán disponibles en GET /service, POST /service y GET /ws. Los nombres de los métodos son insensibles a mayúsculas y minúsculas. Los parámetros de los métodos se deserializan automáticamente en sus tipos específicos. También se admite el uso de parámetros con nombre en las solicitudes. La serialización JSON se realiza mediante la biblioteca LightJson. Cuando un tipo no se deserializa correctamente, puedes crear un convertidor JSON personalizado para ese tipo y asociarlo con tus opciones de serializador JSON más adelante. También puedes obtener el objeto $.params crudo de la solicitud JSON-RPC directamente en tu método. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Para que esto ocurra, @params debe ser el único parámetro en tu método, con exactamente el nombre params (en C#, el @ es necesario para escapar este nombre de parámetro). La deserialización de parámetros ocurre tanto para objetos con nombre como para matrices posicionales. Por ejemplo, el siguiente método se puede llamar de forma remota mediante ambas solicitudes: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Para una matriz, el orden de los parámetros debe seguirse. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Personalización del serializador Puedes personalizar el serializador JSON en la propiedad JsonRpcHandler.JsonSerializerOptions. En esta propiedad, puedes habilitar el uso de JSON5 para deserializar mensajes. Aunque no es una conformidad con JSON-RPC 2.0, JSON5 es una extensión de JSON que permite una escritura más legible y humana. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // utiliza un comparador de nombres sanitizado. este comparador compara solo letras // y dígitos en un nombre, y descarta otros símbolos. por ejemplo: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // habilita JSON5 para el intérprete JSON. incluso activando esto, el JSON plano todavía se admite e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // asigna la ruta POST /service al controlador JSON-RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/es/extensions/service-providers.html": {
    "href": "docs/es/extensions/service-providers.html",
    "title": "Proveedores de Servicios | Sisk",
    "keywords": "Proveedores de Servicios Los Proveedores de Servicios son una forma de portar su aplicación Sisk a diferentes entornos con un archivo de configuración portátil. Esta característica permite cambiar el puerto del servidor, parámetros y otras opciones sin tener que modificar el código de la aplicación para cada entorno. Este módulo depende de la sintaxis de construcción de Sisk y se puede configurar a través del método UsePortableConfiguration. Un proveedor de configuración se implementa con IConfigurationProvider, que proporciona un lector de configuración y puede recibir cualquier implementación. Por defecto, Sisk proporciona un lector de configuración JSON, pero también hay un paquete para archivos INI. También puede crear su propio proveedor de configuración y registrararlo con: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Como se mencionó anteriormente, el proveedor predeterminado es un archivo JSON. Por defecto, el nombre del archivo que se busca es service-config.json, y se busca en el directorio actual del proceso en ejecución, no en el directorio del ejecutable. Puede elegir cambiar el nombre del archivo, así como dónde Sisk debe buscar el archivo de configuración, con: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); El código anterior buscará el archivo config.toml en el directorio actual del proceso en ejecución. Si no se encuentra, luego buscará en el directorio donde se encuentra el ejecutable. Si el archivo no existe, el parámetro createIfDontExists se honra, creando el archivo, sin contenido, en la última ruta de acceso probada (basada en lookupDirectories), y se lanza un error en la consola, evitando que la aplicación se inicialice. Tip Puede ver el código fuente del lector de configuración INI y el lector de configuración JSON para entender cómo se implementa un IConfigurationProvider. Lectura de configuraciones desde un archivo JSON Por defecto, Sisk proporciona un proveedor de configuración que lee configuraciones desde un archivo JSON. Este archivo sigue una estructura fija y está compuesto por los siguientes parámetros: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"Mi aplicación Sisk\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Los archivos de configuración también admiten comentarios ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // Nuevo en 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Los parámetros creados a partir de un archivo de configuración se pueden acceder en el constructor del servidor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Cada lector de configuración proporciona una forma de leer los parámetros de inicialización del servidor. Algunas propiedades se indican que deben estar en el entorno del proceso en lugar de estar definidas en el archivo de configuración, como datos de API sensibles, claves de API, etc. Estructura del archivo de configuración El archivo de configuración JSON está compuesto por las siguientes propiedades: Propiedad Obligatorio Descripción Server Requerido Representa el servidor en sí con sus configuraciones. Server.AccessLogsStream Opcional Por defecto, es console. Especifica la secuencia de salida de los registros de acceso. Puede ser un nombre de archivo, null o console. Server.ErrorsLogsStream Opcional Por defecto, es null. Especifica la secuencia de salida de los registros de errores. Puede ser un nombre de archivo, null o console. Server.MaximumContentLength Opcional Server.MaximumContentLength Opcional Por defecto, es 0. Especifica la longitud máxima de contenido en bytes. Cero significa infinito. Server.IncludeRequestIdHeader Opcional Por defecto, es false. Especifica si el servidor HTTP debe enviar el encabezado X-Request-Id. Server.ThrowExceptions Opcional Por defecto, es true. Especifica si las excepciones no controladas deben lanzarse. Establezca en false cuando esté en producción y true cuando esté depurando. ListeningHost Requerido Representa el host de escucha del servidor. ListeningHost.Label Opcional Representa la etiqueta de la aplicación. ListeningHost.Ports Requerido Representa una matriz de cadenas, que coincide con la sintaxis de ListeningPort. ListeningHost.CrossOriginResourceSharingPolicy Opcional Configura los encabezados CORS para la aplicación. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Opcional Por defecto, es false. Especifica el encabezado Allow-Credentials. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Expose-Headers. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Opcional Por defecto, es null. Esta propiedad espera una cadena. Especifica el encabezado Allow-Origin. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica múltiples encabezados Allow-Origin. Consulte AllowOrigins para obtener más información. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Allow-Methods. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Opcional Por defecto, es null. Esta propiedad espera una matriz de cadenas. Especifica el encabezado Allow-Headers. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Opcional Por defecto, es null. Esta propiedad espera un entero. Especifica el encabezado Max-Age en segundos. ListeningHost.Parameters Opcional Especifica las propiedades proporcionadas al método de configuración de la aplicación."
  },
  "docs/es/extensions/ssl-proxy.html": {
    "href": "docs/es/extensions/ssl-proxy.html",
    "title": "Proxy SSL | Sisk",
    "keywords": "Proxy SSL Warning Esta característica es experimental y no debe usarse en producción. Por favor, consulte este documento si desea hacer que Sisk funcione con SSL. El Proxy SSL de Sisk es un módulo que proporciona una conexión HTTPS para un ListeningHost en Sisk y enruta los mensajes HTTPS a un contexto HTTP inseguro. El módulo se creó para proporcionar una conexión SSL para un servicio que utiliza HttpListener para ejecutarse, que no admite SSL. El proxy se ejecuta dentro de la misma aplicación y escucha los mensajes HTTP/1.1, reenviándolos en el mismo protocolo a Sisk. Actualmente, esta característica es muy experimental y puede ser lo suficientemente inestable como para no usarse en producción. En la actualidad, el SslProxy admite casi todas las características de HTTP/1.1, como keep-alive, codificación chunked, websockets, etc. Para una conexión abierta al proxy SSL, se crea una conexión TCP al servidor de destino y el proxy se reenvía a la conexión establecida. El SslProxy se puede utilizar con HttpServer.CreateBuilder de la siguiente manera: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hola, mundo!\"); }); }) // agregar SSL al proyecto .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Debes proporcionar un certificado SSL válido para el proxy. Para asegurarte de que el certificado sea aceptado por los navegadores, recuerda importarlo en el sistema operativo para que funcione correctamente."
  },
  "docs/es/features/discard-syntax.html": {
    "href": "docs/es/features/discard-syntax.html",
    "title": "Sintaxis de descarte | Sisk",
    "keywords": "Sintaxis de descarte El servidor HTTP se puede utilizar para escuchar una solicitud de devolución de llamada desde una acción, como la autenticación OAuth, y se puede descartar después de recibir esa solicitud. Esto puede ser útil en casos donde necesite una acción en segundo plano pero no desee configurar una aplicación HTTP completa para ello. El siguiente ejemplo muestra cómo crear un servidor HTTP de escucha en el puerto 5555 con CreateListener y esperar el siguiente contexto: using (var server = HttpServer.CreateListener(5555)) { // espera la próxima solicitud HTTP var context = await server.WaitNextAsync(); Console.WriteLine($\"Ruta solicitada: {context.Request.Path}\"); } La función WaitNext espera el próximo contexto de un procesamiento de solicitud completado. Una vez que se obtiene el resultado de esta operación, el servidor ya ha procesado completamente la solicitud y ha enviado la respuesta al cliente."
  },
  "docs/es/features/instancing.html": {
    "href": "docs/es/features/instancing.html",
    "title": "Inyección de dependencias | Sisk",
    "keywords": "Inyección de dependencias Es común dedicar miembros e instancias que duran toda la vida de una solicitud, como una conexión a una base de datos, un usuario autenticado o un token de sesión. Una de las posibilidades es a través de HttpContext.RequestBag, que crea un diccionario que dura toda la vida de una solicitud. Este diccionario se puede acceder desde manejadores de solicitudes y definir variables a lo largo de esa solicitud. Por ejemplo, un manejador de solicitudes que autentica a un usuario establece este usuario dentro de HttpContext.RequestBag, y dentro de la lógica de la solicitud, este usuario se puede recuperar con HttpContext.RequestBag.Get<User>(). Aquí hay un ejemplo: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // avanzar a la siguiente solicitud de manejo o lógica de solicitud } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hola {authenticatedUser.Name}!\") }; } Este es un ejemplo preliminar de esta operación. La instancia de User se creó dentro del manejador de solicitudes dedicado a la autenticación, y todas las rutas que utilizan este manejador de solicitudes tendrán la garantía de que habrá un User en su instancia de HttpContext.RequestBag. Es posible definir lógica para obtener instancias cuando no se han definido previamente en RequestBag a través de métodos como GetOrAdd o GetOrAddAsync. Desde la versión 1.3, se introdujo la propiedad estática HttpContext.Current, que permite acceder al HttpContext actualmente en ejecución del contexto de la solicitud. Esto permite exponer miembros del HttpContext fuera de la solicitud actual y definir instancias en objetos de rutas. El ejemplo siguiente define un controlador que tiene miembros comúnmente accedidos por el contexto de una solicitud. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // crear un DbContext o obtener el existente return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // la siguiente línea lanzará una excepción si la propiedad se accede cuando el Usuario no // está definido en la bolsa de solicitudes public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // También se admite la exposición de la instancia de HttpRequest public HttpRequest Request { get => HttpContext.Current.Request; } } Y define tipos que heredan del controlador: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Para el ejemplo anterior, necesitarás configurar un manejador de valores en tu enrutador para que los objetos devueltos por el enrutador se transformen en un HttpResponse válido. Tenga en cuenta que los métodos no tienen un argumento HttpRequest request como está presente en otros métodos. Esto se debe a que, desde la versión 1.3, el enrutador admite dos tipos de delegados para respuestas de enrutamiento: RouteAction, que es el delegado predeterminado que recibe un argumento HttpRequest, y ParameterlessRouteAction. El objeto HttpRequest aún se puede acceder desde ambos delegados a través de la propiedad Request del HttpContext estático en el subproceso. En el ejemplo anterior, definimos un objeto desechable, el DbContext, y necesitamos asegurarnos de que todas las instancias creadas en un DbContext se desechen cuando la sesión HTTP finalice. Para ello, podemos utilizar dos formas de lograrlo. Una es crear un manejador de solicitudes que se ejecute después de la acción del enrutador, y la otra forma es a través de un manejador de servidor personalizado. Para el primer método, podemos crear el manejador de solicitudes directamente en el método OnSetup heredado de RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // obtener un DbContext definido en el contexto del manejador de solicitudes y // desecharlo ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Desde Sisk versión 1.4, la propiedad HttpServerConfiguration.DisposeDisposableContextValues se introdujo y se habilitó de forma predeterminada, lo que define si el servidor HTTP debe desechar todos los valores IDisposable en la bolsa de contexto cuando se cierra una sesión HTTP. El método anterior garantizará que el DbContext se deseché cuando la sesión HTTP se finalice. Puedes hacer esto para más miembros que necesitan desecharse al final de una respuesta. Para el segundo método, puedes crear un manejador de servidor personalizado que desechará el DbContext cuando la sesión HTTP se finalice. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } Y usarlo en tu constructor de aplicaciones: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Esta es una forma de manejar la limpieza de código y mantener las dependencias de una solicitud separadas por el tipo de módulo que se utilizará, reduciendo la cantidad de código duplicado dentro de cada acción de un enrutador. Es una práctica similar a la que se utiliza la inyección de dependencias en frameworks como ASP.NET."
  },
  "docs/es/features/logging.html": {
    "href": "docs/es/features/logging.html",
    "title": "Registro | Sisk",
    "keywords": "Registro Puedes configurar Sisk para que escriba automáticamente los registros de acceso y error. Es posible definir la rotación de registros, extensiones y frecuencia. La clase LogStream proporciona una forma asíncrona de escribir registros y mantenerlos en una cola de escritura esperable. En este artículo te mostraremos cómo configurar el registro para tu aplicación. Registros de acceso basados en archivos Los registros en archivos abren el archivo, escriben el texto de la línea y luego cierran el archivo para cada línea escrita. Este procedimiento se adoptó para mantener la respuesta de escritura en los registros. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } El código anterior escribirá todas las solicitudes entrantes en el archivo logs/access.log. Ten en cuenta que, si el archivo no existe, se crea automáticamente, sin embargo, la carpeta anterior no. No es necesario crear el directorio logs/ ya que la clase LogStream lo crea automáticamente. Registro basado en flujo Puedes escribir archivos de registro en objetos TextWriter, como Console.Out, pasando un objeto TextWriter en el constructor: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); Para cada mensaje escrito en el registro basado en flujo, se llama al método TextWriter.Flush(). Formato de registro de acceso Puedes personalizar el formato de registro de acceso mediante variables predefinidas. Considera la siguiente línea: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou en %lmsms [%{user-agent}]\"; Escribirá un mensaje como: 29/mar./2023 15:21:47 -0300 Ejecutado ::1 http://localhost:5555/ [200 OK] 689B -> 707B en 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] Puedes formatear tu archivo de registro según el formato descrito en la tabla: Valor Lo que representa Ejemplo %dd Día del mes (formateado como dos dígitos) 05 %dmmm Nombre completo del mes Julio %dmm Nombre abreviado del mes (tres letras) Jul %dm Número de mes (formateado como dos dígitos) 07 %dy Año (formateado como cuatro dígitos) 2023 %th Hora en formato de 12 horas 03 %tH Hora en formato de 24 horas (HH) 15 %ti Minutos (formateados como dos dígitos) 30 %ts Segundos (formateados como dos dígitos) 45 %tm Milisegundos (formateados como tres dígitos) 123 %tz Desplazamiento de zona horaria (total de horas en UTC) +03:00 %ri Dirección IP remota del cliente 192.168.1.100 %rm Método HTTP (en mayúsculas) GET %rs Esquema de URI (http/https) https %ra Autoridad de URI (dominio) example.com %rh Host de la solicitud www.example.com %rp Puerto de la solicitud 443 %rz Ruta de la solicitud /path/to/resource %rq Cadena de consulta ?key=value&another=123 %sc Código de estado de respuesta HTTP 200 %sd Descripción de estado de respuesta HTTP OK %lin Tamaño legible de la solicitud 1.2 KB %linr Tamaño bruto de la solicitud (bytes) 1234 %lou Tamaño legible de la respuesta 2.5 KB %lour Tamaño bruto de la respuesta (bytes) 2560 %lms Tiempo transcurrido en milisegundos 120 %ls Estado de ejecución Ejecutado Registros rotativos Tip En Sisk 0.15 y versiones anteriores, esta función solo está disponible con el paquete Sisk.ServiceProvider. En Sisk 0.16 y superior, esta función se implementa en el paquete principal. Puedes configurar el servidor HTTP para que gire los archivos de registro a un archivo comprimido .gz cuando alcancen un tamaño determinado. El tamaño se comprueba periódicamente por el límite que defines. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); El código anterior comprueba cada seis horas si el archivo de LogStream ha alcanzado su límite de 1MB. Si es así, el archivo se comprime a un archivo .gz y luego se limpia el archivo access.log. Durante este proceso, la escritura en el archivo está bloqueada hasta que el archivo se comprima y limpie. Todas las líneas que entren para ser escritas en este período esperarán hasta el final de la compresión. Esta función solo funciona con LogStreams basados en archivos. Registro de errores Cuando un servidor no está lanzando errores al depurador, los reenvía a la escritura de registros cuando hay alguno. Puedes configurar la escritura de errores con: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Esta propiedad solo escribirá algo en el registro si el error no es capturado por la devolución de llamada o la propiedad Router.CallbackErrorHandler. El error escrito por el servidor siempre escribe la fecha y hora, los encabezados de la solicitud (no el cuerpo), la traza del error y la traza de la excepción interna, si la hay. Otras instancias de registro Tu aplicación puede tener cero o varias instancias de LogStream, no hay límite en la cantidad de canales de registro que puede tener. Por lo tanto, es posible dirigir el registro de tu aplicación a un archivo diferente al registro de acceso o error predeterminado. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Aplicación iniciada en {0}\", DateTime.Now); Extensión de LogStream Puedes extender la clase LogStream para escribir formatos personalizados, compatibles con el motor de registro actual de Sisk. El ejemplo siguiente permite escribir mensajes con colores en la consola a través de la biblioteca Spectre.Console: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Otra forma de escribir automáticamente registros personalizados para cada solicitud/respuesta es crear un HttpServerHandler. El ejemplo siguiente es un poco más completo. Escribe el cuerpo de la solicitud y la respuesta en JSON en la consola. Puede ser útil para depurar solicitudes en general. Este ejemplo utiliza ContextBag y HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // En este punto, la conexión está abierta y el cliente ha enviado el encabezado que especifica // que el contenido es JSON. La línea siguiente lee el contenido y lo deja almacenado en la solicitud. // // Si el contenido no se lee en la acción de la solicitud, es probable que el GC lo recolecte // después de enviar la respuesta al cliente, por lo que el contenido puede no estar disponible después de cerrar la respuesta. // _ = request.RawBody; // agregar una pista en el contexto para indicar que esta solicitud tiene un cuerpo JSON request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformatea el JSON utilizando la biblioteca CypherPotato.LightJson var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // verificar si la respuesta es JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // obtener el estado de manejo interno del servidor responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/es/features/server-sent-events.html": {
    "href": "docs/es/features/server-sent-events.html",
    "title": "Eventos Enviados por el Servidor | Sisk",
    "keywords": "Eventos Enviados por el Servidor Sisk admite el envío de mensajes a través de Eventos Enviados por el Servidor de forma predeterminada. Puedes crear conexiones desechables y persistentes, obtener las conexiones durante la ejecución y utilizarlas. Esta función tiene algunas limitaciones impuestas por los navegadores, como el envío solo de mensajes de texto y no poder cerrar permanentemente una conexión. Una conexión cerrada por el servidor tendrá un cliente que intentará reconectar cada 5 segundos (3 para algunos navegadores). Estas conexiones son útiles para enviar eventos desde el servidor al cliente sin que el cliente tenga que solicitar la información cada vez. Crear una conexión SSE Una conexión SSE funciona como una solicitud HTTP regular, pero en lugar de enviar una respuesta y cerrar la conexión inmediatamente, la conexión se mantiene abierta para enviar mensajes. Al llamar al método HttpRequest.GetEventSource(), la solicitud se pone en un estado de espera mientras se crea la instancia SSE. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.Send(\"Hola, mundo!\"); return sse.Close(); }); En el código anterior, creamos una conexión SSE y enviamos un mensaje \"Hola, mundo\", luego cerramos la conexión SSE desde el lado del servidor. Note Cuando se cierra una conexión desde el lado del servidor, por defecto el cliente intentará conectarse de nuevo en ese extremo y la conexión se reiniciará, ejecutando el método de nuevo, indefinidamente. Es común enviar un mensaje de terminación desde el servidor cada vez que la conexión se cierra desde el lado del servidor para evitar que el cliente intente reconectar de nuevo. Agregar encabezados Si necesitas enviar encabezados, puedes utilizar el método HttpRequestEventSource.AppendHeader antes de enviar cualquier mensaje. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hola!\"); return sse.Close(); }); Tenga en cuenta que es necesario enviar los encabezados antes de enviar cualquier mensaje. Conexiones de espera por fallo Las conexiones normalmente se terminan cuando el servidor ya no puede enviar mensajes debido a una posible desconexión del cliente. Con esto, la conexión se termina automáticamente y la instancia de la clase se descarta. Incluso con una reconexión, la instancia de la clase no funcionará, ya que está vinculada a la conexión anterior. En algunas situaciones, es posible que necesites esta conexión más adelante y no quieras administrarla a través del método de devolución de llamada de la ruta. Para esto, podemos identificar las conexiones SSE con un identificador y obtenerlas utilizando este identificador más adelante, incluso fuera del método de devolución de llamada de la ruta. Además, marcamos la conexión con WaitForFail para no terminar la ruta y la conexión automáticamente. Una conexión SSE en KeepAlive esperará a que se produzca un error de envío (causado por una desconexión) para reanudar la ejecución del método. También es posible establecer un tiempo de espera para esto. Después del tiempo, si no se ha enviado ningún mensaje, la conexión se termina y la ejecución se reanuda. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // esperar 15 segundos sin ningún mensaje antes de terminar la conexión return sse.Close(); }); El método anterior creará la conexión, la administrará y esperará a que se produzca una desconexión o un error. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // la conexión todavía está viva evs.Send(\"Hola de nuevo!\"); } Y el fragmento de código anterior intentará buscar la conexión recién creada, y si existe, enviará un mensaje a ella. Todas las conexiones de servidor activas que estén identificadas estarán disponibles en la colección HttpServer.EventSources. Esta colección solo almacena conexiones activas y identificadas. Las conexiones cerradas se eliminan de la colección. Note Es importante tener en cuenta que el mantenimiento de la conexión tiene un límite establecido por componentes que pueden estar conectados a Sisk de manera no controlable, como un proxy web, un kernel HTTP o un controlador de red, y que cierran las conexiones inactivas después de un cierto período de tiempo. Por lo tanto, es importante mantener la conexión abierta enviando mensajes periódicos o extendiendo el tiempo máximo antes de que la conexión se cierre. Lea la siguiente sección para comprender mejor el envío de mensajes periódicos. Configurar la política de ping de las conexiones La política de ping es una forma automatizada de enviar mensajes periódicos al cliente. Esta función permite al servidor entender cuándo el cliente se ha desconectado de la conexión sin tener que mantener la conexión abierta indefinidamente. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } En el código anterior, cada 5 segundos, se enviará un nuevo mensaje de ping al cliente. Esto mantendrá la conexión TCP abierta y evitará que se cierre debido a la inactividad. Además, cuando un mensaje no se pueda enviar, la conexión se cerrará automáticamente, liberando los recursos utilizados por la conexión. Consultar conexiones Puedes buscar conexiones activas utilizando un predicado en el identificador de la conexión, para poder difundir, por ejemplo. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Difundiendo a todas las fuentes de eventos que comienzan con 'my-connection-'\"); } También puedes utilizar el método All para obtener todas las conexiones SSE activas."
  },
  "docs/es/features/websockets.html": {
    "href": "docs/es/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk admite web sockets, como recibir y enviar mensajes a sus clientes. Esta característica funciona bien en la mayoría de los navegadores, pero en Sisk todavía es experimental. Por favor, si encuentra algún error, repórtelo en github. Aceptar y recibir mensajes de forma asíncrona El ejemplo a continuación muestra cómo funciona el websocket en la práctica, con un ejemplo de abrir una conexión, recibir un mensaje y mostrarlo en la consola. Todos los mensajes recibidos por WebSocket se reciben en bytes, por lo que tendrá que decodificarlos al recibirlos. De forma predeterminada, los mensajes se fragmentan en trozos y el último trozo se envía como el paquete final del mensaje. Puede configurar el tamaño del paquete con la bandera WebSocketBufferSize. Este búfer es el mismo para enviar y recibir mensajes. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Mensaje recibido: \" + msgText); // obtiene el contexto de HttpWebSocket que recibió el mensaje HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Respuesta!\"); }; ws.WaitForClose(); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Aceptar y recibir mensajes de forma síncrona El ejemplo a continuación contiene una forma de utilizar un websocket síncrono, sin un contexto asíncrono, donde recibe los mensajes, los procesa y termina de utilizar el socket. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/connect\", (req) => { var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"¿Cuál es su nombre?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Por favor, ingrese su nombre!\"); goto askName; } askAge: ws.Send(\"¿Y su edad?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Por favor, ingrese un número válido\"); goto askAge; } ws.Send($\"Usted es {name}, y tiene {age} años.\"); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Enviar mensajes El método Send tiene tres sobrecargas, que permiten enviar texto, un arreglo de bytes o un span de bytes. Todos ellos se fragmentan si el tamaño del búfer del servidor WebSocketBufferSize es mayor que el tamaño total de la carga. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hola, mundo\"); // se codificará como un arreglo de bytes UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Esperar el cierre del websocket El método WaitForClose() bloquea la pila de llamadas actual hasta que la conexión se termine por parte del cliente o del servidor. Con esto, la ejecución del callback de la solicitud se bloqueará hasta que el cliente o el servidor se desconecte. También puede cerrar manualmente la conexión con el método Close(). Este método devuelve un objeto HttpResponse vacío, que no se envía al cliente, pero funciona como un valor de retorno de la función donde se recibió la solicitud HTTP. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // espera a que el cliente cierre la conexión ws.WaitForClose(); // espera hasta que no se intercambien mensajes en 60 segundos // o hasta que alguna de las partes cierre la conexión ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Política de ping Similar a cómo funciona la política de ping en Server Side Events, también puede configurar una política de ping para mantener la conexión TCP abierta si hay inactividad en ella. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/es/fundamentals/request-handlers.html": {
    "href": "docs/es/fundamentals/request-handlers.html",
    "title": "Manejo de solicitudes | Sisk",
    "keywords": "Manejo de solicitudes Los controladores de solicitudes, también conocidos como \"middlewares\", son funciones que se ejecutan antes o después de que se ejecute una solicitud en el enrutador. Pueden definirse por ruta o por enrutador. Existen dos tipos de controladores de solicitudes: BeforeResponse: define que el controlador de solicitudes se ejecutará antes de llamar a la acción del enrutador. AfterResponse: define que el controlador de solicitudes se ejecutará después de llamar a la acción del enrutador. Enviar una respuesta HTTP en este contexto sobrescribirá la respuesta de la acción del enrutador. Ambos controladores de solicitudes pueden anular la respuesta real de la función de devolución de llamada del enrutador. Además, los controladores de solicitudes pueden ser útiles para validar una solicitud, como la autenticación, el contenido o cualquier otra información, como almacenar información, registros o otros pasos que se pueden realizar antes o después de una respuesta. De esta manera, un controlador de solicitudes puede interrumpir toda esta ejecución y devolver una respuesta antes de terminar el ciclo, descartando todo lo demás en el proceso. Ejemplo: supongamos que un controlador de solicitudes de autenticación de usuario no autentica al usuario. Evitará que el ciclo de vida de la solicitud continúe y se suspenderá. Si esto sucede en el controlador de solicitudes en la posición dos, el tercero y siguientes no se evaluarán. Crear un controlador de solicitudes Para crear un controlador de solicitudes, podemos crear una clase que herede de la interfaz IRequestHandler, en este formato: public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Devolver null indica que el ciclo de la solicitud puede continuar return null; } else { // Devolver un objeto HttpResponse indica que esta respuesta sobrescribirá las respuestas adyacentes. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } En el ejemplo anterior, indicamos que si el encabezado Authorization está presente en la solicitud, debe continuar y llamar al siguiente controlador de solicitudes o a la función de devolución de llamada del enrutador, lo que sea que venga a continuación. Si un controlador de solicitudes se ejecuta después de la respuesta por su propiedad ExecutionMode y devuelve un valor no nulo, sobrescribirá la respuesta del enrutador. Siempre que un controlador de solicitudes devuelva null, indica que la solicitud debe continuar y el siguiente objeto debe ser llamado o el ciclo debe terminar con la respuesta del enrutador. Asociar un controlador de solicitudes con una sola ruta Puedes definir uno o más controladores de solicitudes para una ruta. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // controlador de solicitudes antes de la solicitud new ValidateJsonContentRequestHandler(), // controlador de solicitudes antes de la solicitud // -- el método IndexPage se ejecutará aquí new WriteToLogRequestHandler() // controlador de solicitudes después de la solicitud }); O creando un objeto Route: Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Asociar un controlador de solicitudes con un enrutador Puedes definir un controlador de solicitudes global que se ejecutará en todas las rutas del enrutador. mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Asociar un controlador de solicitudes con un atributo Puedes definir un controlador de solicitudes en un atributo de método junto con un atributo de ruta. public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() .WithContent(new StringContent(\"Hello world!\")); } } Ten en cuenta que es necesario pasar el tipo de controlador de solicitudes deseado y no una instancia del objeto. De esta manera, el controlador de solicitudes se instanciará mediante el analizador del enrutador. Puedes pasar argumentos en el constructor de la clase con la propiedad ConstructorArguments. Ejemplo: [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } También puedes crear tu propio atributo que implemente RequestHandler: public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } Y utilizarlo de la siguiente manera: [Authenticate] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Saltar un controlador de solicitudes global Después de definir un controlador de solicitudes global en una ruta, puedes ignorar este controlador de solicitudes en rutas específicas. var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: la misma instancia de lo que está en los controladores de solicitudes globales new AuthenticateUserRequestHandler() // incorrecto: no saltará el controlador de solicitudes global } }); Note Si estás saltando un controlador de solicitudes, debes utilizar la misma referencia de lo que instanciaste antes para saltar. Crear otra instancia de controlador de solicitudes no saltará el controlador de solicitudes global, ya que su referencia cambiará. Recuerda utilizar la misma referencia del controlador de solicitudes utilizada en ambos GlobalRequestHandlers y BypassGlobalRequestHandlers."
  },
  "docs/es/fundamentals/requests.html": {
    "href": "docs/es/fundamentals/requests.html",
    "title": "Solicitudes | Sisk",
    "keywords": "Solicitudes Las solicitudes son estructuras que representan un mensaje de solicitud HTTP. El objeto HttpRequest contiene funciones útiles para manejar mensajes HTTP en toda su aplicación. Una solicitud HTTP se forma por el método, ruta, versión, encabezados y cuerpo. En este documento, le enseñaremos cómo obtener cada uno de estos elementos. Obtener el método de la solicitud Para obtener el método de la solicitud recibida, puede utilizar la propiedad Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Esta propiedad devuelve el método de la solicitud representado por un objeto HttpMethod. Note A diferencia de los métodos de ruta, esta propiedad no sirve para el elemento RouteMethod.Any. En su lugar, devuelve el método de solicitud real. Obtener componentes de la URL de la solicitud Puede obtener varios componentes de una URL a través de ciertas propiedades de una solicitud. Para este ejemplo, consideremos la URL: http://localhost:5000/user/login?email=foo@bar.com Nombre del componente Descripción Valor del componente Path Obtiene la ruta de la solicitud. /user/login FullPath Obtiene la ruta y la cadena de consulta de la solicitud. /user/login?email=foo@bar.com FullUrl Obtiene la cadena de solicitud de URL completa. http://localhost:5000/user/login?email=foo@bar.com Host Obtiene el host de la solicitud. localhost Authority Obtiene el host y el puerto de la solicitud. localhost:5000 QueryString Obtiene la consulta de la solicitud. ?email=foo@bar.com Query Obtiene la consulta de la solicitud en una colección de valores con nombre. {StringValueCollection object} IsSecure Determina si la solicitud utiliza SSL (true) o no (false). false También puede optar por utilizar la propiedad HttpRequest.Uri, que incluye todo lo anterior en un solo objeto. Obtener el cuerpo de la solicitud Algunas solicitudes incluyen un cuerpo, como formularios, archivos o transacciones de API. Puede obtener el cuerpo de una solicitud desde la propiedad: // obtiene el cuerpo de la solicitud como una cadena, utilizando la codificación de la solicitud como codificador string body = request.Body; // o lo obtiene en un arreglo de bytes byte[] bodyBytes = request.RawBody; // o también puede transmitirlo. Stream requestStream = request.GetRequestStream(); También es posible determinar si hay un cuerpo en la solicitud y si está cargado con las propiedades HasContents, que determina si la solicitud tiene contenido y IsContentAvailable que indica que el servidor HTTP recibió completamente el contenido del punto remoto. No es posible leer el contenido de la solicitud a través de GetRequestStream más de una vez. Si lee con este método, los valores en RawBody y Body no estarán disponibles. No es necesario desechar el flujo de solicitud en el contexto de la solicitud, ya que se desecha al final de la sesión HTTP en la que se crea. También puede utilizar la propiedad HttpRequest.RequestEncoding para obtener la mejor codificación para decodificar la solicitud manualmente. El servidor tiene límites para leer el contenido de la solicitud, que se aplica tanto a HttpRequest.Body como a HttpRequest.RawBody. Estas propiedades copian el flujo de entrada completo en un búfer local del mismo tamaño que HttpRequest.ContentLength. Una respuesta con estado 413 Contenido demasiado grande se devuelve al cliente si el contenido enviado es mayor que HttpServerConfiguration.MaximumContentLength definido en la configuración del usuario. Además, si no hay un límite configurado o si es demasiado grande, el servidor lanzará una OutOfMemoryException cuando el contenido enviado por el cliente exceda Int32.MaxValue (2 GB) y si el contenido se intenta acceder a través de una de las propiedades mencionadas anteriormente. Todavía puede tratar con el contenido a través de transmisión. Note Aunque Sisk lo permite, siempre es una buena idea seguir la semántica HTTP para crear su aplicación y no obtener o servir contenido en métodos que no lo permiten. Lea sobre RFC 9110 \"Semántica HTTP\". Obtener el contexto de la solicitud El contexto HTTP es un objeto exclusivo de Sisk que almacena información del servidor HTTP, ruta, enrutador y controlador de solicitud. Puede utilizarlo para organizarse en un entorno donde estos objetos son difíciles de organizar. El objeto RequestBag contiene información almacenada que se pasa de un controlador de solicitud a otro punto y se puede consumir en el destino final. Este objeto también se puede utilizar por controladores de solicitud que se ejecutan después de la devolución de llamada de la ruta. Tip Esta propiedad también es accesible a través de la propiedad HttpRequest.Bag. public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers[\"Authorization\"] != null) { context.RequestBag.Add(\"AuthenticatedUser\", \"Bob\"); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } El controlador de solicitud anterior definirá AuthenticatedUser en la bolsa de solicitud y se puede consumir más adelante en la devolución de llamada final: public class MyController { [Route(RouteMethod.Get, \"/\")] [RequestHandler(typeof(AuthenticateUserRequestHandler))] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); string authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; res.Content = new StringContent($\"Hello, {authUser}!\"); return res; } } También puede utilizar los métodos auxiliares Bag.Set() y Bag.Get() para obtener o establecer objetos por sus singleton de tipo. public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse Test(HttpRequest request) { var user = request.Bag.Get<User>(); } Obtener datos de formulario Puede obtener los valores de los datos de formulario en una NameValueCollection con el ejemplo siguiente: static HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password) == true) { ... } } Obtener datos de formulario multipart La solicitud HTTP de Sisk le permite obtener contenidos multipart, como archivos, campos de formulario o cualquier contenido binario. static HttpResponse Index(HttpRequest request) { // el siguiente método lee la entrada de solicitud completa en un // arreglo de objetos Multipart var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // El nombre del archivo proporcionado por los datos de formulario multipart. // Se devuelve null si el objeto no es un archivo. Console.WriteLine(\"Nombre del archivo : \" + uploadedObject.Filename); // El nombre del campo de los datos de formulario multipart. Console.WriteLine(\"Nombre del campo : \" + uploadedObject.Name); // La longitud del contenido de los datos de formulario multipart. Console.WriteLine(\"Longitud del contenido : \" + uploadedObject.ContentLength); // Determina el formato de imagen en función del encabezado del archivo para cada // tipo de contenido conocido. Si el contenido no es un formato de archivo común reconocido, // el método siguiente devolverá MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Formato común : \" + uploadedObject.GetCommonFileFormat()); } } Puede leer más sobre los objetos de formulario multipart de Sisk y sus métodos, propiedades y funcionalidades. Soporte para eventos enviados por el servidor Sisk admite eventos enviados por el servidor, que permite enviar fragmentos como un flujo y mantener la conexión entre el servidor y el cliente viva. Llamando al método HttpRequest.GetEventSource se pondrá la solicitud HTTP en su estado de escucha. A partir de esto, el contexto de esta solicitud HTTP no esperará una respuesta HTTP, ya que se superpondrá a los paquetes enviados por eventos del servidor. Después de enviar todos los paquetes, la devolución de llamada debe devolver el método Close, que enviará la respuesta final al servidor y indicará que la transmisión ha terminado. No es posible predecir qué será la longitud total de todos los paquetes que se enviarán, por lo que no es posible determinar el final de la conexión con el encabezado Content-Length. Por defecto, la mayoría de los navegadores no admiten el envío de encabezados HTTP o métodos diferentes al GET. Por lo tanto, tenga cuidado al utilizar controladores de solicitud con solicitudes de evento de origen que requieren encabezados específicos en la solicitud, ya que es probable que no los tengan. Además, la mayoría de los navegadores reinician las transmisiones si el método EventSource.close no se llama en el lado del cliente después de recibir todos los paquetes, lo que causa un procesamiento adicional infinito en el lado del servidor. Para evitar este tipo de problema, es común enviar un paquete final que indique que el evento de origen ha terminado de enviar todos los paquetes. El ejemplo siguiente muestra cómo el navegador puede comunicarse con el servidor que admite eventos enviados por el servidor. <html> <body> <b>Frutas:</b> <ul></ul> </body> <script> const evtSource = new EventSource('/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `mensaje: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomate\") { evtSource.close(); } } </script> </html> Y envíe progresivamente los mensajes al cliente: public class MyController { [Route(RouteMethod.Get, \"/event-source\")] static HttpResponse ServerEventsResponse(HttpRequest request) { var serverEvents = request.GetEventSource(); string[] frutas = new[] { \"Manzana\", \"Plátano\", \"Sandía\", \"Tomate\" }; foreach (string fruta in frutas) { serverEvents.Send(fruta); Thread.Sleep(1500); } return serverEvents.Close(); } } Al ejecutar este código, esperamos un resultado similar a este: Resolución de IPs y hosts proxy Sisk se puede utilizar con proxies, y por lo tanto, las direcciones IP pueden reemplazarse por el punto final del proxy en la transacción desde un cliente hasta el proxy. Puede definir sus propios resolutores en Sisk con resolutores de reenvío. Codificación de encabezados La codificación de encabezados puede ser un problema para algunas implementaciones. En Windows, los encabezados UTF-8 no son compatibles, por lo que se utiliza ASCII. Sisk tiene un convertidor de codificación incorporado, que puede ser útil para decodificar encabezados codificados incorrectamente. Esta operación es costosa y está deshabilitada de forma predeterminada, pero se puede habilitar bajo la bandera NormalizeHeadersEncodings."
  },
  "docs/es/fundamentals/responses.html": {
    "href": "docs/es/fundamentals/responses.html",
    "title": "Respuestas | Sisk",
    "keywords": "Respuestas Las respuestas representan objetos que son respuestas HTTP a solicitudes HTTP. Se envían desde el servidor al cliente como indicación de la solicitud de un recurso, página, documento, archivo u otro objeto. Una respuesta HTTP se compone de estado, encabezados y contenido. En este documento, te enseñaremos cómo arquitectar respuestas HTTP con Sisk. Establecer un estado HTTP La lista de estados HTTP es la misma desde HTTP/1.0, y Sisk admite todos ellos. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 O con sintaxis fluida: new HttpResponse() .WithStatus(200) // o .WithStatus(HttpStatusCode.Ok) // o .WithStatus(HttpStatusInformation.Ok); Puedes ver la lista completa de códigos de estado HTTP disponibles aquí. También puedes proporcionar tu propio código de estado utilizando la estructura HttpStatusInformation. Cuerpo y tipo de contenido Sisk admite objetos de contenido nativos de .NET para enviar el cuerpo en respuestas. Puedes utilizar la clase StringContent para enviar una respuesta JSON, por ejemplo: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); El servidor siempre intentará calcular la longitud del contenido (Content-Length) a partir de lo que hayas definido en el contenido, si no lo has definido explícitamente en un encabezado. Si el servidor no puede obtener implícitamente la longitud del contenido, la respuesta se enviará con codificación en bloques. También puedes transmitir la respuesta enviando un StreamContent o utilizando el método GetResponseStream. Encabezados de respuesta Puedes agregar, editar o eliminar encabezados que se envían en la respuesta. El ejemplo siguiente muestra cómo enviar una respuesta de redirección al cliente. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); O con sintaxis fluida: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Cuando utilizas el método Add de HttpHeaderCollection, estás agregando un encabezado a la solicitud sin alterar los que ya se han enviado. El método Set reemplaza los encabezados con el mismo nombre con el valor indicado. El indexador de HttpHeaderCollection llama internamente al método Set para reemplazar los encabezados. Enviar cookies Sisk tiene métodos que facilitan la definición de cookies en el cliente. Las cookies establecidas por este método ya están codificadas en URL y cumplen con el estándar RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); O con sintaxis fluida: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Hay versiones más completas del mismo método aquí. Respuestas en bloques Puedes establecer la codificación de transferencia en bloques para enviar respuestas grandes. HttpResponse res = new HttpResponse(); res.SendChunked = true; Al utilizar la codificación en bloques, el encabezado Content-Length se omite automáticamente. Flujo de respuesta Los flujos de respuesta son una forma administrada de enviar respuestas de manera segmentada. Es una operación de nivel inferior que la utilización de objetos HttpResponse, ya que requiere que envíes los encabezados y el contenido manualmente y luego cierres la conexión. Este ejemplo abre un flujo de lectura para el archivo, copia el flujo al flujo de salida de la respuesta y no carga el archivo completo en la memoria. Esto puede ser útil para servir archivos medianos o grandes. // obtiene el flujo de salida de la respuesta using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // establece la codificación de la respuesta para utilizar la codificación en bloques // también no debes enviar el encabezado de longitud del contenido cuando se utiliza // la codificación en bloques responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copia el flujo del archivo al flujo de salida de la respuesta fileStream.CopyTo(responseStream.ResponseStream); // cierra el flujo return responseStream.Close(); Compresión GZip, Deflate y Brotli Puedes enviar respuestas con contenido comprimido en Sisk comprimiendo el contenido HTTP. Primero, encapsula tu objeto HttpContent dentro de uno de los compresores a continuación para enviar la respuesta comprimida al cliente. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // o Content = new BrotliContent(new HtmlContent(myHtml)), // o Content = new DeflateContent(new HtmlContent(myHtml)), }; }); También puedes utilizar estos contenidos comprimidos con flujos. router.MapGet(\"/archive.zip\", request => { // no apliques \"using\" aquí. El HttpServer descartará tu contenido // después de enviar la respuesta. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Los encabezados Content-Encoding se establecen automáticamente al utilizar estos contenidos. Tipos de respuesta implícitos Desde la versión 0.15, puedes utilizar otros tipos de retorno además de HttpResponse, pero es necesario configurar el enrutador para que sepa cómo manejar cada tipo de objeto. El concepto es siempre devolver un tipo de referencia y convertirlo en un objeto HttpResponse válido. Las rutas que devuelven HttpResponse no se someten a ninguna conversión. Los tipos de valor (estructuras) no se pueden utilizar como tipo de retorno porque no son compatibles con el RouterCallback, por lo que deben envolverse en un ValueResult para poder utilizarse en los controladores. Considera el siguiente ejemplo de un módulo de enrutador que no utiliza HttpResponse en el tipo de retorno: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } Con eso, ahora es necesario definir en el enrutador cómo manejar cada tipo de objeto. Los objetos siempre son el primer argumento del controlador y el tipo de salida debe ser un objeto HttpResponse válido. También, los objetos de salida de una ruta nunca deben ser nulos. Para los tipos ValueResult no es necesario indicar que el objeto de entrada es un ValueResult y solo T, ya que ValueResult es un objeto reflejado a partir de su componente original. La asociación de tipos no compara lo que se registró con el tipo del objeto devuelto desde el callback del enrutador. En su lugar, verifica si el tipo del resultado del enrutador es asignable al tipo registrado. Registrar un controlador de tipo Object hará que se ignoren todos los demás controladores de tipo específico. El orden de inserción de los controladores de valor también es importante, por lo que registrar un controlador de objeto debe ser el último controlador de valor que se utilizará como respaldo. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<bool>(bolVal => { HttpResponse res = new HttpResponse(); res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest; return res; }); r.RegisterValueHandler<IEnumerable>(enumerableValue => { return new HttpResponse(); // haz algo con enumerableValue aquí }); // registrar un controlador de valor de objeto debe ser el último // controlador de valor que se utilizará como respaldo r.RegisterValueHandler<object>(fallback => { HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.OK; res.Content = JsonContent.Create(fallback); return res; });"
  },
  "docs/es/fundamentals/routing.html": {
    "href": "docs/es/fundamentals/routing.html",
    "title": "Enrutamiento | Sisk",
    "keywords": "Enrutamiento El Router es el primer paso en la construcción del servidor. Es responsable de contener objetos Route, que son puntos de conexión que asignan URLs y sus métodos a acciones ejecutadas por el servidor. Cada acción es responsable de recibir una solicitud y entregar una respuesta al cliente. Las rutas son pares de expresiones de ruta (\"patrón de ruta\") y el método HTTP que pueden escuchar. Cuando se realiza una solicitud al servidor, intentará encontrar una ruta que coincida con la solicitud recibida, luego llamará a la acción de esa ruta y entregará la respuesta resultante al cliente. Hay varias formas de definir rutas en Sisk: pueden ser estáticas, dinámicas o auto-escaneadas, definidas por atributos o directamente en el objeto Router. Router mainRouter = new Router(); // asigna la ruta GET / a la siguiente acción mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hola, mundo!\"); }); Para entender qué es capaz de hacer una ruta, debemos entender qué es capaz de hacer una solicitud. Un HttpRequest contendrá todo lo que necesite. Sisk también incluye algunas características adicionales que aceleran el desarrollo en general. Para cada acción recibida por el servidor, se llamará a un delegado de tipo RouteAction. Este delegado contiene un parámetro que contiene un HttpRequest con toda la información necesaria sobre la solicitud recibida por el servidor. El objeto resultante de este delegado debe ser un HttpResponse o un objeto que se asigna a él a través de tipos de respuesta implícitos. Coincidencia de rutas Cuando se recibe una solicitud por el servidor HTTP, Sisk busca una ruta que satisfaga la expresión de la ruta recibida por la solicitud. La expresión siempre se prueba entre la ruta y la ruta de la solicitud, sin considerar la cadena de consulta. Esta prueba no tiene prioridad y es exclusiva de una sola ruta. Cuando no se encuentra una ruta que coincida con la solicitud, se devuelve la respuesta Router.NotFoundErrorHandler al cliente. Cuando se coincide con el patrón de ruta, pero el método HTTP no coincide, se envía la respuesta Router.MethodNotAllowedErrorHandler al cliente. Sisk verifica la posibilidad de colisiones de rutas para evitar estos problemas. Al definir rutas, Sisk buscará rutas posibles que puedan colisionar con la ruta que se está definiendo. Esta prueba incluye la comprobación de la ruta y el método que la ruta está configurada para aceptar. Creación de rutas utilizando patrones de ruta Puedes definir rutas utilizando varios métodos SetRoute. // forma SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hola, {name}\"); }); // forma Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // 200 ok vacío }); // métodos de ayuda Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // el contenido de StreamContent se descarta después de enviar // la respuesta. Content = new StreamContent(imageStream) }; }); // varios parámetros mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hola, {name} {surname}!\"); }); La propiedad RouteParameters de HttpResponse contiene toda la información sobre las variables de ruta de la solicitud recibida. Cada ruta recibida por el servidor se normaliza antes de que se ejecute la prueba de patrón de ruta, siguiendo estas reglas: Todos los segmentos vacíos se eliminan de la ruta, por ejemplo: ////foo//bar se convierte en /foo/bar. La coincidencia de ruta es sensible a mayúsculas y minúsculas, a menos que Router.MatchRoutesIgnoreCase esté establecido en true. Las propiedades Query y RouteParameters de HttpRequest devuelven un objeto StringValueCollection, donde cada propiedad indexada devuelve un StringValue no nulo, que se puede utilizar como una opción/monada para convertir su valor raw en un objeto administrado. El ejemplo siguiente lee el parámetro de ruta \"id\" y obtiene un Guid de él. Si el parámetro no es un Guid válido, se lanza una excepción y se devuelve un error 500 al cliente si el servidor no está manejando Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); [!NOTA] Las rutas tienen su / final ignorado en ambas rutas de solicitud y ruta, es decir, si intentas acceder a una ruta definida como /index/page podrás acceder utilizando /index/page/ también. También puedes forzar las URLs a terminar con / habilitando la bandera ForceTrailingSlash. Creación de rutas utilizando instancias de clase También puedes definir rutas dinámicamente utilizando reflexión con el atributo RouteAttribute. De esta manera, la instancia de una clase en la que sus métodos implementan este atributo tendrá sus rutas definidas en el router de destino. Para que un método se defina como una ruta, debe estar marcado con un RouteAttribute, como el atributo en sí o un RouteGetAttribute. El método puede ser estático, de instancia, público o privado. Cuando se utiliza el método SetObject(type) o SetObject<TType>(), se ignoran los métodos de instancia. public class MyController { // coincidirá con GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Índice!\"); return res; } // los métodos estáticos también funcionan [RouteGet(\"/hola\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hola mundo!\"); return res; } } La línea siguiente definirá tanto el método Index como el método Hello de MyController como rutas, ya que ambos están marcados como rutas, y se ha proporcionado una instancia de la clase, no su tipo. Si se hubiera proporcionado su tipo en lugar de una instancia, solo se habrían definido los métodos estáticos. var myController = new MyController(); mainRouter.SetObject(myController); Desde la versión 0.16 de Sisk, es posible habilitar AutoScan, que buscará clases definidas por el usuario que implementen RouterModule y las asociará automáticamente con el router. Esto no es compatible con la compilación AOT. mainRouter.AutoScanModules<ApiController>(); La instrucción anterior buscará todos los tipos que implementan ApiController, pero no el tipo en sí. Los dos parámetros opcionales indican cómo se buscarán estos tipos. El primer argumento implica el ensamblado donde se buscarán los tipos y el segundo indica la forma en que se definirán los tipos. Rutas de regex En lugar de utilizar los métodos de coincidencia de ruta HTTP predeterminados, puedes marcar una ruta para que se interprete con Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"Mi ruta\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); O con la clase RegexRoute: RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hola, mundo\"); }); mainRouter.SetRoute(indexRoute); También puedes capturar grupos de la expresión regular en el contenido de HttpRequest.RouteParameters: [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Accediendo al archivo {filename}\"); } Rutas de cualquier método Puedes definir una ruta para que se ajuste solo por su ruta y omitir el método HTTP. Esto puede ser útil para que realices la validación de método dentro de la devolución de llamada de la ruta. // coincidirá con / en cualquier método HTTP mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Rutas de cualquier ruta Las rutas de cualquier ruta prueban cualquier ruta recibida por el servidor HTTP, sujeto al método de ruta que se está probando. Si el método de ruta es RouteMethod.Any y la ruta utiliza Route.AnyPath en su expresión de ruta, esta ruta escuchará todas las solicitudes del servidor HTTP, y no se pueden definir otras rutas. // la siguiente ruta coincidirá con todas las solicitudes POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Coincidencia de ruta sin distinguir mayúsculas y minúsculas De forma predeterminada, la interpretación de rutas con solicitudes es sensible a mayúsculas y minúsculas. Para hacer que ignore mayúsculas y minúsculas, habilita esta opción: mainRouter.MatchRoutesIgnoreCase = true; Esto también habilitará la opción RegexOptions.IgnoreCase para rutas donde se realice la coincidencia con regex. Controlador de errores de no encontrado (404) Puedes crear un controlador de errores personalizado para cuando una solicitud no coincida con ninguna ruta conocida. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Desde la versión v0.14 Content = new HtmlContent(\"<h1>No encontrado</h1>\") // versiones anteriores Content = new StringContent(\"<h1>No encontrado</h1>\", Encoding.UTF8, \"text/html\") }; }; Controlador de errores de método no permitido (405) También puedes crear un controlador de errores personalizado para cuando una solicitud coincida con su ruta, pero no coincida con el método. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Método no permitido para esta ruta.\") }; }; Controlador de errores internos Las devoluciones de llamada de ruta pueden generar errores durante la ejecución del servidor. Si no se manejan correctamente, el funcionamiento general del servidor HTTP puede interrumpirse. El router tiene una devolución de llamada para cuando una devolución de llamada de ruta falla y evita la interrupción del servicio. Este método solo es accesible cuando ThrowExceptions está establecido en false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/es/getting-started.html": {
    "href": "docs/es/getting-started.html",
    "title": "Introducción a Sisk | Sisk",
    "keywords": "Introducción a Sisk Sisk puede ejecutarse en cualquier entorno .NET. En esta guía, te enseñaremos cómo crear una aplicación Sisk utilizando .NET. Si aún no lo has instalado, por favor descarga el SDK desde aquí. En este tutorial, cubriremos cómo crear una estructura de proyecto, recibir una solicitud, obtener un parámetro de URL y enviar una respuesta. Esta guía se centrará en construir un servidor simple utilizando C#. También puedes utilizar tu lenguaje de programación favorito. Note Es posible que estés interesado en un proyecto de inicio rápido. Consulta este repositorio para obtener más información. Creación de un Proyecto Llamemos a nuestro proyecto \"Mi Aplicación Sisk\". Una vez que tengas .NET configurado, puedes crear tu proyecto con el siguiente comando: dotnet new console -n mi-aplicacion-sisk A continuación, navega hasta el directorio de tu proyecto e instala Sisk utilizando la herramienta de utilidad .NET: cd mi-aplicacion-sisk dotnet add package Sisk.HttpServer Puedes encontrar formas adicionales de instalar Sisk en tu proyecto aquí. Ahora, creemos una instancia de nuestro servidor HTTP. En este ejemplo, lo configuraremos para escuchar en el puerto 5000. Construcción del Servidor HTTP Sisk te permite construir tu aplicación paso a paso manualmente, ya que enruta al objeto HttpServer. Sin embargo, esto puede no ser muy conveniente para la mayoría de los proyectos. Por lo tanto, podemos utilizar el método de creación, que facilita la ejecución de nuestra aplicación. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hola, mundo!\") }; }); await app.StartAsync(); } } Es importante entender cada componente vital de Sisk. Más adelante en este documento, aprenderás más sobre cómo funciona Sisk. Configuración Manual (Avanzada) Puedes aprender cómo funciona cada mecanismo de Sisk en esta sección de la documentación, que explica el comportamiento y las relaciones entre el HttpServer, Router, ListeningPort y otros componentes."
  },
  "docs/es/installing.html": {
    "href": "docs/es/installing.html",
    "title": "Instalación | Sisk",
    "keywords": "Instalación Puedes instalar Sisk a través de Nuget, dotnet cli o otras opciones. Puedes configurar fácilmente tu entorno de Sisk ejecutando este comando en tu consola de desarrollador: Warning Las versiones más recientes de Sisk son compatibles con .NET 8 y pronto .NET 9. Las versiones heredadas de Sisk para .NET 6 y .NET 7 se mantendrán hasta el 30 de noviembre de 2024, recibiendo solo parches de seguridad y correcciones bajo la rama \"legacy\". Por favor, actualiza tus proyectos que utilizan Sisk a .NET 8. dotnet add package Sisk.HttpServer Este comando instalará la versión más reciente de Sisk en tu proyecto."
  },
  "docs/es/native-aot.html": {
    "href": "docs/es/native-aot.html",
    "title": "Soporte nativo AOT | Sisk",
    "keywords": "Soporte nativo AOT En el .NET 7, se introdujo el Native AOT, un modo de compilación de .NET que permite exportar binarios listos en cualquier plataforma compatible, sin requerir que el tiempo de ejecución de .NET esté instalado en la máquina objetivo. Con Native AOT, su código se compila para código nativo y ya contiene todo lo que necesita para ser ejecutado. Sisk ha estado experimentando con la característica desde la versión 0.9.1, que mejora el soporte para Native AOT con características para definir rutas dinámicas por aplicación sin afectar la compilación con mensajes de advertencia. Sisk utiliza la reflexión para obtener los métodos que se definirán desde tipos y objetos. Además, Sisk utiliza la reflexión para atributos como RequestHandlerAttribute, que se inicializan desde un tipo. Para funcionar correctamente, la compilación AOT utiliza el recorte, donde los tipos dinámicos deben especificar qué se utilizará en el ensamblado final. Considerando el ejemplo a continuación, es una ruta que llama a un RequestHandler. [Route(RouteMethod.Get, \"/\", LogMode = LogOutput.None)] [RequestHandler(typeof(MyRequestHandler))] static HttpResponse IndexPage(HttpRequest request) { HttpResponse htmlResponse = new HttpResponse(); htmlResponse.Content = new StringContent(\"Hola, mundo!\", System.Text.Encoding.UTF8, \"text/plain\"); return htmlResponse; } Este RequestHandler se invoca dinámicamente durante la ejecución, y esta invocación debe segmentarse, y esta segmentación debe ser explícita. Para entender mejor qué considerará el compilador de MyRequestHandler que se debe mantener en la compilación final es: Propiedades públicas; Campos públicos y privados; Constructores públicos y privados; Métodos públicos y privados; Todo lo que tenga en un RequestHandler que no esté mencionado anteriormente será eliminado por el compilador. Recordando que todos los demás componentes, clases y paquetes que utilice en su aplicación deben ser compatibles con el recorte AOT, o su código no funcionará como se espera. De todos modos, Sisk no lo abandonará si desean construir algo donde el rendimiento sea una prioridad. Puede leer más sobre Native AOT y cómo funciona en la documentación oficial de Microsoft."
  },
  "docs/es/registering-namespace.html": {
    "href": "docs/es/registering-namespace.html",
    "title": "Configuración de reservas de namespace en Windows | Sisk",
    "keywords": "Configuración de reservas de namespace en Windows Sisk funciona con la interfaz de red HttpListener, que enlaza un host virtual al sistema para escuchar solicitudes. En Windows, esta unión es un poco restrictiva, solo permitiendo que localhost se enlace como un host válido. Al intentar escuchar a otro host, se lanza un error de acceso denegado en el servidor. Este tutorial explica cómo conceder autorización para escuchar en cualquier host que desee en el sistema. Configuración de namespace.bat BATCH @echo off :: insertar prefijo aquí, sin espacios ni comillas SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Donde en PREFIX, es el prefijo (\"Host de escucha->Puerto\") que su servidor escuchará. Debe estar formateado con el esquema de URL, host, puerto y una barra al final, ejemplo: Configuración de namespace.bat BATCH SET PREFIX=http://mi-aplicación.example.test/ Para que pueda ser escuchado en su aplicación a través de: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://mi-aplicación.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hola, mundo!\") }; }); await app.StartAsync(); } }"
  },
  "docs/es/ssl.html": {
    "href": "docs/es/ssl.html",
    "title": "Trabajando con SSL | Sisk",
    "keywords": "Trabajando con SSL Trabajar con SSL para desarrollo puede ser necesario cuando se trabaja en contextos que requieren seguridad, como la mayoría de los escenarios de desarrollo web. Sisk opera sobre HttpListener, que no admite HTTPS de forma nativa, solo HTTP. Sin embargo, existen soluciones alternativas que te permiten trabajar con SSL en Sisk. Consulta a continuación: A través de IIS en Windows Disponible en: Windows Esfuerzo: medio Si estás en Windows, puedes utilizar IIS para habilitar SSL en tu servidor HTTP. Para que esto funcione, es recomendable que sigas este tutorial con anticipación si deseas que tu aplicación escuche en un host diferente a \"localhost\". Para que esto funcione, debes instalar IIS a través de las características de Windows. IIS está disponible de forma gratuita para usuarios de Windows y Windows Server. Para configurar SSL en tu aplicación, ten el certificado SSL listo, incluso si es auto-firmado. A continuación, puedes ver cómo configurar SSL en IIS 7 o superior. A través de mitmproxy Disponible en: Linux, macOS, Windows Esfuerzo: fácil mitmproxy es una herramienta de proxy de interceptación que permite a los desarrolladores y testers de seguridad inspeccionar, modificar y grabar el tráfico HTTP y HTTPS entre un cliente (como un navegador web) y un servidor. Puedes utilizar la utilidad mitmdump para iniciar un proxy SSL inverso entre tu cliente y tu aplicación Sisk. Primero, instala mitmproxy en tu máquina. Inicia tu aplicación Sisk. En este ejemplo, utilizaremos el puerto 8000 como el puerto HTTP inseguro. Inicia el servidor mitmproxy para escuchar el puerto seguro en 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 Y listo! Ya puedes acceder a tu aplicación a través de https://localhost:8001/. Tu aplicación no necesita estar en ejecución para iniciar mitmdump. A través del paquete Sisk.SslProxy Disponible en: Linux, macOS, Windows Esfuerzo: fácil El paquete Sisk.SslProxy es una forma sencilla de habilitar SSL en tu aplicación Sisk. Sin embargo, es un paquete extremadamente experimental. Puede ser inestable trabajar con este paquete, pero puedes ser parte del pequeño porcentaje de personas que contribuirán a hacer que este paquete sea viable y estable. Para empezar, puedes instalar el paquete Sisk.SslProxy con: dotnet add package Sisk.SslProxy Note Debes habilitar \"Habilitar paquetes de pre-lanzamiento\" en el Administrador de paquetes de Visual Studio para instalar Sisk.SslProxy. Nuevamente, es un proyecto experimental, así que no pienses en ponerlo en producción. En este momento, Sisk.SslProxy puede manejar la mayoría de las características de HTTP/1.1, incluyendo HTTP Continue, Chunked-Encoding, WebSockets y SSE. Lee más sobre SslProxy aquí."
  },
  "docs/extensions/basic-auth.html": {
    "href": "docs/extensions/basic-auth.html",
    "title": "Basic Auth | Sisk",
    "keywords": "Basic Auth The Basic Auth package adds a request handler capable of handling basic authentication scheme in your Sisk application with very little configuration and effort. Basic HTTP authentication is a minimal input form of authenticating requests by an user id and password, where the session is controlled exclusively by the client and there are no authentication or access tokens. Read more about the Basic authentication scheme in the MDN specification. Installing To get started, install the Sisk.BasicAuth package in your project: > dotnet add package Sisk.BasicAuth You can view more ways to install it in your project in the Nuget repository. Creating your auth handler You can control the authentication scheme for an entire module or for individual routes. For that, let's first write our first basic authentication handler. In the example below, a connection is made to the database, it checks if the user exists and if the password is valid, and after that, stores the user in the context bag. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"To enter this page, please, inform your credentials.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // in this case, we're using the email as the user id field, so we're // going to search for an user using their email. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Sorry! No user was found by this email.\"); } // validates that the credentials password is valid for this user. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Invalid credentials.\"); } // adds the logged user to the http context // and continues the execution context.Bag.Add(\"loggedUser\", user); return null; } } So, just associate this request handler with our route or class. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hello, \" + loggedUser.Name + \"!\"; } } Or using RouterModule class: public class UsersController : RouterModule { public ClientModule() { // now all routes inside this class will be handled by // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Hello, \" + loggedUser.Name + \"!\"; } } Remarks The primary responsibility of basic authentication is carried out on the client-side. Storage, cache control, and encryption are all handled locally on the client. The server only receives the credentials and validates whether access is allowed or not. Note that this method is not one of the most secure because it places a significant responsibility on the client, which can be difficult to trace and maintain the security of its credentials. Additionally, it is crucial for passwords to be transmitted in a secure connection context (SSL), as they do not have any inherent encryption. A brief interception in the headers of a request can expose the access credentials of your user. Opt for more robust authentication solutions for applications in production and avoid using too many off-the-shelf components, as they may not adapt to the needs of your project and end up exposing it to security risks."
  },
  "docs/extensions/ini-configuration.html": {
    "href": "docs/extensions/ini-configuration.html",
    "title": "INI configuration provider | Sisk",
    "keywords": "INI configuration provider Sisk has a method for obtaining startup configurations other than JSON. In fact, any pipeline that implements IConfigurationReader can be used with PortableConfigurationBuilder.WithConfigurationPipeline, reading the server configuration from any file type. The Sisk.IniConfiguration package provides a stream-based INI file reader that does not throw exceptions for common syntax errors and has a simple configuration syntax. This package can be used outside the Sisk framework, offering flexibility for projects that require an efficient INI document reader. Installing To install the package, you can start with: $ dotnet add package Sisk.IniConfiguration You can also install the core package, which doens't includes the INI IConfigurationReader, neither the Sisk dependency, just the INI serializers: $ dotnet add package Sisk.IniConfiguration.Core With the main package, you can use it in your code as shown in the example below: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // uses the IniConfigurationReader configuration reader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } The code above will look for an app.ini file in the process's current directory (CurrentDirectory). The INI file looks like this: [Server] # Multiple listen addresses are supported Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" INI flavor and syntax Current implementation flavor: Properties and section names are case-insensitive. Properties names and values are trimmed, unless values are quoted. Values can be quoted with single or double quotes. Quotes can have line-breaks inside them. Comments are supported with # and ;. Also, trailing comments are allowed. Properties can have multiple values. In detail, the documentation for the \"flavor\" of the INI parser used in Sisk is available in this document. Using the following ini code as example: One = 1 Value = this is an value Another value = \"this value has an line break on it\" ; the code below has some colors [some section] Color = Red Color = Blue Color = Yellow ; do not use yellow Parse it with: // parse the ini text from the string IniDocument doc = IniDocument.FromString(iniText); // get one value string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // get multiple values string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Configuration parameters Section and name Allow multiple values Description Server.Listen Yes The server listening addresses/ports. Server.Encoding No The server default encoding. Server.MaximumContentLength No The server max content-length size in bytes. Server.IncludeRequestIdHeader No Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions No Specifies if unhandled exceptions should be thrown. Server.AccessLogsStream No Specifies the access log output stream. Server.ErrorsLogsStream No Specifies the error log output stream. Cors.AllowMethods No Specifies the CORS Allow-Methods header value. Cors.AllowHeaders No Specifies the CORS Allow-Headers header value. Cors.AllowOrigins No Specifies multiples Allow-Origin headers, separated by commas. AllowOrigins for more information. Cors.AllowOrigin No Specifies one Allow-Origin header. Cors.ExposeHeaders No Specifies the CORS Expose-Headers header value. Cors.AllowCredentials No Specifies the CORS Allow-Credentials header value. Cors.MaxAge No Specifies the CORS Max-Age header value."
  },
  "docs/extensions/json-rpc.html": {
    "href": "docs/extensions/json-rpc.html",
    "title": "JSON-RPC Extension | Sisk",
    "keywords": "JSON-RPC Extension Sisk has an experimental module for a JSON-RPC 2.0 API, which allows you to create even simpler applications. This extension strictly implements the JSON-RPC 2.0 transport interface and offers transport via HTTP GET, POST requests, and also web-sockets with Sisk. You can install the extension via Nuget with the command below. Note that, in experimental/beta versions, you should enable the option to search for pre-release packages in Visual Studio. dotnet add package Sisk.JsonRpc Transport Interface JSON-RPC is a stateless, asynchronous remote procedure execution (RDP) protocol that uses JSON for unilateral data communication. A JSON-RPC request is typically identified by an ID, and a response is delivered by the same ID that was sent in the request. Not all requests require a response, which are called \"notifications\". The JSON-RPC 2.0 specification explains in detail how the transport works. This transport is agnostic of where it will be used. Sisk implements this protocol through HTTP, following the conformities of JSON-RPC over HTTP, which partially supports GET requests, but completely supports POST requests. Web-sockets are also supported, providing asynchronous message communication. A JSON-RPC request looks similar to: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } And a successful response looks similar to: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } JSON-RPC Methods The following example shows how to create a JSON-RPC API using Sisk. A mathematical operations class performs the remote operations and delivers the serialized response to the client. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // add all methods tagged with WebMethod to the JSON-RPC handler args.Handler.Methods.AddMethodsFromType(new MathOperations()); // maps the /service route to handle JSON-RPC POST and GET requests args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // creates an websocket handler on GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } The above example will map the Sum and Sqrt methods to the JSON-RPC handler, and these methods will be available at GET /service, POST /service and GET /ws. Method names are case-insensitive. Method parameters are automatically deserialized to their specific types. Using a request with named parameters is also supported. JSON serialization is done by the LightJson library. When a type is not correctly deserialized, you can create a specific JSON converter for that type and associate it with your JsonSerializerOptions later. You can also get the $.params raw object from the JSON-RPC request directly in your method. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } For this to occur, @params must be the only parameter in your method, with exactly the name params (in C#, the @ is necessary to escape this parameter name). Parameter deserialization occurs for both named objects or positional arrays. For example, the following method can be called remotely by both requests: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } For an array, the order of the parameters must be followed. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Customizing the serializer You can customize the JSON serializer in the JsonRpcHandler.JsonSerializerOptions property. In this property, you can enable the use of JSON5 for deserializing messages. Although not a conformity with JSON-RPC 2.0, JSON5 is an extension of JSON that allows for more human-readable and legible writing. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // uses a sanitized name comparer. this comparer compares only letters // and digits in a name, and discards other symbols. ex: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // enables JSON5 for the JSON interpreter. even activating this, plain JSON is still allowed e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // maps the POST /service route to the JSON RPC handler e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/extensions/service-providers.html": {
    "href": "docs/extensions/service-providers.html",
    "title": "Service Providers | Sisk",
    "keywords": "Service Providers Service Providers is a way to port your Sisk application to different environments with a portable configuration file. This feature allows you to change the server's port, parameters, and other options without having to modify the application code for each environment. This module depends on the Sisk construction syntax and can be configured through the UsePortableConfiguration method. A configuration provider is implemented with IConfigurationProvider, which provides a configuration reader and can receive any implementation. By default, Sisk provides a JSON configuration reader, but there is also a package for INI files. You can also create your own configuration provider and register it with: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); As mentioned earlier, the default provider is a JSON file. By default, the file name searched for is service-config.json, and it is searched in the current directory of the running process, not the executable directory. You can choose to change the file name, as well as where Sisk should look for the configuration file, with: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); The code above will look for the config.toml file in the current directory of the running process. If not found, it will then search in the directory where the executable is located. If the file does not exist, the createIfDontExists parameter is honored, creating the file, without any content, in the last tested path (based on lookupDirectories), and an error is thrown in the console, preventing the application from initializing. Tip You can look at the source code of the INI configuration reader and the JSON configuration reader to understand how an IConfigurationProvider is implemented. Reading configurations from a JSON file By default, Sisk provides a configuration provider that reads configurations from a JSON file. This file follows a fixed structure and is composed of the following parameters: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Configuration files also support comments ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // new on 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } The parameters created from a configuration file can be accessed in the server constructor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Each configuration reader provides a way to read the server initialization parameters. Some properties are indicated to be in the process environment instead of being defined in the configuration file, such as sensitive API data, API keys, etc. Configuration file structure The JSON configuration file is composed of the following properties: Property Mandatory Description Server Required Represents the server itself with its settings. Server.AccessLogsStream Optional Default to console. Specifies the access log output stream. Can be a filename, null or console. Server.ErrorsLogsStream Optional Default to null. Specifies the error log output stream. Can be a filename, null or console. Server.MaximumContentLength Optional Server.MaximumContentLength Optional Default to 0. Specifies the maximum content length in bytes. Zero means infinite. Server.IncludeRequestIdHeader Optional Default to false. Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions Optional Default to true. Specifies if unhandled exceptions should be thrown. Set to false when production and true when debugging. ListeningHost Required Represents the server listening host. ListeningHost.Label Optional Represents the application label. ListeningHost.Ports Required Represents an array of strings, matching the ListeningPort syntax. ListeningHost.CrossOriginResourceSharingPolicy Optional Setup the CORS headers for the application. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Optional Defaults to false. Specifies the Allow-Credentials header. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Expose-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Optional Defaults to null. This property expects an string. Specifies the Allow-Origin header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Optional Defaults to null. This property expects an array of strings. Specifies multiples Allow-Origin headers. See AllowOrigins for more information. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Methods header. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Optional Defaults to null. This property expects an integer. Specifies the Max-Age header in seconds. ListeningHost.Parameters Optional Specifies the properties provided to the application setup method."
  },
  "docs/extensions/ssl-proxy.html": {
    "href": "docs/extensions/ssl-proxy.html",
    "title": "SSL Proxy | Sisk",
    "keywords": "SSL Proxy Warning This feature is experimental and should not be used in production. Please refer to this document if you want to make Sisk work with SSL. The Sisk SSL Proxy is a module that provides an HTTPS connection for a ListeningHost in Sisk and routes HTTPS messages to an insecure HTTP context. The module was built to provide SSL connection for a service that uses HttpListener to run, which does not support SSL. The proxy runs within the same application and listens for HTTP/1.1 messages, forwarding them in the same protocol to Sisk. Currently, this feature is highly experimental and may be unstable enough to not be used in production. At present, the SslProxy supports almost all HTTP/1.1 features, such as keep-alive, chunked encoding, websockets, etc. For an open connection to the SSL proxy, a TCP connection is created to the target server, and the proxy is forwarded to the established connection. The SslProxy can be used with HttpServer.CreateBuilder as follows: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // add SSL to the project .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); You must provide a valid SSL certificate for the proxy. To ensure that the certificate is accepted by browsers, remember to import it into the operating system so that it functions correctly."
  },
  "docs/features/discard-syntax.html": {
    "href": "docs/features/discard-syntax.html",
    "title": "Discard syntax | Sisk",
    "keywords": "Discard syntax The HTTP server can be used to listen for a callback request from an action, such as OAuth authentication, and can be discarded after receiving that request. This can be useful in cases where you need a background action but do not want to set up an entire HTTP application for it. The following example show us how to create an listening HTTP server at port 5555 with CreateListener and wait the next context: using (var server = HttpServer.CreateListener(5555)) { // wait for the next http request var context = await server.WaitNextAsync(); Console.WriteLine($\"Requested path: {context.Request.Path}\"); } The WaitNext function waits for the next context of a completed request processing. Once the result of this operation is obtained, the server has already fully handled the request and sent the response to the client."
  },
  "docs/features/instancing.html": {
    "href": "docs/features/instancing.html",
    "title": "Dependency injection | Sisk",
    "keywords": "Dependency injection It is common to dedicate members and instances that last for the lifetime of a request, such as a database connection, an authenticated user, or a session token. One of the possibilities is through the HttpContext.RequestBag, which creates a dictionary that lasts for the entire lifetime of a request. This dictionary can be accessed by request handlers and define variables throughout that request. For example, a request handler that authenticates a user sets this user within the HttpContext.RequestBag, and within the request logic, this user can be retrieved with HttpContext.RequestBag.Get<User>(). Here’s an example: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } This is a preliminary example of this operation. The instance of User was created within the request handler dedicated to authentication, and all routes that use this request handler will have the guarantee that there will be a User in their instance of HttpContext.RequestBag. It is possible to define logic to obtain instances when not previously defined in the RequestBag through methods like GetOrAdd or GetOrAddAsync. Since version 1.3, the static property HttpContext.Current was introduced, allowing access to the currently executing HttpContext of the request context. This enables exposing members of the HttpContext outside the current request and defining instances in route objects. The example below defines a controller that has members commonly accessed by the context of a request. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // create an DbContext or get the existing one return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // the following line will throw if the property is accessed when the User is not // defined in the request bag public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // Exposing the HttpRequest instance is supported too public HttpRequest Request { get => HttpContext.Current.Request; } } And define types that inherit from the controller: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } For the example above, you will need to configure a value handler in your router so that the objects returned by the router are transformed into a valid HttpResponse. Note that the methods do not have an HttpRequest request argument as present in other methods. This is because, since version 1.3, the router supports two types of delegates for routing responses: RouteAction, which is the default delegate that receives an HttpRequest argument, and ParameterlessRouteAction. The HttpRequest object can still be accessed by both delegates through the Request property of the static HttpContext on the thread. In the example above, we defined a disposable object, the DbContext, and we need to ensure that all instances created in a DbContext are disposed of when the HTTP session ends. For this, we can use two ways to achieve this. One is to create a request handler that is executed after the router's action, and the other way is through a custom server handler. For the first method, we can create the request handler inline directly in the OnSetup method inherited from RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // get one DbContext defined in the request handler context and // dispose it ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip Since Sisk version 1.4, the property HttpServerConfiguration.DisposeDisposableContextValues is introduced and enabled by default, which defines whether the HTTP server should dispose all IDisposable values in the context bag when an HTTP session is closed. The method above will ensure that the DbContext is disposed of when the HTTP session is finalized. You can do this for more members that need to be disposed of at the end of a response. For the second method, you can create a custom server handler that will dispose of the DbContext when the HTTP session is finalized. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } And use it in your app builder: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); This is a way to handle code cleanup and keep the dependencies of a request separated by the type of module that will be used, reducing the amount of duplicated code within each action of a router. It is a practice similar to what dependency injection is used for in frameworks like ASP.NET."
  },
  "docs/features/logging.html": {
    "href": "docs/features/logging.html",
    "title": "Logging | Sisk",
    "keywords": "Logging You can configure Sisk to write access and error logs automatically. It is possible to define log rotation, extensions and frequency. The LogStream class provides an asynchronous way of writing logs and keeping them in an awaitable write queue. In this article we will show you how to configure logging for your application. File based access logs Logs to files open the file, write the line text, and then close the file for every line written. This procedure was adopted to maintain write responsiveness in the logs. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } The above code will write all incoming requests to the logs/access.log file. Note that, the file is created automatically if it does not exist, however the folder before it does not. It's not necessary to create the logs/ directory as the LogStream class automatically creates it. Stream based logging You can write log files to TextWriter objects instances, such as Console.Out, by passing an TextWriter object in the constructor: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); For every message written in the stream-based log, the TextWriter.Flush() method is called. Access log formatting You can customize the access log format by predefined variables. Consider the following line: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; It will write an message like: 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] You can format your log file by the format described by the table: Value What it represents Example %dd Day of the month (formatted as two digits) 05 %dmmm Full name of the month July %dmm Abbreviated name of the month (three letters) Jul %dm Month number (formatted as two digits) 07 %dy Year (formatted as four digits) 2023 %th Hour in 12-hour format 03 %tH Hour in 24-hour format (HH) 15 %ti Minutes (formatted as two digits) 30 %ts Seconds (formatted as two digits) 45 %tm Milliseconds (formatted as three digits) 123 %tz Time zone offset (total hours in UTC) +03:00 %ri Client's remote IP address 192.168.1.100 %rm HTTP method (uppercase) GET %rs URI scheme (http/https) https %ra URI authority (domain) example.com %rh Host of the request www.example.com %rp Port of the request 443 %rz Path of the request /path/to/resource %rq Query string ?key=value&another=123 %sc HTTP response status code 200 %sd HTTP response status description OK %lin Human-readable size of the request 1.2 KB %linr Raw size of the request (bytes) 1234 %lou Human-readable size of the response 2.5 KB %lour Raw size of the response (bytes) 2560 %lms Elapsed time in milliseconds 120 %ls Execution status Executed Rotating logs Tip In Sisk 0.15 and older, this function is only available with the Sisk.ServiceProvider package. In Sisk 0.16 and above, this function is implemented on it's core package. You can configure the HTTP server to rotate the log files to a compressed .gz file when they reach a certain size. The size is checked periodically by the limiar you define. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); The above code will check every six hours if the LogStream's file has reached it's 1MB limit. If so, the file is compressed to an .gz file and it then access.log is cleaned. During this process, writing to the file is locked until the file is compressed and cleaned. All lines that enter to be written in this period will be in a queue waiting for the end of compression. This function only works with file-based LogStreams. Error logging When a server is not throwing errors to the debugger, it forwards the errors to log writing when there are any. You can configure error writing with: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); This property will only write something to the log if the error is not captured by the callback or the Router.CallbackErrorHandler property. The error written by the server always writes the date and time, the request headers (not the body), the error trace, and the inner exception trace, if theres any. Other logging instances Your application can have zero or multiple LogStreams, there is no limit on how many log channels it can have. Therefore, it is possible to direct your application's log to a file other than the default AccessLog or ErrorLog. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Application started at {0}\", DateTime.Now); Extending LogStream You can extend the LogStream class to write custom formats, compatible with the current Sisk log engine. The example below allows to write colorful messages into the Console through Spectre.Console library: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Another way to automatically write custom logs for each request/response is to create an HttpServerHandler. The example below is a little more complete. It writes the body of the request and response in JSON to the Console. It can be useful for debugging requests in general. This example makes use of ContextBag and HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // At this point, the connection is open and the client has sent the header specifying // that the content is JSON.The line below reads the content and leaves it stored in the request. // // If the content is not read in the request action, the GC is likely to collect the content // after sending the response to the client, so the content may not be available after the response is closed. // _ = request.RawBody; // add hint in the context to tell that this request has an json body on it request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformats the JSON using the CypherPotato.LightJson library var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // check if the response is JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // gets the internal server handling status responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/features/server-sent-events.html": {
    "href": "docs/features/server-sent-events.html",
    "title": "Server Sent Events | Sisk",
    "keywords": "Server Sent Events Sisk supports sending messages through Server Sent Events out of the box. You can create disposable and persistent connections, get the connections during runtime and use them. This feature has some limitations imposed by browsers, such as sending only texts messages and not being able to permanently close a connection. A server-side closed connection will have a client periodically trying to reconnect every 5 seconds (3 for some browsers). These connections are useful for sending events from the server to the client without having the client request the information every time. Creating an SSE connection A SSE connection works like a regular HTTP request, but instead of sending a response and immediately closing the connection, the connection is kept open to send messages. Calling the HttpRequest.GetEventSource() method, the request is put in a waiting state while the SSE instance is created. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.Send(\"Hello, world!\"); return sse.Close(); }); In the above code, we create an SSE connection and send a \"Hello, world\" message, then we close the SSE connection from the server side. Note When closing a server-side connection, by default the client will try to connect again at that end and the connection will be restarted, executing the method again, forever. It's common to forward a termination message from the server whenever the connection is closed from the server to prevent the client from trying to reconnect again. Appending headers If you need to send headers, you can use the HttpRequestEventSource.AppendHeader method before sending any messages. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Hello!\"); return sse.Close(); }); Note that it is necessary to send the headers before sending any messages. Wait-For-Fail connections Connections are normally terminated when the server is no longer able to send messages due to an possible client-side disconnection. With that, the connection is automatically terminated and the instance of the class is discarded. Even with a reconnection, the instance of the class will not work, as it is linked to the previous connection. In some situations, you may need this connection later and you don't want to manage it via the callback method of the route. For this, we can identify the SSE connections with an identifier and get them using it later, even outside the callback of the route. In addition, we mark the connection with WaitForFail so as not to terminate the route and terminate the connection automatically. An SSE connection in KeepAlive will wait for a send error (caused by disconnection) to resume method execution. It is also possible to set a Timeout for this. After the time, if no message has been sent, the connection is terminated and execution resumes. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // wait for 15 seconds without any message before terminating the connection return sse.Close(); }); The above method will create the connection, handle it and wait for a disconnection or error. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // the connection is still alive evs.Send(\"Hello again!\"); } And the snippet above will try to look for the newly created connection, and if it exists, it will send a message to it. All active server connections that are identified will be available in the collection HttpServer.EventSources. This collection only stores active and identified connections. Closed connections are removed from the collection. Note It is important to note that keep alive has a limit established by components that may be connected to Sisk in an uncontrollable way, such as an web proxy, an HTTP kernel or a network driver, and they close idle connections after a certain period of time. Therefore, it is important to keep the connection open by sending periodic pings or extending the maximum time before the connection is closed. Read the next section to better understand sending periodic pings. Setup connections ping policy Ping Policy is an automated way of sending periodic messages to your client. This function allows the server to understand when the client has disconnected from that connection without having to keep the connection open indefinitely. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } In the code above, every 5 seconds, a new ping message will be sent to the client. This will keep the TCP connection alive and prevent it from being closed due to inactivity. Also, when a message fails to be sent, the connection is automatically closed, freeing up the resources used by the connection. Querying connections You can search for active connections using a predicate on the connection identifier, to be able to broadcast, for example. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Broadcasting to all event sources that starts with 'my-connection-'\"); } You can also use the All method to get all active SSE connections."
  },
  "docs/features/websockets.html": {
    "href": "docs/features/websockets.html",
    "title": "Web Sockets | Sisk",
    "keywords": "Web Sockets Sisk supports web sockets as well, such as receiving and sending messages to their client. This feature works fine in most browsers, but in Sisk it is still experimental. Please, if you find any bugs, report it on github. Accepting and receiving messages asynchronously The example below shows how websocket works in practice, with an example of opening a connection, receiving a message and displaying it in the console. All messages received by WebSocket are received in bytes, so you will have to decode them upon receipt. By default, messages are fragmented into chunks and the last piece is sent as the final packet of the message. You can configure the packet size with the WebSocketBufferSize flag. This buffering is the same for sending and receiving messages. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Received message: \" + msgText); // gets the HttpWebSocket context which received the message HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Response!\"); }; ws.WaitForClose(); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Accepting and receiving messages synchronously The example below contains a way for you to use a synchronous websocket, without an asynchronous context, where you receive the messages, deal with them, and finish using the socket. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/connect\", (req) => { var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"What is your name?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Please, insert your name!\"); goto askName; } askAge: ws.Send(\"And your age?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Please, insert an valid number\"); goto askAge; } ws.Send($\"You're {name}, and you are {age} old.\"); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Sending messages The Send method has three overloads, which allow you to send text, a byte array, or a byte span. All of them is chunked if the server's WebSocketBufferSize flag is greater than the total payload size. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Hello, world\"); // will be encoded as an UTF-8 byte array ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Waiting for websocket close The method WaitForClose() blocks the current call stack until the connection is terminated by either the client or the server. With this, the execution of the callback of the request will be blocked until the client or the server disconnects. You can also manually close the connection with the Close() method. This method returns an empty HttpResponse object, which is not sent to the client, but works as a return from the function where the HTTP request was received. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // wait for client close connection ws.WaitForClose(); // waits until no messages are exchanged in the 60 seconds // or until some party closes the connection ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Ping Policy Similar to how ping policy in Server Side Events works, you can also configure a ping policy to keep the TCP connection open if there is inactivity in it. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/fundamentals/request-handlers.html": {
    "href": "docs/fundamentals/request-handlers.html",
    "title": "Request handling | Sisk",
    "keywords": "Request handling Request handlers, also known as \"middlewares\", are functions that run before or after a request is executed on the router. They can be defined per route or per router. There are two types of request handlers: BeforeResponse: defines that the request handler will be executed before calling the router action. AfterResponse: defines that the request handler will be executed after calling the router action. Sending an HTTP response in this context will overwrite the router's action response. Both requests handlers can override the actual router callback function response. By the way, request handlers can be useful for validating a request, such as authentication, content, or any other information, such as storing information, logs, or other steps that can be performed before or after a response. This way, a request handler can interrupt all this execution and return a response before finishing the cycle, discarding everything else in the process. Example: let's assume that a user authentication request handler does not authenticate him. It will prevent the request lifecycle from being continued and will hang. If this happens in the request handler at position two, the third and onwards will not be evaluated. Creating an request handler To create a request handler, we can create a class that inherits the IRequestHandler interface, in this format: public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Returning null indicates that the request cycle can be continued return null; } else { // Returning an HttpResponse object indicates that this response will overwrite adjacent responses. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } In the above example, we indicated that if the Authorization header is present in the request, it should continue and the next request handler or the router callback should be called, whichever comes next. If it's a request handler is executed after the response by their property ExecutionMode and return an non-null value, it will overwrite the router's response. Whenever a request handler returns null, it indicates that the request must continue and the next object must be called or the cycle must end with the router's response. Associating a request handler with a single route You can define one or more request handlers for a route. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // before request handler new ValidateJsonContentRequestHandler(), // before request handler // -- method IndexPage will be executed here new WriteToLogRequestHandler() // after request handler }); Or creating an Route object: Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Associating a request handler with a router You can define a global request handler that will runned on all routes on a router. mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Associating a request handler with an attribute You can define a request handler on a method attribute along with a route attribute. public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() .WithContent(new StringContent(\"Hello world!\")); } } Note that it is necessary to pass the desired request handler type and not an object instance. That way, the request handler will be instantiated by the router parser. You can pass arguments in the class constructor with the ConstructorArguments property. Example: [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } You can also create your own attribute that implements RequestHandler: public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } And use it as: [Authenticate] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Bypassing an global request handler After defining a global request handler on a route, you can ignore this request handler on specific routes. var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: the same instance of what is in the global request handlers new AuthenticateUserRequestHandler() // wrong: will not skip the global request handler } }); Note If you're bypassing a request handler you must use the same reference of what you instanced before to skip. Creating another request handler instance will not skip the global request handler since it's reference will change. Remember to use the same request handler reference used in both GlobalRequestHandlers and BypassGlobalRequestHandlers."
  },
  "docs/fundamentals/requests.html": {
    "href": "docs/fundamentals/requests.html",
    "title": "Requests | Sisk",
    "keywords": "Requests Requests are structures that represent an HTTP request message. The HttpRequest object contains useful functions for handling HTTP messages throughout your application. An HTTP request is formed by the method, path, version, headers and body. In this document, we will teach you how to obtain each of these elements. Getting the request method To obtain the method of the received request, you can use the Method property: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } This property returns the request's method represented by an HttpMethod object. Note Unlike route methods, this property does not serves the RouteMethod.Any item. Instead, it returns the real request method. Getting request url components You can get various component from a URL through certain properties of a request. For this example, let's consider the URL: http://localhost:5000/user/login?email=foo@bar.com Component name Description Component value Path Gets the request path. /user/login FullPath Gets the request path and the query string. /user/login?email=foo@bar.com FullUrl Gets the entire URL request string. http://localhost:5000/user/login?email=foo@bar.com Host Gets the request host. localhost Authority Gets the request host and port. localhost:5000 QueryString Gets the request query. ?email=foo@bar.com Query Gets the request query in a named value collection. {StringValueCollection object} IsSecure Determines if the request is using SSL (true) or not (false). false You can also opt by using the HttpRequest.Uri property, which includes everything above in one object. Getting the request body Some requests include body such as forms, files, or API transactions. You can get the body of a request from the property: // gets the request body as an string, using the request encoding as the encoder string body = request.Body; // or gets it in an byte array byte[] bodyBytes = request.RawBody; // or else, you can stream it. Stream requestStream = request.GetRequestStream(); It is also possible to determine if there is a body in the request and if it is loaded with the properties HasContents, which determines if the request has contents and IsContentAvailable which indicates that the HTTP server fully received the content from the remote point. It is not possible to read the request content through GetRequestStream more than once. If you read with this method, the values in RawBody and Body will also not be available. It's not necessary to dispose the request stream in the context of the request, as it is disposed at the end of the HTTP session in which it is created. Also, you can use HttpRequest.RequestEncoding property to get the best encoding to decode the request manually. The server has limits for reading the request content, which applies to both HttpRequest.Body and HttpRequest.RawBody. These properties copies the entire input stream to an local buffer of the same size of HttpRequest.ContentLength. A response with status 413 Content Too Large is returned to the client if the content sent is larger than HttpServerConfiguration.MaximumContentLength defined in the user configuration. Additionally, if there is no configured limit or if it is too large, the server will throw an OutOfMemoryException when the content sent by the client exceeds Int32.MaxValue (2 GB) and if the content is attempted to be accessed through one of the properties mentioned above. You can still deal with the content through streaming. Note Although Sisk allows it, it is always a good idea to follow HTTP Semantics to create your application and not obtain or serve content in methods that do not allow it. Read about RFC 9110 \"HTTP Semantics\". Getting the request context The HTTP Context is an exclusive Sisk object that stores HTTP server, route, router and request handler information. You can use it to be able to organize yourself in an environment where these objects are difficult to organize. The RequestBag object contains stored information that is passed from an request handler to another point, and can be consumed at the final destination. This object can also be used by request handlers that run after the route callback. Tip This property is also acessible by HttpRequest.Bag property. public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers[\"Authorization\"] != null) { context.RequestBag.Add(\"AuthenticatedUser\", \"Bob\"); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } The above request handler will define AuthenticatedUser in the request bag, and can be consumed later in the final callback: public class MyController { [Route(RouteMethod.Get, \"/\")] [RequestHandler(typeof(AuthenticateUserRequestHandler))] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); string authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; res.Content = new StringContent($\"Hello, {authUser}!\"); return res; } } You can also use the Bag.Set() and Bag.Get() helper methods to get or set objects by their type singletons. public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse Test(HttpRequest request) { var user = request.Bag.Get<User>(); } Getting form data You can get the values of a form data in an NameValueCollection with the example below: static HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password) == true) { ... } } Getting multipart form data Sisk's HTTP request lets you get uploaded multipart contents, such as a files, form fields, or any binary content. static HttpResponse Index(HttpRequest request) { // the following method reads the entire request input into an // array of MultipartObjects var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // The name of the file provided by Multipart form data. // Null is returned if the object is not a file. Console.WriteLine(\"File name : \" + uploadedObject.Filename); // The multipart form data object field name. Console.WriteLine(\"Field name : \" + uploadedObject.Name); // The multipart form data content length. Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // Determine the image format based in the file header for each // known content type. If the content ins't an recognized common file // format, this method below will return MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } You can read more about Sisk Multipart form objects and it's methods, properties and functionalities. Server-sent events support Sisk supports Server-sent events, which allows sending chunks as an stream and keeping the connection between the server and the client alive. Calling the HttpRequest.GetEventSource method will put the HttpRequest in it's listener state. From this, the context of this HTTP request will not expect an HttpResponse as it will overlap the packets sent by server side events. After sending all packets, the callback must return the Close method, which will send the final response to the server and indicate that the streaming has ended. It's not possible to predict what the total length of all packets that will be sent, so it is not possible to determine the end of the connection with Content-Length header. By most browsers defaults, server-side events does not support sending HTTP headers or methods other than the GET method. Therefore, be careful when using request handlers with event-source requests that require specific headers in the request, as it probably they ins't going to have them. Also, most browsers restart streams if the EventSource.close method ins't called on the client side after receiving all the packets, causing infinite additional processing on the server side. To avoid this kind of problem, it's common to send an final packet indicating that the event source has finished sending all packets. The example below shows how the browser can communicate with the server that supports Server-side events. <html> <body> <b>Fruits:</b> <ul></ul> </body> <script> const evtSource = new EventSource('/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> And progressively send the messages to the client: public class MyController { [Route(RouteMethod.Get, \"/event-source\")] static HttpResponse ServerEventsResponse(HttpRequest request) { var serverEvents = request.GetEventSource(); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { serverEvents.Send(fruit); Thread.Sleep(1500); } return serverEvents.Close(); } } When running this code, we expect a result similar to this: Resolving proxied IPs and hosts Sisk can be used with proxies, and therefore IP addresses can be replaced by the proxy endpoint in the transaction from a client to the proxy. You can define your own resolvers in Sisk with forwarding resolvers. Headers encoding Header encoding can be a problem for some implementations. On Windows, UTF-8 headers are not supported, so ASCII is used. Sisk has a built-in encoding converter, which can be useful for decoding incorrectly encoded headers. This operation is costly and disabled by default, but can be enabled under the NormalizeHeadersEncodings flag."
  },
  "docs/fundamentals/responses.html": {
    "href": "docs/fundamentals/responses.html",
    "title": "Responses | Sisk",
    "keywords": "Responses Responses represent objects that are HTTP responses to HTTP requests. They are sent by the server to the client as an indication of the request for a resource, page, document, file or other object. An HTTP response is formed up of status, headers and content. In this document, we will teach you how to architect HTTP responses with Sisk. Setting an HTTP status The HTTP status list is the same since HTTP/1.0, and Sisk supports all of them. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 Or with Fluent Syntax: new HttpResponse() .WithStatus(200) // or .WithStatus(HttpStatusCode.Ok) // or .WithStatus(HttpStatusInformation.Ok); You can see the full list of available HttpStatusCode here. You can also provide your own status code by using the HttpStatusInformation structure. Body and content-type Sisk supports native .NET content objects to send body in responses. You can use the StringContent class to send a JSON response for example: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); The server will always attempt to calculate the Content-Length from what you have defined in the content if you haven't explicitly defined it in a header. If the server cannot implicitly obtain the Content-Length header from the response content, the response will be sent with Chunked-Encoding. You can also stream the response by sending a StreamContent or using the method GetResponseStream. Response headers You can add, edit or remove headers you're sending in the response. The example below shows how to send an redirect response to the client. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Or with Fluent Syntax: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); When you use the Add method of HttpHeaderCollection, you are adding a header to the request without altering the ones already sent. The Set method replaces the headers with the same name with the instructed value. The indexer of HttpHeaderCollection internally calls the Set method to replace the headers. Sending cookies Sisk has methods that facilitate the definition of cookies in the client. Cookies set by this method are already URL encoded and fit the RFC-6265 standard. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Or with Fluent Syntax: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); There are other more complete versions of the same method. Chunked responses You can set the transfer encoding to chunked to send large responses. HttpResponse res = new HttpResponse(); res.SendChunked = true; When using chunked-encoding, the Content-Length header is automatically omitted. Response stream Response streams are an managed way that allow you to send responses in a segmented way. It's a lower level operation than using HttpResponse objects, as they require you to send the headers and content manually, and then close the connection. This example opens an read-only stream for the file, copies the stream to the response output stream and doens't loads the entire file in the memory. This can be useful to serving medium or big files. // gets the response output stream using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // sets the response encoding to use chunked-encoding // also you shouldn't send content-length header when using // chunked encoding responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copies the file stream to the response output stream fileStream.CopyTo(responseStream.ResponseStream); // closes the stream return responseStream.Close(); GZip, Deflate and Brotli compression You can send responses with compressed content in Sisk with compressing HTTP contents. Firstly, encapsulate your HttpContent object within one of the compressors below to send the compressed response to the client. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // or Content = new BrotliContent(new HtmlContent(myHtml)), // or Content = new DeflateContent(new HtmlContent(myHtml)), }; }); You can also use these compressed contents with streams. router.MapGet(\"/archive.zip\", request => { // do not apply \"using\" here. the HttpServer will discard your content // after sending the response. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); The Content-Encoding headers are automatically set when using these contents. Implicit response types Since version 0.15, you can use other return types besides HttpResponse, but it is necessary to configure the router how it will handle each type of object. The concept is to always return a reference type and turn it into a valid HttpResponse object. Routes that return HttpResponse do not undergo any conversion. Value types (structures) cannot be used as a return type because they are not compatible with the RouterCallback, so they must be wrapped in a ValueResult to be able to be used in handlers. Consider the following example from a router module not using HttpResponse in the return type: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } With that, now it is necessary to define in the router how it will deal with each type of object. Objects are always the first argument of the handler and the output type must be a valid HttpResponse. Also, the output objects of a route should never be null. For ValueResult types it is not necessary to indicate that the input object is a ValueResult and only T, since ValueResult is an object reflected from its original component. The association of types does not compare what was registered with the type of the object returned from the router callback. Instead, it checks whether the type of the router result is assignable to the registered type. Registering a handler of type Object will fallback to all previously unvalidated types. The inserting order of the value handlers also matters, so registering an Object handler will ignore all other type-specific handlers. Always register specific value handlers first to ensure order. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<bool>(bolVal => { HttpResponse res = new HttpResponse(); res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest; return res; }); r.RegisterValueHandler<IEnumerable>(enumerableValue => { return new HttpResponse(); // do something with enumerableValue here }); // registering an value handler of object must be the last // value handler which will be used as an fallback r.RegisterValueHandler<object>(fallback => { HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.OK; res.Content = JsonContent.Create(fallback); return res; });"
  },
  "docs/fundamentals/routing.html": {
    "href": "docs/fundamentals/routing.html",
    "title": "Routing | Sisk",
    "keywords": "Routing The Router is the first step in building the server. It is responsible for housing Route objects, which are endpoints that map URLs and their methods to actions executed by the server. Each action is responsible for receiving a request and delivering a response to the client. The routes are pairs of path expressions (\"path pattern\") and the HTTP method that they can listen to. When a request is made to the server, it will attempt to find a route that matches the received request, then it will call the action of that route and deliver the resulting response to the client. There are multiple ways to define routes in Sisk: they can be static, dynamic or auto-scanned, defined by attributes, or directly in the Router object. Router mainRouter = new Router(); // maps the GET / route into the following action mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); To understand what a route is capable of doing, we need to understand what a request is capable of doing. An HttpRequest will contain everything you need. Sisk also includes some extra features that speed up the overral development. For every action received by the server, a delegate of type RouteAction will be called. This delegate contains an parameter holding an HttpRequest with all the necessary information about the request received by the server. The resulting object from this delegate must be an HttpResponse or an object that maps to it through implicit response types. Matching routes When a request is received by the HTTP server, Sisk searches for a route that satisfies the expression of the path received by the request. The expression is always tested between the route and the request path, without considering the query string. This test does not have priority and is exclusive to a single route. When no route is matched with that request, the Router.NotFoundErrorHandler response is returned to the client. When the path pattern is matched, but the HTTP method is mismatched, the Router.MethodNotAllowedErrorHandler response is sent back to the client. Sisk checks for the possibility of route collisions to avoid these problems. When defining routes, Sisk will look for possible routes that might collide with the route being defined. This test includes checking the path and the method that the route is set to accept. Creating routes using path patterns You can define routes using various SetRoute methods. // SetRoute way mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Hello, {name}\"); }); // Map* way mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // empty 200 ok }); // Route.* helper methods mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // the StreamContent inner // stream is disposed after sending // the response. Content = new StreamContent(imageStream) }; }); // multiple parameters mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Hello, {name} {surname}!\"); }); The RouteParameters property of HttpResponse contains all the information about the path variables of the received request. Every path received by the server is normalized before the path pattern test is executed, following these rules: All empty segments are removed from the path, eg: ////foo//bar becomes /foo/bar. Path matching is case-sensitive, unless Router.MatchRoutesIgnoreCase is set to true. The Query and RouteParameters properties of HttpRequest return a StringValueCollection object, where each indexed property returns a non-null StringValue, which can be used as an option/monad to convert its raw value into a managed object. The example below reads the route parameter \"id\" and obtains a Guid from it. If the parameter is not a valid Guid, an exception is thrown, and a 500 error is returned to the client if the server is not handling Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note Paths have their trailing / ignored in both request and route path, that is, if you try to access a route defined as /index/page you'll be able to access using /index/page/ too. You can also force URLs to terminate with / enabling the ForceTrailingSlash flag. Creating routes using class instances You can also define routes dynamically using reflection with the attribute RouteAttribute. This way, the instance of a class in which its methods implement this attribute will have their routes defined in the target router. For a method to be defined as a route, it must be marked with a RouteAttribute, such as the attribute itself or a RouteGetAttribute. The method can be static, instance, public, or private. When the method SetObject(type) or SetObject<TType>() is used, instance methods are ignored. public class MyController { // will match GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // static methods works too [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } The line below will define both the Index and Hello methods of MyController as routes, as both are marked as routes, and an instance of the class has been provided, not its type. If its type had been provided instead of an instance, only the static methods would be defined. var myController = new MyController(); mainRouter.SetObject(myController); Since Sisk version 0.16, it is possible to enable AutoScan, which will search for user-defined classes that implement RouterModule and will automatically associate it with the router. This is not supported with AOT compilation. mainRouter.AutoScanModules<ApiController>(); The above instruction will search for all types which implements ApiController but not the type itself. The two optional parameters indicate how the method will search for these types. The first argument implies the Assembly where the types will be searched and the second indicates the way in which the types will be defined. Regex routes Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Or with RegexRoute class: RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); }); mainRouter.SetRoute(indexRoute); You can also capture groups from the regex pattern into the HttpRequest.RouteParameters contents: [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessing file {filename}\"); } Any method routes You can define a route to be matched only by its path and skip the HTTP method. This can be useful for you to do method validation inside the route callback. // will match / on any HTTP method mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Any path routes Any path routes test for any path received by the HTTP server, subject to the route method being tested. If the route method is RouteMethod.Any and the route uses Route.AnyPath in its path expression, this route will listen to all requests from the HTTP server, and no other routes can be defined. // the following route will match all POST requests mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Ignore case route matching By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable this option: mainRouter.MatchRoutesIgnoreCase = true; This will also enable the option RegexOptions.IgnoreCase for routes where it's regex-matching. Not Found (404) callback handler You can create a custom callback for when a request doesn't match any known routes. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Since v0.14 Content = new HtmlContent(\"<h1>Not found</h1>\") // older versions Content = new StringContent(\"<h1>Not found</h1>\", Encoding.UTF8, \"text/html\") }; }; Method not allowed (405) callback handler You can also create a custom callback for when a request matches it's path, but doens't match the method. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Method not allowed for this route.\") }; }; Internal error handler Route callbacks can throw errors during server execution. If not handled correctly, the overall functioning of the HTTP server can be terminated. The router has a callback for when a route callback fails and prevents service interruption. This method is only reacheable when ThrowExceptions is set to false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Error: {ex.Message}\") }; };"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started with Sisk | Sisk",
    "keywords": "Getting Started with Sisk Sisk can run in any .NET environment. In this guide, we will teach you how to create a Sisk application using .NET. If you haven't installed it yet, please download the SDK from here. In this tutorial, we will cover how to create a project structure, receive a request, obtain a URL parameter, and send a response. This guide will focus on building a simple server using C#. You can also use your favorite programming language. Note You may be interested in a quickstart project. Check this repository for more information. Creating a Project Let's name our project \"My Sisk Application.\" Once you have .NET set up, you can create your project with the following command: dotnet new console -n my-sisk-application Next, navigate to your project directory and install Sisk using the .NET utility tool: cd my-sisk-application dotnet add package Sisk.HttpServer You can find additional ways to install Sisk in your project here. Now, let's create an instance of our HTTP server. For this example, we will configure it to listen on port 5000. Building the HTTP Server Sisk allows you to build your application step by step manually, as it routes to the HttpServer object. However, this may not be very convenient for most projects. Therefore, we can use the builder method, which makes it easier to get our app up and running. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } It's important to understand each vital component of Sisk. Later in this document, you will learn more about how Sisk works. Manual (advanced) setup You can learn how each Sisk mechanism works in this section of the documentation, which explains the behavior and relationships between the HttpServer, Router, ListeningPort, and other components."
  },
  "docs/installing.html": {
    "href": "docs/installing.html",
    "title": "Installing | Sisk",
    "keywords": "Installing You can install Sisk through Nuget, dotnet cli or another options. You can easily setup your Sisk environment by running this command in your developer console: Warning Newest versions of Sisk are compatible with .NET 8 and soon .NET 9. Legacy versions of Sisk for .NET 6 and .NET 7 will be maintained until November 30, 2024, receiving only security patches and fixes under the \"legacy\" branch. Please, update your projects using Sisk to .NET 8. dotnet add package Sisk.HttpServer This command will install the latest version of Sisk in your project."
  },
  "docs/native-aot.html": {
    "href": "docs/native-aot.html",
    "title": "Native AOT support | Sisk",
    "keywords": "Native AOT support In the .NET 7, Native AOT was introduced, a .NET compilation mode that allows you to export ready binaries on any supported platform, without requiring the .NET runtime to be installed on the target machine. With Native AOT, your code is compiled for native code and already contains everything it needs to be executed. Sisk has been experimenting with the feature since version 0.9.1, which improves support for Native AOT with features to define dynamic routes by application without afecting the compilation with warning messages. Sisk uses reflection to obtain the methods that will be defined from types and objects. In addition, Sisk uses reflection for attributes such as RequestHandlerAttribute, which are initialized from a type. To function properly, AOT compilation uses trimming, where dynamic types should be specified what will be used in the final assembly. Considering the example below, it is a route that calls a RequestHandler. [Route(RouteMethod.Get, \"/\", LogMode = LogOutput.None)] [RequestHandler(typeof(MyRequestHandler))] static HttpResponse IndexPage(HttpRequest request) { HttpResponse htmlResponse = new HttpResponse(); htmlResponse.Content = new StringContent(\"Hello, world!\", System.Text.Encoding.UTF8, \"text/plain\"); return htmlResponse; } This RequestHandler is dynamically invoked during the runtime, and this invocation must be segmented, and this segmentation must be explicitly. To better understand what the compiler will consider from MyRequestHandler should be kept in the final compilation is: Public properties; Public and private fields; Public and private constructors; Public and private methods; Everything you have in a RequestHandler that is not mentioned above will be removed by the compiler. Remembering that all other components, classes and packages that you use in your application should be compatible with AOT Trimming, or your code will not function as expected. By the way, Sisk will not leave you if they want to build something where performance is a priority. You can read more about Native AOT and how it works in the official Microsoft Documentation."
  },
  "docs/pt-br/advanced/forwarding-resolvers.html": {
    "href": "docs/pt-br/advanced/forwarding-resolvers.html",
    "title": "Forwarding Resolvers | Sisk",
    "keywords": "Forwarding Resolvers Um Forwarding Resolver é um auxiliar que ajuda a decodificar informações que identificam o cliente por meio de uma solicitação, proxy, CDN ou balanceadores de carga. Quando seu serviço Sisk é executado por meio de um proxy inverso ou avançado, o endereço IP, o host e o protocolo do cliente podem ser diferentes da solicitação original, pois é um encaminhamento de um serviço para outro. Essa funcionalidade do Sisk permite que você controle e resolva essas informações antes de trabalhar com a solicitação. Esses proxies geralmente fornecem cabeçalhos úteis para identificar seu cliente. Atualmente, com a classe ForwardingResolver, é possível resolver o endereço IP do cliente, o host e o protocolo HTTP usado. Após a versão 1.0 do Sisk, o servidor não possui mais uma implementação padrão para decodificar esses cabeçalhos por motivos de segurança que variam de serviço para serviço. Por exemplo, o cabeçalho X-Forwarded-For inclui informações sobre os endereços IP que encaminharam a solicitação. Este cabeçalho é usado por proxies para transportar uma cadeia de informações para o serviço final e inclui o IP de todos os proxies usados, incluindo o endereço real do cliente. O problema é: às vezes é desafiador identificar o IP remoto do cliente e não há uma regra específica para identificar este cabeçalho. É altamente recomendável ler a documentação dos cabeçalhos que você está prestes a implementar abaixo: Leia sobre o cabeçalho X-Forwarded-For aqui. Leia sobre o cabeçalho X-Forwarded-Host aqui. Leia sobre o cabeçalho X-Forwarded-Proto aqui. A classe ForwardingResolver Esta classe possui três métodos virtuais que permitem a implementação mais adequada para cada serviço. Cada método é responsável por resolver informações da solicitação por meio de um proxy: o endereço IP do cliente, o host da solicitação e o protocolo de segurança usado. Por padrão, o Sisk sempre usará as informações da solicitação original, sem resolver nenhum cabeçalho. O exemplo abaixo mostra como essa implementação pode ser usada. Este exemplo resolve o endereço IP do cliente através do cabeçalho X-Forwarded-For e lança um erro quando mais de um IP foi encaminhado na solicitação. [!IMPORTANTE] Não use este exemplo em código de produção. Verifique sempre se a implementação é apropriada para uso. Leia a documentação do cabeçalho antes de implementá-lo. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"O cabeçalho X-Forwarded-For está faltando.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Número excessivo de endereços no cabeçalho X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/pt-br/advanced/http-server-handlers.html": {
    "href": "docs/pt-br/advanced/http-server-handlers.html",
    "title": "Handlers de servidor HTTP | Sisk",
    "keywords": "Handlers de servidor HTTP Na versão 0.16 do Sisk, introduzimos a classe HttpServerHandler, que visa estender o comportamento geral do Sisk e fornecer manipuladores de eventos adicionais ao Sisk, como lidar com solicitações HTTP, roteadores, bolsas de contexto e muito mais. A classe concentra eventos que ocorrem durante a vida útil do servidor HTTP inteiro e também de uma solicitação. O protocolo HTTP não possui sessões e, portanto, não é possível preservar informações de uma solicitação para outra. O Sisk, por enquanto, fornece uma maneira para você implementar sessões, contextos, conexões de banco de dados e outros provedores úteis para ajudar no seu trabalho. Consulte esta página para saber onde cada evento é acionado e qual é o seu propósito. Você também pode visualizar o ciclo de vida de uma solicitação HTTP para entender o que acontece com uma solicitação e onde os eventos são disparados. O servidor HTTP permite que você use vários manipuladores ao mesmo tempo. Cada chamada de evento é síncrona, ou seja, bloqueará a thread atual para cada solicitação ou contexto até que todos os manipuladores associados a essa função sejam executados e concluídos. Ao contrário dos RequestHandlers, eles não podem ser aplicados a alguns grupos de rotas ou rotas específicas. Em vez disso, eles são aplicados a todo o servidor HTTP. Você pode aplicar condições dentro do seu Http Server Handler. Além disso, singletons de cada HttpServerHandler são definidos para cada aplicativo Sisk, portanto, apenas uma instância por HttpServerHandler é definida. Um exemplo prático de uso do HttpServerHandler é descartar automaticamente uma conexão de banco de dados no final da solicitação. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // verifica se a solicitação definiu um DbContext // em sua bolsa de contexto if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // permite que o usuário crie um dbcontext a partir de uma solicitação HTTP // e armazene-o em sua bolsa de contexto public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } Com o código acima, a extensão GetDbContext permite que uma conexão de contexto seja criada diretamente do objeto HttpRequest. Uma conexão não descartada pode causar problemas ao executar com o banco de dados, portanto, é encerrada em OnHttpRequestClose. Você pode registrar um manipulador em um servidor HTTP em seu construtor ou diretamente com HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } Com isso, a classe UsersController pode usar o contexto do banco de dados como: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"User added.\"); } } O código acima usa métodos como JsonOk e JsonMessage que são integrados ao ApiController, que é herdado de um RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Os desenvolvedores podem implementar sessões, contextos e conexões de banco de dados usando esta classe. O código fornecido mostra um exemplo prático com o DatabaseConnectionHandler, automatizando o descarte da conexão do banco de dados no final de cada solicitação. A integração é simples, com manipuladores registrados durante a configuração do servidor. A classe HttpServerHandler oferece um conjunto poderoso de ferramentas para gerenciar recursos e estender o comportamento do Sisk em aplicações HTTP."
  },
  "docs/pt-br/advanced/manual-setup.html": {
    "href": "docs/pt-br/advanced/manual-setup.html",
    "title": "Configuração manual (avançado) | Sisk",
    "keywords": "Configuração manual (avançado) Nesta seção, vamos criar nosso servidor HTTP sem nenhum padrão predefinido, de uma maneira completamente abstrata. Aqui, você pode construir manualmente como seu servidor HTTP funcionará. Cada ListeningHost possui um roteador, e um servidor HTTP pode ter vários ListeningHosts, cada um apontando para um host diferente em uma porta diferente. Primeiro, precisamos entender o conceito de solicitação/resposta. É bastante simples: para cada solicitação, deve haver uma resposta. O Sisk segue esse princípio também. Vamos criar um método que responda com uma mensagem \"Olá, Mundo!\" em HTML, especificando o código de status e cabeçalhos. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Olá, mundo!</h1> </body> </html> \") }; return indexResponse; } O próximo passo é associar esse método a uma rota HTTP. Roteadores Roteadores são abstrações de rotas de solicitação e servem como a ponte entre solicitações e respostas para o serviço. Roteadores gerenciam rotas de serviço, funções e erros. Um roteador pode ter várias rotas, e cada rota pode realizar diferentes operações naquele caminho, como executar uma função, servir uma página ou fornecer um recurso do servidor. Vamos criar nosso primeiro roteador e associar nosso método IndexPage ao caminho index. Router mainRouter = new Router(); // SetRoute associará todas as rotas index às nossas funções. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Agora nosso roteador pode receber solicitações e enviar respostas. No entanto, mainRouter não está vinculado a um host ou servidor, então ele não funcionará sozinho. O próximo passo é criar nosso ListeningHost. Hosts de Escuta e Portas Um ListeningHost pode hospedar um roteador e várias portas de escuta para o mesmo roteador. Um ListeningPort é um prefixo onde o servidor HTTP irá escutar. Aqui, podemos criar um ListeningHost que aponta para dois endpoints para nosso roteador: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Agora nosso servidor HTTP irá escutar os endpoints especificados e redirecionar suas solicitações para nosso roteador. Configuração do Servidor A configuração do servidor é responsável por grande parte do comportamento do servidor HTTP em si. Nesta configuração, podemos associar ListeningHosts ao nosso servidor. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Adicione nosso ListeningHost a esta configuração do servidor Em seguida, podemos criar nosso servidor HTTP: HttpServer server = new HttpServer(config); server.Start(); // Inicia o servidor Console.ReadKey(); // Previne o encerramento da aplicação Agora podemos compilar nosso executável e executar nosso servidor HTTP com o comando: dotnet watch Em tempo de execução, abra seu navegador e navegue até o caminho do servidor, e você deve ver:"
  },
  "docs/pt-br/advanced/multi-host-setup.html": {
    "href": "docs/pt-br/advanced/multi-host-setup.html",
    "title": "Configuração de vários hosts | Sisk",
    "keywords": "Configuração de vários hosts O Sisk Framework sempre suportou o uso de mais de um host por servidor, ou seja, um único servidor HTTP pode escutar em múltiplos portas e cada porta possui seu próprio roteador e seu próprio serviço em execução nela. Isso facilita a separação de responsabilidades e a gestão de serviços em um único servidor HTTP com o Sisk. O exemplo abaixo mostra a criação de dois ListeningHosts, cada um escutando em uma porta diferente, com roteadores e ações diferentes. Leia criação manual do seu aplicativo para entender os detalhes sobre essa abstração. static void Main(string[] args) { // criar dois hosts de escuta, cada um com seu próprio roteador e // escutando em sua própria porta // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Olá do host A!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Olá do host B!\")); // criar uma configuração do servidor e adicionar ambos // os hosts de escuta nela // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // cria um servidor HTTP que usa a configuração especificada // HttpServer server = new HttpServer(configuration); // inicia o servidor server.Start(); Console.WriteLine(\"Tente acessar o host A em {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Tente acessar o host B em {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/pt-br/advanced/request-lifecycle.html": {
    "href": "docs/pt-br/advanced/request-lifecycle.html",
    "title": "Clico de vida da requisição | Sisk",
    "keywords": "Clico de vida da requisição Este diagrama explica o processo de vida de uma solicitação HTTP desde o momento em que chega ao servidor até ser entregue ao cliente."
  },
  "docs/pt-br/changelogs.html": {
    "href": "docs/pt-br/changelogs.html",
    "title": "Histórico de Versões | Sisk",
    "keywords": "Histórico de Versões Todas as alterações feitas no Sisk são registradas no histórico de versões. Você pode visualizar os históricos de versões para todas as versões do Sisk aqui."
  },
  "docs/pt-br/deploying.html": {
    "href": "docs/pt-br/deploying.html",
    "title": "Implantando sua Aplicação Sisk | Sisk",
    "keywords": "Implantando sua Aplicação Sisk O processo de implantar uma aplicação Sisk consiste em publicar seu projeto em produção. Embora o processo seja relativamente simples, é importante notar detalhes que podem ser letais para a segurança e estabilidade da infraestrutura de implantação. Idealmente, você deve estar pronto para implantar sua aplicação na nuvem, após realizar todos os testes possíveis para ter sua aplicação pronta. Publicando sua aplicação Publicar sua aplicação ou serviço Sisk é gerar binários prontos e otimizados para produção. Neste exemplo, vamos compilar os binários para produção para executar em uma máquina que tenha o .NET Runtime instalado. Você precisará ter o .NET SDK instalado em sua máquina para compilar sua aplicação, e o .NET Runtime instalado no servidor de destino para executar sua aplicação. Você pode aprender como instalar o .NET Runtime em seu servidor Linux aqui, Windows e Mac OS. No diretório onde seu projeto está localizado, abra um terminal e use o comando de publicação do .NET: $ dotnet publish -r linux-x64 -c Release Isso gerará seus binários dentro de bin/Release/publish/linux-x64. Note Se sua aplicação estiver executando usando o pacote Sisk.ServiceProvider, você deve copiar seu service-config.json para o servidor de hospedagem junto com todos os binários gerados pelo dotnet publish. Você pode deixar o arquivo pré-configurado, com variáveis de ambiente, portas e hosts de escuta e configurações adicionais do servidor. A próxima etapa é levar esses arquivos para o servidor onde sua aplicação será hospedada. Depois disso, dê permissões de execução para o arquivo binário. Neste caso, vamos considerar que o nome do nosso projeto é \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app Após executar sua aplicação, verifique se ela produz alguma mensagem de erro. Se não produzir, é porque sua aplicação está em execução. Neste ponto, provavelmente não será possível acessar sua aplicação pela rede externa fora do seu servidor, pois as regras de acesso, como Firewall, não foram configuradas. Vamos considerar isso nas próximas etapas. Você deve ter o endereço do host virtual onde sua aplicação está escutando. Isso é definido manualmente na aplicação e depende de como você está instanciando seu serviço Sisk. Se você não estiver usando o pacote Sisk.ServiceProvider, você deve encontrar o endereço onde definiu sua instância de HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk deve escutar em http://localhost:5000/ Associando um ListeningHost manualmente: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Ou se você estiver usando o pacote Sisk.ServiceProvider, em seu service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } A partir disso, podemos criar um proxy reverso para escutar seu serviço e tornar o tráfego disponível sobre a rede aberta. Proxyando sua aplicação Proxyar seu serviço significa não expor diretamente seu serviço Sisk à rede externa. Essa prática é muito comum para implantações de servidor porque: Permite associar um certificado SSL à sua aplicação; Cria regras de acesso antes de acessar o serviço e evitar sobrecargas; Controla a largura de banda e os limites de solicitação; Separa os balanceadores de carga para sua aplicação; Previne danos de segurança à infraestrutura de falha. Você pode servir sua aplicação por meio de um proxy reverso como Nginx ou Apache, ou você pode usar um túnel http-over-dns como Cloudflared. Além disso, lembre-se de resolver corretamente os cabeçalhos de encaminhamento do proxy para obter as informações do cliente, como endereço IP e host, por meio de resolutores de encaminhamento. A próxima etapa após criar seu túnel, configurar o firewall e ter sua aplicação em execução é criar um serviço para sua aplicação. Note Usar certificados SSL diretamente no serviço Sisk em sistemas não-Windows não é possível. Isso é um ponto da implementação do HttpListener, que é o módulo central para como a gestão da fila HTTP é feita no Sisk, e essa implementação varia de sistema operacional para sistema operacional. Você pode usar SSL em seu serviço Sisk se associar um certificado ao host virtual com IIS. Para outros sistemas, usar um proxy reverso é altamente recomendado. Criando um serviço Criar um serviço fará com que sua aplicação esteja sempre disponível, mesmo após reiniciar a instância do servidor ou uma falha não recuperável. Neste tutorial simples, vamos usar o conteúdo do tutorial anterior como um exemplo para manter seu serviço sempre ativo. Acesse o diretório onde os arquivos de configuração do serviço estão localizados: cd /etc/systemd/system Crie seu arquivo my-app.service e inclua o conteúdo: my-app.service INI [Unit] Description=<descrição sobre sua aplicação> [Service] # defina o usuário que lançará o serviço User=<usuário que lançará o serviço> # o caminho do ExecStart não é relativo ao WorkingDirectory. # defina-o como o caminho completo para o arquivo executável WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # defina o serviço para sempre reiniciar em caso de falha Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Reinicie o módulo de gerenciamento de serviços: $ sudo systemctl daemon-reload Inicie seu novo serviço criado a partir do nome do arquivo que você definiu e verifique se ele está em execução: $ sudo systemctl start my-app $ sudo systemctl status my-app Agora, se sua aplicação estiver em execução (\"Active: active\"), habilite seu serviço para continuar em execução após uma reinicialização do sistema: $ sudo systemctl enable my-app Agora você está pronto para apresentar sua aplicação Sisk a todos."
  },
  "docs/pt-br/extensions/basic-auth.html": {
    "href": "docs/pt-br/extensions/basic-auth.html",
    "title": "Autenticação Básica | Sisk",
    "keywords": "Autenticação Básica O pacote Basic Auth adiciona um processador de solicitações capaz de lidar com o esquema de autenticação básica em seu aplicativo Sisk com pouca configuração e esforço. A autenticação HTTP básica é uma forma mínima de entrada de autenticação de solicitações por um ID de usuário e senha, onde a sessão é controlada exclusivamente pelo cliente e não há tokens de autenticação ou acesso. Leia mais sobre o esquema de autenticação básica na especificação MDN. Instalando Para começar, instale o pacote Sisk.BasicAuth em seu projeto: > dotnet add package Sisk.BasicAuth Você pode visualizar mais maneiras de instalá-lo em seu projeto no repositório Nuget. Criando seu manipulador de autenticação Você pode controlar o esquema de autenticação para um módulo inteiro ou para rotas individuais. Para isso, primeiro vamos escrever nosso primeiro manipulador de autenticação básica. No exemplo abaixo, uma conexão é feita com o banco de dados, verifica se o usuário existe e se a senha é válida e, em seguida, armazena o usuário na bolsa de contexto. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Para entrar nesta página, informe suas credenciais.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // neste caso, estamos usando o email como campo de ID de usuário, então vamos // procurar um usuário usando seu email. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Desculpe! Nenhum usuário foi encontrado por este email.\"); } // valida que a senha das credenciais é válida para este usuário. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Credenciais inválidas.\"); } // adiciona o usuário logado ao contexto HTTP // e continua a execução context.Bag.Add(\"loggedUser\", user); return null; } } Então, basta associar este manipulador de solicitações à nossa rota ou classe. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Olá, \" + loggedUser.Name + \"!\"; } } Ou usando a classe RouterModule: public class UsersController : RouterModule { public ClientModule() { // agora todas as rotas dentro desta classe serão tratadas por // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Olá, \" + loggedUser.Name + \"!\"; } } Observações A principal responsabilidade da autenticação básica é realizada no lado do cliente. Armazenamento, controle de cache e criptografia são todos gerenciados localmente no cliente. O servidor apenas recebe as credenciais e valida se o acesso é permitido ou não. Observe que este método não é uma das soluções mais seguras porque coloca uma responsabilidade significativa no cliente, o que pode ser difícil de rastrear e manter a segurança de suas credenciais. Além disso, é essencial que as senhas sejam transmitidas em um contexto de conexão segura (SSL), pois elas não possuem nenhuma criptografia inerente. Uma breve interceptação nos cabeçalhos de uma solicitação pode expor as credenciais de acesso do seu usuário. Opte por soluções de autenticação mais robustas para aplicativos em produção e evite usar muitos componentes prontos para uso, pois eles podem não se adaptar às necessidades do seu projeto e acabar expondo-o a riscos de segurança."
  },
  "docs/pt-br/extensions/ini-configuration.html": {
    "href": "docs/pt-br/extensions/ini-configuration.html",
    "title": "Configuração INI | Sisk",
    "keywords": "Configuração INI O Sisk tem um método para obter configurações de inicialização além do JSON. Na verdade, qualquer pipeline que implemente IConfigurationReader pode ser usado com PortableConfigurationBuilder.WithConfigurationPipeline, lendo a configuração do servidor de qualquer tipo de arquivo. O pacote Sisk.IniConfiguration fornece um leitor de arquivos INI baseado em fluxo que não lança exceções para erros de sintaxe comuns e tem uma sintaxe de configuração simples. Esse pacote pode ser usado fora do framework Sisk, oferecendo flexibilidade para projetos que requerem um leitor de documentos INI eficiente. Instalando Para instalar o pacote, você pode começar com: $ dotnet add package Sisk.IniConfiguration Você também pode instalar o pacote core, que não inclui o IConfigurationReader INI, nem a dependência do Sisk, apenas os serializadores INI: $ dotnet add package Sisk.IniConfiguration.Core Com o pacote principal, você pode usá-lo em seu código como mostrado no exemplo abaixo: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // usa o leitor de configuração IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } O código acima procurará por um arquivo app.ini no diretório atual do processo (CurrentDirectory). O arquivo INI tem a seguinte aparência: [Server] # Múltiplos endereços de escuta são suportados Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Sabor e sintaxe INI Implementação atual do sabor: Nomes de propriedades e seções são insensíveis a letras maiúsculas e minúsculas. Nomes de propriedades e valores são recortados, a menos que os valores sejam citados. Valores podem ser citados com aspas simples ou duplas. Aspas podem ter quebras de linha dentro delas. Comentários são suportados com # e ;. Além disso, comentários de tralha são permitidos. Propriedades podem ter múltiplos valores. Em detalhe, a documentação para o \"sabor\" do analisador INI usado no Sisk está disponível neste documento. Usando o seguinte código INI como exemplo: One = 1 Value = este é um valor Another value = \"este valor tem uma quebra de linha nele\" ; o código abaixo tem algumas cores [some section] Color = Red Color = Blue Color = Yellow ; não use amarelo Analisá-lo com: // analisa o texto INI da string IniDocument doc = IniDocument.FromString(iniText); // obtenha um valor string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // obtenha múltiplos valores string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Parâmetros de configuração Seção e nome Permite múltiplos valores Descrição Server.Listen Sim Os endereços/ports de escuta do servidor. Server.Encoding Não A codificação padrão do servidor. Server.MaximumContentLength Não O tamanho máximo do conteúdo em bytes. Server.IncludeRequestIdHeader Não Especifica se o servidor HTTP deve enviar o cabeçalho X-Request-Id. Server.ThrowExceptions Não Especifica se as exceções não tratadas devem ser lançadas. Server.AccessLogsStream Não Especifica o fluxo de saída do log de acesso. Server.ErrorsLogsStream Não Especifica o fluxo de saída do log de erros. Cors.AllowMethods Não Especifica o valor do cabeçalho Allow-Methods CORS. Cors.AllowHeaders Não Especifica o valor do cabeçalho Allow-Headers CORS. Cors.AllowOrigins Não Especifica múltiplos cabeçalhos Allow-Origin, separados por vírgulas. AllowOrigins para mais informações. Cors.AllowOrigin Não Especifica um cabeçalho Allow-Origin. Cors.ExposeHeaders Não Especifica o valor do cabeçalho Expose-Headers CORS. Cors.AllowCredentials Não Especifica o valor do cabeçalho Allow-Credentials CORS. Cors.MaxAge Não Especifica o valor do cabeçalho Max-Age CORS."
  },
  "docs/pt-br/extensions/json-rpc.html": {
    "href": "docs/pt-br/extensions/json-rpc.html",
    "title": "Sisk + JSON-RPC | Sisk",
    "keywords": "Sisk + JSON-RPC Sisk possui um módulo experimental de uma API JSON-RPC 2.0, o que possibilita criar aplicações ainda mais simples. Essa extensão implementa extritamente a interface de transporte JSON-RPC 2.0, e oferece transporte via requisições HTTP GET, POST e também web-sockets com Sisk. Você pode instalar a extensão pelo Nuget com o comando abaixo. Note que, em versões experimentais/betas, deverá ser ativado a opção de buscar por pacotes em pré-lançamento pelo Visual Studio. dotnet add package Sisk.JsonRpc Interface de transporte O JSON-RPC é um protocolo de execução remota de procedimentos (RDP) sem estado, assíncrono, e utiliza o JSON para comunicação unilateral dos dados. Uma requisição JSON-RPC é normalmente identificada por um ID, e uma resposta é entregue pelo mesmo ID que foi enviado na requisição. Nem todas as requisições são necessárias de resposta, o que são chamadas de \"notificações\". Na especificação do JSON-RPC 2.0 é explicado com detalhes como o transporte funciona. Este transporte é agnóstico de onde será usado. O Sisk implementa esse protocolo através do HTTP, seguindo as conformidades do JSON-RPC over HTTP, que suporta parcialmente requisições GET, mas completamente requisições POST. Também é suportado o uso de web-sockets, o que provê uma comunicação assíncrona de mensagens. Uma requisição JSON-RPC é parecida com: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } E uma resposta, quando bem-sucedida, é semelhante: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Métodos JSON-RPC O exemplo a seguir mostra como criar uma API JSON-RPC usando o Sisk. Uma classe de operações matemáticas realiza as operações remotas e entrega a resposta serializada ao cliente. using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // add all methods tagged with WebMethod to the JSON-RPC handler args.Handler.Methods.AddMethodsFromType(new MathOperations()); // maps the /service route to handle JSON-RPC POST and GET requests args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // creates an websocket handler on GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } O exemplo acima irá mapear os métodos Sum e Sqrt para o handler JSON-RPC, e estes métodos ficarão disponíveis no GET /service, POST /service e GET /ws. O nome dos métodos não são sensíveis a caso. Os parâmetros dos métodos são deserializados automaticamente para seus tipos específicos. Usar uma requisição com parâmetros nomeados também é suportado. A serialização JSON é feita pela biblioteca LightJson. Quando um tipo não é corretamente deserializado, você poderá criar um conversor JSON específico para aquele tipo e associar ele em seu JsonSerializerOptions posteriormente. Você também pode obter o objeto $.params cru da requisição JSON-RPC diretamente no seu método. [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Para isso ocorrer, @params deve ser o único parâmetro no seu método, com exatamente o nome params (em C#, o @ é necessário para escapar o nome deste parâmetro). A deserialização dos parâmetros ocorre tanto para objetos nomeados ou para arrays posicionais. Por exemplo, o método abaixo pode ser chamado remotamente por ambas requisições: [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Por um objeto em params não é necessário seguir a ordem dos parâmetros: { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": { \"apiKey\": \"1234567890\", \"store\": { \"name\": \"My Store\" }, \"user\": { \"name\": \"John Doe\", \"email\": \"john@example.com\" } }, \"id\": 1 } Por array é necessário seguir a ordem dos parâmetros. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Personalizando o serializer Você pode personalizar o serializador JSON na propriedade JsonRpcHandler.JsonSerializerOptions. Nessa propriedade, você pode ativar o uso de JSON5 para deserialização de mensagens. Por mais que não é conformidade com o JSON-RPC 2.0, JSON5 é uma extensão do JSON que permite uma escrita mais humanizada e legível. using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // usa um comparador de nomes sanitizado. esse comparador compara apenas letras // e dígitos em um nome, e descarta outros símbolos. ex: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // habilita JSON5 para o interpretador JSON. mesmo ativando isso, JSON plano ainda é permitido e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // mapeia a rota POST /service para o handler JSON RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/pt-br/extensions/service-providers.html": {
    "href": "docs/pt-br/extensions/service-providers.html",
    "title": "Service Providers | Sisk",
    "keywords": "Service Providers Service Providers é uma forma de portar sua aplicação Sisk para diferentes ambientes com um arquivo de configuração portátil. Este recurso possibilita alterar funcionamento de portas, parâmetros e demais opções do servidor sem ter que alterar o código do aplicativo para cada ambiente. Este módulo depende da sintaxe de construção do Sisk e pode ser configurada através do método UsePortableConfiguration. Um provedor de configuração é implementado com IConfigurationProvider, o que provê um leitor de configurações e pode receber qualquer implementação. Por padrão, o Sisk fornece um leitor de configurações em JSON, mas também existe um pacote para arquivos INI. Você também pode criar seu próprio provedor de configurações e registrar com: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Como mencionado anteriormente, o provedor padrão é de um arquivo JSON. Por padrão, o nome do arquivo buscado é service-config.json, e é buscado na pasta atual (Current Directory) do processo em execução, e não do diretório do executável. Você pode optar em alterar o nome do arquivo, bem como onde o Sisk deve procurar pelo arquivo de configuração, com: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); O código acima irá procurar o arquivo config.toml na pasta atual do processo em execução. Se não encontrado o arquivo, irá então buscar no diretório de onde o executável está localizado. Caso o arquivo não exista, o parâmetro createIfDontExists é honrado, criando o arquivo, sem nenhum conteúdo, no último caminho testado (com base em lookupDirectories), e um erro é lançado no console, impedindo a inicialização do aplicativo. Tip Você pode olhar no código fonte do leitor de configurações de arquivos INI e no de JSON para entender como um IConfigurationProvider é implementado. Lendo configurações de um arquivo JSON Por padrão, o Sisk fornece um provedor de configuração que lê configurações em um arquivo JSON. Este arquivo segue uma estrutura fixa e é composto pelos parâmetros: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"My sisk application\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Configuration files also supports comments ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // new on 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Os parâmetros criados a partir de um arquivo de configurações pode ser acessado no construtor do servidor: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Cada leitor de configurações fornece uma forma de ler os parâmetros de inicialização do servidor. Algumas propriedades são indicadas a ficarem no ambiente do processo ao invés de serem definidas no arquivo de configuração, como por exemplo, dados sensíveis de API, chaves de API, etc. Estrutura de arquivo de configuração O arquivo de configuração JSON é composto pelas propriedades: Property Mandatory Description Server Required Represents the server itself with their settings. Server.AccessLogsStream Optional Default to console. Specifies the access log output stream. Can be an filename, null or console. Server.ErrorsLogsStream Optional Default to null. Specifies the error log output stream. Can be an filename, null or console. Server.MaximumContentLength Optional Default to 0. Specifies the maximum content length in bytes. Zero means infinite. Server.IncludeRequestIdHeader Optional Default to false. Specifies if the HTTP server should send the X-Request-Id header. Server.ThrowExceptions Optional Default to true. Specifies if unhandled exceptions should be thrown. Set to false when production and true when debugging. ListeningHost Required Represents the server listening host. ListeningHost.Label Optional Represents the application label. ListeningHost.Ports Required Represents an array of strings, matching the ListeningPort syntax. ListeningHost.CrossOriginResourceSharingPolicy Optional Setup the CORS headers for the application. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Optional Defaults to false. Specifies the Allow-Credentials header. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Expose-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Optional Defaults to null. This property expects an string. Specifies the Allow-Origin header. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Optional Defaults to null. This property expects an array of strings. Specifies multiples Allow-Origin headers. See AllowOrigins for more information. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Methods header. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Optional Defaults to null. This property expects an array of strings. Specifies the Allow-Headers header. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Optional Defaults to null. This property expects an interger. Specifies the Max-Age header in seconds. ListeningHost.Parameters Optional Specifies the properties provided to the application setup method."
  },
  "docs/pt-br/extensions/ssl-proxy.html": {
    "href": "docs/pt-br/extensions/ssl-proxy.html",
    "title": "Proxy SSL | Sisk",
    "keywords": "Proxy SSL Warning Este recurso é experimental e não deve ser usado em produção. Consulte este documento se quiser fazer o Sisk funcionar com SSL. O Proxy SSL do Sisk é um módulo que fornece uma conexão HTTPS para um ListeningHost no Sisk e roteia mensagens HTTPS para um contexto HTTP inseguro. O módulo foi construído para fornecer conexão SSL para um serviço que usa HttpListener para executar, que não suporta SSL. O proxy é executado dentro do mesmo aplicativo e escuta por mensagens HTTP/1.1, encaminhando-as para o Sisk no mesmo protocolo. Atualmente, esse recurso é altamente experimental e pode ser instável o suficiente para não ser usado em produção. No momento, o SslProxy suporta quase todos os recursos HTTP/1.1, como keep-alive, codificação chunked, websockets, etc. Para uma conexão aberta ao proxy SSL, uma conexão TCP é criada para o servidor de destino e o proxy é encaminhado para a conexão estabelecida. O SslProxy pode ser usado com HttpServer.CreateBuilder da seguinte forma: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // adicionar SSL ao projeto .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Você deve fornecer um certificado SSL válido para o proxy. Para garantir que o certificado seja aceito pelos navegadores, lembre-se de importá-lo no sistema operacional para que ele funcione corretamente."
  },
  "docs/pt-br/features/discard-syntax.html": {
    "href": "docs/pt-br/features/discard-syntax.html",
    "title": "Sintaxe de descarte | Sisk",
    "keywords": "Sintaxe de descarte O servidor HTTP pode ser usado para escutar uma solicitação de retorno de uma ação, como autenticação OAuth, e pode ser descartado após receber essa solicitação. Isso pode ser útil em casos em que você precisa de uma ação em segundo plano, mas não deseja configurar um aplicativo HTTP inteiro para isso. O exemplo a seguir mostra como criar um servidor HTTP ouvindo na porta 5555 com CreateListener e aguardar o próximo contexto: using (var server = HttpServer.CreateListener(5555)) { // aguardar a próxima solicitação HTTP var context = await server.WaitNextAsync(); Console.WriteLine($\"Caminho solicitado: {context.Request.Path}\"); } A função WaitNext aguarda o próximo contexto de um processamento de solicitação concluído. Uma vez que o resultado dessa operação é obtido, o servidor já tratou completamente a solicitação e enviou a resposta para o cliente."
  },
  "docs/pt-br/features/instancing.html": {
    "href": "docs/pt-br/features/instancing.html",
    "title": "Instanciando membros por solicitação | Sisk",
    "keywords": "Instanciando membros por solicitação É comum dedicar membros e instâncias que duram por toda a vida de uma solicitação, como uma conexão com banco de dados, um usuário autenticado ou um token de sessão. Uma das possibilidades é através do HttpContext.RequestBag, que cria um dicionário que dura por toda a vida de uma solicitação. Este dicionário pode ser acessado por tratadores de solicitação e definir variáveis ​​durante toda a solicitação. Por exemplo, um tratador de solicitação que autentica um usuário define esse usuário dentro do HttpContext.RequestBag, e dentro da lógica da solicitação, esse usuário pode ser recuperado com HttpContext.RequestBag.Get<User>(). Aqui está um exemplo: public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // avançar para o próximo tratador de solicitação ou lógica da solicitação } } [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Olá {authenticatedUser.Name}!\") }; } Este é um exemplo preliminar dessa operação. A instância de User foi criada dentro do tratador de solicitação dedicado à autenticação, e todas as rotas que usam esse tratador de solicitação terão a garantia de que haverá um User em sua instância de HttpContext.RequestBag. É possível definir lógica para obter instâncias quando não definidas anteriormente no RequestBag através de métodos como GetOrAdd ou GetOrAddAsync. Desde a versão 1.3, a propriedade estática HttpContext.Current foi introduzida, permitindo o acesso ao HttpContext atualmente em execução do contexto da solicitação. Isso permite expor membros do HttpContext fora do contexto da solicitação atual e definir instâncias em objetos de rota. O exemplo abaixo define um controlador que possui membros comumente acessados pelo contexto de uma solicitação. public abstract class Controller : RouterModule { public DbContext Database { get { // criar um DbContext ou obter o existente return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // a linha seguinte lançará uma exceção se a propriedade for acessada quando o User não // estiver definido no bag da solicitação public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // Expor a instância HttpRequest também é suportado public HttpRequest Request { get => HttpContext.Current.Request; } } E definir tipos que herdam do controlador: [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Para o exemplo acima, você precisará configurar um tratador de valor no seu roteador para que os objetos retornados pelo roteador sejam transformados em um HttpResponse válido. Observe que os métodos não têm um argumento HttpRequest request como presente em outros métodos. Isso ocorre porque, desde a versão 1.3, o roteador suporta dois tipos de delegados para roteamento de respostas: RouteAction, que é o delegado padrão que recebe um argumento HttpRequest, e ParameterlessRouteAction. O objeto HttpRequest ainda pode ser acessado por ambos os delegados através da propriedade Request do HttpContext estático no thread. No exemplo acima, definimos um objeto descartável, o DbContext, e precisamos garantir que todas as instâncias criadas em um DbContext sejam descartadas quando a sessão HTTP terminar. Para isso, podemos usar duas maneiras de alcançar isso. Uma é criar um tratador de solicitação que é executado após a ação do roteador, e a outra maneira é através de um tratador de servidor personalizado. Para o primeiro método, podemos criar o tratador de solicitação inline diretamente no método OnSetup herdado de RouterModule: public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // obter um DbContext definido no contexto do tratador de solicitação e // descartá-lo ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } O método acima garantirá que o DbContext seja descartado quando a sessão HTTP for finalizada. Você pode fazer isso para mais membros que precisam ser descartados no final de uma resposta. Para o segundo método, você pode criar um tratador de servidor personalizado que descartará o DbContext quando a sessão HTTP for finalizada. public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } E usá-lo no seu construtor: using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Esta é uma maneira de lidar com a limpeza de código e manter as dependências de uma solicitação separadas pelo tipo de módulo que será usado, reduzindo a quantidade de código duplicado dentro de cada ação de um roteador. É uma prática semelhante ao que a injeção de dependência é usada em frameworks como ASP.NET."
  },
  "docs/pt-br/features/logging.html": {
    "href": "docs/pt-br/features/logging.html",
    "title": "Log | Sisk",
    "keywords": "Log Você pode configurar o Sisk para escrever logs de acesso e erros automaticamente. É possível definir rotação de logs, extensões e frequência. A classe LogStream fornece uma maneira assíncrona de escrever logs e mantê-los em uma fila de escrita aguarda. Neste artigo, mostraremos como configurar o log para seu aplicativo. Logs de acesso baseados em arquivo Logs para arquivos abrem o arquivo, escrevem o texto da linha e, em seguida, fecham o arquivo para cada linha escrita. Este procedimento foi adotado para manter a responsividade de escrita nos logs. config.AccessLogsStream = new LogStream(\"logs/access.log\"); O código acima escreverá todas as solicitações recebidas no arquivo logs/access.log. Observe que o arquivo é criado automaticamente se não existir, mas a pasta anterior não. Não é necessário criar o diretório logs/ pois a classe LogStream o cria automaticamente. Logamento baseado em stream Você pode escrever arquivos de log para instâncias de objetos TextWriter, como Console.Out, passando um objeto TextWriter no construtor: config.AccessLogsStream = new LogStream(Console.Out); Para cada mensagem escrita no log baseado em stream, o método TextWriter.Flush() é chamado. Formatação do log de acesso Você pode personalizar o formato do log de acesso usando variáveis predefinidas. Considere a seguinte linha: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; Ele escreverá uma mensagem como: 29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ \\[200 OK\\] 689B -> 707B in 84ms \\[Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36\\] Você pode formatar seu arquivo de log de acordo com a tabela descrita: Variável Descrição Exemplo %dd O dia do timestamp atual, no formato 00. 25 %dm O mês do timestamp atual, no formato 00. 03 %dmm O mês do timestamp atual, no formato abreviado. mar. %dmmm O mês do timestamp atual, no formato completo. Março %dy O ano do timestamp atual, no formato 0000. 2023 %th A hora atual do timestamp, no formato de 12 horas. 03 %tH A hora atual do timestamp, no formato de 24 horas. 15 %ti Os minutos atuais do timestamp, no formato 00. 25 %ts Os segundos atuais do timestamp, no formato 00. 32 %tm Os milissegundos atuais do timestamp, no formato 000. 633 %tz A diferença de fuso horário atual, no formato +/- 0000. +0300, -0500, +0000 %ri O endereço IP do usuário solicitante (pode ser IPv4 ou IPv6). 192.168.0.1 %rm O método de solicitação em maiúsculas. GET %rs O esquema do URL do usuário solicitante. https, http %ra A autoridade do URL do usuário solicitante. my.contorso.com:8080 %rh O host do URL do usuário solicitante. my.contorso.com %rp A porta do URL do usuário solicitante. 8080 %rz O caminho absoluto do URL do usuário solicitante. /index.html %rq A cadeia de consulta do URL do usuário solicitante. ?foo=bar&aaa=bbb %sc O código de status da resposta, no formato 000. 404 %sd A descrição do código de status da resposta. Não encontrado %lin O tamanho do conteúdo da solicitação entrante, em uma forma legível por humanos. 12,5kb %lou O tamanho do conteúdo da resposta saindo, em uma forma legível por humanos. 65,8kb %lms O tempo de processamento do servidor da solicitação e entrega da resposta, em milissegundos (000). 18 %{header} Obtém o valor de um cabeçalho HTTP, onde o cabeçalho é o nome do cabeçalho, ou um valor vazio se o cabeçalho não estiver presente. Este campo é insensível a maiúsculas e minúsculas. %{user-agent} Rotação de logs Tip Em Sisk 0.15 e versões anteriores, essa função está disponível apenas com o pacote Sisk.ServiceProvider. Em Sisk 0.16 e versões posteriores, essa função é implementada no pacote principal. Você pode configurar o servidor HTTP para rotar os arquivos de log para um arquivo .gz compactado quando eles atingirem um determinado tamanho. O tamanho é verificado periodicamente pelo limiar que você define. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); O código acima verificará a cada seis horas se o arquivo do LogStream tenha atingido o limite de 1 MB. Se sim, o arquivo é compactado para um arquivo .gz e, em seguida, access.log é limpo. Durante esse processo, a escrita no arquivo é bloqueada até que o arquivo seja compactado e limpo. Todas as linhas que entram para serem escritas neste período ficarão em uma fila aguardando o final da compactação. Essa função funciona apenas com LogStreams baseados em arquivos. Log de erros Quando um servidor não está lançando erros para o depurador, ele encaminha os erros para o log de escrita quando houver algum. Você pode configurar a escrita de erros com: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Essa propriedade só escreverá algo no log se o erro não for capturado pelo callback ou pela propriedade Router.CallbackErrorHandler. O erro escrito pelo servidor sempre escreve a data e hora, os cabeçalhos da solicitação (não o corpo), o rastreamento de erros e o rastreamento de exceções internas, se houver. Outras instâncias de log Seu aplicativo pode ter zero ou várias LogStreams, não há limite para o número de canais de log que ele pode ter. Portanto, é possível direcionar o log do seu aplicativo para um arquivo diferente do log de acesso padrão ou do log de erros. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Application started at {0}\", DateTime.Now); Extensão de LogStream Você pode estender a classe LogStream para escrever formatos personalizados, compatíveis com o mecanismo de log atual do Sisk. O exemplo abaixo permite escrever mensagens coloridas no Console usando a biblioteca Spectre.Console. public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Outra maneira de escrever automaticamente logs personalizados para cada solicitação/resposta é criar um HttpServerHandler. O exemplo abaixo é um pouco mais completo. Ele escreve o corpo da solicitação e a resposta em JSON para o Console. Pode ser útil para depurar solicitações em geral. Este exemplo usa ContextBag e HttpServerHandler. class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!! \" })); }); await app.StartAsync(); } } class JsonMessageHandler : HttpServerHandler { protected override async void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // Neste ponto, a conexão está aberta e o cliente enviou o cabeçalho especificando que o conteúdo é JSON. // O conteúdo é lido e armazenado na solicitação. // // Se o conteúdo não for lido na ação da solicitação, o GC provavelmente coletará o conteúdo após o envio da resposta para o cliente, então o conteúdo pode não estar disponível após o fechamento da resposta. // _ = request.RawBody; // adicionar uma dica no contexto para indicar que esta solicitação tem um corpo JSON. request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // reformatted the JSON using the CypherPotato.LightJson library var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // check if the response is JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // gets the internal server handling status responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson is not null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine(\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/pt-br/features/server-sent-events.html": {
    "href": "docs/pt-br/features/server-sent-events.html",
    "title": "Eventos Server-Sent-Events | Sisk",
    "keywords": "Eventos Server-Sent-Events O Sisk suporta o envio de mensagens através de Eventos Envio de Servidor (SSE) diretamente. Você pode criar conexões descartáveis e persistentes, obter as conexões durante a execução e usá-las. Este recurso possui algumas limitações impostas por navegadores, como o envio apenas de mensagens de texto e a impossibilidade de fechar permanentemente uma conexão. Uma conexão fechada do lado do servidor terá um cliente tentando reconectar periodicamente a cada 5 segundos (3 para alguns navegadores). Essas conexões são úteis para enviar eventos do servidor para o cliente sem que o cliente precise solicitar a informação a cada vez. Criando uma conexão SSE Uma conexão SSE funciona como uma solicitação HTTP regular, mas em vez de enviar uma resposta e fechar a conexão imediatamente, a conexão é mantida aberta para enviar mensagens. Ao chamar o método HttpRequest.GetEventSource(), a solicitação é colocada em estado de espera enquanto a instância SSE é criada. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.Send(\"Olá, mundo!\"); return sse.Close(); }); No código acima, criamos uma conexão SSE e enviamos uma mensagem \"Olá, mundo!\", então fechamos a conexão SSE do lado do servidor. Note Ao fechar uma conexão do lado do servidor, por padrão o cliente tentará se reconectar e a conexão será reiniciada, executando o método novamente, para sempre. É comum encaminhar uma mensagem de término do servidor sempre que a conexão é fechada do lado do servidor para evitar que o cliente tente se reconectar novamente. Adicionando cabeçalhos Se você precisar enviar cabeçalhos, pode usar o método HttpRequestEventSource.AppendHeader antes de enviar qualquer mensagem. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Olá!\"); return sse.Close(); }); Observe que é necessário enviar os cabeçalhos antes de enviar qualquer mensagem. Conexões Wait-For-Fail As conexões são normalmente terminadas quando o servidor não consegue mais enviar mensagens devido a uma possível desconexão do cliente. Com isso, a conexão é automaticamente encerrada e a instância da classe é descartada. Mesmo com uma reconexão, a instância da classe não funcionará, pois está vinculada à conexão anterior. Em algumas situações, você pode precisar dessa conexão posteriormente e não deseja gerenciá-la através do método de callback da rota. Para isso, podemos identificar as conexões SSE com um identificador e obtê-las usando-o posteriormente, mesmo fora do callback da rota. Além disso, marcamos a conexão com WaitForFail para não terminar a rota e terminar a conexão automaticamente. Uma conexão SSE em KeepAlive aguardará um erro de envio (causado por desconexão) para recomeçar a execução do método. Também é possível definir um Timeout para isso. Após o tempo, se nenhuma mensagem foi enviada, a conexão é encerrada e a execução é retomada. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // aguardar 15 segundos sem nenhuma mensagem antes de terminar a conexão return sse.Close(); }); O método acima criará a conexão, a manejará e aguardará uma desconexão ou erro. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // a conexão ainda está ativa evs.Send(\"Olá novamente!\"); } E o trecho acima tentará procurar a conexão recém-criada e, se ela existir, enviará uma mensagem para ela. Todas as conexões ativas do servidor que forem identificadas estarão disponíveis na coleção HttpServer.EventSources. Esta coleção armazena apenas conexões ativas e identificadas. Conexões fechadas são removidas da coleção. Note É importante notar que o keep alive possui um limite estabelecido por componentes que podem estar conectados ao Sisk de forma não controlada, como um proxy web, um kernel HTTP ou um driver de rede, e eles fecham conexões inativas após um determinado período de tempo. Portanto, é importante manter a conexão aberta enviando pings periódicos ou estendendo o tempo máximo antes que a conexão seja fechada. Leia a próxima seção para entender melhor o envio de pings periódicos. Configuração da política de ping de conexões A Política de Ping é uma maneira automatizada de enviar mensagens periódicas para seu cliente. Essa função permite que o servidor entenda quando o cliente se desconectou dessa conexão sem precisar manter a conexão aberta indefinidamente. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } No código acima, a cada 5 segundos, uma nova mensagem de ping será enviada para o cliente. Isso manterá a conexão TCP ativa e impedirá que ela seja fechada devido à inatividade. Além disso, quando uma mensagem falha em ser enviada, a conexão é automaticamente fechada, liberando os recursos usados pela conexão. Consultando conexões Você pode pesquisar conexões ativas usando um predicado no identificador da conexão, para poder transmitir, por exemplo. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Transmissão para todos os eventos que começam com 'my-connection-'\"); } Você também pode usar o método All para obter todas as conexões SSE ativas."
  },
  "docs/pt-br/features/websockets.html": {
    "href": "docs/pt-br/features/websockets.html",
    "title": "WebSockets | Sisk",
    "keywords": "WebSockets O Sisk suporta websockets, como receber e enviar mensagens para seus clientes. Este recurso funciona bem na maioria dos navegadores, mas no Sisk ainda está em fase experimental. Por favor, se encontrar algum bug, denuncie-o no github. Aceitando e recebendo mensagens assincronamente O exemplo abaixo mostra como o websocket funciona na prática, com um exemplo de abertura de uma conexão, recebimento de uma mensagem e exibição na console. Todas as mensagens recebidas pelo WebSocket são recebidas em bytes, então você terá que decodificá-las após o recebimento. Por padrão, as mensagens são fragmentadas em pedaços e o último pedaço é enviado como o pacote final da mensagem. Você pode configurar o tamanho do pacote com a bandeira WebSocketBufferSize. Este buffer é o mesmo para enviar e receber mensagens. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Mensagem recebida: \" + msgText); // obtém o contexto HttpWebSocket que recebeu a mensagem HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Resposta!\"); }; ws.WaitForClose(); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Aceitando e recebendo mensagens sincronicamente O exemplo abaixo contém uma maneira de você usar um websocket síncrono, sem um contexto assíncrono, onde você recebe as mensagens, lida com elas e finaliza o uso do socket. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/connect\", (req) => { var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"Qual é o seu nome?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Por favor, insira seu nome!\"); goto askName; } askAge: ws.Send(\"E sua idade?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Por favor, insira um número válido\"); goto askAge; } ws.Send($\"Você é {name}, e você tem {age} anos.\"); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Envio de mensagens O método Send possui três sobrecargas, que permitem enviar texto, uma matriz de bytes ou um intervalo de bytes. Todos eles são fragmentados se a bandeira WebSocketBufferSize do servidor for maior que o tamanho total da carga útil. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Olá, mundo\"); // será codificado como uma matriz de bytes UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Aguardando o fechamento do websocket O método WaitForClose() bloqueia a pilha de chamadas atuais até que a conexão seja encerrada por qualquer um dos lados (cliente ou servidor). Com isso, a execução do callback da solicitação será bloqueada até que o cliente ou o servidor se desconecte. Você também pode fechar a conexão manualmente com o método Close(). Este método retorna um objeto HttpResponse vazio, que não é enviado para o cliente, mas funciona como um retorno da função onde a solicitação HTTP foi recebida. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // aguarda o fechamento da conexão do cliente ws.WaitForClose(); // aguarda até que não haja mais mensagens trocadas nos 60 segundos // ou até que alguma parte feche a conexão ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Política de Ping Similar ao funcionamento da política de ping em Eventos do Servidor, você também pode configurar uma política de ping para manter a conexão TCP aberta se houver inatividade nela. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/pt-br/fundamentals/request-handlers.html": {
    "href": "docs/pt-br/fundamentals/request-handlers.html",
    "title": "Processamento de Requisições | Sisk",
    "keywords": "Processamento de Requisições Os manipuladores de requisições, também conhecidos como \"middlewares\", são funções que são executadas antes ou depois de uma requisição ser processada pelo roteador. Eles podem ser definidos por rota ou por roteador. Existem dois tipos de manipuladores de requisições: BeforeResponse: define que o manipulador de requisição será executado antes de chamar a ação do roteador. AfterResponse: define que o manipulador de requisição será executado após chamar a ação do roteador. O envio de uma resposta HTTP neste contexto sobrescreverá a resposta da ação do roteador. Ambos os manipuladores de requisições podem sobrescrever a resposta da função de callback do roteador. Aliás, manipuladores de requisições podem ser úteis para validar uma requisição, como autenticação, conteúdo ou qualquer outra informação, como armazenar informações, logs ou outras etapas que podem ser realizadas antes ou depois de uma resposta. Desta forma, um manipulador de requisição pode interromper toda essa execução e retornar uma resposta antes de terminar o ciclo, descartando tudo mais no processo. Exemplo: suponha que um manipulador de requisição de autenticação de usuário não o autentique. Ele impedirá que o ciclo de vida da requisição seja continuado e ficará pendente. Se isso acontecer no manipulador de requisição na posição dois, o terceiro e os seguintes não serão avaliados. Criando um manipulador de requisição Para criar um manipulador de requisição, podemos criar uma classe que herda a interface IRequestHandler, no seguinte formato: public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Retornando null indica que o ciclo de requisição pode ser continuado return null; } else { // Retornando um objeto HttpResponse indica que esta resposta sobrescreverá respostas adjacentes. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } No exemplo acima, indicamos que se o cabeçalho Authorization estiver presente na requisição, ele deve continuar e o próximo manipulador de requisição ou a callback do roteador deve ser chamada, seja qual for a próxima. Se um manipulador de requisição é executado após a resposta por sua propriedade ExecutionMode e retornar um valor não nulo, ele sobrescreverá a resposta do roteador. Sempre que um manipulador de requisição retorna null, indica que a requisição deve continuar e o próximo objeto deve ser chamado ou o ciclo deve terminar com a resposta do roteador. Associando um manipulador de requisição a uma única rota Você pode definir um ou mais manipuladores de requisição para uma rota. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // manipulador de requisição antes new ValidateJsonContentRequestHandler(), // manipulador de requisição antes // -- método IndexPage será executado aqui new WriteToLogRequestHandler() // manipulador de requisição depois }); Ou criando um objeto Route: Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Associando um manipulador de requisição a um roteador Você pode definir um manipulador de requisição global que será executado em todas as rotas de um roteador. mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Associando um manipulador de requisição a um atributo Você pode definir um manipulador de requisição em um atributo de método junto com um atributo de rota. public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() .WithContent(new StringContent(\"Hello world!\")); } } Observe que é necessário passar o tipo de manipulador de requisição desejado e não uma instância de objeto. Dessa forma, o manipulador de requisição será instanciado pelo parser do roteador. Você pode passar argumentos no construtor com a propriedade ConstructorArguments. Exemplo: [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Você também pode criar seu próprio atributo que implementa RequestHandler: public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } E usá-lo como: [Authenticate] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Ignorando um manipulador de requisição global Depois de definir um manipulador de requisição global em uma rota, você pode ignorá-lo em rotas específicas. var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: a mesma instância do que está nos manipuladores de requisição globais new AuthenticateUserRequestHandler() // errado: não ignorará o manipulador de requisição global } }); Note Se você estiver ignorando um manipulador de requisição, deve usar a mesma referência do que você instanciou antes para ignorá-lo. Criar outra instância de manipulador de requisição não ignorará o manipulador de requisição global, pois a referência será alterada. Lembre-se de usar a mesma referência de manipulador de requisição usada tanto em GlobalRequestHandlers quanto em BypassGlobalRequestHandlers."
  },
  "docs/pt-br/fundamentals/requests.html": {
    "href": "docs/pt-br/fundamentals/requests.html",
    "title": "Requisições | Sisk",
    "keywords": "Requisições Requisições são estruturas que representam uma mensagem de requisição HTTP. O objeto HttpRequest contém funções úteis para manipular mensagens HTTP ao longo de sua aplicação. Uma requisição HTTP é formada pelo método, caminho, versão, cabeçalhos e corpo. Neste documento, vamos ensinar como obter cada um desses elementos. Obtendo o método da requisição Para obter o método da requisição recebida, você pode usar a propriedade Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Essa propriedade retorna o método da requisição representado por um objeto HttpMethod. Note Ao contrário dos métodos de rota, essa propriedade não atende ao item RouteMethod.Any. Em vez disso, ela retorna o método de requisição real. Obtendo componentes da URL da requisição Você pode obter vários componentes de uma URL por meio de propriedades de uma requisição. Para este exemplo, vamos considerar a URL: http://localhost:5000/user/login?email=foo@bar.com Nome do componente Descrição Valor do componente Path Obtém o caminho da requisição. /user/login FullPath Obtém o caminho da requisição e a string de consulta. /user/login?email=foo@bar.com FullUrl Obtém a string de requisição URL completa. http://localhost:5000/user/login?email=foo@bar.com Host Obtém o host da requisição. localhost Authority Obtém o host e a porta da requisição. localhost:5000 QueryString Obtém a consulta da requisição. ?email=foo@bar.com Query Obtém a consulta da requisição em uma coleção de valores nomeados. {StringValueCollection object} IsSecure Determina se a requisição está usando SSL (true) ou não (false). false Você também pode optar por usar a propriedade HttpRequest.Uri, que inclui tudo acima em um objeto. Obtendo o corpo da requisição Algumas requisições incluem corpo, como formulários, arquivos ou transações de API. Você pode obter o corpo de uma requisição da propriedade: // obtém o corpo da requisição como uma string, usando o codificador de requisição string body = request.Body; // ou obtém em um array de bytes byte[] bodyBytes = request.RawBody; // ou ainda, você pode transmiti-lo. Stream requestStream = request.GetRequestStream(); Também é possível determinar se há um corpo na requisição e se ele está carregado com as propriedades HasContents, que determina se a requisição tem conteúdo e IsContentAvailable que indica que o servidor HTTP recebeu completamente o conteúdo do ponto remoto. Não é possível ler o conteúdo da requisição por meio de GetRequestStream mais de uma vez. Se você ler com este método, os valores em RawBody e Body também não estarão disponíveis. Não é necessário descartar o fluxo de requisição no contexto da requisição, pois ele é descartado no final da sessão HTTP em que é criado. Além disso, você pode usar a propriedade HttpRequest.RequestEncoding para obter o melhor codificador para decodificar a requisição manualmente. O servidor tem limites para ler o conteúdo da requisição, o que se aplica a ambos HttpRequest.Body e HttpRequest.RawBody. Essas propriedades copiam o fluxo de entrada inteiro para um buffer local do mesmo tamanho de HttpRequest.ContentLength. Uma resposta com status 413 Conteúdo Muito Grande é retornada ao cliente se o conteúdo enviado for maior que HttpServerConfiguration.MaximumContentLength definido na configuração do usuário. Além disso, se não houver limite configurado ou se ele for muito grande, o servidor lançará uma OutOfMemoryException quando o conteúdo enviado pelo cliente exceder Int32.MaxValue (2 GB) e se o conteúdo for tentado acessado por meio de uma das propriedades mencionadas acima. Você ainda pode lidar com o conteúdo por meio de transmissão. Note Embora o Sisk permita, é sempre uma boa ideia seguir a Semântica HTTP para criar sua aplicação e não obter ou servir conteúdo em métodos que não o permitam. Leia sobre RFC 9110 \"HTTP Semantics\". Obtendo o contexto da requisição O Contexto HTTP é um objeto exclusivo do Sisk que armazena informações do servidor HTTP, rota, roteador e manipulador de requisição. Você pode usá-lo para se organizar em um ambiente onde esses objetos são difíceis de organizar. O objeto RequestBag contém informações armazenadas que são passadas de um manipulador de requisição para outro ponto e podem ser consumidas no destino final. Esse objeto também pode ser usado por manipuladores de requisição que são executados após o callback da rota. Tip Essa propriedade também é acessível pela propriedade HttpRequest.Bag. public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers[\"Authorization\"] != null) { context.RequestBag.Add(\"AuthenticatedUser\", \"Bob\"); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } O manipulador de requisição acima definirá AuthenticatedUser no saco de requisição e pode ser consumido posteriormente no callback final: public class MyController { [Route(RouteMethod.Get, \"/\")] [RequestHandler(typeof(AuthenticateUserRequestHandler))] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); string authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; res.Content = new StringContent($\"Hello, {authUser}!\"); return res; } } Você também pode usar os métodos auxiliares Bag.Set() e Bag.Get() para obter ou definir objetos por seus tipos singleton. public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse Test(HttpRequest request) { var user = request.Bag.Get<User>(); } Obtendo dados de formulário Você pode obter os valores de um formulário em uma NameValueCollection com o exemplo abaixo: static HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password) == true) { ... } } Obtendo dados de formulário multipart A requisição HTTP do Sisk permite obter conteúdos multipart, como arquivos, campos de formulário ou qualquer conteúdo binário. static HttpResponse Index(HttpRequest request) { // o método a seguir lê a entrada de requisição inteira em um // array de MultipartObjects var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // O nome do arquivo fornecido pelo formulário multipart. // Null é retornado se o objeto não for um arquivo. Console.WriteLine(\"Nome do arquivo : \" + uploadedObject.Filename); // O nome do campo do formulário multipart. Console.WriteLine(\"Nome do campo : \" + uploadedObject.Name); // O comprimento do conteúdo do formulário multipart. Console.WriteLine(\"Comprimento do conteúdo : \" + uploadedObject.ContentLength); // Determina o formato do arquivo com base no cabeçalho para cada // tipo de conteúdo conhecido. Se o conteúdo não for um formato de arquivo // comum reconhecido, o método abaixo retornará MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Formato comum : \" + uploadedObject.GetCommonFileFormat()); } } Você pode ler mais sobre os objetos de formulário multipart do Sisk Multipart form objects e seus métodos, propriedades e funcionalidades. Suporte a eventos enviados pelo servidor O Sisk suporta Eventos enviados pelo servidor, que permitem enviar pedaços como um fluxo e manter a conexão entre o servidor e o cliente viva. Chamar o método HttpRequest.GetEventSource colocará a requisição HTTP em seu estado de ouvinte. A partir disso, o contexto dessa requisição HTTP não esperará uma resposta HTTP, pois ela sobreporá os pacotes enviados por eventos do servidor. Depois de enviar todos os pacotes, o callback deve retornar o método Close, que enviará a resposta final ao servidor e indicará que o streaming terminou. Não é possível prever o comprimento total de todos os pacotes que serão enviados, portanto, não é possível determinar o fim da conexão com o cabeçalho Content-Length. Por padrão, a maioria dos navegadores não suporta o envio de cabeçalhos HTTP ou métodos diferentes do GET. Portanto, tenha cuidado ao usar manipuladores de requisição com solicitações de evento de origem que exigem cabeçalhos específicos na requisição, pois eles provavelmente não os terão. Além disso, a maioria dos navegadores reinicia os fluxos se o método EventSource.close não for chamado no lado do cliente após receber todos os pacotes, causando processamento adicional infinito no lado do servidor. Para evitar esse tipo de problema, é comum enviar um pacote final indicando que a origem do evento terminou de enviar todos os pacotes. O exemplo abaixo mostra como o navegador pode se comunicar com o servidor que suporta Eventos enviados pelo servidor. <html> <body> <b>Frutas:</b> <ul></ul> </body> <script> const evtSource = new EventSource('/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `mensagem: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomate\") { evtSource.close(); } } </script> </html> E envie progressivamente as mensagens para o cliente: public class MyController { [Route(RouteMethod.Get, \"/event-source\")] static HttpResponse ServerEventsResponse(HttpRequest request) { var serverEvents = request.GetEventSource(); string[] frutas = new[] { \"Maçã\", \"Banana\", \"Melancia\", \"Tomate\" }; foreach (string fruta in frutas) { serverEvents.Send(fruta); Thread.Sleep(1500); } return serverEvents.Close(); } } Quando executarmos esse código, esperamos um resultado semelhante a este: Resolvendo IPs e hosts proxy O Sisk pode ser usado com proxies, e portanto, os endereços IP podem ser substituídos pelo ponto de extremidade do proxy na transação de um cliente para o proxy. Você pode definir seus próprios resolvidores no Sisk com resolvidores de encaminhamento. Codificação de cabeçalhos A codificação de cabeçalhos pode ser um problema para algumas implementações. No Windows, cabeçalhos UTF-8 não são suportados, portanto, o ASCII é usado. O Sisk tem um conversor de codificação incorporado, que pode ser útil para decodificar cabeçalhos codificados incorretamente. Essa operação é custosa e está desabilitada por padrão, mas pode ser habilitada sob a flag NormalizeHeadersEncodings."
  },
  "docs/pt-br/fundamentals/responses.html": {
    "href": "docs/pt-br/fundamentals/responses.html",
    "title": "Respostas | Sisk",
    "keywords": "Respostas Respostas representam objetos que são respostas HTTP para requisições HTTP. Elas são enviadas pelo servidor para o cliente como uma indicação da requisição de um recurso, página, documento, arquivo ou outro objeto. Uma resposta HTTP é formada por status, headers e conteúdo. Neste documento, vamos ensinar como arquitetar respostas HTTP com Sisk. Definindo um status HTTP A lista de status HTTP é a mesma desde o HTTP/1.0, e Sisk suporta todos eles. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 Ou com sintaxe Fluent: new HttpResponse() .WithStatus(200) // ou .WithStatus(HttpStatusCode.Ok) // ou .WithStatus(HttpStatusInformation.Ok); Você pode ver a lista completa de HttpStatusCode disponíveis aqui. Você também pode fornecer seu próprio código de status usando a estrutura HttpStatusInformation. Corpo e tipo de conteúdo Sisk suporta objetos de conteúdo nativos do .NET para enviar corpo em respostas. Você pode usar a classe StringContent para enviar uma resposta JSON, por exemplo: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); O servidor sempre tentará calcular o Content-Length a partir do que você definiu no conteúdo, se você não o definir explicitamente em um header. Se o servidor não puder obter implicitamente o header Content-Length do conteúdo da resposta, a resposta será enviada com Chunked-Encoding. Você também pode transmitir a resposta enviando um StreamContent ou usando o método GetResponseStream. Cabeçalhos de resposta Você pode adicionar, editar ou remover cabeçalhos que estão sendo enviados na resposta. O exemplo abaixo mostra como enviar uma resposta de redirecionamento para o cliente. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Ou com sintaxe Fluent: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Quando você usa o método Add da HttpHeaderCollection, você está adicionando um cabeçalho à requisição sem alterar os que já foram enviados. O método Set substitui os cabeçalhos com o mesmo nome pelo valor instruído. O indexador da HttpHeaderCollection internamente chama o método Set para substituir os cabeçalhos. Enviando cookies Sisk tem métodos que facilitam a definição de cookies no cliente. Cookies definidos por este método já estão codificados em URL e atendem ao padrão RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Ou com sintaxe Fluent: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Há outras versões mais completas do mesmo método. Respostas em chunk Você pode definir o encoding de transferência como chunked para enviar respostas grandes. HttpResponse res = new HttpResponse(); res.SendChunked = true; Ao usar chunked-encoding, o header Content-Length é automaticamente omitido. Stream de resposta Streams de resposta são uma maneira gerenciada de enviar respostas de forma segmentada. É uma operação de nível mais baixo do que usar objetos HttpResponse, pois requer que você envie os cabeçalhos e o conteúdo manualmente e, em seguida, feche a conexão. Este exemplo abre um stream de leitura para o arquivo, copia o stream para o stream de saída da resposta e não carrega o arquivo inteiro na memória. Isso pode ser útil para servir arquivos de tamanho médio ou grande. // obtém o stream de saída da resposta using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // define o encoding de resposta para usar chunked-encoding // também você não deve enviar o header content-length quando usar // chunked encoding responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // copia o stream do arquivo para o stream de saída da resposta fileStream.CopyTo(responseStream.ResponseStream); // fecha o stream return responseStream.Close(); Compactação GZip, Deflate e Brotli Você pode enviar respostas com conteúdo compactado em Sisk compactando os conteúdos HTTP. Primeiramente, encapsule seu objeto HttpContent dentro de um dos compactadores abaixo para enviar a resposta compactada para o cliente. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // ou Content = new BrotliContent(new HtmlContent(myHtml)), // ou Content = new DeflateContent(new HtmlContent(myHtml)), }; }); Você também pode usar esses conteúdos compactados com streams. router.MapGet(\"/archive.zip\", request => { // não aplique \"using\" aqui. o HttpServer descartará seu conteúdo // após enviar a resposta. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Os headers Content-Encoding são definidos automaticamente ao usar esses conteúdos. Tipos de resposta implícitos Desde a versão 0.15, você pode usar outros tipos de retorno além de HttpResponse, mas é necessário configurar o roteador para lidar com cada tipo de objeto. O conceito é sempre retornar um tipo de referência e convertê-lo em um objeto HttpResponse válido. Rotas que retornam HttpResponse não passam por nenhuma conversão. Tipos de valor (estruturas) não podem ser usados como tipo de retorno porque não são compatíveis com o RouterCallback, então devem ser encapsulados em um ValueResult para serem usados em manipuladores. Considere o exemplo abaixo de um módulo de roteador que não usa HttpResponse no tipo de retorno: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } Com isso, agora é necessário definir no roteador como ele lidará com cada tipo de objeto. Objetos são sempre o primeiro argumento do manipulador e o tipo de saída deve ser um HttpResponse válido. Além disso, os objetos de saída de uma rota nunca devem ser nulos. Para tipos ValueResult, não é necessário indicar que o objeto de entrada é um ValueResult e apenas T, pois ValueResult é um objeto refletido a partir de seu componente original. A associação de tipos não compara o que foi registrado com o tipo do objeto retornado do callback do roteador. Em vez disso, verifica se o tipo do resultado do roteador é atribuível ao tipo registrado. Registrar um manipulador de tipo Object fará com que todos os tipos anteriores sejam ignorados. A ordem de inserção dos manipuladores de valor também é importante, então registrar um manipulador de Object deve ser feito por último. Sempre registre manipuladores de valor específicos primeiro para garantir a ordem. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<bool>(bolVal => { HttpResponse res = new HttpResponse(); res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest; return res; }); r.RegisterValueHandler<IEnumerable>(enumerableValue => { return new HttpResponse(); // faça algo com enumerableValue aqui }); // registrar um manipulador de valor de objeto deve ser o último // manipulador de valor que será usado como fallback r.RegisterValueHandler<object>(fallback => { HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.OK; res.Content = JsonContent.Create(fallback); return res; });"
  },
  "docs/pt-br/fundamentals/routing.html": {
    "href": "docs/pt-br/fundamentals/routing.html",
    "title": "Roteamento | Sisk",
    "keywords": "Roteamento O Router é o primeiro passo na construção do servidor. Ele é responsável por armazenar objetos Route, que são endpoints que mapeiam URLs e seus métodos para ações executadas pelo servidor. Cada ação é responsável por receber uma solicitação e entregar uma resposta ao cliente. As rotas são pares de expressões de caminho (\"padrão de caminho\") e o método HTTP que elas podem ouvir. Quando uma solicitação é feita ao servidor, ele tentará encontrar uma rota que corresponda à solicitação recebida, então ele chamará a ação daquela rota e entregará a resposta resultante ao cliente. Existem várias maneiras de definir rotas no Sisk: elas podem ser estáticas, dinâmicas ou auto-escaneadas, definidas por atributos ou diretamente no objeto Router. Router mainRouter = new Router(); // mapeia a rota GET / para a ação a seguir mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Olá, mundo!\"); }); Para entender o que uma rota é capaz de fazer, precisamos entender o que uma solicitação é capaz de fazer. Um HttpRequest conterá tudo o que você precisa. O Sisk também inclui alguns recursos extras que aceleram o desenvolvimento geral. Para cada ação recebida pelo servidor, um delegado do tipo RouteAction será chamado. Esse delegado contém um parâmetro que segura um HttpRequest com todas as informações necessárias sobre a solicitação recebida pelo servidor. O objeto resultante desse delegado deve ser um HttpResponse ou um objeto que mapeia para ele por meio de tipos de resposta implícitos. Correspondência de rotas Quando uma solicitação é recebida pelo servidor HTTP, o Sisk procura uma rota que satisfaça a expressão do caminho recebido pela solicitação. A expressão é sempre testada entre a rota e o caminho da solicitação, sem considerar a string de consulta. Esse teste não tem prioridade e é exclusivo para uma única rota. Quando nenhuma rota é correspondida com aquela solicitação, a resposta Router.NotFoundErrorHandler é retornada ao cliente. Quando o padrão de caminho é correspondido, mas o método HTTP é incorreto, a resposta Router.MethodNotAllowedErrorHandler é enviada de volta ao cliente. O Sisk verifica a possibilidade de colisões de rotas para evitar esses problemas. Quando as rotas são definidas, o Sisk procurará por rotas possíveis que possam colidir com a rota sendo definida. Esse teste inclui a verificação do caminho e do método que a rota está configurada para aceitar. Criando rotas usando padrões de caminho Você pode definir rotas usando vários métodos SetRoute. // maneira SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<nome>\", (request) => { string nome = request.RouteParameters[\"nome\"].GetString(); return new HttpResponse($\"Olá, {nome}\"); }); // maneira Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // vazio 200 ok }); // métodos de ajuda Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // o StreamContent interno // stream é descartado após o envio // da resposta. Content = new StreamContent(imageStream) }; }); // vários parâmetros mainRouter.MapGet(\"/hey/<nome>/sobrenome/<sobrenome>\", (request) => { string nome = request.RouteParameters[\"nome\"].GetString(); string sobrenome = request.RouteParameters[\"sobrenome\"].GetString(); return new HttpResponse($\"Olá, {nome} {sobrenome}!\"); }); A propriedade RouteParameters do HttpResponse contém todas as informações sobre as variáveis de caminho da solicitação recebida. Todo caminho recebido pelo servidor é normalizado antes do teste do padrão de caminho ser executado, seguindo essas regras: Todos os segmentos vazios são removidos do caminho, por exemplo: ////foo//bar se torna /foo/bar. A correspondência de caminho é sensível a maiúsculas e minúsculas, a menos que Router.MatchRoutesIgnoreCase seja definido como true. As propriedades Query e RouteParameters do HttpRequest retornam um objeto StringValueCollection, onde cada propriedade indexada retorna um StringValue não nulo, que pode ser usado como uma opção/monad para converter seu valor bruto em um objeto gerenciado. O exemplo abaixo lê o parâmetro de rota \"id\" e obtém um Guid a partir dele. Se o parâmetro não for um Guid válido, uma exceção é lançada e um erro 500 é retornado ao cliente se o servidor não estiver lidando com Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); [!NOTA] Os caminhos têm sua barra final / ignorada em ambos os caminhos da solicitação e da rota, ou seja, se você tentar acessar uma rota definida como /index/page você poderá acessá-la usando /index/page/ também. Você também pode forçar as URLs a terminar com / habilitando a flag ForceTrailingSlash. Criando rotas usando instâncias de classe Você também pode definir rotas dinamicamente usando reflexão com o atributo RouteAttribute. Dessa forma, a instância de uma classe na qual seus métodos implementam esse atributo terá suas rotas definidas no roteador de destino. Para que um método seja definido como uma rota, ele deve ser marcado com um RouteAttribute, como o próprio atributo ou um RouteGetAttribute. O método pode ser estático, de instância, público ou privado. Quando o método SetObject(type) ou SetObject<TType>() é usado, os métodos de instância são ignorados. public class MeuControlador { // corresponderá a GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // métodos estáticos também funcionam [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Olá, mundo!\"); return res; } } A linha abaixo definirá tanto o método Index quanto o método Hello da classe MeuControlador como rotas, pois ambos são marcados como rotas e uma instância da classe foi fornecida, não seu tipo. Se seu tipo tivesse sido fornecido em vez de uma instância, apenas os métodos estáticos seriam definidos. var meuControlador = new MeuControlador(); mainRouter.SetObject(meuControlador); Desde a versão 0.16 do Sisk, é possível habilitar o AutoScan, que procurará por classes definidas pelo usuário que implementam RouterModule e as associará automaticamente ao roteador. Isso não é suportado com compilação AOT. mainRouter.AutoScanModules<ApiController>(); A instrução acima procurará por todos os tipos que implementam ApiController, mas não o tipo em si. Os dois parâmetros opcionais indicam como o método procurará por esses tipos. O primeiro argumento implica a Assembly onde os tipos serão procurados e o segundo indica a forma como os tipos serão definidos. Rotas de regex Em vez de usar os métodos de correspondência de caminho HTTP padrão, você pode marcar uma rota para ser interpretada com Regex. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"Minha rota\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Ou com a classe RegexRoute: RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"olá, mundo\"); }); mainRouter.SetRoute(indexRoute); Você também pode capturar grupos da expressão regular no padrão para o conteúdo de HttpRequest.RouteParameters: [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Acessando arquivo {filename}\"); } Rotas de qualquer método Você pode definir uma rota para ser correspondida apenas pelo seu caminho e ignorar o método HTTP. Isso pode ser útil para você fazer a validação do método dentro da callback da rota. // corresponderá a / em qualquer método HTTP mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Rotas de qualquer caminho As rotas de qualquer caminho testam qualquer caminho recebido pelo servidor HTTP, sujeito ao método da rota sendo testado. Se o método da rota for RouteMethod.Any e a rota usar Route.AnyPath em sua expressão de caminho, essa rota ouvirá todas as solicitações do servidor HTTP e nenhuma outra rota poderá ser definida. // a seguinte rota corresponderá a todas as solicitações POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Ignorar caso na correspondência de rotas Por padrão, a interpretação de rotas com solicitações é sensível a maiúsculas e minúsculas. Para fazer com que ela ignore o caso, habilite essa opção: mainRouter.MatchRoutesIgnoreCase = true; Isso também habilitará a opção RegexOptions.IgnoreCase para rotas onde é feita a correspondência com regex. Manipulador de callback não encontrado (404) Você pode criar um callback personalizado para quando uma solicitação não corresponde a nenhuma rota conhecida. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // Desde a v0.14 Content = new HtmlContent(\"<h1>Não encontrado</h1>\") // versões anteriores Content = new StringContent(\"<h1>Não encontrado</h1>\", Encoding.UTF8, \"text/html\") }; }; Manipulador de callback de método não permitido (405) Você também pode criar um callback personalizado para quando uma solicitação corresponde ao seu caminho, mas não corresponde ao método. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Método não permitido para essa rota.\") }; }; Manipulador de erro interno Os callbacks de rota podem lançar erros durante a execução do servidor. Se não forem tratados corretamente, o funcionamento geral do servidor HTTP pode ser interrompido. O roteador tem um callback para quando um callback de rota falha e impede a interrupção do serviço. Esse método só é alcançável quando ThrowExceptions é definido como false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Erro: {ex.Message}\") }; };"
  },
  "docs/pt-br/getting-started.html": {
    "href": "docs/pt-br/getting-started.html",
    "title": "Introdução ao Sisk | Sisk",
    "keywords": "Introdução ao Sisk Sisk pode ser executado em qualquer ambiente .NET. Neste guia, vamos ensinar como criar um aplicativo Sisk usando .NET. Se você ainda não o instalou, por favor, baixe o SDK aqui. Neste tutorial, vamos cobrir como criar uma estrutura de projeto, receber uma solicitação, obter um parâmetro de URL e enviar uma resposta. Este guia se concentrará em construir um servidor simples usando C#. Você também pode usar sua linguagem de programação favorita. Note Você pode estar interessado em um projeto de início rápido. Verifique este repositório para obter mais informações. Criando um Projeto Vamos nomear nosso projeto \"Meu Aplicativo Sisk\". Uma vez que você tenha o .NET configurado, você pode criar seu projeto com o seguinte comando: dotnet new console -n meu-aplicativo-sisk Em seguida, navegue até o diretório do seu projeto e instale o Sisk usando a ferramenta de utilitário .NET: cd meu-aplicativo-sisk dotnet add package Sisk.HttpServer Você pode encontrar maneiras adicionais de instalar o Sisk no seu projeto aqui. Agora, vamos criar uma instância do nosso servidor HTTP. Para este exemplo, vamos configurá-lo para ouvir na porta 5000. Construindo o Servidor HTTP Sisk permite que você construa seu aplicativo passo a passo manualmente, pois ele roteia para o objeto HttpServer. No entanto, isso pode não ser muito conveniente para a maioria dos projetos. Portanto, podemos usar o método de construtor, que torna mais fácil colocar nosso aplicativo em execução. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Olá, mundo!\") }; }); await app.StartAsync(); } } É importante entender cada componente vital do Sisk. Mais tarde neste documento, você aprenderá mais sobre como o Sisk funciona. Configuração Manual (avançada) Você pode aprender como cada mecanismo do Sisk funciona nesta seção da documentação, que explica o comportamento e as relações entre o HttpServer, Router, ListeningPort e outros componentes."
  },
  "docs/pt-br/installing.html": {
    "href": "docs/pt-br/installing.html",
    "title": "Instalando | Sisk",
    "keywords": "Instalando Você pode instalar o Sisk através do Nuget, dotnet cli ou outras opções. Você pode configurar facilmente seu ambiente Sisk executando este comando em seu console de desenvolvedor: Warning Versões mais recentes do Sisk são compatíveis com .NET 8 e em breve .NET 9. Versões antigas do Sisk para .NET 6 e .NET 7 serão mantidas até 30 de novembro de 2024, recebendo apenas patches de segurança e correções no ramo \"legacy\". Por favor, atualize seus projetos usando o Sisk para .NET 8. dotnet add package Sisk.HttpServer Este comando instalará a versão mais recente do Sisk no seu projeto."
  },
  "docs/pt-br/native-aot.html": {
    "href": "docs/pt-br/native-aot.html",
    "title": "Suporte com AOT | Sisk",
    "keywords": "Suporte com AOT Na .NET 7, foi introduzido o Native AOT, um modo de compilação .NET que permite exportar binários prontos para qualquer plataforma suportada, sem exigir que o runtime .NET seja instalado na máquina de destino. Com o Native AOT, seu código é compilado para código nativo e já contém tudo o que precisa para ser executado. O Sisk tem experimentado o recurso desde a versão 0.9.1, que melhora o suporte para Native AOT com recursos para definir rotas dinâmicas por aplicativo sem afetar a compilação com mensagens de aviso. O Sisk usa reflexão para obter os métodos que serão definidos a partir de tipos e objetos. Além disso, o Sisk usa reflexão para atributos como RequestHandlerAttribute, que são inicializados a partir de um tipo. Para funcionar corretamente, a compilação AOT usa o trimming, onde os tipos dinâmicos devem especificar o que será usado na montagem final. Considerando o exemplo abaixo, é uma rota que chama um RequestHandler. [Route(RouteMethod.Get, \"/\", LogMode = LogOutput.None)] [RequestHandler(typeof(MyRequestHandler))] static HttpResponse IndexPage(HttpRequest request) { HttpResponse htmlResponse = new HttpResponse(); htmlResponse.Content = new StringContent(\"Hello, world!\", System.Text.Encoding.UTF8, \"text/plain\"); return htmlResponse; } Este RequestHandler é invocado dinamicamente durante a execução, e essa invocação deve ser segmentada e essa segmentação deve ser explícita. Para entender melhor o que o compilador considerará de MyRequestHandler deve ser mantido na compilação final é: Propriedades públicas; Campos públicos e privados; Construtor público e privado; Métodos públicos e privados; Tudo o que você tiver em um RequestHandler que não seja mencionado acima será removido pelo compilador. Lembre-se de que todos os outros componentes, classes e pacotes que você usar em seu aplicativo devem ser compatíveis com o AOT Trimming, ou seu código não funcionará como esperado. A propósito, o Sisk não vai te deixar na mão se você quiser construir algo onde o desempenho é uma prioridade. Você pode ler mais sobre o Native AOT e como ele funciona na documentação oficial da Microsoft."
  },
  "docs/pt-br/registering-namespace.html": {
    "href": "docs/pt-br/registering-namespace.html",
    "title": "Configurando reservas de namespace no Windows | Sisk",
    "keywords": "Configurando reservas de namespace no Windows Sisk trabalha com a interface de rede HttpListener, que vincula um host virtual ao sistema para ouvir solicitações. No Windows, essa vinculação é um pouco restritiva, permitindo apenas que o localhost seja vinculado como um host válido. Ao tentar ouvir outro host, um erro de acesso negado é lançado no servidor. Este tutorial explica como conceder autorização para ouvir em qualquer host que você desejar no sistema. Namespace Setup.bat BATCH @echo off :: insira o prefixo aqui, sem espaços ou aspas SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Onde em PREFIX, é o prefixo (\"Host de Escuta->Porta\") que o servidor irá ouvir. Ele deve ser formatado com o esquema de URL, host, porta e uma barra no final, exemplo: Namespace Setup.bat BATCH SET PREFIX=http://meu-aplicativo.exemplo.teste/ Para que você possa ser ouvido em sua aplicação por meio de: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://meu-aplicativo.exemplo.teste/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Olá, mundo!\") }; }); await app.StartAsync(); } }"
  },
  "docs/pt-br/ssl.html": {
    "href": "docs/pt-br/ssl.html",
    "title": "Trabalhando com SSL | Sisk",
    "keywords": "Trabalhando com SSL Trabalhar com SSL para desenvolvimento pode ser necessário quando se trabalha em contextos que exigem segurança, como a maioria dos cenários de desenvolvimento web. O Sisk opera em cima do HttpListener, que não suporta HTTPS nativo, apenas HTTP. No entanto, existem soluções alternativas que permitem trabalhar com SSL no Sisk. Veja-as abaixo: Através do IIS no Windows Disponível em: Windows Esforço: médio Se você estiver no Windows, pode usar o IIS para habilitar SSL no seu servidor HTTP. Para que isso funcione, é recomendável que você siga este tutorial com antecedência se quiser que seu aplicativo esteja ouvindo em um host diferente de \"localhost\". Para que isso funcione, você deve instalar o IIS através dos recursos do Windows. O IIS está disponível gratuitamente para usuários do Windows e Windows Server. Para configurar o SSL em seu aplicativo, tenha o certificado SSL pronto, mesmo que seja autoassinado. Em seguida, você pode ver como configurar o SSL no IIS 7 ou superior. Através do mitmproxy Disponível em: Linux, macOS, Windows Esforço: fácil mitmproxy é uma ferramenta de proxy de interceptação que permite que desenvolvedores e testadores de segurança inspecionem, modifiquem e registrem o tráfego HTTP e HTTPS entre um cliente (como um navegador web) e um servidor. Você pode usar a utilitário mitmdump para iniciar um proxy SSL reversa entre seu cliente e seu aplicativo Sisk. Primeiro, instale o mitmprxy em sua máquina. Inicie seu aplicativo Sisk. Para este exemplo, usaremos a porta 8000 como a porta HTTP não segura. Inicie o servidor mitmproxy para ouvir a porta segura na 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 E você está pronto para começar! Você já pode acessar seu aplicativo através de https://localhost:8001/. Seu aplicativo não precisa estar em execução para você iniciar mitmdump. Através do pacote Sisk.SslProxy Disponível em: Linux, macOS, Windows Esforço: fácil O pacote Sisk.SslProxy é uma maneira simples de habilitar SSL no seu aplicativo Sisk. No entanto, é um pacote extremamente experimental. Pode ser instável trabalhar com este pacote, mas você pode fazer parte da pequena porcentagem de pessoas que contribuirão para tornar este pacote viável e estável. Para começar, você pode instalar o pacote Sisk.SslProxy com: dotnet add package Sisk.SslProxy Note Você deve habilitar \"Habilitar pacotes pré-lançamento\" no Gerenciador de Pacotes do Visual Studio para instalar o Sisk.SslProxy. Novamente, é um projeto experimental, então nem pense em colocá-lo em produção. No momento, o Sisk.SslProxy pode lidar com a maioria dos recursos HTTP/1.1, incluindo HTTP Continue, Chunked-Encoding, WebSockets e SSE. Leia mais sobre o SslProxy aqui."
  },
  "docs/registering-namespace.html": {
    "href": "docs/registering-namespace.html",
    "title": "Configuring namespace reservations on Windows | Sisk",
    "keywords": "Configuring namespace reservations on Windows Sisk works with the HttpListener network interface, which binds a virtual host to the system to listen for requests. On Windows, this binding is a bit restrictive, only allowing localhost to be bound as a valid host. When attempting to listen to another host, an access denied error is thrown on the server. This tutorial explains how to grant authorization to listen on any host you want on the system. Namespace Setup.bat BATCH @echo off :: insert prefix here, without spaces or quotes SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Where in PREFIX, is the prefix (\"Listening Host->Port\") that your server will listen to. It must be formatted with the URL scheme, host, port and a slash at the end, example: Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ So that you can be listened in your application through: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/ru/advanced/forwarding-resolvers.html": {
    "href": "docs/ru/advanced/forwarding-resolvers.html",
    "title": "Перенаправляющие Резолверы | Sisk",
    "keywords": "Перенаправляющие Резолверы Перенаправляющий Резолвер - это помощник, который помогает декодировать информацию, идентифицирующую клиента через запрос, прокси, CDN или балансировщики нагрузки. Когда ваш сервис Sisk запускается через обратный или прямой прокси, IP-адрес клиента, хост и протокол могут быть khácными от исходного запроса, поскольку это перенаправление из одного сервиса в другой. Эта функциональность Sisk позволяет вам контролировать и решать эту информацию перед работой с запросом. Эти прокси обычно предоставляют полезные заголовки для идентификации их клиента. В настоящее время с помощью класса ForwardingResolver возможно решить IP-адрес клиента, хост и HTTP-протокол, используемый. После версии 1.0 Sisk сервер больше не имеет стандартной реализации для декодирования этих заголовков по причинам безопасности, которые варьируются от сервиса к сервису. Например, заголовок X-Forwarded-For содержит информацию об IP-адресах, которые перенаправили запрос. Этот заголовок используется прокси для переноса цепочки информации к конечному сервису и включает IP-адрес всех прокси, использованных, включая реальный адрес клиента. Проблема в том, что иногда бывает сложно идентифицировать удаленный IP-адрес клиента, и нет конкретного правила для идентификации этого заголовка. Высоко рекомендуется прочитать документацию для заголовков, которые вы собираетесь реализовать ниже: Прочитайте о заголовке X-Forwarded-For здесь. Прочитайте о заголовке X-Forwarded-Host здесь. Прочитайте о заголовке X-Forwarded-Proto здесь. Класс ForwardingResolver Этот класс имеет три виртуальных метода, которые позволяют наиболее подходящую реализацию для каждого сервиса. Каждый метод отвечает за решение информации из запроса через прокси: IP-адрес клиента, хост запроса и протокол безопасности, используемый. По умолчанию Sisk всегда будет использовать информацию из исходного запроса, не решая никаких заголовков. Пример ниже показывает, как можно использовать эту реализацию. Этот пример решает IP-адрес клиента через заголовок X-Forwarded-For и выбрасывает ошибку, когда более одного IP-адреса было перенаправлено в запросе. Important Не используйте этот пример в производственном коде. Всегда проверяйте, является ли реализация подходящей для использования. Прочитайте документацию заголовков перед их реализацией. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"Заголовок X-Forwarded-For отсутствует.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Слишком много адресов в заголовке X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/ru/advanced/http-server-handlers.html": {
    "href": "docs/ru/advanced/http-server-handlers.html",
    "title": "Обработчики HTTP-сервера | Sisk",
    "keywords": "Обработчики HTTP-сервера В версии Sisk 0.16 мы ввели класс HttpServerHandler, целью которого является расширение общего поведения Sisk и предоставление дополнительных обработчиков событий для Sisk, таких как обработка запросов HTTP, маршрутизаторы, контекстные сумки и многое другое. Этот класс концентрирует события, которые происходят во время существования всего HTTP-сервера и каждого запроса. Протокол HTTP не имеет сессий, и поэтому невозможно сохранить информацию от одного запроса к другому. Sisk в настоящее время предоставляет способ реализации сессий, контекстов, подключений к базе данных и других полезных провайдеров, чтобы помочь вашей работе. Пожалуйста, обратитесь к этой странице, чтобы прочитать, где каждое событие вызывается и какова его цель. Вы также можете просмотреть жизненный цикл запроса HTTP, чтобы понять, что происходит с запросом и где вызываются события. HTTP-сервер позволяет использовать несколько обработчиков одновременно. Каждый вызов события является синхронным, то есть он будет блокировать текущую нить для каждого запроса или контекста, пока все обработчики, связанные с этой функцией, не будут выполнены и завершены. В отличие от RequestHandlers, они не могут быть применены к определенным группам маршрутов или конкретным маршрутам. Вместо этого они применяются к整个 HTTP-серверу. Вы можете применять условия внутри вашего обработчика HTTP-сервера. Кроме того, синглтоны каждого HttpServerHandler определяются для каждого приложения Sisk, поэтому существует только один экземпляр на HttpServerHandler. Практическим примером использования HttpServerHandler является автоматическое освобождение подключения к базе данных в конце запроса. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // проверяет, определена ли DbContext в контекстной сумке запроса if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // позволяет пользователю создать контекст базы данных из запроса HTTP // и сохранить его в контекстной сумке public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } С помощью кода выше, расширение GetDbContext позволяет создать контекст подключения к базе данных直接 из объекта HttpRequest. Неправильно освобожденное подключение может вызвать проблемы при работе с базой данных, поэтому оно завершается в OnHttpRequestClose. Вы можете зарегистрировать обработчик на HTTP-сервере в вашем построителе или直接 с помощью HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } С помощью этого, класс UsersController может использовать контекст базы данных следующим образом: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Пользователь добавлен.\"); } } Код выше использует методы, такие как JsonOk и JsonMessage, которые встроены в ApiController, который наследуется от RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Разработчики могут реализовать сессии, контексты и подключения к базе данных, используя этот класс. Предоставленный код демонстрирует практический пример с DatabaseConnectionHandler, автоматизирующий освобождение подключения к базе данных в конце каждого запроса. Интеграция проста, с обработчиками, зарегистрированными во время настройки сервера. Класс HttpServerHandler предлагает мощный набор инструментов для управления ресурсами и расширения поведения Sisk в HTTP-приложениях."
  },
  "docs/ru/advanced/manual-setup.html": {
    "href": "docs/ru/advanced/manual-setup.html",
    "title": "Руководство (расширенная) настройка | Sisk",
    "keywords": "Руководство (расширенная) настройка В этом разделе мы создадим наш HTTP-сервер без каких-либо предопределенных стандартов, совершенно абстрактным способом. Здесь вы можете вручную настроить, как будет функционировать ваш HTTP-сервер. Каждый ListeningHost имеет маршрутизатор, и HTTP-сервер может иметь несколько ListeningHosts, каждый из которых указывает на другой хост на другом порту. Сначала нам нужно понять концепцию запроса/ответа. Это довольно просто: на каждый запрос должен быть ответ. Sisk также следует этому принципу. Давайте создадим метод, который отвечает сообщением \"Hello, World!\" в HTML, указывая статусный код и заголовки. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Привет, мир!</h1> </body> </html> \") }; return indexResponse; } Следующий шаг - связать этот метод с HTTP-маршрутом. Маршрутизаторы Маршрутизаторы являются абстракциями запросов и служат мостом между запросами и ответами для службы. Маршрутизаторы управляют маршрутами службы, функциями и ошибками. Маршрутизатор может иметь несколько маршрутов, и каждый маршрут может выполнять разные операции на этом пути, такие как выполнение функции, служба страницы или предоставление ресурса с сервера. Давайте создадим наш первый маршрутизатор и свяжем наш метод IndexPage с индексным путем. Router mainRouter = new Router(); // SetRoute будет связывать все индексные маршруты с нашим методом. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Теперь наш маршрутизатор может получать запросы и отправлять ответы. Однако mainRouter не привязан к хосту или серверу, поэтому он не будет работать самостоятельно. Следующий шаг - создать наш ListeningHost. Listening Hosts и Порты ListeningHost может хостить маршрутизатор и несколько прослушиваемых портов для одного и того же маршрутизатора. ListeningPort - это префикс, где HTTP-сервер будет слушать. Здесь мы можем создать ListeningHost, который указывает на два端пойнта для нашего маршрутизатора: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Теперь наш HTTP-сервер будет слушать указанные端пойнты и перенаправлять свои запросы на наш маршрутизатор. Настройка Сервера Настройка сервера отвечает за большую часть поведения HTTP-сервера. В этой конфигурации мы можем связать ListeningHosts с нашим сервером. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Добавляем наш ListeningHost в эту конфигурацию сервера Далее мы можем создать наш HTTP-сервер: HttpServer server = new HttpServer(config); server.Start(); // Запускает сервер Console.ReadKey(); // Предотвращает выход из приложения Теперь мы можем скомпилировать наш исполняемый файл и запустить наш HTTP-сервер с командой: dotnet watch Во время выполнения откройте браузер и перейдите по пути сервера, и вы должны увидеть:"
  },
  "docs/ru/advanced/multi-host-setup.html": {
    "href": "docs/ru/advanced/multi-host-setup.html",
    "title": "Несколько прослушивающих хостов на сервере | Sisk",
    "keywords": "Несколько прослушивающих хостов на сервере Фреймворк Sisk всегда поддерживал использование более одного хоста на сервер, то есть один HTTP-сервер может прослушивать несколько портов, и каждый порт имеет свой собственный маршрутизатор и свою службу, работающую на нем. Таким образом, легко разделить обязанности и управлять службами на одном HTTP-сервере с помощью Sisk. Пример ниже показывает создание двух прослушивающих хостов, каждый из которых прослушивает разный порт, с разными маршрутизаторами и действиями. Прочитайте создание приложения вручную, чтобы понять детали об этом абстрактном классе. static void Main(string[] args) { // создаем два прослушивающих хоста, каждый из которых имеет свой собственный маршрутизатор и // прослушивает свой собственный порт // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста А!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста Б!\")); // создаем конфигурацию сервера и добавляем оба // прослушивающих хоста в нее // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // создаем HTTP-сервер, который использует указанную // конфигурацию // HttpServer server = new HttpServer(configuration); // запускаем сервер server.Start(); Console.WriteLine(\"Попробуйте обратиться к хосту А по адресу {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Попробуйте обратиться к хосту Б по адресу {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/ru/advanced/request-lifecycle.html": {
    "href": "docs/ru/advanced/request-lifecycle.html",
    "title": "Жизненный цикл запроса | Sisk",
    "keywords": "Жизненный цикл запроса Эта диаграмма объясняет процесс жизни HTTP-запроса с момента его прибытия на сервер до доставки его клиенту."
  },
  "docs/ru/changelogs.html": {
    "href": "docs/ru/changelogs.html",
    "title": "Журнал изменений | Sisk",
    "keywords": "Журнал изменений Каждое изменение, внесенное в Sisk, записывается в журнал изменений. Вы можете просмотреть журналы изменений для всех версий Sisk здесь."
  },
  "docs/ru/deploying.html": {
    "href": "docs/ru/deploying.html",
    "title": "Развертывание вашего приложения Sisk | Sisk",
    "keywords": "Развертывание вашего приложения Sisk Процесс развертывания приложения Sisk состоит в том, чтобы опубликовать ваш проект в производстве. Хотя процесс относительно прост, стоит отметить детали, которые могут быть опасны для безопасности и стабильности инфраструктуры развертывания. Идеально, вы должны быть готовы развернуть ваше приложение в облаке после проведения всех возможных тестов, чтобы ваше приложение было готово. Публикация вашего приложения Публикация вашего приложения Sisk или сервиса заключается в генерации бинарных файлов, готовых и оптимизированных для производства. В этом примере мы скомпилируем бинарные файлы для производства, чтобы они могли работать на машине, на которой установлен .NET Runtime. Вам понадобится .NET SDK, установленный на вашей машине, чтобы построить ваше приложение, и .NET Runtime, установленный на целевом сервере, чтобы запустить ваше приложение. Вы можете узнать, как установить .NET Runtime на вашем Linux-сервере здесь, Windows и Mac OS. В папке, где находится ваш проект, откройте терминал и используйте команду .NET publish: $ dotnet publish -r linux-x64 -c Release Это сгенерирует ваши бинарные файлы внутри bin/Release/publish/linux-x64. Note Если ваше приложение запускается с помощью пакета Sisk.ServiceProvider, вы должны скопировать ваш service-config.json на ваш хост-сервер вместе со всеми бинарными файлами, сгенерированными командой dotnet publish. Вы можете оставить файл предварительно настроенным, с переменными окружения, портами и хостами, а также дополнительными настройками сервера. Следующий шаг - перенести эти файлы на сервер, где будет размещено ваше приложение. После этого, дайте права на выполнение вашему бинарному файлу. В этом случае давайте рассмотрим, что наш проект называется \"my-app\": $ cd /home/htdocs $ chmod +x my-app $ ./my-app После запуска вашего приложения, проверьте, не выдает ли оно какие-либо сообщения об ошибках. Если оно не выдало, это означает, что ваше приложение работает. На этом этапе, скорее всего, не будет возможно получить доступ к вашему приложению из внешней сети, поскольку правила доступа, такие как брандмауэр, не настроены. Мы рассмотрим это в следующих шагах. У вас должна быть адрес виртуального хоста, на котором слушает ваше приложение. Это устанавливается вручную в приложении и зависит от того, как вы создаете экземпляр вашего сервиса Sisk. Если вы не используете пакет Sisk.ServiceProvider, вы должны найти его там, где вы определили экземпляр вашего HttpServer: HttpServer server = HttpServer.Emit(5000, out HttpServerConfiguration config, out var host, out var router); // sisk должен слушать на http://localhost:5000/ Присвоение ListeningHost вручную: config.ListeningHosts.Add(new ListeningHost(\"https://localhost:5000/\", router)); Или если вы используете пакет Sisk.ServiceProvider, в вашем service-config.json: { \"Server\": { }, \"ListeningHost\": { \"Ports\": [ \"http://localhost:5000/\" ] } } Из этого мы можем создать обратный прокси, чтобы слушать ваш сервис и сделать трафик доступным по открытой сети. Проксирование вашего приложения Проксирование вашего сервиса означает, что вы не直接 подвергаете ваш сервис Sisk внешней сети. Эта практика очень распространена для серверных развертываний, потому что: Позволяет присвоить сертификат SSL в вашем приложении; Создать правила доступа перед доступом к сервису и избежать перегрузок; Контролировать пропускную способность и ограничения запросов; Отделить балансировщики нагрузки для вашего приложения; Предотвратить повреждение безопасности из-за неисправной инфраструктуры. Вы можете обслуживать ваше приложение через обратный прокси, такой как Nginx или Apache, или вы можете использовать туннель http-over-dns, такой как Cloudflared. Также помните, что необходимо правильно разрешить заголовки прокси для получения информации о клиенте, такой как IP-адрес и хост, через forwarding resolvers. Следующий шаг после создания туннеля, настройки брандмауэра и запуска вашего приложения - создать сервис для вашего приложения. Note Использование сертификатов SSL напрямую в сервисе Sisk на не-Windows системах невозможно. Это связано с реализацией HttpListener, который является центральным модулем для управления очередью HTTP в Sisk, и эта реализация варьируется от операционной системы к операционной системе. Вы можете использовать SSL в вашем сервисе Sisk, если присвоите сертификат виртуальному хосту с помощью IIS. Для других систем использование обратного прокси высоко рекомендуется. Создание сервиса Создание сервиса сделает ваше приложение всегда доступным, даже после перезапуска вашего сервера или неисправной ошибки. В этом простом учебнике мы будем использовать содержимое из предыдущего учебника в качестве примера, чтобы ваш сервис всегда был активен. Получите доступ к папке, где находятся файлы конфигурации сервиса: cd /etc/systemd/system Создайте файл my-app.service и включите содержимое: my-app.service INI [Unit] Description=<описание вашего приложения> [Service] # задайте пользователя, который будет запускать сервис User=<пользователь, который будет запускать сервис> # путь к ExecStart не относителен к WorkingDirectory. # задайте его как полный путь к исполняемому файлу WorkingDirectory=/home/htdocs ExecStart=/home/htdocs/my-app # задайте сервис для перезапуска после краха Restart=always RestartSec=3 [Install] WantedBy=multi-user.target Перезапустите модуль сервиса: $ sudo systemctl daemon-reload Запустите созданный сервис с именем файла, который вы задали, и проверьте, запущен ли он: $ sudo systemctl start my-app $ sudo systemctl status my-app Теперь, если ваше приложение запущено (\"Active: active\"), включите сервис, чтобы он запускался после перезапуска системы: $ sudo systemctl enable my-app Теперь вы готовы представить ваше приложение Sisk всем."
  },
  "docs/ru/es/advanced/forwarding-resolvers.html": {
    "href": "docs/ru/es/advanced/forwarding-resolvers.html",
    "title": "Резолверы Перенаправления | Sisk",
    "keywords": "Резолверы Перенаправления Резолвер перенаправления - это помощник, который помогает декодировать информацию, идентифицирующую клиента, через запрос, прокси, CDN или балансировщик нагрузки. Когда ваш сервис Sisk запускается через обратный прокси или прямой прокси, адрес IP клиента, хост и протокол могут быть khácными от исходного запроса, поскольку это перенаправление из одного сервиса в другой. Эта функциональность Sisk позволяет контролировать и решать эту информацию до работы с запросом. Эти прокси обычно предоставляют полезные заголовки для идентификации вашего клиента. В настоящее время, с классом ForwardingResolver, возможно решить адрес IP клиента, хост и протокол HTTP, используемый. После версии 1.0 Sisk сервер больше не имеет стандартной реализации для декодирования этих заголовков по причинам безопасности, которые варьируются от сервиса к сервису. Например, заголовок X-Forwarded-For включает информацию о адресах IP, которые перенаправили запрос. Этот заголовок используется для передачи цепочки информации конечному сервису и включает адрес IP всех использованных прокси, включая реальный адрес клиента. Проблема в том, что иногда бывает трудно идентифицировать удаленный адрес IP клиента, и нет конкретного правила для идентификации этого заголовка. Рекомендуется внимательно прочитать документацию о заголовках, которые будут реализованы: Прочитайте о заголовке X-Forwarded-For здесь. Прочитайте о заголовке X-Forwarded-Host здесь. Прочитайте о заголовке X-Forwarded-Proto здесь. Класс ForwardingResolver Этот класс имеет три виртуальных метода, которые позволяют реализовать наиболее подходящую реализацию для каждого сервиса. Каждый метод отвечает за решение информации запроса через прокси: адрес IP клиента, хост запроса и протокол безопасности, используемый. По умолчанию Sisk всегда будет использовать информацию исходного запроса, не решая никаких заголовков. Пример ниже показывает, как можно использовать эту реализацию. Этот пример решает адрес IP клиента через заголовок X-Forwarded-For и генерирует ошибку, когда в запросе перенаправляются более одной адреса IP. Important Не используйте этот пример в коде производства. Всегда проверяйте, является ли реализация подходящей для вашего использования. Прочитайте документацию заголовка перед его реализацией. class Program { static void Main(string[] args) { using var host = HttpServer.CreateBuilder() .UseForwardingResolver<Resolver>() .UseListeningPort(5555) .Build(); host.Router.SetRoute(RouteMethod.Any, Route.AnyPath, request => new HttpResponse(\"Hello, world!!!\")); host.Start(); } class Resolver : ForwardingResolver { public override IPAddress OnResolveClientAddress(HttpRequest request, IPEndPoint connectingEndpoint) { string? forwardedFor = request.Headers.XForwardedFor; if (forwardedFor is null) { throw new Exception(\"Заголовок X-Forwarded-For отсутствует.\"); } string[] ipAddresses = forwardedFor.Split(','); if (ipAddresses.Length != 1) { throw new Exception(\"Слишком много адресов в заголовке X-Forwarded-For.\"); } return IPAddress.Parse(ipAddresses[0]); } } }"
  },
  "docs/ru/es/advanced/http-server-handlers.html": {
    "href": "docs/ru/es/advanced/http-server-handlers.html",
    "title": "Обработчики сервера HTTP | Sisk",
    "keywords": "Обработчики сервера HTTP В Sisk версии 0.16, мы ввели класс HttpServerHandler, целью которого является расширение общего поведения Sisk и предоставление дополнительных обработчиков событий для Sisk, таких как обработка HTTP-запросов, маршрутизация, контекстные сумки и многое другое. Этот класс концентрирует события, которые происходят во время жизненного цикла всего HTTP-сервера и отдельного запроса. Протокол HTTP не имеет сессий, и поэтому невозможно сохранять информацию от одного запроса к другому. Sisk предоставляет на данный момент способ реализации сессий, контекстов, подключений к базе данных и других полезных провайдеров, чтобы помочь в вашей работе. Пожалуйста, ознакомьтесь с этой страницей, чтобы узнать, где срабатывает каждое событие и какова его цель. Также вы можете ознакомиться с жизненным циклом HTTP-запроса, чтобы понять, что происходит с запросом и где срабатывают события. HTTP-сервер позволяет использовать несколько обработчиков одновременно. Каждый вызов события является синхронным, то есть блокирует текущий поток для каждого запроса или контекста до тех пор, пока все связанные с ним обработчики не будут выполнены и завершены. В отличие от обработчиков запросов, их нельзя применять к группам маршрутов или конкретным маршрутам. Вместо этого они применяются ко всему HTTP-серверу. Вы можете применять условия внутри своего обработчика сервера HTTP. Кроме того, определяются синглтоны для каждого HttpServerHandler для каждой приложения Sisk, поэтому определяется только одна инстанция для HttpServerHandler. Практический пример использования HttpServerHandler — автоматическое удаление подключения к базе данных в конце запроса. // DatabaseConnectionHandler.cs public class DatabaseConnectionHandler : HttpServerHandler { public override void OnHttpRequestClose(HttpServerExecutionResult result) { var requestBag = result.Request.Context.RequestBag; // проверяет, определено ли в контексте запроса DbContext if (requestBag.IsSet<DbContext>()) { var db = requestBag.Get<DbContext>(); db.Dispose(); } } } public static class DatabaseConnectionHandlerExtensions { // позволяет пользователю создать контекст базы данных из HTTP-запроса // и сохранить его в контекстной сумке public static DbContext GetDbContext(this HttpRequest request) { var db = new DbContext(); return request.SetContextBag<DbContext>(db); } } С помощью приведенного выше кода, расширение GetDbContext позволяет создать контекст подключения直接 из объекта HttpRequest. Неразорванное подключение может вызвать проблемы при работе с базой данных, поэтому оно завершается в OnHttpRequestClose. Вы можете зарегистрировать обработчик в HTTP-сервере в его конструкторе или直接 с помощью HttpServer.RegisterHandler. // Program.cs class Program { static void Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseHandler<DatabaseConnectionHandler>() .Build(); app.Router.SetObject(new UserController()); app.Start(); } } С этим, класс UsersController может использовать контекст базы данных следующим образом: // UserController.cs [RoutePrefix(\"/users\")] public class UserController : ApiController { [RouteGet()] public async Task<HttpResponse> List(HttpRequest request) { var db = request.GetDbContext(); var users = db.Users.ToArray(); return JsonOk(users); } [RouteGet(\"<id>\")] public async Task<HttpResponse> View(HttpRequest request) { var db = request.GetDbContext(); var userId = request.GetQueryValue<int>(\"id\"); var user = db.Users.FirstOrDefault(u => u.Id == userId); return JsonOk(user); } [RoutePost] public async Task<HttpResponse> Create(HttpRequest request) { var db = request.GetDbContext(); var user = JsonSerializer.Deserialize<User>(request.Body); ArgumentNullException.ThrowIfNull(user); db.Users.Add(user); await db.SaveChangesAsync(); return JsonMessage(\"Пользователь добавлен.\"); } } Приведенный выше код использует методы, такие как JsonOk и JsonMessage, которые интегрированы в ApiController, который наследует от RouterController: // ApiController.cs public class ApiController : RouterModule { public HttpResponse JsonOk(object value) { return new HttpResponse(200) .WithContent(JsonContent.Create(value, null, new JsonSerializerOptions() { PropertyNameCaseInsensitive = true })); } public HttpResponse JsonMessage(string message, int statusCode = 200) { return new HttpResponse(statusCode) .WithContent(JsonContent.Create(new { Message = message })); } } Разработчики могут реализовать сессии, контексты и подключения к базе данных, используя этот класс. Приведенный выше код демонстрирует практический пример с DatabaseConnectionHandler, автоматизирующий удаление подключения к базе данных в конце каждого запроса. Интеграция проста, с обработчиками, зарегистрированными во время настройки сервера. Класс HttpServerHandler предлагает набор мощных инструментов для управления ресурсами и расширения поведения Sisk в HTTP-приложениях."
  },
  "docs/ru/es/advanced/manual-setup.html": {
    "href": "docs/ru/es/advanced/manual-setup.html",
    "title": "Ручная настройка (продвинутая) | Sisk",
    "keywords": "Ручная настройка (продвинутая) В этом разделе мы создадим наш сервер HTTP без использования каких-либо предварительно определенных стандартов, совершенно абстрактным способом. Здесь вы можете вручную настроить, как будет работать ваш сервер HTTP. Каждый ListeningHost имеет маршрутизатор, и сервер HTTP может иметь несколько ListeningHosts, каждый из которых указывает на разный хост на разном порту. Сначала нам нужно понять концепцию запрос/ответ. Это довольно просто: на каждый запрос должен быть ответ. Sisk также следует этому принципу. Мы создаем метод, который отвечает сообщением \"Привет, мир!\" в HTML, указывая код состояния и заголовки. // Program.cs using Sisk.Core.Http; using Sisk.Core.Routing; static HttpResponse IndexPage(HttpRequest request) { HttpResponse indexResponse = new HttpResponse { Status = System.Net.HttpStatusCode.OK, Content = new HtmlContent(@\" <html> <body> <h1>Привет, мир!</h1> </body> </html> \") }; return indexResponse; } Следующий шаг - связать этот метод с маршрутом HTTP. Маршрутизаторы Маршрутизаторы являются абстракциями маршрутов запросов и служат мостом между запросами и ответами для службы. Маршрутизаторы управляют маршрутами службы, функциями и ошибками. Маршрутизатор может иметь несколько маршрутов, и каждый маршрут может выполнять различные операции на этом маршруте, такие как выполнение функции, обслуживание страницы или предоставление ресурса с сервера. Мы создаем наш первый маршрутизатор и связываем наш метод IndexPage с маршрутом индекса. Router mainRouter = new Router(); // SetRoute связывает все маршруты индекса с нашим методом. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage); Теперь наш маршрутизатор может получать запросы и отправлять ответы. Однако mainRouter не связан с хостом или сервером, поэтому он не будет работать самостоятельно. Следующий шаг - создать наш ListeningHost. Хосты и порты прослушивания ListeningHost может размещать маршрутизатор и несколько портов прослушивания для одного и того же маршрутизатора. ListeningPort является префиксом, где сервер HTTP будет прослушивать. Здесь мы можем создать ListeningHost, который указывает на два конца для нашего маршрутизатора: ListeningHost myHost = new ListeningHost { Router = new Router(), Ports = new ListeningPort[] { new ListeningPort(\"http://localhost:5000/\") } }; Теперь наш сервер HTTP будет прослушивать указанные концы и перенаправлять свои запросы на наш маршрутизатор. Настройка сервера Настройка сервера отвечает за большинство поведения сервера HTTP сам по себе. В этой настройке мы можем связать ListeningHosts с нашим сервером. HttpServerConfiguration config = new HttpServerConfiguration(); config.ListeningHosts.Add(myHost); // Добавьте наш ListeningHost в эту настройку сервера Далее мы можем создать наш сервер HTTP: HttpServer server = new HttpServer(config); server.Start(); // Запускает сервер Console.ReadKey(); // Предотвращает закрытие приложения Теперь мы можем скомпилировать наш исполняемый файл и запустить наш сервер HTTP с помощью команды: dotnet watch В время выполнения откройте свой браузер и перейдите по маршруту сервера, и вы должны увидеть:"
  },
  "docs/ru/es/advanced/multi-host-setup.html": {
    "href": "docs/ru/es/advanced/multi-host-setup.html",
    "title": "Несколько хостов для прослушивания на сервере | Sisk",
    "keywords": "Несколько хостов для прослушивания на сервере Фреймворк Sisk всегда поддерживал использование нескольких хостов на сервере, то есть один сервер HTTP может прослушивать на нескольких портах, и каждый порт имеет свой собственный маршрутизатор и свой собственный сервис в исполнении. Таким образом, легко разделить обязанности и управлять сервисами на одном сервере HTTP с помощью Sisk. Пример ниже показывает создание двух ListeningHosts, каждый из которых прослушивает на разных портах, с разными маршрутизаторами и действиями. Прочитайте создание приложения вручную, чтобы понять детали об этой абстракции. static void Main(string[] args) { // создает два хоста для прослушивания, каждый со своим собственным маршрутизатором и // прослушивающий на своем собственном порту // ListeningHost hostA = new ListeningHost(); hostA.Ports = [new ListeningPort(12000)]; hostA.Router = new Router(); hostA.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста А!\")); ListeningHost hostB = new ListeningHost(); hostB.Ports = [new ListeningPort(12001)]; hostB.Router = new Router(); hostB.Router.SetRoute(RouteMethod.Get, \"/\", request => new HttpResponse().WithContent(\"Привет от хоста Б!\")); // создает конфигурацию сервера и добавляет оба хоста для прослушивания // HttpServerConfiguration configuration = new HttpServerConfiguration(); configuration.ListeningHosts.Add(hostA); configuration.ListeningHosts.Add(hostB); // создает сервер HTTP, который использует указанную конфигурацию // HttpServer server = new HttpServer(configuration); // запускает сервер server.Start(); Console.WriteLine(\"Попробуйте обратиться к хосту А по {0}\", server.ListeningPrefixes[0]); Console.WriteLine(\"Попробуйте обратиться к хосту Б по {0}\", server.ListeningPrefixes[1]); Thread.Sleep(-1); }"
  },
  "docs/ru/es/advanced/request-lifecycle.html": {
    "href": "docs/ru/es/advanced/request-lifecycle.html",
    "title": "Жизненный цикл запроса | Sisk",
    "keywords": "Жизненный цикл запроса Эта диаграмма объясняет процесс жизни запроса HTTP с момента его поступления на сервер до доставки клиенту."
  },
  "docs/ru/es/changelogs.html": {
    "href": "docs/ru/es/changelogs.html",
    "title": "Журнал изменений | Sisk",
    "keywords": "Журнал изменений Каждое изменение, внесенное в Sisk, регистрируется через журнал изменений. Вы можете просмотреть журнал изменений для всех версий Sisk здесь."
  },
  "docs/ru/extensions/basic-auth.html": {
    "href": "docs/ru/extensions/basic-auth.html",
    "title": "Базовая Аутентификация | Sisk",
    "keywords": "Базовая Аутентификация Пакет Basic Auth добавляет обработчик запросов, способный обрабатывать базовую схему аутентификации в вашем приложении Sisk с минимальной конфигурацией и усилиями. Базовая аутентификация HTTP - это минимальная форма аутентификации запросов по идентификатору пользователя и паролю, где сессия контролируется исключительно клиентом, и нет аутентификационных или доступных токенов. Читайте больше о схеме базовой аутентификации в спецификации MDN. Установка Чтобы начать, установите пакет Sisk.BasicAuth в вашем проекте: > dotnet add package Sisk.BasicAuth Вы можете просмотреть больше способов установки его в вашем проекте в репозитории Nuget. Создание обработчика аутентификации Вы можете контролировать схему аутентификации для всего модуля или для отдельных маршрутов. Для этого давайте сначала напишем наш первый базовый обработчик аутентификации. В примере ниже устанавливается соединение с базой данных, проверяется, существует ли пользователь и является ли пароль действительным, и после этого хранит пользователя в контексте. public class UserAuthHandler : BasicAuthenticateRequestHandler { public UserAuthHandler() : base() { Realm = \"Чтобы войти на эту страницу, пожалуйста, введите ваши учетные данные.\"; } public override HttpResponse? OnValidating(BasicAuthenticationCredentials credentials, HttpContext context) { DbContext db = new DbContext(); // в этом случае мы используем электронную почту в качестве идентификатора пользователя, поэтому мы // ищем пользователя по его электронной почте. User? user = db.Users.FirstOrDefault(u => u.Email == credentials.UserId); if (user == null) { return base.CreateUnauthorizedResponse(\"Извините! Пользователь с таким электронным адресом не найден.\"); } // проверяет, что пароль учетных данных действителен для этого пользователя. if (!user.ValidatePassword(credentials.Password)) { return base.CreateUnauthorizedResponse(\"Недействительные учетные данные.\"); } // добавляет вошедшего пользователя в контекст HTTP // и продолжает выполнение context.Bag.Add(\"loggedUser\", user); return null; } } Итак, просто ассоциируйте этот обработчик запросов с нашим маршрутом или классом. public class UsersController { [RouteGet(\"/\")] [RequestHandler(typeof(UserAuthHandler))] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Привет, \" + loggedUser.Name + \"!\"; } } Или используя класс RouterModule: public class UsersController : RouterModule { public ClientModule() { // теперь все маршруты внутри этого класса будут обрабатываться // UserAuthHandler. base.HasRequestHandler(new UserAuthHandler()); } [RouteGet(\"/\")] public string Index(HttpRequest request) { User loggedUser = (User)request.Context.RequestBag[\"loggedUser\"]; return \"Привет, \" + loggedUser.Name + \"!\"; } } Примечания Основная ответственность базовой аутентификации лежит на клиентской стороне. Хранение, кэширование и шифрование обрабатываются локально на клиенте. Сервер получает только учетные данные и проверяет, разрешен ли доступ или нет. Обратите внимание, что этот метод не является одним из самых безопасных, поскольку он возлагает значительную ответственность на клиента, что может быть трудно отслеживать и поддерживать безопасность его учетных данных. Кроме того, важно передавать пароли в безопасном контексте соединения (SSL), поскольку они не имеют встроенного шифрования. Короткий перехват в заголовках запроса может раскрыть учетные данные доступа вашего пользователя. Выбирайте более надежные решения аутентификации для приложений в производстве и избегайте использования слишком многих готовых компонентов, поскольку они могут не адаптироваться к потребностям вашего проекта и в конечном итоге подвергать его риску безопасности."
  },
  "docs/ru/extensions/ini-configuration.html": {
    "href": "docs/ru/extensions/ini-configuration.html",
    "title": "Провайдер конфигурации INI | Sisk",
    "keywords": "Провайдер конфигурации INI Sisk имеет метод для получения конфигураций запуска, отличных от JSON. На самом деле, любой конвейер, реализующий IConfigurationReader, может быть использован с PortableConfigurationBuilder.WithConfigurationPipeline, читая конфигурацию сервера из любого типа файла. Пакет Sisk.IniConfiguration предоставляет потоковый читатель файлов INI, который не выбрасывает исключения для обычных синтаксических ошибок и имеет простой синтаксис конфигурации. Этот пакет можно использовать вне рамок фреймворка Sisk, предлагая гибкость для проектов, требующих эффективного считывателя документов INI. Установка Чтобы установить пакет, можно начать с: $ dotnet add package Sisk.IniConfiguration Также можно установить основной пакет, который не включает в себя INI IConfigurationReader, ни зависимость от Sisk, только сериализаторы INI: $ dotnet add package Sisk.IniConfiguration.Core С основным пакетом можно использовать его в коде, как показано в примере ниже: class Program { static HttpServerHostContext Host = null!; static void Main(string[] args) { Host = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"app.ini\", createIfDontExists: true); // использует конфигурационный читатель IniConfigurationReader config.WithConfigurationPipeline<IniConfigurationReader>(); }) .UseRouter(r => { r.MapGet(\"/\", SayHello); }) .Build(); Host.Start(); } static HttpResponse SayHello(HttpRequest request) { string? name = Host.Parameters[\"name\"] ?? \"world\"; return new HttpResponse($\"Hello, {name}!\"); } } Код выше будет искать файл app.ini в текущем каталоге процесса (CurrentDirectory). Файл INI выглядит так: [Server] # Множественные адреса прослушивания поддерживаются Listen = http://localhost:5552/ Listen = http://localhost:5553/ ThrowExceptions = false AccessLogsStream = console [Cors] AllowMethods = GET, POST AllowHeaders = Content-Type, Authorization AllowOrigin = * [Parameters] Name = \"Kanye West\" Вкус и синтаксис INI Текущая реализация вкуса: Имена свойств и секций не чувствительны к регистру. Имена свойств и значения обрезаются, если значения не заключены в кавычки. Значения можно заключать в одинарные или двойные кавычки. Кавычки могут содержать переносы строк внутри себя. Комментарии поддерживаются с помощью # и ;. Также допускаются конечные комментарии. Свойства могут иметь несколько значений. Подробнее, документация для \"вкуса\" парсера INI, используемого в Sisk, доступна в этом документе. Используя следующий код INI в качестве примера: One = 1 Value = это значение Another value = \"это значение имеет перенос строки на нем\" ; код ниже имеет некоторые цвета [some section] Color = Red Color = Blue Color = Yellow ; не используйте желтый Парсить его с помощью: // парсить текст INI из строки IniDocument doc = IniDocument.FromString(iniText); // получить одно значение string? one = doc.Global.GetOne(\"one\"); string? anotherValue = doc.Global.GetOne(\"another value\"); // получить несколько значений string[]? colors = doc.GetSection(\"some section\")?.GetMany(\"color\"); Параметры конфигурации Секция и имя Разрешить несколько значений Описание Server.Listen Да Адреса и порты прослушивания сервера. Server.Encoding Нет Кодировка сервера по умолчанию. Server.MaximumContentLength Нет Максимальный размер содержимого в байтах. Server.IncludeRequestIdHeader Нет Указывает, должен ли HTTP-сервер отправлять заголовок X-Request-Id. Server.ThrowExceptions Нет Указывает, должны ли быть выброшены необработанные исключения. Server.AccessLogsStream Нет Указывает поток вывода журнала доступа. Server.ErrorsLogsStream Нет Указывает поток вывода журнала ошибок. Cors.AllowMethods Нет Указывает значение заголовка CORS Allow-Methods. Cors.AllowHeaders Нет Указывает значение заголовка CORS Allow-Headers. Cors.AllowOrigins Нет Указывает несколько заголовков Allow-Origin, разделенных запятыми. AllowOrigins для более подробной информации. Cors.AllowOrigin Нет Указывает один заголовок Allow-Origin. Cors.ExposeHeaders Нет Указывает значение заголовка CORS Expose-Headers. Cors.AllowCredentials Нет Указывает значение заголовка CORS Allow-Credentials. Cors.MaxAge Нет Указывает значение заголовка CORS Max-Age."
  },
  "docs/ru/extensions/json-rpc.html": {
    "href": "docs/ru/extensions/json-rpc.html",
    "title": "Расширение JSON-RPC | Sisk",
    "keywords": "Расширение JSON-RPC Sisk имеет экспериментальный модуль для API JSON-RPC 2.0, который позволяет создавать еще более простые приложения. Это расширение строго реализует транспортный интерфейс JSON-RPC 2.0 и предлагает транспорт через HTTP GET, POST-запросы и также веб-сокеты с Sisk. Вы можете установить расширение через Nuget с помощью команды ниже. Обратите внимание, что в экспериментальных/бета-версиях необходимо включить опцию поиска предварительных пакетов в Visual Studio. dotnet add package Sisk.JsonRpc Транспортный Интерфейс JSON-RPC - это бесстаточный, асинхронный протокол удаленного выполнения процедур (RDP), который использует JSON для односторонней передачи данных. Запрос JSON-RPC обычно идентифицируется по ID, и ответ доставляется с тем же ID, который был отправлен в запросе. Не все запросы требуют ответа, которые называются \"уведомлениями\". Спецификация JSON-RPC 2.0 подробно объясняет, как работает транспорт. Этот транспорт независим от того, где он будет использоваться. Sisk реализует этот протокол через HTTP, следуя соответствиям JSON-RPC over HTTP, который частично поддерживает GET-запросы, но полностью поддерживает POST-запросы. Также поддерживаются веб-сокеты, которые обеспечивают асинхронную передачу сообщений. Запрос JSON-RPC выглядит примерно так: { \"jsonrpc\": \"2.0\", \"method\": \"Sum\", \"params\": [1, 2, 4], \"id\": 1 } И успешный ответ выглядит примерно так: { \"jsonrpc\": \"2.0\", \"result\": 7, \"id\": 1 } Методы JSON-RPC Следующий пример показывает, как создать API JSON-RPC с помощью Sisk. Класс математических операций выполняет удаленные операции и доставляет сериализированный ответ клиенту. Program.cs C# using var app = HttpServer.CreateBuilder(port: 5555) .UseJsonRPC((sender, args) => { // добавляет все методы, помеченные как WebMethod, в обработчик JSON-RPC args.Handler.Methods.AddMethodsFromType(new MathOperations()); // сопоставляет маршрут /service с обработчиком JSON-RPC POST и GET-запросов args.Router.MapPost(\"/service\", args.Handler.Transport.HttpPost); args.Router.MapGet(\"/service\", args.Handler.Transport.HttpGet); // создает обработчик веб-сокета на GET /ws args.Router.MapGet(\"/ws\", request => { var ws = request.GetWebSocket(); ws.OnReceive += args.Handler.Transport.WebSocket; ws.WaitForClose(timeout: TimeSpan.FromSeconds(30)); return ws.Close(); }); }) .Build(); await app.StartAsync(); MathOperations.cs C# public class MathOperations { [WebMethod] public float Sum(float a, float b) { return a + b; } [WebMethod] public double Sqrt(float a) { return Math.Sqrt(a); } } Вышеуказанный пример сопоставит методы Sum и Sqrt с обработчиком JSON-RPC, и эти методы будут доступны по адресам GET /service, POST /service и GET /ws. Имена методов регистронезависимы. Параметры методов автоматически десериализуются в свои конкретные типы. Также поддерживается использование запросов с именованными параметрами. Сериализация JSON выполняется библиотекой LightJson. Если тип не десериализуется правильно, вы можете создать специальный конвертер JSON для этого типа и связать его с вашими JsonSerializerOptions позже. Вы также можете получить объект $.params из запроса JSON-RPC напрямую в вашем методе. MathOperations.cs C# [WebMethod] public float Sum(JsonArray|JsonObject @params) { ... } Для этого @params должен быть единственным параметром в вашем методе, с точным именем params (в C#, символ @ необходим для экранирования этого имени параметра). Десериализация параметров происходит как для именованных объектов, так и для позиционных массивов. Например, следующий метод можно вызвать удаленно как с помощью запроса с именованными параметрами, так и с помощью запроса с позиционными параметрами. [WebMethod] public float AddUserToStore(string apiKey, User user, UserStore store) { ... } Для массива порядок параметров должен быть соблюдён. { \"jsonrpc\": \"2.0\", \"method\": \"AddUserToStore\", \"params\": [ \"1234567890\", { \"name\": \"John Doe\", \"email\": \"john@example.com\" }, { \"name\": \"My Store\" } ], \"id\": 1 } Настройка сериализатора Вы можете настроить сериализатор JSON в свойстве JsonRpcHandler.JsonSerializerOptions. В этом свойстве вы можете включить использование JSON5 для десериализации сообщений. Хотя это не соответствует спецификации JSON-RPC 2.0, JSON5 является расширением JSON, которое позволяет писать более читаемые и понятные данные. Program.cs C# using var host = HttpServer.CreateBuilder ( 5556 ) .UseJsonRPC ( ( o, e ) => { // использует санитизированный компаратор имен. этот компаратор сравнивает только буквы // и цифры в имени, и игнорирует другие символы. например: // foo_bar10 == FooBar10 e.Handler.JsonSerializerOptions.PropertyNameComparer = new JsonSanitizedComparer (); // включает JSON5 для интерпретатора JSON. даже активируя это, обычный JSON все еще поддерживается e.Handler.JsonSerializerOptions.SerializationFlags = LightJson.Serialization.JsonSerializationFlags.Json5; // сопоставляет маршрут POST /service с обработчиком JSON-RPC e.Router.MapPost ( \"/service\", e.Handler.Transport.HttpPost ); } ) .Build (); host.Start ();"
  },
  "docs/ru/extensions/service-providers.html": {
    "href": "docs/ru/extensions/service-providers.html",
    "title": "Поставщики услуг | Sisk",
    "keywords": "Поставщики услуг Поставщики услуг - это способ переноса вашего приложения Sisk в разные среды с помощью переносимого файла конфигурации. Эта функция позволяет изменить порт сервера, параметры и другие настройки без необходимости изменения кода приложения для каждой среды. Этот модуль зависит от синтаксиса конструкции Sisk и может быть настроен с помощью метода UsePortableConfiguration. Поставщик конфигурации реализуется с помощью IConfigurationProvider, который предоставляет читатель конфигурации и может получать любую реализацию. По умолчанию, Sisk предоставляет читатель конфигурации JSON, но также есть пакет для файлов INI. Вы также можете создать свой собственный поставщик конфигурации и зарегистрировать его с помощью: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigReader<MyConfigurationReader>(); }) .Build(); Как упоминалось ранее, поставщик конфигурации по умолчанию - это файл JSON. По умолчанию, имя файла, которое ищется, - это service-config.json, и он ищется в текущем каталоге запускаемого процесса, а не в каталоге исполняемого файла. Вы можете выбрать изменение имени файла, а также указать, где Sisk должен искать файл конфигурации, с помощью: using Sisk.Core.Http; using Sisk.Core.Http.Hosting; using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithConfigFile(\"config.toml\", createIfDontExists: true, lookupDirectories: ConfigurationFileLookupDirectory.CurrentDirectory | ConfigurationFileLookupDirectory.AppDirectory); }) .Build(); Код выше будет искать файл config.toml в текущем каталоге запускаемого процесса. Если файл не найден, он затем будет искать в каталоге, где находится исполняемый файл. Если файл не существует, параметр createIfDontExists будет выполнен, создав файл без содержимого в последнем проверенном пути (на основе lookupDirectories), и будет выдано сообщение об ошибке в консоли, предотвращая инициализацию приложения. Tip Вы можете посмотреть исходный код поставщика конфигурации INI и поставщика конфигурации JSON, чтобы понять, как реализуется IConfigurationProvider. Чтение конфигураций из файла JSON По умолчанию, Sisk предоставляет поставщик конфигурации, который читает конфигурации из файла JSON. Этот файл имеет фиксированную структуру и состоит из следующих параметров: { \"Server\": { \"DefaultEncoding\": \"UTF-8\", \"ThrowExceptions\": true, \"IncludeRequestIdHeader\": true }, \"ListeningHost\": { \"Label\": \"Мое приложение Sisk\", \"Ports\": [ \"http://localhost:80/\", \"https://localhost:443/\", // Файлы конфигурации также поддерживают комментарии ], \"CrossOriginResourceSharingPolicy\": { \"AllowOrigin\": \"*\", \"AllowOrigins\": [ \"*\" ], // новое в 0.14 \"AllowMethods\": [ \"*\" ], \"AllowHeaders\": [ \"*\" ], \"MaxAge\": 3600 }, \"Parameters\": { \"MySqlConnection\": \"server=localhost;user=root;\" } } } Параметры, созданные из файла конфигурации, можно получить в конструкторе сервера: using var app = HttpServer.CreateBuilder() .UsePortableConfiguration(config => { config.WithParameters(paramCollection => { string databaseConnection = paramCollection.GetValueOrThrow(\"MySqlConnection\"); }); }) .Build(); Каждый поставщик конфигурации предоставляет способ чтения параметров инициализации сервера. Некоторые свойства указаны для того, чтобы они находились в процессе окружения вместо того, чтобы быть определены в файле конфигурации, такие как чувствительные данные API, ключи API и т. д. Структура файла конфигурации Файл конфигурации JSON состоит из следующих свойств: Свойство Обязательное Описание Server Требуется Представляет собой сервер с его настройками. Server.AccessLogsStream Необязательно По умолчанию - console. Указывает поток вывода журнала доступа. Может быть именем файла, null или console. Server.ErrorsLogsStream Необязательно По умолчанию - null. Указывает поток вывода журнала ошибок. Может быть именем файла, null или console. Server.MaximumContentLength Необязательно Server.MaximumContentLength Необязательно По умолчанию - 0. Указывает максимальную длину содержимого в байтах. Ноль означает бесконечность. Server.IncludeRequestIdHeader Необязательно По умолчанию - false. Указывает, должен ли HTTP-сервер отправлять заголовок X-Request-Id. Server.ThrowExceptions Необязательно По умолчанию - true. Указывает, должны ли быть выброшены необработанные исключения. Установите значение false при производстве и true при отладке. ListeningHost Требуется Представляет собой хост, на котором слушает сервер. ListeningHost.Label Необязательно Представляет собой метку приложения. ListeningHost.Ports Требуется Представляет собой массив строк, соответствующих синтаксису ListeningPort. ListeningHost.CrossOriginResourceSharingPolicy Необязательно Настройка CORS-заголовков для приложения. ListeningHost.CrossOriginResourceSharingPolicy.AllowCredentials Необязательно По умолчанию - false. Указывает заголовок Allow-Credentials. ListeningHost.CrossOriginResourceSharingPolicy.ExposeHeaders Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Expose-Headers. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigin Необязательно По умолчанию - null. Это свойство ожидает строку. Указывает заголовок Allow-Origin. ListeningHost.CrossOriginResourceSharingPolicy.AllowOrigins Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает несколько заголовков Allow-Origin. См. AllowOrigins для получения дополнительной информации. ListeningHost.CrossOriginResourceSharingPolicy.AllowMethods Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Allow-Methods. ListeningHost.CrossOriginResourceSharingPolicy.AllowHeaders Необязательно По умолчанию - null. Это свойство ожидает массив строк. Указывает заголовок Allow-Headers. ListeningHost.CrossOriginResourceSharingPolicy.MaxAge Необязательно По умолчанию - null. Это свойство ожидает целое число. Указывает заголовок Max-Age в секундах. ListeningHost.Parameters Необязательно Указывает свойства, предоставляемые методу настройки приложения."
  },
  "docs/ru/extensions/ssl-proxy.html": {
    "href": "docs/ru/extensions/ssl-proxy.html",
    "title": "SSL Proxy | Sisk",
    "keywords": "SSL Proxy Warning Эта функция экспериментальная и не должна использоваться в производстве. Пожалуйста, обратитесь к этому документу, если вы хотите сделать Sisk работать с SSL. Sisk SSL Proxy - это модуль, который предоставляет HTTPS-соединение для ListeningHost в Sisk и маршрутизирует HTTPS-сообщения в не安全ный HTTP-контекст. Модуль был создан для предоставления SSL-соединения для службы, которая использует HttpListener для запуска, который не поддерживает SSL. Прокси работает внутри одного и того же приложения и слушает HTTP/1.1-сообщения, пересылая их в том же протоколе в Sisk. В настоящее время эта функция является высокоэкспериментальной и может быть достаточно нестабильной, чтобы не использовать ее в производстве. На данный момент SslProxy поддерживает почти все функции HTTP/1.1, такие как keep-alive, chunked encoding, websockets и т. д. Для открытого соединения с SSL-прокси создается TCP-соединение с целевым сервером, и прокси пересылается на установленное соединение. SslProxy можно использовать с HttpServer.CreateBuilder следующим образом: using var app = HttpServer.CreateBuilder(port: 5555) .UseRouter(r => { r.MapGet(\"/\", request => { return new HttpResponse(\"Hello, world!\"); }); }) // добавление SSL в проект .UseSsl( sslListeningPort: 5567, new X509Certificate2(@\".\\ssl.pfx\", password: \"12345\") ) .Build(); app.Start(); Вам необходимо предоставить действительный SSL-сертификат для прокси. Чтобы обеспечить принятие сертификата браузерами, не забудьте импортировать его в операционную систему, чтобы он функционировал правильно."
  },
  "docs/ru/features/discard-syntax.html": {
    "href": "docs/ru/features/discard-syntax.html",
    "title": "Синтаксис Discard | Sisk",
    "keywords": "Синтаксис Discard Веб-сервер HTTP можно использовать для прослушивания запроса обратного вызова из действия, такого как аутентификация OAuth, и можно отбросить после получения этого запроса. Это может быть полезно в случаях, когда вам нужна фоновое действие, но вы не хотите настраивать整个 веб-приложение для этого. Следующий пример показывает, как создать прослушивающий HTTP-сервер на порту 5555 с помощью CreateListener и ожидать следующий контекст: using (var server = HttpServer.CreateListener(5555)) { // ожидать следующий HTTP-запрос var context = await server.WaitNextAsync(); Console.WriteLine($\"Запрошенный путь: {context.Request.Path}\"); } Функция WaitNext ожидает следующий контекст завершенной обработки запроса. Как только получен результат этой операции, сервер уже полностью обработал запрос и отправил ответ клиенту."
  },
  "docs/ru/features/instancing.html": {
    "href": "docs/ru/features/instancing.html",
    "title": "Внедрение зависимостей | Sisk",
    "keywords": "Внедрение зависимостей Обычно выделяют члены и экземпляры, которые существуют в течение всего времени жизни запроса, такие как соединение с базой данных, аутентифицированный пользователь или токен сессии. Одним из возможностей является использование HttpContext.RequestBag, который создает словарь, существующий в течение всего времени жизни запроса. Этот словарь можно получить у обработчиков запросов и определить переменные на протяжении всего запроса. Например, обработчик запроса, который аутентифицирует пользователя, устанавливает этого пользователя в HttpContext.RequestBag, и в логике запроса этот пользователь можно получить с помощью HttpContext.RequestBag.Get<User>(). Вот пример: RequestHandlers/AuthenticateUser.cs C# public class AuthenticateUser : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { User authenticatedUser = AuthenticateUser(request); context.RequestBag.Set(authenticatedUser); return null; // advance to the next request handler or request logic } } Controllers/HelloController.cs C# [RouteGet(\"/hello\")] [RequestHandler<AuthenticateUser>] public static HttpResponse SayHello(HttpRequest request) { var authenticatedUser = request.Bag.Get<User>(); return new HttpResponse() { Content = new StringContent($\"Hello {authenticatedUser.Name}!\") }; } Это предварительный пример этой операции. Экземпляр User был создан в обработчике запроса, посвященном аутентификации, и все маршруты, которые используют этот обработчик запроса, будут иметь гарантию, что в их экземпляре HttpContext.RequestBag будет User. Возможно определить логику получения экземпляров, когда они не были предварительно определены в RequestBag, через методы типа GetOrAdd или GetOrAddAsync. С версии 1.3 был введен статический свойство HttpContext.Current, которое позволяет получить доступ к текущему контексту запроса. Это позволяет экспонировать члены HttpContext вне текущего запроса и определять экземпляры в объектах маршрутов. Пример ниже определяет контроллер, который имеет члены, обычно доступные контекстом запроса. Controllers/Controller.cs C# public abstract class Controller : RouterModule { public DbContext Database { get { // создать DbContext или получить существующий return HttpContext.Current.RequestBag.GetOrAdd(() => new DbContext()); } } // следующая строка выдаст исключение, если свойство доступно, когда User не // определен в пакете запроса public User AuthenticatedUser { get => HttpContext.Current.RequestBag.Get<User>(); } // экспонирование экземпляра HttpRequest также поддерживается public HttpRequest Request { get => HttpContext.Current.Request; } } И определить типы, которые наследуются от контроллера: Controllers/PostsController.cs C# [RoutePrefix(\"/api/posts\")] public class PostsController : Controller { [RouteGet] public IEnumerable<Blog> ListPosts() { return Database.Posts .Where(post => post.AuthorId == AuthenticatedUser.Id) .ToList(); } [RouteGet(\"<id>\")] public Post GetPost() { int blogId = Request.RouteParameters[\"id\"].GetInteger(); Post? post = Database.Posts .FirstOrDefault(post => post.Id == blogId && post.AuthorId == AuthenticatedUser.Id); return post ?? new HttpResponse(404); } } Для примера выше вам необходимо настроить обработчик значения в вашем маршрутизаторе, чтобы объекты, возвращаемые маршрутизатором, были преобразованы в допустимый HttpResponse. Обратите внимание, что методы не имеют аргумента HttpRequest request, как это присутствует в других методах. Это связано с тем, что с версии 1.3 маршрутизатор поддерживает два типа делегатов для маршрутизации ответов: RouteAction, который является делегатом по умолчанию, получающим аргумент HttpRequest, и ParameterlessRouteAction. Экземпляр HttpRequest все равно можно получить через свойство Request статического HttpContext в потоке. В примере выше мы определили объект, подлежащий удалению, DbContext, и нам необходимо обеспечить, чтобы все экземпляры, созданные в DbContext, были удалены, когда HTTP-сессия завершается. Для этого можно использовать два способа достижения этой цели. Один из них - создать обработчик запроса, который выполняется после действия маршрутизатора, а другой способ - через пользовательский обработчик сервера. Для первого метода можно создать обработчик запроса trực в методе OnSetup, унаследованном от RouterModule: Controllers/PostsController.cs C# public abstract class Controller : RouterModule { ... protected override void OnSetup(Router parentRouter) { base.OnSetup(parentRouter); HasRequestHandler(RequestHandler.Create( execute: (req, ctx) => { // получить один DbContext, определенный в контексте обработчика запроса и // удалить его ctx.RequestBag.GetOrDefault<DbContext>()?.Dispose(); return null; }, executionMode: RequestHandlerExecutionMode.AfterResponse)); } } Tip С версии Sisk 1.4 свойство HttpServerConfiguration.DisposeDisposableContextValues было введено и включено по умолчанию, которое определяет, должен ли HTTP-сервер удалять все значения IDisposable в пакете контекста, когда HTTP-сессия закрывается. Метод выше обеспечит удаление DbContext, когда HTTP-сессия завершается. Вы можете сделать это для других членов, которые необходимо удалить в конце ответа. Для второго метода можно создать пользовательский обработчик сервера, который будет удалять DbContext, когда HTTP-сессия завершается. Server/Handlers/ObjectDisposerHandler.cs C# public class ObjectDisposerHandler : HttpServerHandler { protected override void OnHttpRequestClose(HttpServerExecutionResult result) { result.Context.RequestBag.GetOrDefault<DbContext>()?.Dispose(); } } И использовать его в вашем построителе приложения: Program.cs C# using var host = HttpServer.CreateBuilder() .UseHandler<ObjectDisposerHandler>() .Build(); Это один из способов обработки очистки кода и поддержания зависимостей запроса, разделенных по типу модуля, который будет использоваться, уменьшая количество дублирующего кода внутри каждого действия маршрутизатора. Это практика, аналогичная тому, для чего используется внедрение зависимостей в фреймворках типа ASP.NET."
  },
  "docs/ru/features/logging.html": {
    "href": "docs/ru/features/logging.html",
    "title": "Журналирование | Sisk",
    "keywords": "Журналирование Вы можете настроить Sisk для автоматического записи журналов доступа и ошибок. Также можно определить ротацию журналов, расширения и частоту. Класс LogStream предоставляет асинхронный способ записи журналов и поддерживает ожидаемую очередь записи. В этой статье мы покажем вам, как настроить журналирование для вашего приложения. Журналы доступа на основе файлов Журналы в файлах открывают файл, записывают текст строки, а затем закрывают файл для каждой записанной строки. Этот процесс был принят для поддержания отзывчивости записи в журналах. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); ... await app.StartAsync(); } } Вышеуказанный код запишет все входящие запросы в файл logs/access.log. Обратите внимание, что файл создается автоматически, если он не существует, но папка перед ним не создается. Не обязательно создавать папку logs/, поскольку класс LogStream автоматически создает ее. Журналирование на основе потока Вы можете записывать журналы в объекты TextWriter, такие как Console.Out, передав объект TextWriter в конструктор: Program.cs C# using var app = HttpServer.CreateBuilder() .UseConfiguration(config => { config.AccessLogsStream = new LogStream(\"logs/access.log\"); }) .Build(); Для каждого сообщения, записанного в потоковом журнале, вызывается метод TextWriter.Flush(). Форматирование журнала доступа Вы можете настроить формат журнала доступа с помощью предопределенных переменных. Рассмотрим следующую строку: config.AccessLogsFormat = \"%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -> %lou in %lmsms [%{user-agent}]\"; Она запишет сообщение, подобное: 29/мар./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -> 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36] Вы можете форматировать свой журнал по формату, описанному в таблице: Значение Что оно представляет Пример %dd День месяца (форматирован как два знака) 05 %dmmm Полное название месяца Июль %dmm Сокращенное название месяца (три знака) Июл %dm Номер месяца (форматирован как два знака) 07 %dy Год (форматирован как четыре знака) 2023 %th Час в 12-часовом формате 03 %tH Час в 24-часовом формате (HH) 15 %ti Минуты (форматированы как два знака) 30 %ts Секунды (форматированы как два знака) 45 %tm Миллисекунды (форматированы как три знака) 123 %tz Часовой пояс (общее количество часов в UTC) +03:00 %ri IP-адрес клиента 192.168.1.100 %rm HTTP-метод (в верхнем регистре) GET %rs Схема URI (http/https) https %ra Авторитет URI (домен) example.com %rh Хост запроса www.example.com %rp Порт запроса 443 %rz Путь запроса /path/to/resource %rq Строка запроса ?key=value&another=123 %sc Код состояния HTTP-ответа 200 %sd Описание состояния HTTP-ответа OK %lin Человекочитаемый размер запроса 1.2 KB %linr Необработанный размер запроса (байты) 1234 %lou Человекочитаемый размер ответа 2.5 KB %lour Необработанный размер ответа (байты) 2560 %lms Затраченное время в миллисекундах 120 %ls Статус выполнения Executed Ротация журналов Tip В Sisk 0.15 и старше, эта функция доступна только с пакетом Sisk.ServiceProvider. В Sisk 0.16 и выше, эта функция реализована в пакете core. Вы можете настроить веб-сервер для ротации файлов журналов в сжатый файл .gz, когда они достигают определенного размера. Размер проверяется периодически по заданному лимиту. config.AccessLogsStream = new LogStream(\"access.log\"); var rotater = new RotatingLogPolicy(config.AccessLogsStream); rotater.Configure(1024 * 1024, TimeSpan.FromHours(6)); Вышеуказанный код проверит каждые шесть часов, достиг ли файл LogStream размера 1 МБ. Если да, файл сжимается в файл .gz, а затем файл access.log очищается. Во время этого процесса запись в файл блокируется до тех пор, пока файл не будет сжат и очищен. Все строки, которые поступают для записи в этот период, будут в очереди ожидания до конца сжатия. Эта функция работает только с файловыми LogStreams. Журналирование ошибок Когда сервер не выбрасывает ошибки в отладчик, он пересылает ошибки в журнал записи, когда они есть. Вы можете настроить запись ошибок с помощью: config.ThrowExceptions = false; config.ErrorsLogsStream = new LogStream(\"error.log\"); Это свойство запишет что-то в журнал только в том случае, если ошибка не была поймана обратным вызовом или свойством Router.CallbackErrorHandler. Ошибка, записанная сервером, всегда записывает дату и время, заголовки запроса (не тело), трассировку ошибки и трассировку внутренней ошибки, если она есть. Другие экземпляры журналирования Ваше приложение может иметь ноль или несколько LogStreams, нет ограничения на количество каналов журналирования, которые оно может иметь. Следовательно, возможно направить журнал вашего приложения в файл, отличный от стандартного AccessLog или ErrorLog. LogStream appMessages = new LogStream(\"messages.log\"); appMessages.WriteLine(\"Приложение запущено в {0}\", DateTime.Now); Расширение LogStream Вы можете расширить класс LogStream, чтобы записывать пользовательские форматы, совместимые с текущим движком журналирования Sisk. Пример ниже позволяет записывать цветные сообщения в консоль через библиотеку Spectre.Console: CustomLogStream.cs C# public class CustomLogStream : LogStream { protected override void WriteLineInternal(string line) { base.WriteLineInternal($\"[{DateTime.Now:g}] {line}\"); } } Другой способ автоматически записывать пользовательские журналы для каждого запроса/ответа — создать HttpServerHandler. Пример ниже немного более полный. Он записывает тело запроса и ответа в JSON в консоль. Это может быть полезно для отладки запросов в целом. Этот пример использует ContextBag и HttpServerHandler. Program.cs C# class Program { static async Task Main(string[] args) { var app = HttpServer.CreateBuilder(host => { host.UseListeningPort(5555); host.UseHandler<JsonMessageHandler>(); }); app.Router += new Route(RouteMethod.Any, \"/json\", request => { return new HttpResponse() .WithContent(JsonContent.Create(new { method = request.Method.Method, path = request.Path, specialMessage = \"Hello, world!!\" })); }); await app.StartAsync(); } } JsonMessageHandler.cs C# class JsonMessageHandler : HttpServerHandler { protected override void OnHttpRequestOpen(HttpRequest request) { if (request.Method != HttpMethod.Get && request.Headers[\"Content-Type\"]?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { // В этот момент соединение открыто, и клиент отправил заголовок, указывающий, // что содержимое является JSON. Строка ниже считывает содержимое и оставляет его // храниться в запросе. // // Если содержимое не прочитано в действии запроса, GC, скорее всего, соберет // содержимое после отправки ответа клиенту, поэтому содержимое может быть недоступно // после закрытия ответа. // _ = request.RawBody; // добавляем намек в контекст, чтобы сказать, что этот запрос имеет JSON-тело request.Bag.Add(\"IsJsonRequest\", true); } } protected override async void OnHttpRequestClose(HttpServerExecutionResult result) { string? requestJson = null, responseJson = null, responseMessage; if (result.Request.Bag.ContainsKey(\"IsJsonRequest\")) { // переформатирует JSON с помощью библиотеки CypherPotato.LightJson var content = result.Request.Body; requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString(); } if (result.Response is { } response) { var content = response.Content; responseMessage = $\"{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}\"; if (content is HttpContent httpContent && // проверяем, является ли ответ JSON httpContent.Headers.ContentType?.MediaType?.Contains(\"json\", StringComparison.InvariantCultureIgnoreCase) == true) { string json = await httpContent.ReadAsStringAsync(); responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString(); } } else { // получаем внутренний статус обработки сервера responseMessage = result.Status.ToString(); } StringBuilder outputMessage = new StringBuilder(); if (requestJson != null) { outputMessage.AppendLine(\"-----\"); outputMessage.AppendLine($\">>> {result.Request.Method} {result.Request.Path}\"); if (requestJson is not null) outputMessage.AppendLine(requestJson); } outputMessage.AppendLine($\"<<< {responseMessage}\"); if (responseJson is not null) outputMessage.AppendLine(responseJson); outputMessage.AppendLine(\"-----\"); await Console.Out.WriteLineAsync(outputMessage.ToString()); } }"
  },
  "docs/ru/features/server-sent-events.html": {
    "href": "docs/ru/features/server-sent-events.html",
    "title": "Серверные события | Sisk",
    "keywords": "Серверные события Sisk поддерживает отправку сообщений через Серверные события из коробки. Вы можете создавать одноразовые и постоянные соединения, получать соединения во время выполнения и использовать их. Эта функция имеет некоторые ограничения, наложенные браузерами, такие как отправка только текстовых сообщений и невозможность постоянного закрытия соединения. Серверное закрытое соединение будет иметь клиент, который периодически попытается переподключиться каждые 5 секунд (3 для некоторых браузеров). Эти соединения полезны для отправки событий от сервера к клиенту без необходимости запроса информации каждый раз. Создание соединения SSE Соединение SSE работает как обычный HTTP-запрос, но вместо отправки ответа и немедленного закрытия соединения, соединение остается открытым для отправки сообщений. Вызывая метод HttpRequest.GetEventSource(), запрос помещается в состояние ожидания, пока экземпляр SSE не будет создан. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.Send(\"Привет, мир!\"); return sse.Close(); }); В вышеприведенном коде мы создаем соединение SSE и отправляем сообщение \"Привет, мир\", затем мы закрываем соединение SSE с серверной стороны. Note Когда соединение закрывается с серверной стороны, по умолчанию клиент попытается подключиться снова и соединение будет перезапущено, выполняя метод снова, бесконечно. Обычно передается сообщение о завершении от сервера всякий раз, когда соединение закрывается с серверной стороны, чтобы предотвратить попытки клиента переподключиться снова. Добавление заголовков Если вам нужно отправить заголовки, вы можете использовать метод HttpRequestEventSource.AppendHeader перед отправкой любых сообщений. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(); sse.AppendHeader(\"Header-Key\", \"Header-value\"); sse.Send(\"Привет!\"); return sse.Close(); }); Обратите внимание, что необходимо отправить заголовки перед отправкой любых сообщений. Соединения Wait-For-Fail Соединения обычно завершаются, когда сервер больше не может отправлять сообщения из-за возможного отключения клиента. С этим соединение автоматически завершается и экземпляр класса удаляется. Даже с переподключением экземпляр класса не будет работать, поскольку он связан с предыдущим соединением. В некоторых ситуациях вам может понадобиться это соединение позже, и вы не хотите управлять им через метод обратного вызова маршрута. Для этого мы можем идентифицировать соединения SSE с помощью идентификатора и получить их позже, даже вне обратного вызова маршрута. Кроме того, мы помечаем соединение как WaitForFail, чтобы не завершать маршрут и не завершать соединение автоматически. Соединение SSE в режиме KeepAlive будет ожидать ошибки отправки (вызванной отключением) для возобновления выполнения метода. Также можно задать таймаут для этого. После истечения времени, если не было отправлено ни одного сообщения, соединение завершается и выполнение возобновляется. r += new Route(RouteMethod.Get, \"/\", (req) => { var sse = req.GetEventSource(\"my-index-connection\"); sse.WaitForFail(TimeSpan.FromSeconds(15)); // ожидать 15 секунд без каких-либо сообщений перед завершением соединения return sse.Close(); }); Вышеприведенный метод создаст соединение, обработает его и будет ожидать отключения или ошибки. HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(\"my-index-connection\"); if (evs != null) { // соединение仍然 существует evs.Send(\"Привет снова!\"); } И вышеприведенный фрагмент кода попытается найти только что созданное соединение, и если оно существует, оно отправит сообщение ему. Все активные серверные соединения, которые идентифицированы, будут доступны в коллекции HttpServer.EventSources. Эта коллекция хранит только активные и идентифицированные соединения. Закрытые соединения удаляются из коллекции. Note Важно отметить, что KeepAlive имеет ограничение, установленное компонентами, которые могут быть подключены к Sisk неуправляемым образом, такими как веб-прокси, HTTP-ядро или сетевой драйвер, и они закрывают неактивные соединения после определенного периода времени. Следовательно, важно поддерживать соединение открытым, отправляя периодические пинги или продлевая максимальное время до закрытия соединения. Прочитайте следующий раздел, чтобы лучше понять отправку периодических пингов. Настройка политики пингов соединений Политика пингов - это автоматизированный способ отправки периодических сообщений клиенту. Эта функция позволяет серверу понять, когда клиент отключился от соединения, не имея необходимости поддерживать соединение открытым бесконечно. [RouteGet(\"/sse\")] public HttpResponse Events(HttpRequest request) { var sse = request.GetEventSource(); sse.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); }); sse.KeepAlive(); return sse.Close(); } В вышеприведенном коде каждые 5 секунд будет отправлено новое сообщение пинга клиенту. Это будет поддерживать TCP-соединение открытым и предотвратить его закрытие из-за неактивности. Кроме того, когда сообщение не может быть отправлено, соединение автоматически закрывается, освобождая ресурсы, используемые соединением. Запрос соединений Вы можете искать активные соединения, используя предикат на идентификаторе соединения, чтобы, например, транслировать сообщения. HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith(\"my-connection-\")); foreach (HttpRequestEventSource e in evs) { e.Send(\"Транслирую всем источникам событий, которые начинаются с 'my-connection-'\"); } Вы также можете использовать метод All, чтобы получить все активные соединения SSE."
  },
  "docs/ru/features/websockets.html": {
    "href": "docs/ru/features/websockets.html",
    "title": "Веб-сокеты | Sisk",
    "keywords": "Веб-сокеты Sisk поддерживает веб-сокеты, такие как получение и отправка сообщений клиенту. Эта функция работает хорошо в большинстве браузеров, но в Sisk она еще экспериментальная. Пожалуйста, если вы найдете какие-либо ошибки, сообщите об этом на github. Принятие и получение сообщений асинхронно Пример ниже показывает, как работает веб-сокет на практике, с примером открытия соединения, получения сообщения и отображения его в консоли. Все сообщения, полученные веб-сокетом, получаются в виде байтов, поэтому вам придется их расшифровать при получении. По умолчанию, сообщения разбиваются на фрагменты и последний фрагмент отправляется как последний пакет сообщения. Вы можете настроить размер пакета с помощью флага WebSocketBufferSize. Этот буферизация одинакова для отправки и получения сообщений. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); ws.OnReceive += (sender, msg) => { string msgText = Encoding.UTF8.GetString(msg.MessageBytes); Console.WriteLine(\"Получено сообщение: \" + msgText); // получает контекст HttpWebSocket, который получил сообщение HttpWebSocket senderWebSocket = (HttpWebSocket)sender!; senderWebSocket.Send(\"Ответ!\"); }; ws.WaitForClose(); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Принятие и получение сообщений синхронно Пример ниже содержит способ использования синхронного веб-сокета, без асинхронного контекста, где вы получаете сообщения, обрабатываете их и завершаете использование сокета. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/connect\", (req) => { var ws = req.GetWebSocket(); WebSocketMessage? msg; askName: ws.Send(\"Как вас зовут?\"); msg = ws.WaitNext(); string? name = msg?.GetString(); if (string.IsNullOrEmpty(name)) { ws.Send(\"Пожалуйста, введите ваше имя!\"); goto askName; } askAge: ws.Send(\"А ваш возраст?\"); msg = ws.WaitNext(); if (!Int32.TryParse(msg?.GetString(), out int age)) { ws.Send(\"Пожалуйста, введите действительное число\"); goto askAge; } ws.Send($\"Вы {name}, и вам {age} лет.\"); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Отправка сообщений Метод Send имеет три перегрузки, которые позволяют отправлять текст, массив байтов или диапазон байтов. Все они разбиваются на фрагменты, если размер серверного буфера WebSocketBufferSize больше общего размера полезной нагрузки. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); byte[] myByteArrayContent = ...; ws.Send(\"Привет, мир\"); // будет закодировано как массив байтов UTF-8 ws.Send(myByteArrayContent); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Ожидание закрытия веб-сокета Метод WaitForClose() блокирует текущий стек вызовов до тех пор, пока соединение не будет завершено клиентом или сервером. С помощью этого метода выполнение callback запроса будет заблокировано до тех пор, пока клиент или сервер не отключится. Вы также можете вручную закрыть соединение с помощью метода Close(). Этот метод возвращает пустой объект HttpResponse, который не отправляется клиенту, но работает как возвращаемое значение из функции, где был получен HTTP-запрос. static ListeningHost BuildLhA() { Router r = new Router(); r += new Route(RouteMethod.Get, \"/\", (req) => { var ws = req.GetWebSocket(); // ожидание закрытия соединения клиентом ws.WaitForClose(); // ожидание 60 секунд без обмена сообщениями // или до тех пор, пока одна из сторон не закроет соединение ws.WaitForClose(TimeSpan.FromSeconds(60)); return ws.Close(); }); return new ListeningHost(\"localhost\", 5551, r); } Политика пинга Аналогично политике пинга в Server Side Events, вы также можете настроить политику пинга, чтобы поддерживать TCP-соединение открытым, если в нем нет активности. ws.WithPing(ping => { ping.DataMessage = \"ping-message\"; ping.Interval = TimeSpan.FromSeconds(5); ping.Start(); });"
  },
  "docs/ru/fundamentals/request-handlers.html": {
    "href": "docs/ru/fundamentals/request-handlers.html",
    "title": "Обработка запросов | Sisk",
    "keywords": "Обработка запросов Обработчики запросов, также известные как \"посредники\", являются функциями, которые выполняются до или после выполнения запроса на маршрутизаторе. Они могут быть определены для каждого маршрута или для всего маршрутизатора. Существует два типа обработчиков запросов: BeforeResponse: определяет, что обработчик запроса будет выполнен до вызова действия маршрутизатора. AfterResponse: определяет, что обработчик запроса будет выполнен после вызова действия маршрутизатора. Отправка ответа HTTP в этом контексте перезапишет ответ действия маршрутизатора. Оба обработчика запросов могут переопределить фактический ответ функции обратного вызова маршрутизатора. Кроме того, обработчики запросов могут быть полезны для проверки запроса, такой как аутентификация, содержимое или любую другую информацию, такую как хранение информации, журналов или других шагов, которые можно выполнить до или после ответа. Таким образом, обработчик запроса может прервать все это выполнение и вернуть ответ до завершения цикла, отбрасывая все остальное в процессе. Пример: предположим, что обработчик запроса аутентификации пользователя не аутентифицирует его. Он предотвратит продолжение жизненного цикла запроса и зависнет. Если это происходит в обработчике запроса на позиции два, третий и последующие не будут оценены. Создание обработчика запроса Чтобы создать обработчик запроса, мы можем создать класс, который наследует интерфейс IRequestHandler, в следующем формате: public class AuthenticateUserRequestHandler : IRequestHandler { public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers.Authorization != null) { // Возвращение null указывает на то, что цикл запроса может быть продолжен return null; } else { // Возвращение объекта HttpResponse указывает на то, что этот ответ перезапишет соседние ответы. return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } В приведенном выше примере мы указали, что если заголовок Authorization присутствует в запросе, он должен продолжаться, и следующий обработчик запроса или функция обратного вызова маршрутизатора должна быть вызвана, в зависимости от того, что происходит дальше. Если обработчик запроса выполняется после ответа по свойству ExecutionMode и возвращает не-null значение, он перезапишет ответ маршрутизатора. Когда обработчик запроса возвращает null, это указывает на то, что запрос должен продолжаться, и следующий объект должен быть вызван или цикл должен завершиться ответом маршрутизатора. Связывание обработчика запроса с одним маршрутом Вы можете определить один или несколько обработчиков запросов для маршрута. mainRouter.SetRoute(RouteMethod.Get, \"/\", IndexPage, \"\", new IRequestHandler[] { new AuthenticateUserRequestHandler(), // до запроса обработчик new ValidateJsonContentRequestHandler(), // до запроса обработчик // -- метод IndexPage будет выполнен здесь new WriteToLogRequestHandler() // после запроса обработчик }); Или создавая объект Route: Route indexRoute = new Route(RouteMethod.Get, \"/\", \"\", IndexPage, null); indexRoute.RequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; mainRouter.SetRoute(indexRoute); Связывание обработчика запроса с маршрутизатором Вы можете определить глобальный обработчик запроса, который будет выполняться для всех маршрутов на маршрутизаторе. mainRouter.GlobalRequestHandlers = new IRequestHandler[] { new AuthenticateUserRequestHandler() }; Связывание обработчика запроса с атрибутом Вы можете определить обработчик запроса на методе атрибута вместе с атрибутом маршрута. public class MyController { [RouteGet(\"/\")] [RequestHandler<AuthenticateUserRequestHandler>] static HttpResponse Index(HttpRequest request) { return new HttpResponse() .WithContent(new StringContent(\"Hello world!\")); } } Обратите внимание, что необходимо передать желаемый тип обработчика запроса, а не экземпляр объекта. Таким образом, обработчик запроса будет создан парсером маршрутизатора. Вы можете передать аргументы в конструктор класса с помощью свойства ConstructorArguments. Пример: [RequestHandler<AuthenticateUserRequestHandler>(\"arg1\", 123, ...)] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Вы также можете создать собственный атрибут, который реализует RequestHandler: public class AuthenticateAttribute : RequestHandlerAttribute { public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { \"arg1\", 123, ... }) { ; } } И использовать его как: [Authenticate] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } Пропуск глобального обработчика запроса После определения глобального обработчика запроса на маршруте вы можете игнорировать этот обработчик запроса на конкретных маршрутах. var myRequestHandler = new AuthenticateUserRequestHandler(); mainRouter.GlobalRequestHandlers = new IRequestHandler[] { myRequestHandler }; mainRouter.SetRoute(new Route(RouteMethod.Get, \"/\", \"My route\", IndexPage, null) { BypassGlobalRequestHandlers = new IRequestHandler[] { myRequestHandler, // ok: тот же экземпляр, что и в глобальных обработчиках запросов new AuthenticateUserRequestHandler() // wrong: не пропустит глобальный обработчик запроса } }); Note Если вы пропускаете обработчик запроса, вы должны использовать тот же ссылку на то, что было создано ранее, чтобы пропустить. Создание другого экземпляра обработчика запроса не пропустит глобальный обработчик запроса, поскольку ссылка изменится. Помните, что необходимо использовать ту же ссылку на обработчик запроса, которая используется как в глобальных обработчиках запросов, так и в обработчиках, которые пропускаются."
  },
  "docs/ru/fundamentals/requests.html": {
    "href": "docs/ru/fundamentals/requests.html",
    "title": "Запросы | Sisk",
    "keywords": "Запросы Запросы представляют собой структуры, которые представляют сообщение HTTP-запроса. Объект HttpRequest содержит полезные функции для обработки HTTP-сообщений на протяжении всего вашего приложения. HTTP-запрос формируется методом, путем, версией, заголовками и телом. В этом документе мы научим вас, как получить каждый из этих элементов. Получение метода запроса Чтобы получить метод полученного запроса, вы можете использовать свойство Method: static HttpResponse Index(HttpRequest request) { HttpMethod requestMethod = request.Method; ... } Это свойство возвращает метод запроса, представленный объектом HttpMethod. Note В отличие от методов маршрутизации, это свойство не обслуживает элемент RouteMethod.Any. Вместо этого оно возвращает фактический метод запроса. Получение компонентов URL Вы можете получить различные компоненты из URL через определенные свойства запроса. Для этого примера давайте рассмотрим URL: http://localhost:5000/user/login?email=foo@bar.com Название компонента Описание Значение компонента Path Получает путь запроса. /user/login FullPath Получает путь запроса и строку запроса. /user/login?email=foo@bar.com FullUrl Получает всю строку URL запроса. http://localhost:5000/user/login?email=foo@bar.com Host Получает хост запроса. localhost Authority Получает хост и порт запроса. localhost:5000 QueryString Получает запрос запроса. ?email=foo@bar.com Query Получает запрос запроса в виде коллекции именованных значений. {StringValueCollection object} IsSecure Определяет, использует ли запрос SSL (true) или нет (false). false Вы также можете использовать свойство HttpRequest.Uri, которое включает все вышеперечисленное в один объект. Получение тела запроса Некоторые запросы включают тело, такое как формы, файлы или транзакции API. Вы можете получить тело запроса из свойства: // получает тело запроса как строку, используя кодировку запроса в качестве декодера string body = request.Body; // или получает его в виде массива байтов byte[] bodyBytes = request.RawBody; // или вы можете передать его как поток. Stream requestStream = request.GetRequestStream(); Также возможно определить, есть ли тело в запросе и загружено ли оно с помощью свойств HasContents, которое определяет, имеет ли запрос содержимое, и IsContentAvailable, которое указывает, что HTTP-сервер полностью получил содержимое из удаленной точки. Невозможно прочитать содержимое запроса через GetRequestStream более одного раза. Если вы прочитаете его с помощью этого метода, значения в RawBody и Body также не будут доступны. Не нужно освобождать поток запроса в контексте запроса, поскольку он освобождается в конце HTTP-сессии, в которой он создается. Кроме того, вы можете использовать свойство HttpRequest.RequestEncoding, чтобы получить лучшую кодировку для декодирования запроса вручную. Сервер имеет ограничения на чтение содержимого запроса, которые применяются как к HttpRequest.Body, так и к HttpRequest.RawBody. Эти свойства копируют весь входной поток в локальный буфер того же размера, что и HttpRequest.ContentLength. Ответ со статусом 413 Содержимое слишком велико возвращается клиенту, если отправленное содержимое больше HttpServerConfiguration.MaximumContentLength, определенного в конфигурации пользователя. Кроме того, если нет настроенного ограничения или если оно слишком велико, сервер выдаст исключение OutOfMemoryException, когда содержимое, отправленное клиентом, превышает Int32.MaxValue (2 ГБ), и если содержимое попытается получить доступ через одно из вышеупомянутых свойств. Вы все равно можете иметь дело с содержимым через поток. Note Хотя Sisk позволяет это, всегда хорошей идеей является следование семантике HTTP для создания вашего приложения и не получать или обслуживать содержимое в методах, которые не допускают этого. Прочитайте о RFC 9110 \"HTTP Семантика\". Получение контекста запроса Контекст HTTP — это эксклюзивный объект Sisk, который хранит информацию о сервере HTTP, маршруте, маршрутизаторе и обработчике запроса. Вы можете использовать его, чтобы организовать себя в среде, где эти объекты трудно организовать. Объект RequestBag содержит сохраненную информацию, которая передается из обработчика запроса в другую точку, и может быть потреблена в конечной точке. Этот объект также может быть использован обработчиками запросов, которые запускаются после обратного вызова маршрута. Tip Это свойство также доступно через свойство HttpRequest.Bag. public class AuthenticateUserRequestHandler : IRequestHandler { public string Identifier { get; init; } = Guid.NewGuid().ToString(); public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse; public HttpResponse? Execute(HttpRequest request, HttpContext context) { if (request.Headers[\"Authorization\"] != null) { context.RequestBag.Add(\"AuthenticatedUser\", \"Bob\"); return null; } else { return new HttpResponse(System.Net.HttpStatusCode.Unauthorized); } } } Вышеуказанный обработчик запроса определит AuthenticatedUser в сумке запроса, и может быть потреблен позже в конечном вызове: public class MyController { [Route(RouteMethod.Get, \"/\")] [RequestHandler(typeof(AuthenticateUserRequestHandler))] static HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); string authUser = request.Context.RequestBag[\"AuthenticatedUser\"]; res.Content = new StringContent($\"Hello, {authUser}!\"); return res; } } Вы также можете использовать методы Bag.Set() и Bag.Get(), чтобы получить или задать объекты по их типам синглтонов. public class Authenticate : RequestHandler { public override HttpResponse? Execute(HttpRequest request, HttpContext context) { request.Bag.Set<User>(authUser); } } [RouteGet(\"/\")] [RequestHandler<Authenticate>] public static HttpResponse Test(HttpRequest request) { var user = request.Bag.Get<User>(); } Получение данных формы Вы можете получить значения данных формы в NameValueCollection с помощью следующего примера: static HttpResponse Index(HttpRequest request) { var form = request.GetFormContent(); string? username = form[\"username\"]; string? password = form[\"password\"]; if (AttempLogin(username, password) == true) { ... } } Получение данных multipart-формы Запрос HTTP Sisk позволяет получить отправленные multipart-содержимое, такое как файлы, поля формы или любое бинарное содержимое. static HttpResponse Index(HttpRequest request) { // следующий метод читает весь входной запрос в массив // MultipartObject var multipartFormDataObjects = request.GetMultipartFormContent(); foreach (MultipartObject uploadedObject in multipartFormDataObjects) { // имя файла, предоставленное multipart-формой. // Null возвращается, если объект не является файлом. Console.WriteLine(\"File name : \" + uploadedObject.Filename); // имя поля multipart-формы. Console.WriteLine(\"Field name : \" + uploadedObject.Name); // длина содержимого multipart-формы. Console.WriteLine(\"Content length : \" + uploadedObject.ContentLength); // определите формат изображения на основе файла для каждого // известного типа содержимого. Если содержимое не является признанным // обычным форматом файла, этот метод ниже вернет // MultipartObjectCommonFormat.Unknown Console.WriteLine(\"Common format : \" + uploadedObject.GetCommonFileFormat()); } } Вы можете прочитать больше о Multipart-объектах Sisk и их методах, свойствах и функциях. Поддержка серверных событий Sisk поддерживает серверные события, которые позволяют отправлять фрагменты как поток и поддерживать соединение между сервером и клиентом. Вызов метода HttpRequest.GetEventSource приведет к тому, что запрос HTTP будет находиться в состоянии прослушивания. С этого момента контекст этого HTTP-запроса не будет ожидать ответа HTTP, поскольку он перекроет пакеты, отправленные серверными событиями. После отправки всех пакетов обратный вызов должен вернуть метод Close, который отправит окончательный ответ серверу и укажет, что потоковое передача завершилась. Невозможно предсказать общую длину всех пакетов, которые будут отправлены, поэтому невозможно определить конец соединения с помощью заголовка Content-Length. По умолчанию большинства браузеров серверные события не поддерживают отправку HTTP-заголовков или методов, кроме метода GET. Поэтому будьте осторожны при использовании обработчиков запросов с запросами event-source, которые требуют определенных заголовков в запросе, поскольку они, вероятно, не будут иметь их. Кроме того, большинство браузеров перезапускают потоки, если метод EventSource.close не вызван на стороне клиента после получения всех пакетов, что вызывает бесконечную дополнительную обработку на стороне сервера. Чтобы избежать этой проблемы, обычно отправляют окончательный пакет, указывающий, что источник событий завершил отправку всех пакетов. Пример ниже показывает, как браузер может общаться с сервером, поддерживающим серверные события. <html> <body> <b>Фрукты:</b> <ul></ul> </body> <script> const evtSource = new EventSource('/event-source'); const eventList = document.querySelector('ul'); evtSource.onmessage = (e) => { const newElement = document.createElement(\"li\"); newElement.textContent = `message: ${e.data}`; eventList.appendChild(newElement); if (e.data == \"Tomato\") { evtSource.close(); } } </script> </html> И постепенно отправляйте сообщения клиенту: public class MyController { [Route(RouteMethod.Get, \"/event-source\")] static HttpResponse ServerEventsResponse(HttpRequest request) { var serverEvents = request.GetEventSource(); string[] fruits = new[] { \"Apple\", \"Banana\", \"Watermelon\", \"Tomato\" }; foreach (string fruit in fruits) { serverEvents.Send(fruit); Thread.Sleep(1500); } return serverEvents.Close(); } } Когда мы запускаем этот код, мы ожидаем результат, подобный этому: Разрешение прокси-IP и хостов Sisk можно использовать с прокси, и поэтому IP-адреса могут быть заменены на конечную точку прокси в транзакции от клиента к прокси. Вы можете определить свои собственные разрешители в Sisk с помощью разрешителей пересылки. Кодирование заголовков Кодирование заголовков может быть проблемой для некоторых реализаций. В Windows не поддерживаются заголовки UTF-8, поэтому используется ASCII. Sisk имеет встроенный конвертер кодировки, который может быть полезен для декодирования неправильно закодированных заголовков. Эта операция дорога и отключена по умолчанию, но может быть включена под флагом NormalizeHeadersEncodings."
  },
  "docs/ru/fundamentals/responses.html": {
    "href": "docs/ru/fundamentals/responses.html",
    "title": "Ответы | Sisk",
    "keywords": "Ответы Ответы представляют собой объекты, которые являются HTTP-ответами на HTTP-запросы. Они отправляются сервером клиенту в качестве указания на запрос ресурса, страницы, документа, файла или другого объекта. HTTP-ответ состоит из статуса, заголовков и содержимого. В этом документе мы научим вас, как проектировать HTTP-ответы с помощью Sisk. Установка HTTP-статуса Список HTTP-статусов остался неизменным с HTTP/1.0, и Sisk поддерживает все они. HttpResponse res = new HttpResponse(); res.Status = System.Net.HttpStatusCode.Accepted; // 202 Или с помощью синтаксиса Fluent: new HttpResponse() .WithStatus(200) // или .WithStatus(HttpStatusCode.Ok) // или .WithStatus(HttpStatusInformation.Ok); Вы можете увидеть полный список доступных HttpStatusCode здесь. Вы также можете предоставить свой собственный код состояния, используя структуру HttpStatusInformation. Тело и тип содержимого Sisk поддерживает родные объекты .NET для отправки тела в ответах. Вы можете использовать класс StringContent, чтобы отправить JSON-ответ, например: HttpResponse res = new HttpResponse(); res.Content = new StringContent(myJson, Encoding.UTF8, \"application/json\"); Сервер всегда попытается рассчитать Content-Length из того, что вы определили в содержимом, если вы не определили его явно в заголовке. Если сервер не может неявно получить заголовок Content-Length из содержимого ответа, ответ будет отправлен с помощью Chunked-Encoding. Вы также можете передавать ответ, отправляя StreamContent или используя метод GetResponseStream. Заголовки ответа Вы можете добавлять, редактировать или удалять заголовки, которые вы отправляете в ответе. Пример ниже показывает, как отправить ответ с перенаправлением клиенту. HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.Moved; res.Headers.Add(HttpKnownHeaderNames.Location, \"/login\"); Или с помощью синтаксиса Fluent: new HttpResponse(301) .WithHeader(\"Location\", \"/login\"); Когда вы используете метод Add класса HttpHeaderCollection, вы добавляете заголовок к запросу без изменения уже отправленных заголовков. Метод Set заменяет заголовки с тем же именем на указанное значение. Индексатор класса HttpHeaderCollection внутренне вызывает метод Set для замены заголовков. Отправка файлов cookie Sisk имеет методы, которые облегчают определение файлов cookie на клиенте. Файлы cookie, установленные этим методом, уже закодированы в URL и соответствуют стандарту RFC-6265. HttpResponse res = new HttpResponse(); res.SetCookie(\"cookie-name\", \"cookie-value\"); Или с помощью синтаксиса Fluent: new HttpResponse(301) .WithCookie(\"cookie-name\", \"cookie-value\", expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7))); Существуют другие более полные версии того же метода. Фрагментированные ответы Вы можете установить кодирование передачи в фрагментированное, чтобы отправить большие ответы. HttpResponse res = new HttpResponse(); res.SendChunked = true; При использовании фрагментированного кодирования заголовок Content-Length автоматически опускается. Поток ответа Потоки ответа являются управляемым способом, который позволяет отправлять ответы поэтапно. Это более низкоуровневая операция, чем использование объектов HttpResponse, поскольку они требуют от вас отправки заголовков и содержимого вручную, а затем закрытия соединения. Этот пример открывает поток только для чтения для файла, копирует поток в поток вывода ответа и не загружает весь файл в память. Это может быть полезно для обслуживания средних или больших файлов. // получает поток вывода ответа using var fileStream = File.OpenRead(\"my-big-file.zip\"); var responseStream = request.GetResponseStream(); // устанавливает кодирование ответа для использования фрагментированного кодирования // также не следует отправлять заголовок content-length при использовании // фрагментированного кодирования responseStream.SendChunked = true; responseStream.SetStatus(200); responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType); // копирует поток файла в поток вывода ответа fileStream.CopyTo(responseStream.ResponseStream); // закрывает поток return responseStream.Close(); Сжатие GZip, Deflate и Brotli Вы можете отправлять ответы со сжатым содержимым в Sisk, сжимая HTTP-содержимое. Сначала заключите объект HttpContent в один из компрессоров ниже, чтобы отправить сжатый ответ клиенту. router.MapGet(\"/hello.html\", request => { string myHtml = \"...\"; return new HttpResponse () { Content = new GZipContent(new HtmlContent(myHtml)), // или Content = new BrotliContent(new HtmlContent(myHtml)), // или Content = new DeflateContent(new HtmlContent(myHtml)), }; }); Вы также можете использовать эти сжатые содержимые с потоками. router.MapGet(\"/archive.zip\", request => { // не примените \"using\" здесь. HttpServer будет удалять ваше содержимое // после отправки ответа. var archive = File.OpenRead(\"/path/to/big-file.zip\"); return new HttpResponse () { Content = new GZipContent(archive) } }); Заголовки Content-Encoding автоматически устанавливаются при использовании этих содержимых. Неявные типы ответов Поскольку версии 0.15, вы можете использовать другие типы ответов, кроме HttpResponse, но для этого необходимо настроить маршрутизатор, чтобы он обрабатывал каждый тип объекта. Концепция заключается в том, чтобы всегда возвращать ссылочный тип и преобразовывать его в допустимый объект HttpResponse. Маршруты, которые возвращают HttpResponse, не подвергаются никакому преобразованию. Типы значений (структуры) не могут использоваться в качестве типа ответа, поскольку они не совместимы с RouterCallback, поэтому они должны быть завернуты в ValueResult, чтобы их можно было использовать в обработчиках. Рассмотрим следующий пример из модуля маршрутизатора, не использующего HttpResponse в качестве типа ответа: [RoutePrefix(\"/users\")] public class UsersController : RouterModule { public List<User> Users = new List<User>(); [RouteGet] public IEnumerable<User> Index(HttpRequest request) { return Users.ToArray(); } [RouteGet(\"<id>\")] public User View(HttpRequest request) { int id = request.RouteParameters[\"id\"].GetInteger(); User dUser = Users.First(u => u.Id == id); return dUser; } [RoutePost] public ValueResult<bool> Create(HttpRequest request) { User fromBody = JsonSerializer.Deserialize<User>(request.Body)!; Users.Add(fromBody); return true; } } С этого момента необходимо определить в маршрутизаторе, как он будет обрабатывать каждый тип объекта. Объекты всегда являются первым аргументом обработчика, а тип ответа должен быть допустимым объектом HttpResponse. Кроме того, выходные объекты маршрута никогда не должны быть null. Для типов ValueResult не необходимо указывать, что входной объект является ValueResult, и только T, поскольку ValueResult является объектом, отраженным от его исходного компонента. Связь типов не сравнивает, что было зарегистрировано с типом объекта, возвращаемого из обратного вызова маршрутизатора. Вместо этого он проверяет, является ли тип результата маршрута назначаемым для зарегистрированного типа. Регистрация обработчика типа Object приведет к тому, что все предыдущие непроверенные типы будут проигнорированы. Порядок вставки обработчиков значений также имеет значение, поэтому регистрация обработчика Object должна быть последней. Всегда регистрируйте конкретные обработчики значений сначала, чтобы обеспечить порядок. Router r = new Router(); r.SetObject(new UsersController()); r.RegisterValueHandler<bool>(bolVal => { HttpResponse res = new HttpResponse(); res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest; return res; }); r.RegisterValueHandler<IEnumerable>(enumerableValue => { return new HttpResponse(); // do something with enumerableValue here }); // регистрация обработчика значения объекта должна быть последней // значение-обработчик, который будет использоваться в качестве обратного вызова r.RegisterValueHandler<object>(fallback => { HttpResponse res = new HttpResponse(); res.Status = HttpStatusCode.OK; res.Content = JsonContent.Create(fallback); return res; });"
  },
  "docs/ru/fundamentals/routing.html": {
    "href": "docs/ru/fundamentals/routing.html",
    "title": "Маршрутизация | Sisk",
    "keywords": "Маршрутизация Маршрутизатор является первым шагом в построении сервера. Он отвечает за хранение объектов Route, которые являются конечными точками, сопоставляющими URL и их методы с действиями, выполняемыми сервером. Каждое действие отвечает за получение запроса и доставку ответа клиенту. Маршруты представляют собой пары выражений пути (\"шаблон пути\") и HTTP-метода, на который они могут реагировать. Когда сервер получает запрос, он попытается найти маршрут, соответствующий полученному запросу, а затем вызовет действие этого маршрута и доставит результирующий ответ клиенту. Существует несколько способов определить маршруты в Sisk: они могут быть статическими, динамическими или автоматически сканированными, определены атрибутами или直接 в объекте Маршрутизатора. Router mainRouter = new Router(); // сопоставляет GET / с следующим действием mainRouter.MapGet(\"/\", request => { return new HttpResponse(\"Привет, мир!\"); }); Чтобы понять, что может делать маршрут, нам нужно понять, что может делать запрос. Объект HttpRequest будет содержать все необходимое. Sisk также включает некоторые дополнительные функции, которые ускоряют общее развитие. Для каждого полученного сервером действия будет вызван делегат типа RouteAction. Этот делегат содержит параметр, который держит объект HttpRequest со всей необходимой информацией о полученном запросе. Результирующий объект от этого делегата должен быть либо HttpResponse, либо объектом, который сопоставляется с ним через неявные типы ответов. Сопоставление маршрутов Когда сервер получает запрос, Sisk ищет маршрут, удовлетворяющий выражению полученного пути. Это выражение всегда тестируется между маршрутом и путем запроса, без учета строки запроса. Этот тест не имеет приоритета и исключителен для одного маршрута. Когда нет маршрута, соответствующего этому запросу, возвращается ответ Router.NotFoundErrorHandler клиенту. Когда шаблон пути совпадает, но HTTP-метод не совпадает, возвращается ответ Router.MethodNotAllowedErrorHandler клиенту. Sisk проверяет возможность коллизий маршрутов, чтобы избежать этих проблем. Когда определяются маршруты, Sisk будет искать возможные маршруты, которые могут столкнуться с определяемым маршрутом. Этот тест включает проверку пути и метода, который маршрут установлен для приема. Создание маршрутов с помощью шаблонов пути Вы можете определить маршруты, используя различные методы SetRoute. // способ SetRoute mainRouter.SetRoute(RouteMethod.Get, \"/hey/<name>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); return new HttpResponse($\"Привет, {name}\"); }); // способ Map* mainRouter.MapGet(\"/form\", (request) => { var formData = request.GetFormData(); return new HttpResponse(); // пустой 200 ок }); // помощник методов Route.* mainRouter += Route.Get(\"/image.png\", (request) => { var imageStream = File.OpenRead(\"image.png\"); return new HttpResponse() { // содержимое StreamContent // поток будет удален после отправки // ответа. Content = new StreamContent(imageStream) }; }); // несколько параметров mainRouter.MapGet(\"/hey/<name>/surname/<surname>\", (request) => { string name = request.RouteParameters[\"name\"].GetString(); string surname = request.RouteParameters[\"surname\"].GetString(); return new HttpResponse($\"Привет, {name} {surname}!\"); }); Свойство RouteParameters объекта HttpResponse содержит всю информацию о переменных пути полученного запроса. Каждый полученный сервером путь нормализуется перед выполнением теста шаблона пути, следующим этими правилами: Все пустые сегменты удаляются из пути, например: ////foo//bar становится /foo/bar. Сопоставление пути чувствительно к регистру, если только Router.MatchRoutesIgnoreCase не установлен в true. Свойства Query и RouteParameters объекта HttpRequest возвращают объект StringValueCollection, где каждый индексированный свойство возвращает не-нулевой StringValue, который можно использовать как опцию/монаду для преобразования его сырого значения в управляемый объект. Пример ниже читает маршрутный параметр \"id\" и получает из него Guid. Если параметр не является допустимым Guid, выбрасывается исключение, и возвращается ошибка 500 клиенту, если сервер не обрабатывает Router.CallbackErrorHandler. mainRouter.SetRoute(RouteMethod.Get, \"/user/<id>\", (request) => { Guid id = request.RouteParameters[\"id\"].GetGuid(); }); Note Пути имеют игнорируемый завершающий / как в запросе, так и в пути маршрута, то есть если вы попытаетесь получить доступ к маршруту, определённому как /index/page, вы сможете получить доступ, используя /index/page/ тоже. Вы также можете принудительно завершать URL /, включив флаг ForceTrailingSlash. Создание маршрутов с помощью экземпляров классов Вы также можете определить маршруты динамически с помощью рефлексии и атрибута RouteAttribute. Таким образом, экземпляр класса, в котором его методы реализуют этот атрибут, будут иметь свои маршруты, определенные в целевом маршрутизаторе. Чтобы метод был определен как маршрут, он должен быть помечен атрибутом RouteAttribute, таким как сам атрибут или RouteGetAttribute. Метод может быть статическим, экземпляром, публичным или приватным. Когда используется метод SetObject(type) или SetObject<TType>(), методы экземпляра игнорируются. public class MyController { // будет соответствовать GET / [RouteGet] HttpResponse Index(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Index!\"); return res; } // статические методы также работают [RouteGet(\"/hello\")] static HttpResponse Hello(HttpRequest request) { HttpResponse res = new HttpResponse(); res.Content = new StringContent(\"Hello world!\"); return res; } } Строка ниже определит оба метода Index и Hello класса MyController как маршруты, поскольку они помечены как маршруты, и предоставлен экземпляр класса, а не его тип. Если бы был предоставлен его тип вместо экземпляра, были бы определены только статические методы. var myController = new MyController(); mainRouter.SetObject(myController); С версии Sisk 0.16 возможно включить AutoScan, который будет искать пользовательские классы, реализующие RouterModule, и автоматически ассоциировать их с маршрутизатором. Это не поддерживается с AOT-компиляцией. mainRouter.AutoScanModules<ApiController>(); Вышеуказанная инструкция будет искать все типы, которые реализуют ApiController, но не сам тип. Два необязательных параметра указывают, как метод будет искать эти типы. Первый аргумент подразумевает сборку, где будут искаться типы, а второй указывает, каким образом будут определены типы. Маршруты с помощью регулярных выражений Вместо использования методов сопоставления пути по умолчанию вы можете пометить маршрут как интерпретируемый с помощью регулярного выражения. Route indexRoute = new Route(RouteMethod.Get, @\"\\/[a-z]+\\/\", \"My route\", IndexPage, null); indexRoute.UseRegex = true; mainRouter.SetRoute(indexRoute); Или с помощью класса RegexRoute: RegexRoute indexRoute = new RegexRoute(RouteMethod.Get, @\"\\/[a-z]+\\/\", request => { return new HttpResponse(\"hello, world\"); }); mainRouter.SetRoute(indexRoute); Вы также можете захватить группы из шаблона регулярного выражения в содержимое HttpRequest.RouteParameters: [RegexRoute(RouteMethod.Get, @\"/uploads/(?<filename>.*\\.(jpeg|jpg|png))\")] static HttpResponse RegexRoute(HttpRequest request) { string filename = request.RouteParameters[\"filename\"].GetString(); return new HttpResponse().WithContent($\"Доступ к файлу {filename}\"); } Маршруты для любого метода Вы можете определить маршрут, который будет соответствовать только его пути и пропустит HTTP-метод. Это может быть полезно для проверки метода внутри маршрута. // будет соответствовать / на любой HTTP-метод mainRouter.SetRoute(RouteMethod.Any, \"/\", callbackFunction); Маршруты для любого пути Маршруты для любого пути тестируют любой путь, полученный HTTP-сервером, подлежащий маршруту метода. Если маршрут метода равен RouteMethod.Any и маршрут использует Route.AnyPath в его выражении пути, этот маршрут будет слушать все запросы от HTTP-сервера, и не могут быть определены другие маршруты. // следующий маршрут будет соответствовать всем запросам POST mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction); Игнорирование регистра при сопоставлении маршрутов По умолчанию интерпретация маршрутов с запросами чувствительна к регистру. Чтобы сделать его игнорируемым, включите эту опцию: mainRouter.MatchRoutesIgnoreCase = true; Это также включит опцию RegexOptions.IgnoreCase для маршрутов, где используется сопоставление с помощью регулярных выражений. Обработчик не найденного (404) обратного вызова Вы можете создать пользовательский обратный вызов для случая, когда запрос не соответствует ни одному известному маршруту. mainRouter.NotFoundErrorHandler = () => { return new HttpResponse(404) { // С версии v0.14 Content = new HtmlContent(\"<h1>Не найдено</h1>\") // более старые версии Content = new StringContent(\"<h1>Не найдено</h1>\", Encoding.UTF8, \"text/html\") }; }; Обработчик метода не допускается (405) обратного вызова Вы также можете создать пользовательский обратный вызов для случая, когда запрос соответствует его пути, но не соответствует методу. mainRouter.MethodNotAllowedErrorHandler = (context) => { return new HttpResponse(405) { Content = new StringContent($\"Метод не допускается для этого маршрута.\") }; }; Обработчик внутренней ошибки Обратные вызовы маршрутов могут выбрасывать ошибки во время выполнения сервера. Если они не обрабатываются правильно, общая работа HTTP-сервера может быть прервана. Маршрутизатор имеет обратный вызов для случая, когда обратный вызов маршрута не удался и предотвращает прерывание обслуживания. Этот метод доступен только тогда, когда ThrowExceptions установлен в false. mainRouter.CallbackErrorHandler = (ex, context) => { return new HttpResponse(500) { Content = new StringContent($\"Ошибка: {ex.Message}\") }; };"
  },
  "docs/ru/getting-started.html": {
    "href": "docs/ru/getting-started.html",
    "title": "Начало работы с Sisk | Sisk",
    "keywords": "Начало работы с Sisk Sisk может работать в любой среде .NET. В этом руководстве мы научим вас, как создать приложение Sisk с использованием .NET. Если вы еще не установили его, пожалуйста, скачайте SDK с сюда. В этом учебнике мы расскажем, как создать структуру проекта, получить запрос, получить параметр URL и отправить ответ. Это руководство будет сосредоточено на построении простого сервера с использованием C#. Вы также можете использовать свой любимый язык программирования. Note Вам может быть интересно начать с проекта быстрого старта. Проверьте этот репозиторий для получения дополнительной информации. Создание проекта Давайте назовем наш проект \"Мое приложение Sisk\". Как только у вас будет настроена среда .NET, вы можете создать свой проект с помощью следующей команды: dotnet new console -n my-sisk-application Далее перейдите в каталог вашего проекта и установите Sisk с помощью утилиты .NET: cd my-sisk-application dotnet add package Sisk.HttpServer Вы можете найти дополнительные способы установки Sisk в вашем проекте здесь. Теперь давайте создадим экземпляр нашего веб-сервера. В этом примере мы настроим его на прослушивание порта 5000. Построение веб-сервера Sisk позволяет вам строить свое приложение шаг за шагом вручную, поскольку оно маршрутизируется к объекту HttpServer. Однако это может быть не очень удобно для большинства проектов. Поэтому мы можем использовать метод построения, который упрощает запуск нашего приложения. Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://localhost:5000/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } } Важно понять каждый важный компонент Sisk. Позже в этом документе вы узнаете больше о том, как работает Sisk. Ручная (расширенная) настройка Вы можете узнать, как работает каждый механизм Sisk в этом разделе документации, который объясняет поведение и отношения между HttpServer, Router, ListeningPort и другими компонентами."
  },
  "docs/ru/installing.html": {
    "href": "docs/ru/installing.html",
    "title": "Установка | Sisk",
    "keywords": "Установка Вы можете установить Sisk через Nuget, dotnet cli или другие варианты. Вы можете легко настроить среду Sisk, выполнив эту команду в консоли разработчика: Warning Последние версии Sisk совместимы с .NET 8 и скоро .NET 9. Устаревшие версии Sisk для .NET 6 и .NET 7 будут поддерживаться до 30 ноября 2024 года, получая только исправления безопасности и исправления в ветке \"legacy\". Пожалуйста, обновите свои проекты, использующие Sisk, до .NET 8. dotnet add package Sisk.HttpServer Эта команда установит последнюю версию Sisk в вашем проекте."
  },
  "docs/ru/native-aot.html": {
    "href": "docs/ru/native-aot.html",
    "title": "Поддержка Native AOT | Sisk",
    "keywords": "Поддержка Native AOT В .NET 7 была введена Native AOT, режим компиляции .NET, который позволяет экспортировать готовые бинарные файлы на любой поддерживаемой платформе, без необходимости установки среды выполнения .NET на целевой машине. С помощью Native AOT ваш код компилируется в родной код и уже содержит все необходимое для его выполнения. Sisk экспериментирует с этой функцией с версии 0.9.1, которая улучшает поддержку Native AOT с функциями определения динамических маршрутов по приложению без влияния на компиляцию предупреждающими сообщениями. Sisk использует рефлексию для получения методов, которые будут определены из типов и объектов. Кроме того, Sisk использует рефлексию для атрибутов, таких как RequestHandlerAttribute, которые инициализируются из типа. Для правильной работы компиляции AOT используется обрезка, где динамические типы должны быть указаны, что будет использовано в окончательном сборке. Рассмотрим пример ниже, это маршрут, который вызывает RequestHandler. [Route(RouteMethod.Get, \"/\", LogMode = LogOutput.None)] [RequestHandler(typeof(MyRequestHandler))] static HttpResponse IndexPage(HttpRequest request) { HttpResponse htmlResponse = new HttpResponse(); htmlResponse.Content = new StringContent(\"Hello, world!\", System.Text.Encoding.UTF8, \"text/plain\"); return htmlResponse; } Этот RequestHandler динамически вызывается во время выполнения, и этот вызов должен быть разделен, и это разделение должно быть явным. Чтобы лучше понять, что компилятор будет учитывать из MyRequestHandler, должно быть сохранено в окончательной компиляции: Публичные свойства; Публичные и приватные поля; Публичные и приватные конструкторы; Публичные и приватные методы; Все, что у вас есть в RequestHandler, что не упоминается выше, будет удалено компилятором. Помните, что все остальные компоненты, классы и пакеты, которые вы используете в своем приложении, должны быть совместимы с AOT Trimming, или ваш код не будет работать так, как ожидается. Тем не менее, Sisk не оставит вас, если вы хотите построить что-то, где производительность является приоритетом. Вы можете прочитать больше о Native AOT и том, как она работает в официальной документации Microsoft."
  },
  "docs/ru/registering-namespace.html": {
    "href": "docs/ru/registering-namespace.html",
    "title": "Настройка резервирования пространств имен в Windows | Sisk",
    "keywords": "Настройка резервирования пространств имен в Windows Sisk работает с сетевым интерфейсом HttpListener, который связывает виртуальный хост с системой для прослушивания запросов. В Windows это связывание немного ограничено, разрешая связывать только localhost в качестве допустимого хоста. При попытке прослушивать другой хост на сервере возникает ошибка доступа. Это руководство объясняет, как предоставить авторизацию для прослушивания на любом хосте, который вы хотите на системе. Namespace Setup.bat BATCH @echo off :: вставьте префикс здесь, без пробелов или кавычек SET PREFIX= SET DOMAIN=%ComputerName%\\%USERNAME% netsh http add urlacl url=%PREFIX% user=%DOMAIN% pause Где в PREFIX находится префикс (\"Хост->Порт прослушивания\"), который будет прослушивать ваш сервер. Он должен быть отформатирован по схеме URL, хосту, порту и слэшу в конце, например: Namespace Setup.bat BATCH SET PREFIX=http://my-application.example.test/ Таким образом, вы можете прослушивать в вашем приложении через: Program.cs C# class Program { static async Task Main(string[] args) { using var app = HttpServer.CreateBuilder() .UseListeningPort(\"http://my-application.example.test/\") .Build(); app.Router.MapGet(\"/\", request => { return new HttpResponse() { Status = 200, Content = new StringContent(\"Hello, world!\") }; }); await app.StartAsync(); } }"
  },
  "docs/ru/ssl.html": {
    "href": "docs/ru/ssl.html",
    "title": "Работа с SSL | Sisk",
    "keywords": "Работа с SSL Работа с SSL при разработке может быть необходима в контекстах, требующих безопасности, таких как большинство сценариев веб-разработки. Sisk работает поверх HttpListener, который не поддерживает родной HTTPS, только HTTP. Однако существуют обходные пути, которые позволяют работать с SSL в Sisk. См. их ниже: Через IIS на Windows Доступно на: Windows Уровень сложности: средний Если вы находитесь на Windows, вы можете использовать IIS для включения SSL на вашем HTTP-сервере. Для этого рекомендуется следовать этому учебнику заранее, если вы хотите, чтобы ваше приложение слушало хост, отличный от \"localhost\". Для этого необходимо установить IIS через функции Windows. IIS доступен бесплатно для пользователей Windows и Windows Server. Чтобы настроить SSL в вашем приложении, необходимо иметь сертификат SSL, даже если он самоподписанный. Далее вы можете увидеть как настроить SSL на IIS 7 или выше. Через mitmproxy Доступно на: Linux, macOS, Windows Уровень сложности: легкий mitmproxy - это инструмент перехвата прокси, который позволяет разработчикам и тестировщикам безопасности осматривать, изменять и записывать HTTP- и HTTPS-трафик между клиентом (таким как веб-браузер) и сервером. Вы можете использовать утилиту mitmdump, чтобы начать обратный SSL-прокси между вашим клиентом и приложением Sisk. Сначала установите mitmproxy на вашем компьютере. Запустите ваше приложение Sisk. Для этого примера мы будем использовать порт 8000 в качестве не安全ного HTTP-порта. Запустите сервер mitmproxy, чтобы слушать безопасный порт на 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 И вы готовы! Вы уже можете обращаться к вашему приложению через https://localhost:8001/. Вашему приложению не нужно запускаться, чтобы начать mitmdump. Через пакет Sisk.SslProxy Доступно на: Linux, macOS, Windows Уровень сложности: легкий Пакет Sisk.SslProxy - это простой способ включить SSL на вашем приложении Sisk. Однако это крайне экспериментальный пакет. Он может быть нестабильным для работы с этим пакетом, но вы можете быть частью небольшого процента людей, которые будут вносить вклад в то, чтобы этот пакет был жизнеспособным и стабильным. Чтобы начать, вы можете установить пакет Sisk.SslProxy с: dotnet add package Sisk.SslProxy Note Вам необходимо включить \"Enable pre-release packages\" в Visual Studio Package Manger, чтобы установить Sisk.SslProxy. Опять же, это экспериментальный проект, поэтому даже не думайте о том, чтобы использовать его в производстве. На данный момент Sisk.SslProxy может обрабатывать большинство функций HTTP/1.1, включая HTTP Continue, Chunked-Encoding, WebSockets и SSE. Читайте больше о SslProxy здесь."
  },
  "docs/ssl.html": {
    "href": "docs/ssl.html",
    "title": "Working with SSL | Sisk",
    "keywords": "Working with SSL Working with SSL for development may be necessary when working in contexts that require security, such as most web development scenarios. Sisk operates on top of HttpListener, which does not support native HTTPS, only HTTP. However, there are workarounds that allow you to work with SSL in Sisk. See them below: Through IIS on Windows Available on: Windows Effort: medium If you are on Windows, you can use IIS to enable SSL on your HTTP server. For this to work, it is advisable that you follow this tutorial beforehand if you want your application to be listening on a host other than \"localhost.\" For this to work, you must install IIS through Windows features. IIS is available for free to Windows and Windows Server users. To configure SSL in your application, have the SSL certificate ready, even if it is self-signed. Next, you can see how to set up SSL on IIS 7 or higher. Through mitmproxy Available on: Linux, macOS, Windows Effort: easy mitmproxy is an interception proxy tool that allows developers and security testers to inspect, modify, and record HTTP and HTTPS traffic between a client (such as a web browser) and a server. You can use the mitmdump utility to start an reverse SSL proxy between your client and your Sisk application. Firstly, install the mitmprxy in your machine. Start your Sisk application. For this example, we'll use the 8000 port as the insecure HTTP port. Start the mitmproxy server to listen the secure port at 8001: mitmdump --mode reverse:http://localhost:8000/ -p 8001 And you're ready to go! You can already your application through https://localhost:8001/. Your application does not need to be running for you to start mitmdump. Through Sisk.SslProxy package Available on: Linux, macOS, Windows Effort: easy The Sisk.SslProxy package is a simple way to enable SSL on your Sisk application. However, it is an extremely experimental package. It may be unstable to work with this package, but you can be part of the small percentage of people who will contribute to making this package viable and stable. To get started, you can install the Sisk.SslProxy package with: dotnet add package Sisk.SslProxy Note You must enable \"Enable pre-release packages\" in the Visual Studio Package Manger to install Sisk.SslProxy. Again, it is an experimental project, so don't even think about putting it into production. At the moment, Sisk.SslProxy can handle most HTTP/1.1 features, including HTTP Continue, Chunked-Encoding, WebSockets, and SSE. Read more about SslProxy here."
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome! | Sisk",
    "keywords": "Welcome! Welcome to the Sisk Framework! This project was initially created to explore the capabilities of the native .NET HttpListener and has gradually evolved into a more commercially oriented framework as I began applying it to personal and commercial projects. What is Sisk? Sisk is a lightweight, agnostic, simple, and robust web development framework. Its core idea is to create a service that runs on the internet, following the patterns you define. Moreover, Sisk adapts to your preferred working style, rather than the other way around. Due to its explicit nature, Sisk's behavior is predictable. The main differentiator from ASP.NET is that Sisk can be up and running with very few lines of code, avoiding unnecessary configurations and requiring minimal setup to get your server operational. Additionally, it does not require any additional .NET SDK packages for development, as the base package of .NET 6 is sufficient to start working with Sisk. Sisk's philosophy emphasizes simplicity and provides all the essential tools for building cloud applications without relying on specific or proprietary technologies from other companies. However, the Sisk environment allows for the implementation of both proprietary and non-proprietary technologies, enabling their use, development, and support within the framework. Furthermore, the term \"framework\" refers to the collection of methods, tools, and libraries that make Sisk a complete web development ecosystem. Contributions must adhere to this philosophy and maintain readable, maintainable code that anyone with a basic understanding can read, maintain, and compile. Sisk has a strict policy of transparency in its code. All technologies used to build Sisk must be open source, traceable, maintainable, and compilable, allowing anyone to edit, view, and create their own version of Sisk. What is Sisk for? With Sisk, you can create RESTful applications, gRPC services, WebSockets, file servers, GraphQL APIs, Entity Framework integrations, and more—essentially, whatever you need. Sisk is an extremely modular and sustainable framework. Its current development is intense, with much more to be added, but the focus remains on keeping it simple, easy to maintain, and enjoyable for developers working on projects of any size. Sisk has also been tested in low-performance environments, such as machines with less than 1GB of RAM, handling over 20,000 requests per second. The code, from the moment it arrives on the server to the response sent back, is extremely concise, with very few steps before reaching the client. One of the pillars of developing with Sisk is its compatibility with any machine that supports .NET, including those that do not require Native AOT. Additional implementations are also provided within the Sisk ecosystem, such as porting projects to other machines using configuration files and a view engine based on LISP, among others, served with packages beyond the core Sisk package. By design, Sisk is built to work with routers, but you are not obligated to use them. Sisk provides all the necessary infrastructure to create a secure application without obfuscating your code. There's no need for excessive ceremony, fluff, or spending hours on tedious documentation. Sisk is simple and elegant in its syntax, facilitating the development of fast and complex systems. But why not just use ASP.NET? ASP.NET is a great and well-established web framework, and many features present in Sisk were inspired by it. However, Sisk focuses on simpler and more performant development, eliminating the need to install additional components in your system, project, or editor. Sisk was designed to be straightforward and robust, enabling you to create anything you desire. Moreover, its development model allows you to choose how you want to work. You can handle requests in a simple, efficient, explicit, and fast manner. A basic understanding of HTTP is required if you want to manage everything manually, but even then, Sisk can greatly simplify the process with the functions it provides in its core package. Getting started with Sisk is easy. Those with prior web development experience typically learn Sisk in one or two days. The Sisk documentation is a valuable resource, serving not just as a specification but as a complete manual with examples and support. You can get started with Sisk here. Let's get started with Sisk."
  },
  "readme.html": {
    "href": "readme.html",
    "title": "Sisk Documentation | Sisk",
    "keywords": "Sisk Documentation This repository contains the source code of the Sisk Documentation website. Building Firstly, make sure you have docfx installed in your machine. You'll need .NET SDK to install it. Clone this repository. Build the Sisk Framework project and put the .DLL binaries and XML documentation file at the ref/ directory, on the repository root. Run docfx, then docfx serve. Warning Please, do not use the docfx version 2.78.0 or later. This version has a bug that changes the documentation navigation layout. See the tracking issue. Prefer the version 2.76.0: dotnet tool install -g docfx --version 2.76.0 Then you're ready to go and you'll have the static website files at /_site. Contributing Contributions are always welcome. Contribute with spelling corrections, fixing broken links and more. Note Please do not edit API specification files (XML). These files are generated. If you want to edit any API documentation, edit it in the repository where the code is hosted."
  }
}