<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Antworten | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Antworten | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/de/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="antworten">Antworten</h1>

<p>Antworten stellen Objekte dar, die HTTP-Antworten auf HTTP-Anfragen sind. Sie werden vom Server an den Client gesendet, um die Anfrage nach einer Ressource, Seite, Dokument, Datei oder einem anderen Objekt anzuzeigen.</p>
<p>Eine HTTP-Antwort besteht aus Status, Headern und Inhalt.</p>
<p>In diesem Dokument erfahren Sie, wie Sie HTTP-Antworten mit Sisk entwerfen.</p>
<h2 id="festlegen-eines-http-status">Festlegen eines HTTP-Status</h2>
<p>Die Liste der HTTP-Statuscodes ist seit HTTP/1.0 gleich und Sisk unterstützt alle davon.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; //202
</code></pre>
<p>Oder mit Fluent-Syntax:</p>
<pre><code class="lang-cs">new HttpResponse()
 .WithStatus(200) // oder
 .WithStatus(HttpStatusCode.Ok) // oder
 .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Sie können die vollständige Liste der verfügbaren HttpStatusCode <a href="https://learn.microsoft.com/de-de/dotnet/api/system.net.httpstatuscode">hier</a> sehen. Sie können auch Ihren eigenen Statuscode mithilfe der <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>-Struktur bereitstellen.</p>
<h2 id="body-und-content-type">Body und Content-Type</h2>
<p>Sisk unterstützt .NET-Inhalte Objekte, um den Body in Antworten zu senden. Sie können die <a href="https://learn.microsoft.com/de-de/dotnet/api/system.net.http.stringcontent">StringContent</a>-Klasse verwenden, um beispielsweise eine JSON-Antwort zu senden:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>Der Server versucht immer, die <code>Content-Length</code> aus dem zu definieren, was Sie im Inhalt definiert haben, wenn Sie es nicht explizit in einem Header definiert haben. Wenn der Server den Content-Length-Header nicht implizit aus dem Antwortinhalt abrufen kann, wird die Antwort mit Chunked-Encoding gesendet.</p>
<p>Sie können die Antwort auch streamen, indem Sie einen <a href="https://learn.microsoft.com/de-de/dotnet/api/system.net.http.streamcontent">StreamContent</a> senden oder die Methode <a href="/api/Sisk.Core.Http.HttpRequest.GetResponseStream">GetResponseStream</a> verwenden.</p>
<h2 id="antwort-header">Antwort-Header</h2>
<p>Sie können Header hinzufügen, bearbeiten oder entfernen, die Sie in der Antwort senden. Das folgende Beispiel zeigt, wie Sie eine Umleitungsantwort an den Client senden.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>Oder mit Fluent-Syntax:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Wenn Sie die <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a>-Methode von HttpHeaderCollection verwenden, fügen Sie einen Header zur Anfrage hinzu, ohne die bereits gesendeten zu ändern. Die <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a>-Methode ersetzt die Header mit demselben Namen durch den angegebenen Wert. Der Index von HttpHeaderCollection ruft intern die Set-Methode auf, um die Header zu ersetzen.</p>
<h2 id="senden-von-cookies">Senden von Cookies</h2>
<p>Sisk verfügt über Methoden, die die Definition von Cookies auf dem Client erleichtern. Cookies, die mit dieser Methode gesetzt werden, sind bereits URL-kodiert und entsprechen dem RFC-6265-Standard.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;);
</code></pre>
<p>Oder mit Fluent-Syntax:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Es gibt andere <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">vollständigere Versionen</a> derselben Methode.</p>
<h2 id="chunked-antworten">Chunked-Antworten</h2>
<p>Sie können die Übertragungskodierung auf chunked setzen, um große Antworten zu senden.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>Bei Verwendung von Chunked- Encoding wird der Content-Length-Header automatisch weggelassen.</p>
<h2 id="antwortstrom">Antwortstrom</h2>
<p>Antwortströme sind eine verwaltete Möglichkeit, die es Ihnen ermöglicht, Antworten auf eine segmentierte Weise zu senden. Es handelt sich um eine Ebene tiefer als die Verwendung von HttpResponse-Objekten, da sie erfordern, dass Sie die Header und Inhalte manuell senden und dann die Verbindung schließen.</p>
<p>Dieses Beispiel öffnet einen schreibgeschützten Strom für die Datei, kopiert den Strom in den Antwortausgabestrom und lädt die gesamte Datei nicht in den Speicher. Dies kann nützlich sein, um mittelgroße oder große Dateien zu bedienen.</p>
<pre><code class="lang-cs">// erhält den Antwortausgabestrom
using var fileStream = File.OpenRead(&quot;my-big-file.zip&quot;);
var responseStream = request.GetResponseStream();

// setzt die Antwortkodierung auf chunked-encoding
// auch sollten Sie den Content-Length-Header nicht senden, wenn Sie chunked-encoding verwenden
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// kopiert den Dateistream in den Antwortausgabestrom
fileStream.CopyTo(responseStream.ResponseStream);

// schließt den Strom
return responseStream.Close();
</code></pre>
<h2 id="gzip--deflate--und-brotli-komprimierung">GZip-, Deflate- und Brotli-Komprimierung</h2>
<p>Sie können Antworten mit komprimierten Inhalten in Sisk senden, indem Sie HTTP-Inhalte komprimieren. Zuerst kapseln Sie Ihr <a href="https://learn.microsoft.com/de-de/dotnet/api/system.net.http.httpcontent">HttpContent</a>-Objekt in eines der untenstehenden Kompressoren, um die komprimierte Antwort an den Client zu senden.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
 string myHtml = &quot;...&quot;;
    
 return new HttpResponse () {
 Content = new GZipContent(new HtmlContent(myHtml)),
 // oder Content = new BrotliContent(new HtmlContent(myHtml)),
 // oder Content = new DeflateContent(new HtmlContent(myHtml)),
 };
});
</code></pre>
<p>Sie können diese komprimierten Inhalte auch mit Strömen verwenden.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
 // verwenden Sie hier nicht &quot;using&quot;. Der HttpServer verwirft Ihren Inhalt
 // nachdem er die Antwort gesendet hat.
 var archive = File.OpenRead(&quot;/path/to/big-file.zip&quot;);
    
 return new HttpResponse () {
 Content = new GZipContent(archive)
 }
});
</code></pre>
<p>Die Content-Encoding-Header werden automatisch gesetzt, wenn diese Inhalte verwendet werden.</p>
<h2 id="automatische-komprimierung">Automatische Komprimierung</h2>
<p>Es ist möglich, HTTP-Antworten mit der <a href="/api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression">EnableAutomaticResponseCompression</a>-Eigenschaft automatisch zu komprimieren. Diese Eigenschaft kapselt den Antwortinhalt vom Router automatisch in einen komprimierbaren Inhalt, der von der Anfrage akzeptiert wird, vorausgesetzt, die Antwort wird nicht von einem <a href="/api/Sisk.Core.Http.CompressedContent">CompressedContent</a> geerbt.</p>
<p>Nur ein komprimierbarer Inhalt wird für eine Anfrage ausgewählt, die gemäß der Accept-Encoding-Header, die der Reihe nach folgt:</p>
<ul>
<li><a href="/api/Sisk.Core.Http.BrotliContent">BrotliContent</a> (br)</li>
<li><a href="/api/Sisk.Core.Http.GZipContent">GZipContent</a> (gzip)</li>
<li><a href="/api/Sisk.Core.Http.DeflateContent">DeflateContent</a> (deflate)</li>
</ul>
<p>Wenn die Anfrage angibt, dass sie eine dieser Komprimierungsmethoden akzeptiert, wird die Antwort automatisch komprimiert.</p>
<h2 id="implizite-antworttypen">Implizite Antworttypen</h2>
<p>Sie können andere Rückgabetypen als HttpResponse verwenden, aber es ist notwendig, den Router zu konfigurieren, wie er jeden Objekttyp behandelt.</p>
<p>Das Konzept besteht darin, immer einen Referenztyp zurückzugeben und ihn in ein gültiges HttpResponse-Objekt umzuwandeln. Routen, die HttpResponse zurückgeben, unterliegen keiner Umwandlung.</p>
<p>Wertetypen (Strukturen) können nicht als Rückgabetyp verwendet werden, da sie nicht mit dem <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a> kompatibel sind. Daher müssen sie in ein ValueResult gekapselt werden, um in Handhabern verwendet werden zu können.</p>
<p>Betrachten Sie das folgende Beispiel eines Router-Moduls, das nicht HttpResponse im Rückgabetyp verwendet:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
 public List&lt;User&gt; Users = new List&lt;User&gt;();

 [RouteGet]
 public IEnumerable&lt;User&gt; Index(HttpRequest request)
 {
 return Users.ToArray();
 }

 [RouteGet(&quot;&lt;id&gt;&quot;)]
 public User View(HttpRequest request)
 {
 int id = request.RouteParameters[&quot;id&quot;].GetInteger();
 User dUser = Users.First(u =&gt; u.Id == id);

 return dUser;
 }

 [RoutePost]
 public ValueResult&lt;bool&gt; Create(HttpRequest request)
 {
 User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
 Users.Add(fromBody);
        
 return true;
 }
}
</code></pre>
<p>Damit muss nun im Router definiert werden, wie er mit jedem Objekttyp umgeht. Objekte sind immer das erste Argument des Handlers und der Ausgabetyp muss ein gültiges HttpResponse sein. Außerdem sollten die Ausgabeobjekte einer Route niemals null sein.</p>
<p>Für ValueResult-Typen ist es nicht notwendig, anzugeben, dass das Eingabeobjekt ein ValueResult ist und nur T, da ValueResult ein Objekt ist, das von seiner ursprünglichen Komponente reflektiert wird.</p>
<p>Die Zuordnung von Typen vergleicht nicht, was registriert wurde, mit dem Typ des Objekts, das vom Router-Callback zurückgegeben wird. Stattdessen prüft es, ob der Typ des Router-Ergebnisses dem registrierten Typ zuweisbar ist.</p>
<p>Das Registrieren eines Handlers vom Typ Object wird auf alle zuvor nicht validierten Typen zurückgeführt. Die Einfügereihenfolge der Wert-Handler spielt auch eine Rolle, daher sollten Sie zuerst bestimmte Wert-Handler registrieren, um die Reihenfolge sicherzustellen.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;ApiResult&gt;(apiResult =&gt;
{
 return new HttpResponse() {
 Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest,
 Content = apiResult.GetHttpContent(),
 Headers = apiResult.GetHeaders()
 };
});
r.RegisterValueHandler&lt;bool&gt;(bvalue =&gt;
{
 return new HttpResponse() {
 Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest
 };
});
r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(enumerableValue =&gt;
{
 return new HttpResponse(string.Join(&quot;\n&quot;, enumerableValue));
});

// das Registrieren eines Wert-Handlers vom Typ Object muss das letzte sein
// Wert-Handler, der als Fallback verwendet wird
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
 return new HttpResponse() {
 Status = HttpStatusCode.OK,
 Content = JsonContent.Create(fallback)
 };
});
</code></pre>
<h2 id="hinweis-zu-enumerable-objekten-und-arrays">Hinweis zu enumerable Objekten und Arrays</h2>
<p>Implizite Antwortobjekte, die <a href="https://learn.microsoft.com/de-de/dotnet/api/system.collections.ienumerable?view=net-8.0">IEnumerable</a> implementieren, werden durch die <code>ToArray()</code>-Methode in den Speicher gelesen, bevor sie durch einen definierten Wert-Handler umgewandelt werden. Damit dies geschieht, wird das <code>IEnumerable</code>-Objekt in ein Array von Objekten umgewandelt, und der Antwortkonverter empfängt immer ein <code>Object[]</code> anstelle des ursprünglichen Typs.</p>
<p>Betrachten Sie das folgende Szenario:</p>
<pre><code class="lang-csharp">using var host = HttpServer.CreateBuilder(12300)
 .UseRouter(r =&gt;
 {
 r.RegisterValueHandler&lt;IEnumerable&lt;string&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;String-Array:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Objekt-Array:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.MapGet(&quot;/&quot;, request =&gt;
 {
 return (IEnumerable&lt;string&gt;)[&quot;hello&quot;, &quot;world&quot;];
 });
 })
 .Build();
</code></pre>
<p>Im obigen Beispiel wird der <code>IEnumerable&lt;string&gt;</code>-Konverter <strong>nie aufgerufen</strong>, da das Eingabeobjekt immer ein <code>Object[]</code> ist und nicht in ein <code>IEnumerable&lt;string&gt;</code> umgewandelt werden kann. Der Konverter unten, der ein <code>IEnumerable&lt;object&gt;</code> empfängt, empfängt jedoch seine Eingabe, da sein Wert kompatibel ist.</p>
<p>Wenn Sie den Typ des Objekts, das enumeriert wird, tatsächlich verarbeiten müssen, müssen Sie die Reflexion verwenden, um den Typ des SammlungsElements zu erhalten. Alle enumerable Objekte (Listen, Arrays und Sammlungen) werden durch den HTTP-Antwortkonverter in ein Array von Objekten umgewandelt.</p>
<p>Werte, die <a href="https://learn.microsoft.com/de-de/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0">IAsyncEnumerable</a> implementieren, werden automatisch vom Server behandelt, wenn die <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable">ConvertIAsyncEnumerableIntoEnumerable</a>-Eigenschaft aktiviert ist, ähnlich wie bei <code>IEnumerable</code>. Eine asynchrone Enumeration wird in einen blockierenden Enumerator umgewandelt und dann in ein synchrones Array von Objekten umgewandelt.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/de/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>