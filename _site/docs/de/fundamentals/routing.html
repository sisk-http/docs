<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Routing | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Routing | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/de/fundamentals/routing.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>
                    <div class="actionbar-actions">
                        <div id="language-wrapper">
                            <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                                <i class="bi bi-globe"></i>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                        <img src="/assets/flag/usa.png">
                                        English
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                        <img src="/assets/flag/russia.png">
                                        Русский
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                        <img src="/assets/flag/brazil.png">
                                        Português
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                        <img src="/assets/flag/spain.png">
                                        Español
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                        <img src="/assets/flag/germany.png">
                                        Deutsch
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                        <img src="/assets/flag/china.png">
                                        中文 (简体)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                        <img src="/assets/flag/japan.png">
                                        日本語
                                    </a>
                                </li>
                            </ul>
                        </div>

                        <div id="copy-article-wrapper">
                            <a class="btn border-0" id="copy-article-btn" title="Copy article">
                                <i class="bi bi-copy"></i>
                            </a>
                            <div class="copy-dropdown" id="copy-dropdown">
                                <button type="button" id="copy-text-btn">
                                    <i class="bi bi-file-text"></i>
                                    Copy as text
                                </button>
                                <button type="button" id="copy-markdown-btn">
                                    <i class="bi bi-markdown"></i>
                                    Copy as Markdown
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <article data-uid="">
<h1 id="routing">Routing</h1>

<p>Der <a href="/api/Sisk.Core.Routing.Router">Router</a> ist der erste Schritt beim Aufbau des Servers. Er ist verantwortlich für die Verwaltung von <a href="/api/Sisk.Core.Routing.Route">Route</a>-Objekten, die Endpunkte sind, die URLs und ihre Methoden mit Aktionen verknüpfen, die vom Server ausgeführt werden. Jede Aktion ist verantwortlich für das Empfangen einer Anfrage und das Liefern einer Antwort an den Client.</p>
<p>Die Routen sind Paare von Pfad-Ausdrücken (&quot;Pfadmuster&quot;) und der HTTP-Methode, auf die sie hören können. Wenn eine Anfrage an den Server gestellt wird, wird er versuchen, eine Route zu finden, die der erhaltenen Anfrage entspricht, und dann die Aktion dieser Route aufrufen und die resultierende Antwort an den Client liefern.</p>
<p>Es gibt mehrere Möglichkeiten, Routen in Sisk zu definieren: Sie können statisch, dynamisch oder auto-gescannt, durch Attribute definiert oder direkt im Router-Objekt definiert werden.</p>
<pre><code class="lang-cs">Router mainRouter = new Router();

// ordnet die GET /-Route der folgenden Aktion zu
mainRouter.MapGet(&quot;/&quot;, request =&gt; {
    return new HttpResponse(&quot;Hallo, Welt!&quot;);
});
</code></pre>
<p>Um zu verstehen, was eine Route tun kann, müssen wir verstehen, was eine Anfrage tun kann. Ein <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> enthält alles, was Sie benötigen. Sisk enthält auch einige zusätzliche Funktionen, die die Gesamtentwicklung beschleunigen.</p>
<p>Für jede Aktion, die vom Server empfangen wird, wird ein Delegat vom Typ <a href="/api/Sisk.Core.Routing.RouteAction">RouteAction</a> aufgerufen. Dieser Delegat enthält ein Parameter, das ein <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> mit allen notwendigen Informationen über die vom Server empfangene Anfrage enthält. Das resultierende Objekt aus diesem Delegaten muss ein <a href="/api/Sisk.Core.Http.HttpResponse">HttpResponse</a> oder ein Objekt sein, das durch <a href="/docs/de/fundamentals/responses#implizite-antworttypen">implizite Antworttypen</a> zugeordnet werden kann.</p>
<h2 id="übereinstimmende-routen">Übereinstimmende Routen</h2>
<p>Wenn eine Anfrage an den HTTP-Server gestellt wird, sucht Sisk nach einer Route, die den Ausdruck des empfangenen Pfads erfüllt. Der Ausdruck wird immer zwischen der Route und dem Anfragepfad getestet, ohne die Abfragezeichenfolge zu berücksichtigen.</p>
<p>Dieser Test hat keine Priorität und ist exklusiv für eine einzelne Route. Wenn keine Route mit dieser Anfrage übereinstimmt, wird die <a href="/api/Sisk.Core.Routing.Router.NotFoundErrorHandler">Router.NotFoundErrorHandler</a>-Antwort an den Client zurückgegeben. Wenn der Pfad-Ausdruck übereinstimmt, aber die HTTP-Methode nicht übereinstimmt, wird die <a href="/api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler">Router.MethodNotAllowedErrorHandler</a>-Antwort an den Client zurückgegeben.</p>
<p>Sisk überprüft die Möglichkeit von Routen-Kollisionen, um diese Probleme zu vermeiden. Wenn Routen definiert werden, sucht Sisk nach möglichen Routen, die mit der definierten Route kollidieren könnten. Dieser Test umfasst die Überprüfung des Pfads und der Methode, die die Route akzeptieren soll.</p>
<h3 id="erstellen-von-routen-mit-pfadmustern">Erstellen von Routen mit Pfadmustern</h3>
<p>Sie können Routen mit verschiedenen <code>SetRoute</code>-Methoden definieren.</p>
<pre><code class="lang-cs">// SetRoute-Methode
mainRouter.SetRoute(RouteMethod.Get, &quot;/hey/&lt;name&gt;&quot;, (request) =&gt;
{
    string name = request.RouteParameters[&quot;name&quot;].GetString();
    return new HttpResponse($&quot;Hallo, {name}&quot;);
});

// Map*-Methode
mainRouter.MapGet(&quot;/form&quot;, (request) =&gt;
{
    var formData = request.GetFormData();
    return new HttpResponse(); // leerer 200-OK
});

// Route.*-Hilfsmethoden
mainRouter += Route.Get(&quot;/image.png&quot;, (request) =&gt;
{
    var imageStream = File.OpenRead(&quot;image.png&quot;);
    
    return new HttpResponse()
    {
        // der StreamContent-Inner
        // Stream wird nach dem Senden
        // der Antwort verworfen.
        Content = new StreamContent(imageStream)
    };
});

// mehrere Parameter
mainRouter.MapGet(&quot;/hey/&lt;name&gt;/surname/&lt;surname&gt;&quot;, (request) =&gt;
{
    string name = request.RouteParameters[&quot;name&quot;].GetString();
    string surname = request.RouteParameters[&quot;surname&quot;].GetString();

    return new HttpResponse($&quot;Hallo, {name} {surname}!&quot;);
});
</code></pre>
<p>Die <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">RouteParameters</a>-Eigenschaft von HttpResponse enthält alle Informationen über die Pfadvariablen der empfangenen Anfrage.</p>
<p>Jeder Pfad, der vom Server empfangen wird, wird vor dem Pfad-Ausdruck-Test normalisiert, indem die folgenden Regeln angewendet werden:</p>
<ul>
<li>Alle leeren Segmente werden aus dem Pfad entfernt, z. B. <code>////foo//bar</code> wird zu <code>/foo/bar</code>.</li>
<li>Pfadübereinstimmung ist <strong>groß-/kleinschreibungsabhängig</strong>, es sei denn, <a href="/api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase">Router.MatchRoutesIgnoreCase</a> ist auf <code>true</code> gesetzt.</li>
</ul>
<p>Die <a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a> und <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">RouteParameters</a> Eigenschaften von <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> geben ein <a href="/api/Sisk.Core.Entity.StringValueCollection">StringValueCollection</a>-Objekt zurück, bei dem jedes indexierte Eigenschaft ein nicht-nullable <a href="/api/Sisk.Core.Entity.StringValue">StringValue</a> zurückgibt, das als Option/Monad verwendet werden kann, um seinen Rohwert in ein verwaltetes Objekt umzuwandeln.</p>
<p>Das folgende Beispiel liest den Routenparameter &quot;id&quot; und erhält ein <code>Guid</code> daraus. Wenn der Parameter kein gültiges Guid ist, wird eine Ausnahme ausgelöst und ein 500-Fehler an den Client zurückgegeben, wenn der Server <a href="/api/Sisk.Core.Routing.Router.CallbackErrorHandler">Router.CallbackErrorHandler</a> nicht behandelt.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/user/&lt;id&gt;&quot;, (request) =&gt;
{
    Guid id = request.RouteParameters[&quot;id&quot;].GetGuid();
});
</code></pre>
<blockquote>
<p>[!HINWEIS]
Pfade haben ihre abschließenden <code>/</code> ignoriert, sowohl in der Anfrage als auch in der Routenpfad, d. h., wenn Sie versuchen, auf eine Route zuzugreifen, die als <code>/index/page</code> definiert ist, können Sie auch auf <code>/index/page/</code> zugreifen.</p>
<p>Sie können auch URLs zwingen, mit <code>/</code> zu enden, indem Sie die <a href="/api/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash">ForceTrailingSlash</a>-Flag setzen.</p>
</blockquote>
<h3 id="erstellen-von-routen-mit-klasseninstanzen">Erstellen von Routen mit Klasseninstanzen</h3>
<p>Sie können auch Routen dynamisch mit Reflexion und dem Attribut <a href="/api/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a> definieren. Auf diese Weise werden die Instanzen einer Klasse, deren Methoden dieses Attribut implementieren, ihre Routen im Ziel-Router definieren.</p>
<p>Damit eine Methode als Route definiert werden kann, muss sie mit einem <a href="/api/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a> markiert werden, wie z. B. das Attribut selbst oder ein <a href="/api/Sisk.Core.Routing.RouteGetAttribute">RouteGetAttribute</a>. Die Methode kann statisch, instanziell, öffentlich oder privat sein. Wenn die Methode <code>SetObject(type)</code> oder <code>SetObject&lt;TType&gt;()</code> verwendet wird, werden Instanzmethoden ignoriert.</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    // wird mit GET / übereinstimmen
    [RouteGet]
    HttpResponse Index(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Index!&quot;);
        return res;
    }
    
    // statische Methoden funktionieren auch
    [RouteGet(&quot;/hello&quot;)]
    static HttpResponse Hello(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Hallo Welt!&quot;);
        return res;
    }
}
</code></pre>
<p>Die folgende Zeile wird beide Methoden <code>Index</code> und <code>Hello</code> von <code>MyController</code> als Routen definieren, da beide als Routen markiert sind und eine Instanz der Klasse bereitgestellt wird, nicht deren Typ. Wenn deren Typ anstelle der Instanz bereitgestellt worden wäre, würden nur die statischen Methoden definiert.</p>
<pre><code class="lang-cs">var myController = new MyController();
mainRouter.SetObject(myController);
</code></pre>
<p>Seit Sisk-Version 0.16 ist es möglich, AutoScan zu aktivieren, das nach benutzerdefinierten Klassen sucht, die <code>RouterModule</code> implementieren, und diese automatisch mit dem Router verknüpft. Dies wird nicht mit AOT-Kompilierung unterstützt.</p>
<pre><code class="lang-cs">mainRouter.AutoScanModules&lt;ApiController&gt;();
</code></pre>
<p>Der obige Befehl sucht nach allen Typen, die <code>ApiController</code> implementieren, aber nicht den Typ selbst. Die beiden optionalen Parameter zeigen an, wie die Methoden nach diesen Typen suchen. Der erste Argument impliziert die Assembly, in der die Typen gesucht werden, und der zweite zeigt an, wie die Typen definiert werden.</p>
<h2 id="regex-routen">Regex-Routen</h2>
<p>Anstelle der Verwendung der Standard-HTTP-Pfad-Übereinstimmungsmethode können Sie eine Route markieren, um sie mit Regex zu interpretieren.</p>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, &quot;Meine Route&quot;, IndexPage, null);
indexRoute.UseRegex = true;
mainRouter.SetRoute(indexRoute);
</code></pre>
<p>Oder mit der <a href="/api/Sisk.Core.Routing.RegexRoute">RegexRoute</a>-Klasse:</p>
<pre><code class="lang-cs">mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, request =&gt;
{
    return new HttpResponse(&quot;hallo, welt&quot;);
}));
</code></pre>
<p>Sie können auch Gruppen aus dem Regex-Muster in die <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">HttpRequest.RouteParameters</a>-Inhalte erfassen:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RegexRoute(RouteMethod.Get, @&quot;/uploads/(?&lt;filename&gt;.*\.(jpeg|jpg|png))&quot;)]
    static HttpResponse RegexRoute(HttpRequest request)
    {
        string filename = request.RouteParameters[&quot;filename&quot;].GetString();
        return new HttpResponse().WithContent($&quot;Zugriff auf Datei {filename}&quot;);
    }
}
</code></pre>
<h2 id="routen-präfixe">Routen-Präfixe</h2>
<p>Sie können alle Routen in einer Klasse oder einem Modul mit dem <a href="/api/Sisk.Core.Routing.RoutePrefixAttribute">RoutePrefix</a>-Attribut vordefinieren und den Präfix als Zeichenfolge setzen.</p>
<p>Siehe das folgende Beispiel mit der BREAD-Architektur (Browse, Read, Edit, Add und Delete):</p>
<div class="script-header">
    <span>
        Controller/Api/UsersController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePrefix(&quot;/api/users&quot;)]
public class UsersController
{
    // GET /api/users/&lt;id&gt;
    [RouteGet]
    public async Task&lt;HttpResponse&gt; Browse()
    {
        ...
    }
    
    // GET /api/users
    [RouteGet(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Read()
    {
        ...
    }
    
    // PATCH /api/users/&lt;id&gt;
    [RoutePatch(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Edit()
    {
        ...
    }
    
    // POST /api/users
    [RoutePost]
    public async Task&lt;HttpResponse&gt; Add()
    {
        ...
    }
    
    // DELETE /api/users/&lt;id&gt;
    [RouteDelete(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Delete()
    {
        ...
    }
}
</code></pre>
<p>Im obigen Beispiel wird der HttpResponse-Parameter weggelassen, um durch den globalen Kontext <a href="/api/Sisk.Core.Http.HttpContext.Current">HttpContext.Current</a> verwendet zu werden. Weitere Informationen finden Sie im folgenden Abschnitt.</p>
<h2 id="routen-ohne-anfrageparameter">Routen ohne Anfrageparameter</h2>
<p>Routen können ohne den <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a>-Parameter definiert werden und es ist dennoch möglich, die Anfrage und ihre Komponenten im Anfragekontext zu erhalten. Betrachten wir eine Abstraktion <code>ControllerBase</code>, die als Grundlage für alle Controller einer API dient und die <code>Request</code>-Eigenschaft bereitstellt, um die <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> derzeit zu erhalten.</p>
<div class="script-header">
    <span>
        Controller/ControllerBase.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public abstract class ControllerBase
{
    // erhält die Anfrage aus dem aktuellen Thread
    public HttpRequest Request { get =&gt; HttpContext.Current.Request; }
    
    // die folgende Zeile erhält die Datenbank aus der aktuellen HTTP-Sitzung,
    // oder erstellt eine neue, wenn sie nicht existiert
    public DbContext Database { get =&gt; HttpContext.Current.RequestBag.GetOrAdd&lt;DbContext&gt;(); }
}
</code></pre>
<p>Und für alle seine Nachkommen, um die Routensyntax ohne den Anfrageparameter zu verwenden:</p>
<div class="script-header">
    <span>
        Controller/UsersController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePrefix(&quot;/api/users&quot;)]
public class UsersController : ControllerBase
{    
    [RoutePost]
    public async Task&lt;HttpResponse&gt; Create()
    {
        // liest die JSON-Daten aus der aktuellen Anfrage
        UserCreationDto? user = JsonSerializer.DeserializeAsync&lt;UserCreationDto&gt;(Request.Body);
        ...
        Database.Users.Add(user);
        
        return new HttpResponse(201);
    }
}
</code></pre>
<p>Weitere Details zum aktuellen Kontext und zur Abhängigkeitsinjektion finden Sie im <a href="/docs/de/features/instancing">Abhängigkeitsinjektion</a>-Tutorial.</p>
<h2 id="routen-für-jede-methode">Routen für jede Methode</h2>
<p>Sie können eine Route definieren, die nur nach ihrem Pfad übereinstimmt und die HTTP-Methode ignoriert. Dies kann nützlich sein, um die Methode innerhalb der Routen-Rückruf-Funktion zu überprüfen.</p>
<pre><code class="lang-cs">// wird mit / auf jede HTTP-Methode übereinstimmen
mainRouter.SetRoute(RouteMethod.Any, &quot;/&quot;, callbackFunction);
</code></pre>
<h2 id="routen-für-jeden-pfad">Routen für jeden Pfad</h2>
<p>Routen für jeden Pfad testen jeden Pfad, der vom HTTP-Server empfangen wird, unter Vorbehalt der Route-Methode, die getestet wird. Wenn die Route-Methode RouteMethod.Any ist und die Route <a href="/api/Sisk.Core.Routing.Route.AnyPath">Route.AnyPath</a> in ihrem Pfad-Ausdruck verwendet, wird diese Route auf alle Anfragen vom HTTP-Server hören, und keine anderen Routen können definiert werden.</p>
<pre><code class="lang-cs">// die folgende Route wird mit allen POST-Anfragen übereinstimmen
mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction);
</code></pre>
<h2 id="groß-kleinschreibungsunabhängige-routen-übereinstimmung">Groß-/Kleinschreibungsunabhängige Routen-Übereinstimmung</h2>
<p>Standardmäßig ist die Interpretation von Routen mit Anfragen groß-/kleinschreibungsabhängig. Um dies zu ignorieren, aktivieren Sie diese Option:</p>
<pre><code class="lang-cs">mainRouter.MatchRoutesIgnoreCase = true;
</code></pre>
<p>Dies aktiviert auch die Option <code>RegexOptions.IgnoreCase</code> für Routen, bei denen Regex-Übereinstimmung verwendet wird.</p>
<h2 id="nicht-gefunden-404-rückruf-handler">Nicht gefunden (404)-Rückruf-Handler</h2>
<p>Sie können einen benutzerdefinierten Rückruf für den Fall erstellen, dass eine Anfrage keine bekannte Route übereinstimmt.</p>
<pre><code class="lang-cs">mainRouter.NotFoundErrorHandler = () =&gt;
{
    return new HttpResponse(404)
    {
        // Seit v0.14
        Content = new HtmlContent(&quot;&lt;h1&gt;Nicht gefunden&lt;/h1&gt;&quot;)
        // ältere Versionen
        Content = new StringContent(&quot;&lt;h1&gt;Nicht gefunden&lt;/h1&gt;&quot;, Encoding.UTF8, &quot;text/html&quot;)
    };
};
</code></pre>
<h2 id="methode-nicht-zulässig-405-rückruf-handler">Methode nicht zulässig (405)-Rückruf-Handler</h2>
<p>Sie können auch einen benutzerdefinierten Rückruf für den Fall erstellen, dass eine Anfrage ihren Pfad übereinstimmt, aber nicht die Methode.</p>
<pre><code class="lang-cs">mainRouter.MethodNotAllowedErrorHandler = (context) =&gt;
{
    return new HttpResponse(405)
    {
        Content = new StringContent($&quot;Methode nicht zulässig für diese Route.&quot;)
    };
};
</code></pre>
<h2 id="interne-fehlerbehandlung">Interne Fehlerbehandlung</h2>
<p>Routen-Rückrufe können während der Serverausführung Fehler auslösen. Wenn diese nicht richtig behandelt werden, kann die Gesamtfunktion des HTTP-Servers unterbrochen werden. Der Router hat einen Rückruf für den Fall, dass ein Routen-Rückruf fehlschlägt und die Dienstunterbrechung verhindert.</p>
<p>Diese Methode ist nur erreichbar, wenn <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions">ThrowExceptions</a> auf <code>false</code> gesetzt ist.</p>
<pre><code class="lang-cs">mainRouter.CallbackErrorHandler = (ex, context) =&gt;
{
    return new HttpResponse(500)
    {
        Content = new StringContent($&quot;Fehler: {ex.Message}&quot;)
    };
};
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/de/fundamentals/routing.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext", "ApiGenerationContext", "OpenApiExporter", "BodyExampleResult",
                            "ParameterExampleResult", "OpenApiContact", "OpenApiLicense", "HttpContent",
                            "ApiDocumentation", "CrossOriginResourceSharingHeaders", "McpProvider",
                            "JsonSchema", "McpToolContext", "HttpListenerAbstractEngine", "HttpListener",
                            "CadenteHttpServerEngine", "CertificateHelper"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort", "HttpServerEngineContextEventLoopMechanism"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
                
                (function() {
                    const copyBtn = document.getElementById('copy-article-btn');
                    const copyDropdown = document.getElementById('copy-dropdown');
                    const copyTextBtn = document.getElementById('copy-text-btn');
                    const copyMarkdownBtn = document.getElementById('copy-markdown-btn');
                    
                    if (!copyBtn) return;
                    
                    copyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        copyDropdown.classList.toggle('show');
                    });
                    
                    document.addEventListener('click', function(e) {
                        if (!copyDropdown.contains(e.target) && e.target !== copyBtn) {
                            copyDropdown.classList.remove('show');
                        }
                    });
                    
                    function getArticleContent() {
                        const article = document.querySelector('article');
                        if (!article) return null;
                        
                        const clone = article.cloneNode(true);
                        clone.querySelectorAll('.line-numbers, .code-action').forEach(el => el.remove());
                        
                        return clone;
                    }
                    
                    copyTextBtn.addEventListener('click', function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        navigator.clipboard.writeText(article.innerText.trim());
                        copyDropdown.classList.remove('show');
                    });
                    
                    copyMarkdownBtn.addEventListener('click', async function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        if (typeof TurndownService === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/turndown/dist/turndown.js';
                            script.onload = function() {
                                convertAndCopy(article);
                            };
                            document.head.appendChild(script);
                        } else {
                            convertAndCopy(article);
                        }
                        
                        copyDropdown.classList.remove('show');
                    });
                    
                    function convertAndCopy(article) {
                        const turndown = new TurndownService({
                            headingStyle: 'atx',
                            codeBlockStyle: 'fenced'
                        });
                        
                        turndown.addRule('codeBlocks', {
                            filter: ['pre'],
                            replacement: function(content, node) {
                                const code = node.querySelector('code');
                                const langClass = code?.className.match(/lang-(\w+)/);
                                const lang = langClass ? langClass[1] : '';
                                const text = code?.textContent || content;
                                return '\n\n```' + lang + '\n' + text.trim() + '\n```\n\n';
                            }
                        });
                        
                        const markdown = turndown.turndown(article.innerHTML);
                        navigator.clipboard.writeText(markdown);
                    }
                })();
            </script>
        </footer>
    </body>
</html>