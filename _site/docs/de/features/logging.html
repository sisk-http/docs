<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Logging | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Logging | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/de/features/logging.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="logging">Logging</h1>

<p>Sie können Sisk so konfigurieren, dass Zugriffs- und Fehlerprotokolle automatisch geschrieben werden. Es ist möglich, Logrotation, Erweiterungen und Frequenz zu definieren.</p>
<p>Die Klasse <a href="/api/Sisk.Core.Http.LogStream">LogStream</a> bietet einen asynchronen Weg, Protokolle zu schreiben und sie in einer wartbaren Schreibwarteschlange zu halten.</p>
<p>In diesem Artikel zeigen wir Ihnen, wie Sie das Logging für Ihre Anwendung konfigurieren.</p>
<h2 id="dateibasierte-zugriffsprotokolle">Dateibasierte Zugriffsprotokolle</h2>
<p>Protokolle zu Dateien öffnen die Datei, schreiben die Zeilentext und schließen die Datei anschließend für jede geschriebene Zeile. Dieses Verfahren wurde übernommen, um die Schreibreaktivität in den Protokollen zu erhalten.</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class Program
{
    static async Task Main(string[] args)
    {
        using var app = HttpServer.CreateBuilder()
            .UseConfiguration(config =&gt; {
                config.AccessLogsStream = new LogStream(&quot;logs/access.log&quot;);
            })
            .Build();
        
        ...
        
        await app.StartAsync();
    }
}
</code></pre>
<p>Der obige Code schreibt alle eingehenden Anfragen in die Datei <code>logs/access.log</code>. Beachten Sie, dass die Datei automatisch erstellt wird, wenn sie nicht existiert, jedoch der Ordner davor nicht. Es ist nicht erforderlich, das Verzeichnis <code>logs/</code> zu erstellen, da die LogStream-Klasse es automatisch erstellt.</p>
<h2 id="stream-basiertes-logging">Stream-basiertes Logging</h2>
<p>Sie können Logdateien in TextWriter-Objekte schreiben, wie z. B. <code>Console.Out</code>, indem Sie ein TextWriter-Objekt im Konstruktor übergeben:</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">using var app = HttpServer.CreateBuilder()
    .UseConfiguration(config =&gt; {
        config.AccessLogsStream = new LogStream(Console.Out);
    })
    .Build();
</code></pre>
<p>Für jede Nachricht, die im stream-basierten Log geschrieben wird, wird die Methode <code>TextWriter.Flush()</code> aufgerufen.</p>
<h2 id="formatierung-des-zugriffsprotokolls">Formatierung des Zugriffsprotokolls</h2>
<p>Sie können das Format des Zugriffsprotokolls mit vordefinierten Variablen anpassen. Betrachten Sie die folgende Zeile:</p>
<pre><code class="lang-cs">config.AccessLogsFormat = &quot;%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -&gt; %lou in %lmsms [%{user-agent}]&quot;;
</code></pre>
<p>Es schreibt eine Nachricht wie:</p>
<pre><code>29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -&gt; 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36]
</code></pre>
<p>Sie können Ihre Logdatei nach dem beschriebenen Format formatieren:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Was es repräsentiert</th>
<th>Beispiel</th>
</tr>
</thead>
<tbody>
<tr>
<td>%dd</td>
<td>Tag des Monats (formatiert als zwei Ziffern)</td>
<td>05</td>
</tr>
<tr>
<td>%dmmm</td>
<td>Vollständiger Name des Monats</td>
<td>July</td>
</tr>
<tr>
<td>%dmm</td>
<td>Abgekürzter Name des Monats (drei Buchstaben)</td>
<td>Jul</td>
</tr>
<tr>
<td>%dm</td>
<td>Monatsnummer (formatiert als zwei Ziffern)</td>
<td>07</td>
</tr>
<tr>
<td>%dy</td>
<td>Jahr (formatiert als vier Ziffern)</td>
<td>2023</td>
</tr>
<tr>
<td>%th</td>
<td>Stunde im 12-Stunden-Format</td>
<td>03</td>
</tr>
<tr>
<td>%tH</td>
<td>Stunde im 24-Stunden-Format (HH)</td>
<td>15</td>
</tr>
<tr>
<td>%ti</td>
<td>Minuten (formatiert als zwei Ziffern)</td>
<td>30</td>
</tr>
<tr>
<td>%ts</td>
<td>Sekunden (formatiert als zwei Ziffern)</td>
<td>45</td>
</tr>
<tr>
<td>%tm</td>
<td>Millisekunden (formatiert als drei Ziffern)</td>
<td>123</td>
</tr>
<tr>
<td>%tz</td>
<td>Zeitzonenoffset (Gesamtstunden in UTC)</td>
<td>+03:00</td>
</tr>
<tr>
<td>%ri</td>
<td>Remote IP-Adresse des Clients</td>
<td>192.168.1.100</td>
</tr>
<tr>
<td>%rm</td>
<td>HTTP-Methode (Großbuchstaben)</td>
<td>GET</td>
</tr>
<tr>
<td>%rs</td>
<td>URI-Schema (http/https)</td>
<td>https</td>
</tr>
<tr>
<td>%ra</td>
<td>URI-Authority (Domain)</td>
<td>example.com</td>
</tr>
<tr>
<td>%rh</td>
<td>Host der Anfrage</td>
<td><a href="http://www.example.com">www.example.com</a></td>
</tr>
<tr>
<td>%rp</td>
<td>Port der Anfrage</td>
<td>443</td>
</tr>
<tr>
<td>%rz</td>
<td>Pfad der Anfrage</td>
<td>/path/to/resource</td>
</tr>
<tr>
<td>%rq</td>
<td>Abfragezeichenkette</td>
<td>?key=value&amp;another=123</td>
</tr>
<tr>
<td>%sc</td>
<td>HTTP-Antwortstatuscode</td>
<td>200</td>
</tr>
<tr>
<td>%sd</td>
<td>HTTP-Antwortstatusbeschreibung</td>
<td>OK</td>
</tr>
<tr>
<td>%lin</td>
<td>Menschlich lesbare Größe der Anfrage</td>
<td>1.2 KB</td>
</tr>
<tr>
<td>%linr</td>
<td>Rohgröße der Anfrage (Bytes)</td>
<td>1234</td>
</tr>
<tr>
<td>%lou</td>
<td>Menschlich lesbare Größe der Antwort</td>
<td>2.5 KB</td>
</tr>
<tr>
<td>%lour</td>
<td>Rohgröße der Antwort (Bytes)</td>
<td>2560</td>
</tr>
<tr>
<td>%lms</td>
<td>Verstrichene Zeit in Millisekunden</td>
<td>120</td>
</tr>
<tr>
<td>%ls</td>
<td>Ausführungsstatus</td>
<td>Executed</td>
</tr>
<tr>
<td>%{header-name}</td>
<td>Repräsentiert den Header <code>header-name</code> der Anfrage.</td>
<td><code>Mozilla/5.0 (platform; rv:gecko [...]</code></td>
</tr>
<tr>
<td>%{:res-name}</td>
<td>Repräsentiert den Header <code>res-name</code> der Antwort.</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="rotierende-protokolle">Rotierende Protokolle</h2>
<p>Sie können den HTTP-Server so konfigurieren, dass die Logdateien in eine komprimierte .gz-Datei umgewandelt werden, wenn sie eine bestimmte Größe erreichen. Die Größe wird periodisch anhand des von Ihnen definierten Schwellenwerts überprüft.</p>
<pre><code class="lang-cs">LogStream errorLog = new LogStream(&quot;logs/error.log&quot;)
    .ConfigureRotatingPolicy(
        maximumSize: 64 * SizeHelper.UnitMb,
        dueTime: TimeSpan.FromHours(6));
</code></pre>
<p>Der obige Code prüft alle sechs Stunden, ob die Datei des LogStreams sein 64 MB-Limit erreicht hat. Wenn ja, wird die Datei in eine .gz-Datei komprimiert und anschließend wird <code>access.log</code> bereinigt.</p>
<p>Während dieses Prozesses ist das Schreiben in die Datei gesperrt, bis die Datei komprimiert und bereinigt ist. Alle Zeilen, die in diesem Zeitraum geschrieben werden sollen, befinden sich in einer Warteschlange, die auf das Ende der Komprimierung wartet.</p>
<p>Diese Funktion funktioniert nur mit dateibasierten LogStreams.</p>
<h2 id="fehlerprotokollierung">Fehlerprotokollierung</h2>
<p>Wenn ein Server keine Fehler an den Debugger weiterleitet, leitet er die Fehler beim Schreiben von Protokollen weiter, wenn welche vorhanden sind. Sie können das Schreiben von Fehlern mit folgendem Code konfigurieren:</p>
<pre><code class="lang-cs">config.ThrowExceptions = false;
config.ErrorsLogsStream = new LogStream(&quot;error.log&quot;);
</code></pre>
<p>Diese Eigenschaft schreibt nur etwas in das Protokoll, wenn der Fehler nicht von der Callback-Funktion oder der Eigenschaft <a href="/api/Sisk.Core.Routing.Router.CallbackErrorHandler">Router.CallbackErrorHandler</a> erfasst wird.</p>
<p>Der vom Server geschriebene Fehler enthält immer Datum und Uhrzeit, die Anfrage-Header (nicht den Körper), die Fehlerspur und die Spur der inneren Ausnahme, falls vorhanden.</p>
<h2 id="weitere-logging-instanzen">Weitere Logging-Instanzen</h2>
<p>Ihre Anwendung kann null oder mehrere LogStreams haben, es gibt keine Begrenzung, wie viele Logkanäle sie haben kann. Daher ist es möglich, das Log Ihrer Anwendung auf eine Datei zu leiten, die nicht das Standardzugriffs- oder Fehlerprotokoll ist.</p>
<pre><code class="lang-cs">LogStream appMessages = new LogStream(&quot;messages.log&quot;);
appMessages.WriteLine(&quot;Application started at {0}&quot;, DateTime.Now);
</code></pre>
<h2 id="erweiterung-von-logstream">Erweiterung von LogStream</h2>
<p>Sie können die Klasse <code>LogStream</code> erweitern, um benutzerdefinierte Formate zu schreiben, die mit der aktuellen Sisk-Log-Engine kompatibel sind. Das folgende Beispiel ermöglicht das Schreiben farbiger Nachrichten in die Konsole über die Bibliothek Spectre.Console:</p>
<div class="script-header">
    <span>
        CustomLogStream.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class CustomLogStream : LogStream
{
    protected override void WriteLineInternal(string line)
    {
        base.WriteLineInternal($&quot;[{DateTime.Now:g}] {line}&quot;);
    }
}
</code></pre>
<p>Eine weitere Möglichkeit, automatisch benutzerdefinierte Protokolle für jede Anfrage/Antwort zu schreiben, besteht darin, einen <a href="/api/Sisk.Core.Http.Handlers.HttpServerHandler">HttpServerHandler</a> zu erstellen. Das folgende Beispiel ist etwas ausführlicher. Es schreibt den Körper der Anfrage und Antwort in JSON in die Konsole. Es kann nützlich sein, Anfragen im Allgemeinen zu debuggen. Dieses Beispiel nutzt ContextBag und HttpServerHandler.</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class Program
{
    static async Task Main(string[] args)
    {
        var app = HttpServer.CreateBuilder(host =&gt;
        {
            host.UseListeningPort(5555);
            host.UseHandler&lt;JsonMessageHandler&gt;();
        });

        app.Router += new Route(RouteMethod.Any, &quot;/json&quot;, request =&gt;
        {
            return new HttpResponse()
                .WithContent(JsonContent.Create(new
                {
                    method = request.Method.Method,
                    path = request.Path,
                    specialMessage = &quot;Hello, world!!&quot;
                }));
        });

        await app.StartAsync();
    }
}
</code></pre>
<div class="script-header">
    <span>
        JsonMessageHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class JsonMessageHandler : HttpServerHandler
{
    protected override void OnHttpRequestOpen(HttpRequest request)
    {
        if (request.Method != HttpMethod.Get &amp;&amp; request.Headers[&quot;Content-Type&quot;]?.Contains(&quot;json&quot;, StringComparison.InvariantCultureIgnoreCase) == true)
        {
            // At this point, the connection is open and the client has sent the header specifying
            // that the content is JSON.The line below reads the content and leaves it stored in the request.
            //
            // If the content is not read in the request action, the GC is likely to collect the content
            // after sending the response to the client, so the content may not be available after the response is closed.
            //
            _ = request.RawBody;

            // add hint in the context to tell that this request has an json body on it
            request.Bag.Add(&quot;IsJsonRequest&quot;, true);
        }
    }

    protected override async void OnHttpRequestClose(HttpServerExecutionResult result)
    {
        string? requestJson = null,
                responseJson = null,
                responseMessage;

        if (result.Request.Bag.ContainsKey(&quot;IsJsonRequest&quot;))
        {
            // reformats the JSON using the CypherPotato.LightJson library
            var content = result.Request.Body;
            requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString();
        }
        
        if (result.Response is { } response)
        {
            var content = response.Content;
            responseMessage = $&quot;{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}&quot;;
            
            if (content is HttpContent httpContent &amp;&amp;
                // check if the response is JSON
                httpContent.Headers.ContentType?.MediaType?.Contains(&quot;json&quot;, StringComparison.InvariantCultureIgnoreCase) == true)
            {
                string json = await httpContent.ReadAsStringAsync();
                responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString();
            }
        }
        else
        {
            // gets the internal server handling status
            responseMessage = result.Status.ToString();
        }
        
        StringBuilder outputMessage = new StringBuilder();

        if (requestJson != null)
        {
            outputMessage.AppendLine(&quot;-----&quot;);
            outputMessage.AppendLine($&quot;&gt;&gt;&gt; {result.Request.Method} {result.Request.Path}&quot;);

            if (requestJson is not null)
                outputMessage.AppendLine(requestJson);
        }

        outputMessage.AppendLine($&quot;&lt;&lt;&lt; {responseMessage}&quot;);

        if (responseJson is not null)
            outputMessage.AppendLine(responseJson);

        outputMessage.AppendLine(&quot;-----&quot;);

        await Console.Out.WriteLineAsync(outputMessage.ToString());
    }
}
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/de/features/logging.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>