<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Server Sent Events | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Server Sent Events | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/de/features/server-sent-events.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="server-sent-events">Server Sent Events</h1>

<p>Sisk unterstützt das Senden von Nachrichten durch Server Sent Events direkt. Sie können verwerfbare und beständige Verbindungen erstellen, die Verbindungen während der Laufzeit abrufen und diese verwenden.</p>
<p>Diese Funktion hat einige durch Browser auferlegte Einschränkungen, wie z.B. das Senden nur von Textnachrichten und die Unfähigkeit, eine Verbindung dauerhaft zu schließen. Eine serverseitig geschlossene Verbindung wird dazu führen, dass der Client alle 5 Sekunden (bei einigen Browsern alle 3 Sekunden) versucht, erneut zu verbinden.</p>
<p>Diese Verbindungen sind nützlich für das Senden von Ereignissen vom Server an den Client, ohne dass der Client die Informationen jedes Mal anfordern muss.</p>
<h2 id="erstellen-einer-sse-verbindung">Erstellen einer SSE-Verbindung</h2>
<p>Eine SSE-Verbindung funktioniert wie eine reguläre HTTP-Anfrage, aber anstelle einer Antwort zu senden und die Verbindung sofort zu schließen, bleibt die Verbindung geöffnet, um Nachrichten zu senden.</p>
<p>Durch den Aufruf der <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource()</a>-Methode wird die Anfrage in einen Wartezustand versetzt, während die SSE-Instanz erstellt wird.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource();

    sse.Send(&quot;Hallo, Welt!&quot;);

    return sse.Close();
});
</code></pre>
<p>Im obigen Code erstellen wir eine SSE-Verbindung und senden eine &quot;Hallo, Welt&quot;-Nachricht, dann schließen wir die SSE-Verbindung vom Server aus.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Wenn eine serverseitige Verbindung geschlossen wird, wird der Client standardmäßig versuchen, erneut zu verbinden, und die Verbindung wird neu gestartet, indem die Methode erneut ausgeführt wird, für immer.</p>
<p>Es ist üblich, eine Beendigungsnachricht vom Server zu senden, wenn die Verbindung vom Server aus geschlossen wird, um zu verhindern, dass der Client erneut versucht, eine Verbindung herzustellen.</p>
</div>
<h2 id="anfügen-von-headern">Anfügen von Headern</h2>
<p>Wenn Sie Header senden müssen, können Sie die <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader">HttpRequestEventSource.AppendHeader</a>-Methode verwenden, bevor Sie Nachrichten senden.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource();
    sse.AppendHeader(&quot;Header-Schlüssel&quot;, &quot;Header-Wert&quot;);

    sse.Send(&quot;Hallo!&quot;);

    return sse.Close();
});
</code></pre>
<p>Beachten Sie, dass es notwendig ist, die Header vor dem Senden von Nachrichten zu senden.</p>
<h2 id="wait-for-fail-verbindungen">Wait-For-Fail-Verbindungen</h2>
<p>Verbindungen werden normalerweise beendet, wenn der Server nicht mehr in der Lage ist, Nachrichten zu senden, aufgrund einer möglichen Client-seitigen Trennung. Mit diesem Verfahren wird die Verbindung automatisch beendet und die Instanz der Klasse wird verworfen.</p>
<p>Auch bei einer erneuten Verbindung wird die Instanz der Klasse nicht funktionieren, da sie mit der vorherigen Verbindung verknüpft ist. In einigen Situationen müssen Sie diese Verbindung möglicherweise später verwenden und möchten sie nicht über die Rückrufmethode der Route verwalten.</p>
<p>Dazu können wir die SSE-Verbindungen mit einem Identifikator kennzeichnen und sie später mithilfe dessen abrufen, auch außerhalb der Rückrufmethode der Route. Zusätzlich markieren wir die Verbindung mit <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail">WaitForFail</a>, um die Route nicht zu beenden und die Verbindung automatisch zu beenden.</p>
<p>Eine SSE-Verbindung in KeepAlive wartet auf einen Sendeerror (verursacht durch eine Trennung) zum Wiederaufnehmen der Methodenausführung. Es ist auch möglich, eine Zeitüberschreitung für diese festzulegen. Nach Ablauf der Zeit wird die Verbindung beendet, wenn keine Nachricht gesendet wurde, und die Ausführung wird wiederaufgenommen.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource(&quot;my-index-connection&quot;);

    sse.WaitForFail(TimeSpan.FromSeconds(15)); // 15 Sekunden warten, ohne dass eine Nachricht gesendet wird, bevor die Verbindung beendet wird

    return sse.Close();
});
</code></pre>
<p>Die obige Methode erstellt die Verbindung, behandelt sie und wartet auf eine Trennung oder einen Fehler.</p>
<pre><code class="lang-cs">HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(&quot;my-index-connection&quot;);
if (evs != null)
{
    // die Verbindung ist noch aktiv
    evs.Send(&quot;Hallo nochmal!&quot;);
}
</code></pre>
<p>Und der obige Codeabschnitt versucht, die neu erstellte Verbindung zu finden, und wenn sie existiert, sendet er eine Nachricht an sie.</p>
<p>Alle aktiven Serververbindungen, die identifiziert werden, sind in der Sammlung <a href="/api/Sisk.Core.Http.HttpServer.EventSources">HttpServer.EventSources</a> verfügbar. Diese Sammlung speichert nur aktive und identifizierte Verbindungen. Geschlossene Verbindungen werden aus der Sammlung entfernt.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Es ist wichtig zu beachten, dass KeepAlive eine durch Komponenten, die möglicherweise mit Sisk in einer nicht kontrollierbaren Weise verbunden sind, wie z.B. einem Web-Proxy, einem HTTP-Kernel oder einem Netzwerktreiber, festgelegte Grenze hat, und diese Komponenten inaktive Verbindungen nach einer bestimmten Zeit schließen.</p>
<p>Es ist daher wichtig, die Verbindung durch das Senden periodischer Pings oder durch Verlängern der maximalen Zeit, bevor die Verbindung geschlossen wird, offen zu halten. Lesen Sie den nächsten Abschnitt, um besser zu verstehen, wie periodische Pings gesendet werden.</p>
</div>
<h2 id="einrichten-der-verbindungs-ping-richtlinie">Einrichten der Verbindungs-Ping-Richtlinie</h2>
<p>Die Ping-Richtlinie ist eine automatisierte Möglichkeit, periodische Nachrichten an Ihren Client zu senden. Diese Funktion ermöglicht es dem Server, zu verstehen, wenn der Client die Verbindung getrennt hat, ohne dass die Verbindung unendlich lange geöffnet bleiben muss.</p>
<pre><code class="lang-cs">[RouteGet(&quot;/sse&quot;)]
public HttpResponse Events(HttpRequest request)
{
    var sse = request.GetEventSource();
    sse.WithPing(ping =&gt;
    {
        ping.DataMessage = &quot;ping-Nachricht&quot;;
        ping.Interval = TimeSpan.FromSeconds(5);
        ping.Start();
    });

    sse.KeepAlive();
    return sse.Close();
}
</code></pre>
<p>Im obigen Code wird alle 5 Sekunden eine neue Ping-Nachricht an den Client gesendet. Dies hält die TCP-Verbindung aktiv und verhindert, dass sie aufgrund von Inaktivität geschlossen wird. Wenn auch eine Nachricht nicht gesendet werden kann, wird die Verbindung automatisch geschlossen und die durch die Verbindung verwendeten Ressourcen werden freigegeben.</p>
<h2 id="abfragen-von-verbindungen">Abfragen von Verbindungen</h2>
<p>Sie können nach aktiven Verbindungen suchen, indem Sie einen Prädikaten auf den Verbindungsidentifikator anwenden, um beispielsweise eine Rundsendung durchzuführen.</p>
<pre><code class="lang-cs">HttpRequestEventSource[] evs = server.EventSources.Find(es =&gt; es.StartsWith(&quot;my-connection-&quot;));
foreach (HttpRequestEventSource e in evs)
{
    e.Send(&quot;Rundsenden an alle Ereignisquellen, die mit 'my-connection-' beginnen&quot;);
}
</code></pre>
<p>Sie können auch die <a href="/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All">All</a>-Methode verwenden, um alle aktiven SSE-Verbindungen abzurufen.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/de/features/server-sent-events.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines == 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>