<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Server Sent Events | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Server Sent Events | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/de/features/server-sent-events.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="server-sent-events">Server Sent Events</h1>

<p>Sisk unterstützt das Senden von Nachrichten über Server Sent Events direkt. Sie können verwerfbare und beständige Verbindungen erstellen, die Verbindungen während der Laufzeit abrufen und diese verwenden.</p>
<p>Diese Funktion hat einige durch Browser auferlegte Einschränkungen, wie z. B. das Senden nur von Textnachrichten und die Unfähigkeit, eine Verbindung dauerhaft zu schließen. Eine serverseitig geschlossene Verbindung wird dazu führen, dass der Client alle 5 Sekunden (bei einigen Browsern alle 3 Sekunden) versucht, erneut zu verbinden.</p>
<p>Diese Verbindungen sind nützlich für das Senden von Ereignissen vom Server an den Client, ohne dass der Client die Informationen jedes Mal anfordern muss.</p>
<h2 id="erstellen-einer-sse-verbindung">Erstellen einer SSE-Verbindung</h2>
<p>Eine SSE-Verbindung funktioniert wie eine reguläre HTTP-Anfrage, aber anstelle des Sendens einer Antwort und des sofortigen Schließens der Verbindung, wird die Verbindung geöffnet, um Nachrichten zu senden.</p>
<p>Durch den Aufruf der <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource()</a>-Methode wird die Anfrage in einen Wartezustand versetzt, während die SSE-Instanz erstellt wird.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    using var sse = req.GetEventSource();

    sse.Send(&quot;Hallo, Welt!&quot;);

    return sse.Close();
});
</code></pre>
<p>Im obigen Code erstellen wir eine SSE-Verbindung und senden eine &quot;Hallo, Welt&quot;-Nachricht, dann schließen wir die SSE-Verbindung vom Server aus.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Wenn eine serverseitige Verbindung geschlossen wird, wird der Client standardmäßig versuchen, erneut zu verbinden, und die Verbindung wird neu gestartet, indem die Methode erneut ausgeführt wird, für immer.</p>
<p>Es ist üblich, eine Beendigungsnachricht vom Server zu senden, wenn die Verbindung vom Server aus geschlossen wird, um zu verhindern, dass der Client erneut versucht, eine Verbindung herzustellen.</p>
</div>
<h2 id="anfügen-von-headern">Anfügen von Headern</h2>
<p>Wenn Sie Header senden müssen, können Sie die <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader">HttpRequestEventSource.AppendHeader</a>-Methode verwenden, bevor Sie Nachrichten senden.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    using var sse = req.GetEventSource();
    sse.AppendHeader(&quot;Header-Schlüssel&quot;, &quot;Header-Wert&quot;);

    sse.Send(&quot;Hallo!&quot;);

    return sse.Close();
});
</code></pre>
<p>Es ist notwendig, die Header vor dem Senden von Nachrichten zu senden.</p>
<h2 id="wait-for-fail-verbindungen">Wait-For-Fail-Verbindungen</h2>
<p>Verbindungen werden normalerweise beendet, wenn der Server nicht mehr in der Lage ist, Nachrichten zu senden, aufgrund einer möglichen Client-seitigen Trennung. Durch diese Trennung wird die Verbindung automatisch beendet und die Instanz der Klasse wird verworfen.</p>
<p>Sogar bei einer erneuten Verbindung wird die Instanz der Klasse nicht funktionieren, da sie mit der vorherigen Verbindung verknüpft ist. In einigen Situationen können Sie diese Verbindung später benötigen und möchten sie nicht über die Rückrufmethode der Route verwalten.</p>
<p>Dafür können wir die SSE-Verbindungen mit einem Identifikator kennzeichnen und sie später mithilfe dieses Identifikators abrufen, auch außerhalb der Rückrufmethode der Route. Zusätzlich markieren wir die Verbindung mit <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail">WaitForFail</a>, um die Route nicht zu beenden und die Verbindung automatisch zu beenden.</p>
<p>Eine SSE-Verbindung in KeepAlive wird warten, bis ein Sendeerror (verursacht durch eine Trennung) auftritt, um die Methode erneut auszuführen. Es ist auch möglich, eine Zeitüberschreitung für diese zu setzen. Nach Ablauf der Zeit wird die Verbindung beendet, wenn keine Nachricht gesendet wurde, und die Ausführung wird fortgesetzt.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    using var sse = req.GetEventSource(&quot;meine-Verbindungs-Id&quot;);

    sse.WaitForFail(TimeSpan.FromSeconds(15)); // warte 15 Sekunden ohne Nachricht, bevor die Verbindung beendet wird

    return sse.Close();
});
</code></pre>
<p>Die obige Methode wird die Verbindung erstellen, verwalten und auf eine Trennung oder einen Fehler warten.</p>
<pre><code class="lang-cs">HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(&quot;meine-Verbindungs-Id&quot;);
if (evs != null)
{
    // die Verbindung ist noch aktiv
    evs.Send(&quot;Hallo nochmal!&quot;);
}
</code></pre>
<p>Und der obige Codeabschnitt wird versuchen, die neu erstellte Verbindung zu finden, und wenn sie existiert, wird er eine Nachricht an sie senden.</p>
<p>Alle aktiven Serververbindungen, die identifiziert werden, sind in der Sammlung <a href="/api/Sisk.Core.Http.HttpServer.EventSources">HttpServer.EventSources</a> verfügbar. Diese Sammlung speichert nur aktive und identifizierte Verbindungen. Geschlossene Verbindungen werden aus der Sammlung entfernt.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Es ist wichtig zu beachten, dass KeepAlive eine durch Komponenten, die möglicherweise auf unkontrollierbare Weise mit Sisk verbunden sind, wie z. B. ein Web-Proxy, ein HTTP-Kernel oder ein Netzwerktreiber, festgelegte Grenze hat, und diese Komponenten inaktive Verbindungen nach einer bestimmten Zeit schließen.</p>
<p>Es ist daher wichtig, die Verbindung durch das Senden periodischer Pings oder durch Verlängern der maximalen Zeit, bevor die Verbindung geschlossen wird, offen zu halten. Lesen Sie den nächsten Abschnitt, um besser zu verstehen, wie periodische Pings gesendet werden.</p>
</div>
<h2 id="einrichten-der-verbindungs-ping-richtlinie">Einrichten der Verbindungs-Ping-Richtlinie</h2>
<p>Die Ping-Richtlinie ist eine automatisierte Möglichkeit, periodische Nachrichten an Ihren Client zu senden. Diese Funktion ermöglicht es dem Server, zu verstehen, wenn der Client von dieser Verbindung getrennt wurde, ohne dass die Verbindung unendlich lange geöffnet bleiben muss.</p>
<pre><code class="lang-cs">[RouteGet(&quot;/sse&quot;)]
public HttpResponse Events(HttpRequest request)
{
    using var sse = request.GetEventSource();
    sse.WithPing(ping =&gt;
    {
        ping.DataMessage = &quot;ping-Nachricht&quot;;
        ping.Interval = TimeSpan.FromSeconds(5);
        ping.Start();
    });
    
    sse.KeepAlive();
    return sse.Close();
}
</code></pre>
<p>Im obigen Code wird alle 5 Sekunden eine neue Ping-Nachricht an den Client gesendet. Dies hält die TCP-Verbindung aktiv und verhindert, dass sie aufgrund von Inaktivität geschlossen wird. Wenn auch eine Nachricht nicht gesendet werden kann, wird die Verbindung automatisch geschlossen, und die durch die Verbindung verwendeten Ressourcen werden freigegeben.</p>
<h2 id="abfragen-von-verbindungen">Abfragen von Verbindungen</h2>
<p>Sie können nach aktiven Verbindungen suchen, indem Sie einen Prädikaten auf den Verbindungs-Identifikator anwenden, um beispielsweise eine Rundsendung durchzuführen.</p>
<pre><code class="lang-cs">HttpRequestEventSource[] evs = server.EventSources.Find(es =&gt; es.StartsWith(&quot;meine-Verbindungs-&quot;));
foreach (HttpRequestEventSource e in evs)
{
    e.Send(&quot;Rundsenden an alle Ereignisquellen, die mit 'meine-Verbindungs-' beginnen&quot;);
}
</code></pre>
<p>Sie können auch die <a href="/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All">All</a>-Methode verwenden, um alle aktiven SSE-Verbindungen abzurufen.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/de/features/server-sent-events.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>