<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Routing | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Routing | Sisk ">


        <link rel="icon" href="../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../public/docfx.min.css">
        <link rel="stylesheet" href="../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/fundamentals/routing.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../index.html">
                        <img id="logo" class="svg" src="../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>
                    <div class="actionbar-actions">
                        <div id="language-wrapper">
                            <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                                <i class="bi bi-globe"></i>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                        <img src="/assets/flag/usa.png">
                                        English
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                        <img src="/assets/flag/russia.png">
                                        Русский
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                        <img src="/assets/flag/brazil.png">
                                        Português
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                        <img src="/assets/flag/spain.png">
                                        Español
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                        <img src="/assets/flag/germany.png">
                                        Deutsch
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                        <img src="/assets/flag/china.png">
                                        中文 (简体)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                        <img src="/assets/flag/japan.png">
                                        日本語
                                    </a>
                                </li>
                            </ul>
                        </div>

                        <div id="copy-article-wrapper">
                            <a class="btn border-0" id="copy-article-btn" title="Copy article">
                                <i class="bi bi-copy"></i>
                            </a>
                            <div class="copy-dropdown" id="copy-dropdown">
                                <button type="button" id="copy-text-btn">
                                    <i class="bi bi-file-text"></i>
                                    Copy as text
                                </button>
                                <button type="button" id="copy-markdown-btn">
                                    <i class="bi bi-markdown"></i>
                                    Copy as Markdown
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <article data-uid="">
<h1 id="routing">Routing</h1>

<p>The <a href="/api/Sisk.Core.Routing.Router">Router</a> is the first step in building the server. It is responsible for housing <a href="/api/Sisk.Core.Routing.Route">Route</a> objects, which are endpoints that map URLs and their methods to actions executed by the server. Each action is responsible for receiving a request and delivering a response to the client.</p>
<p>The routes are pairs of path expressions (&quot;path pattern&quot;) and the HTTP method that they can listen to. When a request is made to the server, it will attempt to find a route that matches the received request, then it will call the action of that route and deliver the resulting response to the client.</p>
<p>There are multiple ways to define routes in Sisk: they can be static, dynamic or auto-scanned, defined by attributes, or directly in the Router object.</p>
<pre><code class="lang-cs">Router mainRouter = new Router();

// maps the GET / route into the following action
mainRouter.MapGet(&quot;/&quot;, request =&gt; {
    return new HttpResponse(&quot;Hello, world!&quot;);
});
</code></pre>
<p>To understand what a route is capable of doing, we need to understand what a request is capable of doing. An <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> will contain everything you need. Sisk also includes some extra features that speed up the overral development.</p>
<p>For every action received by the server, a delegate of type <a href="/api/Sisk.Core.Routing.RouteAction">RouteAction</a> will be called. This delegate contains an parameter holding an <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> with all the necessary information about the request received by the server. The resulting object from this delegate must be an <a href="/api/Sisk.Core.Http.HttpResponse">HttpResponse</a> or an object that maps to it through <a href="/docs/fundamentals/responses#implicit-response-types">implicit response types</a>.</p>
<h2 id="matching-routes">Matching routes</h2>
<p>When a request is received by the HTTP server, Sisk searches for a route that satisfies the expression of the path received by the request. The expression is always tested between the route and the request path, without considering the query string.</p>
<p>This test does not have priority and is exclusive to a single route. When no route is matched with that request, the <a href="/api/Sisk.Core.Routing.Router.NotFoundErrorHandler">Router.NotFoundErrorHandler</a> response is returned to the client. When the path pattern is matched, but the HTTP method is mismatched, the <a href="/api/Sisk.Core.Routing.Router.MethodNotAllowedErrorHandler">Router.MethodNotAllowedErrorHandler</a> response is sent back to the client.</p>
<p>Sisk checks for the possibility of route collisions to avoid these problems. When defining routes, Sisk will look for possible routes that might collide with the route being defined. This test includes checking the path and the method that the route is set to accept.</p>
<h3 id="creating-routes-using-path-patterns">Creating routes using path patterns</h3>
<p>You can define routes using various <code>SetRoute</code> methods.</p>
<pre><code class="lang-cs">// SetRoute way
mainRouter.SetRoute(RouteMethod.Get, &quot;/hey/&lt;name&gt;&quot;, (request) =&gt;
{
    string name = request.RouteParameters[&quot;name&quot;].GetString();
    return new HttpResponse($&quot;Hello, {name}&quot;);
});

// Map* way
mainRouter.MapGet(&quot;/form&quot;, (request) =&gt;
{
    var formData = request.GetFormData();
    return new HttpResponse(); // empty 200 ok
});

// Route.* helper methods
mainRouter += Route.Get(&quot;/image.png&quot;, (request) =&gt;
{
    var imageStream = File.OpenRead(&quot;image.png&quot;);
    
    return new HttpResponse()
    {
        // the StreamContent inner
        // stream is disposed after sending
        // the response.
        Content = new StreamContent(imageStream)
    };
});

// multiple parameters
mainRouter.MapGet(&quot;/hey/&lt;name&gt;/surname/&lt;surname&gt;&quot;, (request) =&gt;
{
    string name = request.RouteParameters[&quot;name&quot;].GetString();
    string surname = request.RouteParameters[&quot;surname&quot;].GetString();

    return new HttpResponse($&quot;Hello, {name} {surname}!&quot;);
});
</code></pre>
<p>The <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">RouteParameters</a> property of HttpResponse contains all the information about the path variables of the received request.</p>
<p>Every path received by the server is normalized before the path pattern test is executed, following these rules:</p>
<ul>
<li>All empty segments are removed from the path, eg: <code>////foo//bar</code> becomes <code>/foo/bar</code>.</li>
<li>Path matching is <strong>case-sensitive</strong>, unless <a href="/api/Sisk.Core.Routing.Router.MatchRoutesIgnoreCase">Router.MatchRoutesIgnoreCase</a> is set to <code>true</code>.</li>
</ul>
<p>The <a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a> and <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">RouteParameters</a> properties of <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> return a <a href="/api/Sisk.Core.Entity.StringValueCollection">StringValueCollection</a> object, where each indexed property returns a non-null <a href="/api/Sisk.Core.Entity.StringValue">StringValue</a>, which can be used as an option/monad to convert its raw value into a managed object.</p>
<p>The example below reads the route parameter &quot;id&quot; and obtains a <code>Guid</code> from it. If the parameter is not a valid Guid, an exception is thrown, and a 500 error is returned to the client if the server is not handling <a href="/api/Sisk.Core.Routing.Router.CallbackErrorHandler">Router.CallbackErrorHandler</a>.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/user/&lt;id&gt;&quot;, (request) =&gt;
{
    Guid id = request.RouteParameters[&quot;id&quot;].GetGuid();
});
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Paths have their trailing <code>/</code> ignored in both request and route path, that is, if you try to access a route defined as <code>/index/page</code> you'll be able to access using <code>/index/page/</code> too.</p>
<p>You can also force URLs to terminate with <code>/</code> enabling the <a href="/api/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash">ForceTrailingSlash</a> flag.</p>
</div>
<h3 id="creating-routes-using-class-instances">Creating routes using class instances</h3>
<p>You can also define routes dynamically using reflection with the attribute <a href="/api/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a>. This way, the instance of a class in which its methods implement this attribute will have their routes defined in the target router.</p>
<p>For a method to be defined as a route, it must be marked with a <a href="/api/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a>, such as the attribute itself or a <a href="/api/Sisk.Core.Routing.RouteGetAttribute">RouteGetAttribute</a>. The method can be static, instance, public, or private. When the method <code>SetObject(type)</code> or <code>SetObject&lt;TType&gt;()</code> is used, instance methods are ignored.</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    // will match GET /
    [RouteGet]
    HttpResponse Index(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Index!&quot;);
        return res;
    }
    
    // static methods works too
    [RouteGet(&quot;/hello&quot;)]
    static HttpResponse Hello(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        res.Content = new StringContent(&quot;Hello world!&quot;);
        return res;
    }
}
</code></pre>
<p>The line below will define both the <code>Index</code> and <code>Hello</code> methods of <code>MyController</code> as routes, as both are marked as routes, and an instance of the class has been provided, not its type. If its type had been provided instead of an instance, only the static methods would be defined.</p>
<pre><code class="lang-cs">var myController = new MyController();
mainRouter.SetObject(myController);
</code></pre>
<p>Since Sisk version 0.16, it is possible to enable AutoScan, which will search for user-defined classes that implement <code>RouterModule</code> and will automatically associate it with the router. This is not supported with AOT compilation.</p>
<pre><code class="lang-cs">mainRouter.AutoScanModules&lt;ApiController&gt;();
</code></pre>
<p>The above instruction will search for all types which implements <code>ApiController</code> but not the type itself. The two optional parameters indicate how the method will search for these types. The first argument implies the Assembly where the types will be searched and the second indicates the way in which the types will be defined.</p>
<h2 id="regex-routes">Regex routes</h2>
<p>Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with Regex.</p>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, &quot;My route&quot;, IndexPage, null);
indexRoute.UseRegex = true;
mainRouter.SetRoute(indexRoute);
</code></pre>
<p>Or with <a href="/api/Sisk.Core.Routing.RegexRoute">RegexRoute</a> class:</p>
<pre><code class="lang-cs">mainRouter.SetRoute(new RegexRoute(RouteMethod.Get, @&quot;\/[a-z]+\/&quot;, request =&gt;
{
    return new HttpResponse(&quot;hello, world&quot;);
}));
</code></pre>
<p>You can also capture groups from the regex pattern into the <a href="/api/Sisk.Core.Http.HttpRequest.RouteParameters">HttpRequest.RouteParameters</a> contents:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RegexRoute(RouteMethod.Get, @&quot;/uploads/(?&lt;filename&gt;.*\.(jpeg|jpg|png))&quot;)]
    static HttpResponse RegexRoute(HttpRequest request)
    {
        string filename = request.RouteParameters[&quot;filename&quot;].GetString();
        return new HttpResponse().WithContent($&quot;Acessing file {filename}&quot;);
    }
}
</code></pre>
<h2 id="prefixing-routes">Prefixing routes</h2>
<p>You can prefix all routes in a class or module with the <a href="/api/Sisk.Core.Routing.RoutePrefixAttribute">RoutePrefix</a> attribute and set the prefix as a string.</p>
<p>See the example below using the BREAD architecture (Browse, Read, Edit, Add and Delete):</p>
<div class="script-header">
    <span>
        Controller/Api/UsersController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePrefix(&quot;/api/users&quot;)]
public class UsersController
{
    // GET /api/users/&lt;id&gt;
    [RouteGet]
    public async Task&lt;HttpResponse&gt; Browse()
    {
        ...
    }
    
    // GET /api/users
    [RouteGet(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Read()
    {
        ...
    }
    
    // PATCH /api/users/&lt;id&gt;
    [RoutePatch(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Edit()
    {
        ...
    }
    
    // POST /api/users
    [RoutePost]
    public async Task&lt;HttpResponse&gt; Add()
    {
        ...
    }
    
    // DELETE /api/users/&lt;id&gt;
    [RouteDelete(&quot;/&lt;id&gt;&quot;)]
    public async Task&lt;HttpResponse&gt; Delete()
    {
        ...
    }
}
</code></pre>
<p>In the above example, the HttpResponse parameter is omitted in favor of being used through the global context <a href="/api/Sisk.Core.Http.HttpContext.Current">HttpContext.Current</a>. Read more in the section that follows.</p>
<h2 id="routes-without-request-parameter">Routes without request parameter</h2>
<p>Routes can be defined without the <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> parameter and still be possible to obtain the request and its components in the request context. Let's consider an abstraction <code>ControllerBase</code> that serves as a foundation for all controllers of an API, and that abstraction provides the <code>Request</code> property to obtain the <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> currently.</p>
<div class="script-header">
    <span>
        Controller/ControllerBase.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public abstract class ControllerBase
{
    // gets the request from the current thread
    public HttpRequest Request { get =&gt; HttpContext.Current.Request; }
    
    // the line below, when called, gets the database from the current HTTP session,
    // or creates a new one if it doesn't exist
    public DbContext Database { get =&gt; HttpContext.Current.RequestBag.GetOrAdd&lt;DbContext&gt;(); }
}
</code></pre>
<p>And for all it's descendants to be able to use the route syntax without the request parameter:</p>
<div class="script-header">
    <span>
        Controller/UsersController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePrefix(&quot;/api/users&quot;)]
public class UsersController : ControllerBase
{    
    [RoutePost]
    public async Task&lt;HttpResponse&gt; Create()
    {
        // reads the JSON data from the current request
        UserCreationDto? user = JsonSerializer.DeserializeAsync&lt;UserCreationDto&gt;(Request.Body);
        ...
        Database.Users.Add(user);
        
        return new HttpResponse(201);
    }
}
</code></pre>
<p>More details about the current context and dependency injection can be found in the <a href="/docs/features/instancing">dependency injection</a> tutorial.</p>
<h2 id="any-method-routes">Any method routes</h2>
<p>You can define a route to be matched only by its path and skip the HTTP method. This can be useful for you to do method validation inside the route callback.</p>
<pre><code class="lang-cs">// will match / on any HTTP method
mainRouter.SetRoute(RouteMethod.Any, &quot;/&quot;, callbackFunction);
</code></pre>
<h2 id="any-path-routes">Any path routes</h2>
<p>Any path routes test for any path received by the HTTP server, subject to the route method being tested. If the route method is RouteMethod.Any and the route uses <a href="/api/Sisk.Core.Routing.Route.AnyPath">Route.AnyPath</a> in its path expression, this route will listen to all requests from the HTTP server, and no other routes can be defined.</p>
<pre><code class="lang-cs">// the following route will match all POST requests
mainRouter.SetRoute(RouteMethod.Post, Route.AnyPath, callbackFunction);
</code></pre>
<h2 id="ignore-case-route-matching">Ignore case route matching</h2>
<p>By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable this option:</p>
<pre><code class="lang-cs">mainRouter.MatchRoutesIgnoreCase = true;
</code></pre>
<p>This will also enable the option <code>RegexOptions.IgnoreCase</code> for routes where it's regex-matching.</p>
<h2 id="not-found-404-callback-handler">Not Found (404) callback handler</h2>
<p>You can create a custom callback for when a request doesn't match any known routes.</p>
<pre><code class="lang-cs">mainRouter.NotFoundErrorHandler = () =&gt;
{
    return new HttpResponse(404)
    {
        // Since v0.14
        Content = new HtmlContent(&quot;&lt;h1&gt;Not found&lt;/h1&gt;&quot;)
        // older versions
        Content = new StringContent(&quot;&lt;h1&gt;Not found&lt;/h1&gt;&quot;, Encoding.UTF8, &quot;text/html&quot;)
    };
};
</code></pre>
<h2 id="method-not-allowed-405-callback-handler">Method not allowed (405) callback handler</h2>
<p>You can also create a custom callback for when a request matches it's path, but doens't match the method.</p>
<pre><code class="lang-cs">mainRouter.MethodNotAllowedErrorHandler = (context) =&gt;
{
    return new HttpResponse(405)
    {
        Content = new StringContent($&quot;Method not allowed for this route.&quot;)
    };
};
</code></pre>
<h2 id="internal-error-handler">Internal error handler</h2>
<p>Route callbacks can throw errors during server execution. If not handled correctly, the overall functioning of the HTTP server can be terminated. The router has a callback for when a route callback fails and prevents service interruption.</p>
<p>This method is only reacheable when <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ThrowExceptions">ThrowExceptions</a> is set to false.</p>
<pre><code class="lang-cs">mainRouter.CallbackErrorHandler = (ex, context) =&gt;
{
    return new HttpResponse(500)
    {
        Content = new StringContent($&quot;Error: {ex.Message}&quot;)
    };
};
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/fundamentals/routing.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext", "ApiGenerationContext", "OpenApiExporter", "BodyExampleResult",
                            "ParameterExampleResult", "OpenApiContact", "OpenApiLicense", "HttpContent",
                            "ApiDocumentation", "CrossOriginResourceSharingHeaders", "McpProvider",
                            "JsonSchema", "McpToolContext", "HttpListenerAbstractEngine", "HttpListener",
                            "CadenteHttpServerEngine", "CertificateHelper"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort", "HttpServerEngineContextEventLoopMechanism"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
                
                (function() {
                    const copyBtn = document.getElementById('copy-article-btn');
                    const copyDropdown = document.getElementById('copy-dropdown');
                    const copyTextBtn = document.getElementById('copy-text-btn');
                    const copyMarkdownBtn = document.getElementById('copy-markdown-btn');
                    
                    if (!copyBtn) return;
                    
                    copyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        copyDropdown.classList.toggle('show');
                    });
                    
                    document.addEventListener('click', function(e) {
                        if (!copyDropdown.contains(e.target) && e.target !== copyBtn) {
                            copyDropdown.classList.remove('show');
                        }
                    });
                    
                    function getArticleContent() {
                        const article = document.querySelector('article');
                        if (!article) return null;
                        
                        const clone = article.cloneNode(true);
                        clone.querySelectorAll('.line-numbers, .code-action').forEach(el => el.remove());
                        
                        return clone;
                    }
                    
                    copyTextBtn.addEventListener('click', function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        navigator.clipboard.writeText(article.innerText.trim());
                        copyDropdown.classList.remove('show');
                    });
                    
                    copyMarkdownBtn.addEventListener('click', async function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        if (typeof TurndownService === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/turndown/dist/turndown.js';
                            script.onload = function() {
                                convertAndCopy(article);
                            };
                            document.head.appendChild(script);
                        } else {
                            convertAndCopy(article);
                        }
                        
                        copyDropdown.classList.remove('show');
                    });
                    
                    function convertAndCopy(article) {
                        const turndown = new TurndownService({
                            headingStyle: 'atx',
                            codeBlockStyle: 'fenced'
                        });
                        
                        turndown.addRule('codeBlocks', {
                            filter: ['pre'],
                            replacement: function(content, node) {
                                const code = node.querySelector('code');
                                const langClass = code?.className.match(/lang-(\w+)/);
                                const lang = langClass ? langClass[1] : '';
                                const text = code?.textContent || content;
                                return '\n\n```' + lang + '\n' + text.trim() + '\n```\n\n';
                            }
                        });
                        
                        const markdown = turndown.turndown(article.innerHTML);
                        navigator.clipboard.writeText(markdown);
                    }
                })();
            </script>
        </footer>
    </body>
</html>