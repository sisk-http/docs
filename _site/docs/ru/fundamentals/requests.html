<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Запросы | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Запросы | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/requests.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="запросы">Запросы</h1>

<p>Запросы представляют собой структуры, которые представляют сообщение HTTP-запроса. Объект <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> содержит полезные функции для обработки HTTP-сообщений на протяжении всего вашего приложения.</p>
<p>HTTP-запрос формируется методом, путем, версией, заголовками и телом.</p>
<p>В этом документе мы научим вас, как получить каждый из этих элементов.</p>
<h2 id="получение-метода-запроса">Получение метода запроса</h2>
<p>Чтобы получить метод полученного запроса, вы можете использовать свойство Method:</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    HttpMethod requestMethod = request.Method;
    ...
}
</code></pre>
<p>Это свойство возвращает метод запроса, представленный объектом <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.httpmethod">HttpMethod</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>В отличие от методов маршрутизации, это свойство не служит для <a href="/api/Sisk.Core.Routing.RouteMethod">RouteMethod.Any</a> элемента. Вместо этого оно возвращает фактический метод запроса.</p>
</div>
<h2 id="получение-компонентов-url">Получение компонентов URL</h2>
<p>Вы можете получить различные компоненты из URL через определенные свойства запроса. Для этого примера давайте рассмотрим URL:</p>
<pre><code>http://localhost:5000/user/login?email=foo@bar.com
</code></pre>
<table>
<thead>
<tr>
<th>Название компонента</th>
<th>Описание</th>
<th>Значение компонента</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Path">Path</a></td>
<td>Получает путь запроса.</td>
<td><code>/user/login</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullPath">FullPath</a></td>
<td>Получает путь запроса и строку запроса.</td>
<td><code>/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullUrl">FullUrl</a></td>
<td>Получает всю строку URL запроса.</td>
<td><code>http://localhost:5000/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Host">Host</a></td>
<td>Получает хост запроса.</td>
<td><code>localhost</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Authority">Authority</a></td>
<td>Получает хост и порт запроса.</td>
<td><code>localhost:5000</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.QueryString">QueryString</a></td>
<td>Получает строку запроса запроса.</td>
<td><code>?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a></td>
<td>Получает строку запроса запроса в виде коллекции именованных значений.</td>
<td><code>{StringValueCollection object}</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.IsSecure">IsSecure</a></td>
<td>Определяет, использует ли запрос SSL (true) или нет (false).</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p>Вы также можете использовать свойство <a href="/api/Sisk.Core.Http.HttpRequest.Uri">HttpRequest.Uri</a>, которое включает все вышеперечисленное в один объект.</p>
<h2 id="получение-тела-запроса">Получение тела запроса</h2>
<p>Некоторые запросы включают тело, такие как формы, файлы или транзакции API. Вы можете получить тело запроса из свойства:</p>
<pre><code class="lang-cs">// получает тело запроса как строку, используя кодировку запроса в качестве кодировщика
string body = request.Body;

// или получает его в виде массива байтов
byte[] bodyBytes = request.RawBody;

// или же вы можете передать его как поток.
Stream requestStream = request.GetRequestStream();
</code></pre>
<p>Также возможно определить, есть ли тело в запросе и загружено ли оно с помощью свойств <a href="/api/Sisk.Core.Http.HttpRequest.HasContents">HasContents</a>, которое определяет, имеет ли запрос содержимое, и <a href="/api/Sisk.Core.Http.HttpRequest.IsContentAvailable">IsContentAvailable</a>, которое указывает, что HTTP-сервер полностью получил содержимое из удаленной точки.</p>
<p>Невозможно прочитать содержимое запроса через <code>GetRequestStream</code> более одного раза. Если вы прочитаете с помощью этого метода, значения в <code>RawBody</code> и <code>Body</code> также не будут доступны. Не нужно освобождать поток запроса в контексте запроса, поскольку он освобождается в конце HTTP-сессии, в которой он создается. Кроме того, вы можете использовать свойство <a href="/api/Sisk.Core.Http.HttpRequest.RequestEncoding">HttpRequest.RequestEncoding</a>, чтобы получить лучшую кодировку для декодирования запроса вручную.</p>
<p>Сервер имеет ограничения на чтение содержимого запроса, которые применяются как к <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.Body</a>, так и к <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.RawBody</a>. Эти свойства копируют весь входной поток в локальный буфер того же размера, что и <a href="/api/Sisk.Core.Http.HttpRequest.ContentLength">HttpRequest.ContentLength</a>.</p>
<p>Ответ с статусом 413 Содержимое слишком велико возвращается клиенту, если содержимое, отправленное клиентом, больше <a href="/api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength">HttpServerConfiguration.MaximumContentLength</a>, определенного в конфигурации пользователя. Кроме того, если нет настроенного ограничения или если оно слишком велико, сервер выдаст исключение <a href="https://learn.microsoft.com/en-us/dotnet/api/system.outofmemoryexception?view=net-8.0">OutOfMemoryException</a>, когда содержимое, отправленное клиентом, превышает <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32.maxvalue">Int32.MaxValue</a> (2 ГБ) и если содержимое попытается получить доступ через одно из упомянутых выше свойств. Вы все равно можете иметь дело с содержимым через поток.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Хотя Sisk позволяет это, всегда хорошей идеей является следование семантике HTTP для создания вашего приложения и не получать или обслуживать содержимое в методах, которые не допускают этого. Прочитайте о <a href="https://httpwg.org/spec/rfc9110.html">RFC 9110 &quot;HTTP Семантика&quot;</a>.</p>
</div>
<h2 id="получение-контекста-запроса">Получение контекста запроса</h2>
<p>Контекст HTTP - это эксклюзивный объект Sisk, который хранит информацию о HTTP-сервере, маршруте, маршрутизаторе и обработчике запроса. Вы можете использовать его, чтобы организовать себя в среде, где эти объекты трудно организовать.</p>
<p>Объект <a href="/api/Sisk.Core.Http.HttpContext.RequestBag">RequestBag</a> содержит сохраненную информацию, которая передается из обработчика запроса в другую точку и может быть потреблена в конечной точке. Этот объект также может быть использован обработчиками запросов, которые запускаются после обратного вызова маршрута.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Это свойство также доступно через свойство <a href="/api/Sisk.Core.Http.HttpRequest.Bag">HttpRequest.Bag</a>.</p>
</div>
<div class="script-header">
    <span>
        Middleware/AuthenticateUserRequestHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public string Identifier { get; init; } = Guid.NewGuid().ToString();
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;
    
    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            context.RequestBag.Add(&quot;AuthenticatedUser&quot;, new User(&quot;Bob&quot;));
            return null;
        }
        else
        {
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>Вышеуказанный обработчик запроса определит <code>AuthenticatedUser</code> в сумке запроса и может быть потреблен позже в конечном обратном вызове:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        User authUser = request.Context.RequestBag[&quot;AuthenticatedUser&quot;];
        
        return new HttpResponse() {
            Content = new StringContent($&quot;Hello, {authUser.Name}!&quot;)
        };
    }
}
</code></pre>
<p>Вы также можете использовать методы <code>Bag.Set()</code> и <code>Bag.Get()</code>, чтобы получить или задать объекты по их типам синглтонов.</p>
<div class="script-header">
    <span>
        Middleware/Authenticate.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class Authenticate : RequestHandler
{
    public override HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        request.Bag.Set&lt;User&gt;(authUser);
    }
}
</code></pre>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">[RouteGet(&quot;/&quot;)]
[RequestHandler&lt;Authenticate&gt;]
public static HttpResponse GetUser(HttpRequest request)
{
    var user = request.Bag.Get&lt;User&gt;();
    ...
}
</code></pre>
<h2 id="получение-данных-формы">Получение данных формы</h2>
<p>Вы можете получить значения данных формы в <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.specialized.namevaluecollection">NameValueCollection</a> с помощью следующего примера:</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/auth&quot;)]
public HttpResponse Index(HttpRequest request)
{
    var form = request.GetFormContent();

    string? username = form[&quot;username&quot;];
    string? password = form[&quot;password&quot;];

    if (AttempLogin(username, password))
    {
        ...
    }
}
</code></pre>
<h2 id="получение-данных-multipart-формы">Получение данных multipart-формы</h2>
<p>Запрос HTTP Sisk позволяет получить загруженные multipart-содержимое, такое как файлы, поля формы или любое бинарное содержимое.</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/upload-contents&quot;)]
public HttpResponse Index(HttpRequest request)
{
    // следующий метод читает весь входной запрос в массив
    // MultipartObject
    var multipartFormDataObjects = request.GetMultipartFormContent();
    
    foreach (MultipartObject uploadedObject in multipartFormDataObjects)
    {
        // имя файла, предоставленное multipart-формой данных.
        // Null возвращается, если объект не является файлом.
        Console.WriteLine(&quot;File name       : &quot; + uploadedObject.Filename);

        // имя поля multipart-формы данных.
        Console.WriteLine(&quot;Field name      : &quot; + uploadedObject.Name);

        // длина содержимого multipart-формы данных.
        Console.WriteLine(&quot;Content length  : &quot; + uploadedObject.ContentLength);

        // определите формат изображения на основе заголовка файла для каждого
        // известного типа содержимого. Если содержимое не является признанным общим форматом файла,
        // этот метод ниже вернет MultipartObjectCommonFormat.Unknown
        Console.WriteLine(&quot;Common format   : &quot; + uploadedObject.GetCommonFileFormat());
    }
}
</code></pre>
<p>Вы можете прочитать больше о Sisk <a href="/api/Sisk.Core.Entity.MultipartObject">Multipart-объектах формы</a> и их методах, свойствах и функциях.</p>
<h2 id="поддержка-серверных-событий">Поддержка серверных событий</h2>
<p>Sisk поддерживает <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">серверные события</a>, которые позволяют отправлять фрагменты как поток и поддерживать соединение между сервером и клиентом.</p>
<p>Вызов метода <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource</a> поставит HttpRequest в его состояние прослушивания. После этого контекст этого HTTP-запроса не будет ожидать HttpResponse, поскольку он перекроет пакеты, отправленные серверными событиями.</p>
<p>После отправки всех пакетов обратный вызов должен вернуть метод <a href="/api/Sisk.Core.Http.HttpRequestEventSource.Close">Close</a>, который отправит окончательный ответ серверу и укажет, что поток закончился.</p>
<p>Невозможно предсказать, какой будет общая длина всех пакетов, которые будут отправлены, поэтому невозможно определить конец соединения с помощью заголовка <code>Content-Length</code>.</p>
<p>По умолчанию большинства браузеров серверные события не поддерживают отправку HTTP-заголовков или методов, кроме метода GET. Поэтому будьте осторожны при использовании обработчиков запросов с запросами event-source, которые требуют определенных заголовков в запросе, поскольку они, вероятно, не будут иметь их.</p>
<p>Кроме того, большинство браузеров перезапускают потоки, если метод <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close">EventSource.close</a> не вызван на стороне клиента после получения всех пакетов, что вызывает бесконечную дополнительную обработку на стороне сервера. Чтобы избежать этой проблемы, часто отправляют окончательный пакет, указывающий, что источник событий закончил отправку всех пакетов.</p>
<p>Пример ниже показывает, как браузер может общаться с сервером, поддерживающим серверные события.</p>
<div class="script-header">
    <span>
        sse-example.html
    </span>
    <span>
        HTML
    </span>
</div>
<pre><code class="lang-html">&lt;html&gt;
    &lt;body&gt;
        &lt;b&gt;Fruits:&lt;/b&gt;
        &lt;ul&gt;&lt;/ul&gt;
    &lt;/body&gt;
    &lt;script&gt;
        const evtSource = new EventSource('http://localhost:5555/event-source');
        const eventList = document.querySelector('ul');
        
        evtSource.onmessage = (e) =&gt; {
            const newElement = document.createElement(&quot;li&quot;);

            newElement.textContent = `message: ${e.data}`;
            eventList.appendChild(newElement);

            if (e.data == &quot;Tomato&quot;) {
                evtSource.close();
            }
        }
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>И прогрессивно отправляйте сообщения клиенту:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/event-source&quot;)]
    public async Task&lt;HttpResponse&gt; ServerEventsResponse(HttpRequest request)
    {
        var sse = await request.GetEventSourceAsync ();
        
        string[] fruits = new[] { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Watermelon&quot;, &quot;Tomato&quot; };
        
        foreach (string fruit in fruits)
        {
            await serverEvents.SendAsync(fruit);
            await Task.Delay(1500);
        }

        return serverEvents.Close();
    }
}
</code></pre>
<p>Когда вы запускаете этот код, мы ожидаем результат, подобный этому:</p>
<img src="/assets/img/server side events demo.gif">
<h2 id="разрешение-прокси-ip-и-хостов">Разрешение прокси-IP и хостов</h2>
<p>Sisk можно использовать с прокси, и поэтому IP-адреса могут быть заменены на конечную точку прокси в транзакции от клиента к прокси.</p>
<p>Вы можете определить свои собственные разрешители в Sisk с помощью <a href="/docs/advanced/forwarding-resolvers">forwarding-разрешителей</a>.</p>
<h2 id="кодирование-заголовков">Кодирование заголовков</h2>
<p>Кодирование заголовков может быть проблемой для некоторых реализаций. В Windows заголовки UTF-8 не поддерживаются, поэтому используется ASCII. Sisk имеет встроенный конвертер кодировки, который может быть полезен для декодирования неправильно закодированных заголовков.</p>
<p>Эта операция дорога и отключена по умолчанию, но может быть включена под флагом <a href="/specification/spec/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings">NormalizeHeadersEncodings</a>.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/requests.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines == 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>