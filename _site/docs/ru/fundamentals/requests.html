<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Запросы | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Запросы | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/requests.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>
            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português Brasileiro
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Spanish
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="запросы">Запросы</h1>

<p>Запросы представляют собой структуры, которые представляют сообщение HTTP-запроса. Объект <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> содержит полезные функции для обработки HTTP-сообщений на протяжении всего вашего приложения.</p>
<p>HTTP-запрос формируется методом, путем, версией, заголовками и телом.</p>
<p>В этом документе мы научим вас, как получить каждый из этих элементов.</p>
<h2 id="получение-метода-запроса">Получение метода запроса</h2>
<p>Чтобы получить метод полученного запроса, вы можете использовать свойство Method:</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    HttpMethod requestMethod = request.Method;
    ...
}
</code></pre>
<p>Это свойство возвращает метод запроса, представленный объектом <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.httpmethod">HttpMethod</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>В отличие от методов маршрутизации, это свойство не обслуживает элемент <a href="/api/Sisk.Core.Routing.RouteMethod">RouteMethod.Any</a>. Вместо этого оно возвращает фактический метод запроса.</p>
</div>
<h2 id="получение-компонентов-url">Получение компонентов URL</h2>
<p>Вы можете получить различные компоненты из URL через определенные свойства запроса. Для этого примера давайте рассмотрим URL:</p>
<pre><code>http://localhost:5000/user/login?email=foo@bar.com
</code></pre>
<table>
<thead>
<tr>
<th>Название компонента</th>
<th>Описание</th>
<th>Значение компонента</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Path">Path</a></td>
<td>Получает путь запроса.</td>
<td><code>/user/login</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullPath">FullPath</a></td>
<td>Получает путь запроса и строку запроса.</td>
<td><code>/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullUrl">FullUrl</a></td>
<td>Получает всю строку URL запроса.</td>
<td><code>http://localhost:5000/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Host">Host</a></td>
<td>Получает хост запроса.</td>
<td><code>localhost</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Authority">Authority</a></td>
<td>Получает хост и порт запроса.</td>
<td><code>localhost:5000</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.QueryString">QueryString</a></td>
<td>Получает запрос запроса.</td>
<td><code>?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a></td>
<td>Получает запрос запроса в виде коллекции именованных значений.</td>
<td><code>{StringValueCollection object}</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.IsSecure">IsSecure</a></td>
<td>Определяет, использует ли запрос SSL (true) или нет (false).</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p>Вы также можете использовать свойство <a href="/api/Sisk.Core.Http.HttpRequest.Uri">HttpRequest.Uri</a>, которое включает все вышеперечисленное в один объект.</p>
<h2 id="получение-тела-запроса">Получение тела запроса</h2>
<p>Некоторые запросы включают тело, такое как формы, файлы или транзакции API. Вы можете получить тело запроса из свойства:</p>
<pre><code class="lang-cs">// получает тело запроса как строку, используя кодировку запроса в качестве декодера
string body = request.Body;

// или получает его в виде массива байтов
byte[] bodyBytes = request.RawBody;

// или вы можете передать его как поток.
Stream requestStream = request.GetRequestStream();
</code></pre>
<p>Также возможно определить, есть ли тело в запросе и загружено ли оно с помощью свойств <a href="/api/Sisk.Core.Http.HttpRequest.HasContents">HasContents</a>, которое определяет, имеет ли запрос содержимое, и <a href="/api/Sisk.Core.Http.HttpRequest.IsContentAvailable">IsContentAvailable</a>, которое указывает, что HTTP-сервер полностью получил содержимое из удаленной точки.</p>
<p>Невозможно прочитать содержимое запроса через <code>GetRequestStream</code> более одного раза. Если вы прочитаете его с помощью этого метода, значения в <code>RawBody</code> и <code>Body</code> также не будут доступны. Не нужно освобождать поток запроса в контексте запроса, поскольку он освобождается в конце HTTP-сессии, в которой он создается. Кроме того, вы можете использовать свойство <a href="/api/Sisk.Core.Http.HttpRequest.RequestEncoding">HttpRequest.RequestEncoding</a>, чтобы получить лучшую кодировку для декодирования запроса вручную.</p>
<p>Сервер имеет ограничения на чтение содержимого запроса, которые применяются как к <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.Body</a>, так и к <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.RawBody</a>. Эти свойства копируют весь входной поток в локальный буфер того же размера, что и <a href="/api/Sisk.Core.Http.HttpRequest.ContentLength">HttpRequest.ContentLength</a>.</p>
<p>Ответ со статусом 413 Содержимое слишком велико возвращается клиенту, если отправленное содержимое больше <a href="/api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength">HttpServerConfiguration.MaximumContentLength</a>, определенного в конфигурации пользователя. Кроме того, если нет настроенного ограничения или если оно слишком велико, сервер выдаст исключение <a href="https://learn.microsoft.com/en-us/dotnet/api/system.outofmemoryexception?view=net-8.0">OutOfMemoryException</a>, когда содержимое, отправленное клиентом, превышает <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32.maxvalue">Int32.MaxValue</a> (2 ГБ), и если содержимое попытается получить доступ через одно из вышеупомянутых свойств. Вы все равно можете иметь дело с содержимым через поток.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Хотя Sisk позволяет это, всегда хорошей идеей является следование семантике HTTP для создания вашего приложения и не получать или обслуживать содержимое в методах, которые не допускают этого. Прочитайте о <a href="https://httpwg.org/spec/rfc9110.html">RFC 9110 &quot;HTTP Семантика&quot;</a>.</p>
</div>
<h2 id="получение-контекста-запроса">Получение контекста запроса</h2>
<p>Контекст HTTP — это эксклюзивный объект Sisk, который хранит информацию о сервере HTTP, маршруте, маршрутизаторе и обработчике запроса. Вы можете использовать его, чтобы организовать себя в среде, где эти объекты трудно организовать.</p>
<p>Объект <a href="/api/Sisk.Core.Http.HttpContext.RequestBag">RequestBag</a> содержит сохраненную информацию, которая передается из обработчика запроса в другую точку, и может быть потреблена в конечной точке. Этот объект также может быть использован обработчиками запросов, которые запускаются после обратного вызова маршрута.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Это свойство также доступно через свойство <a href="/api/Sisk.Core.Http.HttpRequest.Bag">HttpRequest.Bag</a>.</p>
</div>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public string Identifier { get; init; } = Guid.NewGuid().ToString();
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;

    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers[&quot;Authorization&quot;] != null)
        {
            context.RequestBag.Add(&quot;AuthenticatedUser&quot;, &quot;Bob&quot;);
            return null;
        }
        else
        {
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>Вышеуказанный обработчик запроса определит <code>AuthenticatedUser</code> в сумке запроса, и может быть потреблен позже в конечном вызове:</p>
<pre><code class="lang-cs">public class MyController
{
    [Route(RouteMethod.Get, &quot;/&quot;)]
    [RequestHandler(typeof(AuthenticateUserRequestHandler))]
    static HttpResponse Index(HttpRequest request)
    {
        HttpResponse res = new HttpResponse();
        string authUser = request.Context.RequestBag[&quot;AuthenticatedUser&quot;];
        res.Content = new StringContent($&quot;Hello, {authUser}!&quot;);
        return res;
    }
}
</code></pre>
<p>Вы также можете использовать методы <code>Bag.Set()</code> и <code>Bag.Get()</code>, чтобы получить или задать объекты по их типам синглтонов.</p>
<pre><code class="lang-cs">public class Authenticate : RequestHandler
{
    public override HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        request.Bag.Set&lt;User&gt;(authUser);
    }
}

[RouteGet(&quot;/&quot;)]
[RequestHandler&lt;Authenticate&gt;]
public static HttpResponse Test(HttpRequest request)
{
    var user = request.Bag.Get&lt;User&gt;();
}
</code></pre>
<h2 id="получение-данных-формы">Получение данных формы</h2>
<p>Вы можете получить значения данных формы в <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.specialized.namevaluecollection">NameValueCollection</a> с помощью следующего примера:</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    var form = request.GetFormContent();

    string? username = form[&quot;username&quot;];
    string? password = form[&quot;password&quot;];

    if (AttempLogin(username, password) == true)
    {
        ...
    }
}
</code></pre>
<h2 id="получение-данных-multipart-формы">Получение данных multipart-формы</h2>
<p>Запрос HTTP Sisk позволяет получить отправленные multipart-содержимое, такое как файлы, поля формы или любое бинарное содержимое.</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    // следующий метод читает весь входной запрос в массив
    // MultipartObject
    var multipartFormDataObjects = request.GetMultipartFormContent();

    foreach (MultipartObject uploadedObject in multipartFormDataObjects)
    {
        // имя файла, предоставленное multipart-формой.
        // Null возвращается, если объект не является файлом.
        Console.WriteLine(&quot;File name       : &quot; + uploadedObject.Filename);

        // имя поля multipart-формы.
        Console.WriteLine(&quot;Field name      : &quot; + uploadedObject.Name);

        // длина содержимого multipart-формы.
        Console.WriteLine(&quot;Content length  : &quot; + uploadedObject.ContentLength);

        // определите формат изображения на основе файла для каждого
        // известного типа содержимого. Если содержимое не является признанным
        // обычным форматом файла, этот метод ниже вернет
        // MultipartObjectCommonFormat.Unknown
        Console.WriteLine(&quot;Common format   : &quot; + uploadedObject.GetCommonFileFormat());
    }
}
</code></pre>
<p>Вы можете прочитать больше о <a href="/api/Sisk.Core.Entity.MultipartObject">Multipart-объектах Sisk</a> и их методах, свойствах и функциях.</p>
<h2 id="поддержка-серверных-событий">Поддержка серверных событий</h2>
<p>Sisk поддерживает <a href="https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events">серверные события</a>, которые позволяют отправлять фрагменты как поток и поддерживать соединение между сервером и клиентом.</p>
<p>Вызов метода <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource</a> приведет к тому, что запрос HTTP будет находиться в состоянии прослушивания. С этого момента контекст этого HTTP-запроса не будет ожидать ответа HTTP, поскольку он перекроет пакеты, отправленные серверными событиями.</p>
<p>После отправки всех пакетов обратный вызов должен вернуть метод <a href="/api/Sisk.Core.Http.HttpRequestEventSource.Close">Close</a>, который отправит окончательный ответ серверу и укажет, что потоковое передача завершилась.</p>
<p>Невозможно предсказать общую длину всех пакетов, которые будут отправлены, поэтому невозможно определить конец соединения с помощью заголовка <code>Content-Length</code>.</p>
<p>По умолчанию большинства браузеров серверные события не поддерживают отправку HTTP-заголовков или методов, кроме метода GET. Поэтому будьте осторожны при использовании обработчиков запросов с запросами event-source, которые требуют определенных заголовков в запросе, поскольку они, вероятно, не будут иметь их.</p>
<p>Кроме того, большинство браузеров перезапускают потоки, если метод <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource/close">EventSource.close</a> не вызван на стороне клиента после получения всех пакетов, что вызывает бесконечную дополнительную обработку на стороне сервера. Чтобы избежать этой проблемы, обычно отправляют окончательный пакет, указывающий, что источник событий завершил отправку всех пакетов.</p>
<p>Пример ниже показывает, как браузер может общаться с сервером, поддерживающим серверные события.</p>
<pre><code class="lang-html">&lt;html&gt;
    &lt;body&gt;
        &lt;b&gt;Фрукты:&lt;/b&gt;
        &lt;ul&gt;&lt;/ul&gt;
    &lt;/body&gt;
    &lt;script&gt;
        const evtSource = new EventSource('/event-source');
        const eventList = document.querySelector('ul');

        evtSource.onmessage = (e) =&gt; {
            const newElement = document.createElement(&quot;li&quot;);

            newElement.textContent = `message: ${e.data}`;
            eventList.appendChild(newElement);

            if (e.data == &quot;Tomato&quot;) {
                evtSource.close();
            }
        }
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>И постепенно отправляйте сообщения клиенту:</p>
<pre><code class="lang-cs">public class MyController
{
    [Route(RouteMethod.Get, &quot;/event-source&quot;)]
    static HttpResponse ServerEventsResponse(HttpRequest request)
    {
        var serverEvents = request.GetEventSource();

        string[] fruits = new[] { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Watermelon&quot;, &quot;Tomato&quot; };

        foreach (string fruit in fruits)
        {
            serverEvents.Send(fruit);
            Thread.Sleep(1500);
        }

        return serverEvents.Close();
    }
}
</code></pre>
<p>Когда мы запускаем этот код, мы ожидаем результат, подобный этому:</p>
<img src="/assets/img/server side events demo.gif">
<h2 id="разрешение-прокси-ip-и-хостов">Разрешение прокси-IP и хостов</h2>
<p>Sisk можно использовать с прокси, и поэтому IP-адреса могут быть заменены на конечную точку прокси в транзакции от клиента к прокси.</p>
<p>Вы можете определить свои собственные разрешители в Sisk с помощью <a href="/docs/advanced/forwarding-resolvers">разрешителей пересылки</a>.</p>
<h2 id="кодирование-заголовков">Кодирование заголовков</h2>
<p>Кодирование заголовков может быть проблемой для некоторых реализаций. В Windows не поддерживаются заголовки UTF-8, поэтому используется ASCII. Sisk имеет встроенный конвертер кодировки, который может быть полезен для декодирования неправильно закодированных заголовков.</p>
<p>Эта операция дорога и отключена по умолчанию, но может быть включена под флагом <a href="/specification/spec/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings">NormalizeHeadersEncodings</a>.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/requests.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>