<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Ответы | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Ответы | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="ответы">Ответы</h1>

<p>Ответы представляют собой объекты, которые являются HTTP-ответами на HTTP-запросы. Они отправляются сервером клиенту в качестве указания на запрос ресурса, страницы, документа, файла или другого объекта.</p>
<p>HTTP-ответ состоит из статуса, заголовков и содержимого.</p>
<p>В этом документе мы научим вас, как проектировать HTTP-ответы с помощью Sisk.</p>
<h2 id="установка-http-статуса">Установка HTTP-статуса</h2>
<p>Список HTTP-статусов остался неизменным с HTTP/1.0, и Sisk поддерживает все они.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; // 202
</code></pre>
<p>Или с помощью синтаксиса Fluent:</p>
<pre><code class="lang-cs">new HttpResponse()
    .WithStatus(200) // или
    .WithStatus(HttpStatusCode.Ok) // или
    .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Вы можете увидеть полный список доступных HttpStatusCode <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.httpstatuscode">здесь</a>. Вы также можете предоставить свой собственный код статуса, используя структуру <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>.</p>
<h2 id="тело-и-тип-содержимого">Тело и тип содержимого</h2>
<p>Sisk поддерживает родные объекты .NET для отправки тела в ответах. Вы можете использовать класс <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.stringcontent">StringContent</a>, чтобы отправить JSON-ответ, например:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>Сервер всегда попытается рассчитать <code>Content-Length</code> из того, что вы определили в содержимом, если вы не определили его явно в заголовке. Если сервер не может неявно получить заголовок <code>Content-Length</code> из содержимого ответа, ответ будет отправлен с Chunked-Encoding.</p>
<p>Вы также можете передавать ответ, отправляя <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.streamcontent">StreamContent</a> или используя метод <a href="/api/Sisk.Core.Http.HttpRequest.GetResponseStream">GetResponseStream</a>.</p>
<h2 id="заголовки-ответа">Заголовки ответа</h2>
<p>Вы можете добавлять, редактировать или удалять заголовки, которые отправляются в ответе. Пример ниже показывает, как отправить ответ с перенаправлением клиенту.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>Или с помощью синтаксиса Fluent:</p>
<pre><code class="lang-cs">new HttpResponse(301)
    .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Когда вы используете метод <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a> класса HttpHeaderCollection, вы добавляете заголовок к запросу без изменения уже отправленных заголовков. Метод <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a> заменяет заголовки с тем же именем на указанное значение. Индексатор HttpHeaderCollection внутренне вызывает метод Set для замены заголовков.</p>
<h2 id="отправка-файлов-cookie">Отправка файлов cookie</h2>
<p>Sisk имеет методы, которые облегчают определение файлов cookie на клиенте. Файлы cookie, установленные этим методом, уже закодированы в URL и соответствуют стандарту RFC-6265.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;);
</code></pre>
<p>Или с помощью синтаксиса Fluent:</p>
<pre><code class="lang-cs">new HttpResponse(301)
    .WithCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Существуют другие <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">более полные версии</a> того же метода.</p>
<h2 id="фрагментированные-ответы">Фрагментированные ответы</h2>
<p>Вы можете установить кодирование передачи на фрагментированное, чтобы отправить большие ответы.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>При использовании фрагментированного кодирования заголовок <code>Content-Length</code> автоматически опускается.</p>
<h2 id="поток-ответа">Поток ответа</h2>
<p>Потоки ответа являются управляемым способом, который позволяет отправлять ответы поэтапно. Это более низкоуровневая операция, чем использование объектов HttpResponse, поскольку они требуют от вас отправки заголовков и содержимого вручную, а затем закрытия соединения.</p>
<p>Этот пример открывает поток только для чтения файла, копирует поток в поток вывода ответа и не загружает весь файл в память. Это может быть полезно для обслуживания средних или больших файлов.</p>
<pre><code class="lang-cs">// получает поток вывода ответа
using var fileStream = File.OpenRead(&quot;my-big-file.zip&quot;);
var responseStream = request.GetResponseStream();

// устанавливает кодирование ответа для использования фрагментированного кодирования
// также не следует отправлять заголовок content-length при использовании
// фрагментированного кодирования
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// копирует поток файла в поток вывода ответа
fileStream.CopyTo(responseStream.ResponseStream);

// закрывает поток
return responseStream.Close();
</code></pre>
<h2 id="сжатие-gzip-deflate-и-brotli">Сжатие GZip, Deflate и Brotli</h2>
<p>Вы можете отправлять ответы со сжатым содержимым в Sisk, сжимая HTTP-содержимое. Сначала оберните объект <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent">HttpContent</a> в один из компрессоров ниже, чтобы отправить сжатый ответ клиенту.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
    string myHtml = &quot;...&quot;;
    
    return new HttpResponse () {
        Content = new GZipContent(new HtmlContent(myHtml)),
        // или Content = new BrotliContent(new HtmlContent(myHtml)),
        // или Content = new DeflateContent(new HtmlContent(myHtml)),
    };
});
</code></pre>
<p>Вы также можете использовать эти сжатые содержимые с потоками.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
    // не примените &quot;using&quot; здесь. HttpServer будет удалять ваше содержимое
    // после отправки ответа.
    var archive = File.OpenRead(&quot;/path/to/big-file.zip&quot;);
    
    return new HttpResponse () {
        Content = new GZipContent(archive)
    }
});
</code></pre>
<p>Заголовки <code>Content-Encoding</code> автоматически устанавливаются при использовании этих содержимых.</p>
<h2 id="неявные-типы-ответов">Неявные типы ответов</h2>
<p>Поскольку версии 0.15, вы можете использовать другие типы ответов, кроме HttpResponse, но необходимо настроить маршрутизатор, чтобы он обрабатывал каждый тип объекта.</p>
<p>Концепция заключается в том, чтобы всегда возвращать ссылочный тип и преобразовать его в допустимый объект HttpResponse. Маршруты, которые возвращают HttpResponse, не проходят никаких преобразований.</p>
<p>Типы значений (структуры) не могут использоваться в качестве типа ответа, поскольку они несовместимы с <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a>, поэтому они должны быть обернуты в ValueResult, чтобы их можно было использовать в обработчиках.</p>
<p>Рассмотрим следующий пример из модуля маршрутизатора, не использующего HttpResponse в качестве типа ответа:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
    public List&lt;User&gt; Users = new List&lt;User&gt;();

    [RouteGet]
    public IEnumerable&lt;User&gt; Index(HttpRequest request)
    {
        return Users.ToArray();
    }

    [RouteGet(&quot;&lt;id&gt;&quot;)]
    public User View(HttpRequest request)
    {
        int id = request.RouteParameters[&quot;id&quot;].GetInteger();
        User dUser = Users.First(u =&gt; u.Id == id);

        return dUser;
    }

    [RoutePost]
    public ValueResult&lt;bool&gt; Create(HttpRequest request)
    {
        User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
        Users.Add(fromBody);
        
        return true;
    }
}
</code></pre>
<p>С этого момента необходимо определить в маршрутизаторе, как он будет обрабатывать каждый тип объекта. Объекты всегда являются первым аргументом обработчика, а тип ответа должен быть допустимым объектом HttpResponse. Кроме того, выходные объекты маршрута никогда не должны быть null.</p>
<p>Для типов ValueResult не нужно указывать, что входной объект является ValueResult, и только T, поскольку ValueResult является объектом, отраженным от его исходного компонента.</p>
<p>Связь типов не сравнивает, что было зарегистрировано с типом объекта, возвращаемого из обратного вызова маршрутизатора. Вместо этого он проверяет, является ли тип результата маршрутизатора присваиваемым зарегистрированному типу.</p>
<p>Регистрация обработчика типа Object будет откатиться ко всем предыдущим непроверенным типам. Порядок вставки обработчиков значений также имеет значение, поэтому регистрация обработчика Object будет игнорировать все другие типоспецифические обработчики. Всегда регистрируйте конкретные обработчики значений сначала, чтобы обеспечить порядок.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;bool&gt;(bolVal =&gt;
{
    HttpResponse res = new HttpResponse();
    res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest;
    return res;
});

r.RegisterValueHandler&lt;IEnumerable&gt;(enumerableValue =&gt;
{
    return new HttpResponse();
    // do something with enumerableValue here
});

// регистрация обработчика значения объекта должна быть последней
// обработчик значения, который будет использоваться в качестве откатного
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
    HttpResponse res = new HttpResponse();
    res.Status = HttpStatusCode.OK;
    res.Content = JsonContent.Create(fallback);
    return res;
});
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines == 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>