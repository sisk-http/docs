<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Responses | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Responses | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="responses">Responses</h1>

<p>Ответы представляют собой объекты, которые являются HTTP-ответами на HTTP-запросы. Они отправляются сервером клиенту в качестве указания на запрос ресурса, страницы, документа, файла или другого объекта.</p>
<p>HTTP-ответ состоит из статуса, заголовков и содержимого.</p>
<p>В этом документе мы научим вас, как архитектировать HTTP-ответы с помощью Sisk.</p>
<h2 id="установка-http-статуса">Установка HTTP-статуса</h2>
<p>Список HTTP-статусов одинаков с момента появления HTTP/1.0, и Sisk поддерживает все из них.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; //202
</code></pre>
<p>Или с помощью Fluent Syntax:</p>
<pre><code class="lang-cs">new HttpResponse()
 .WithStatus(200) // или
 .WithStatus(HttpStatusCode.Ok) // или
 .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Вы можете просмотреть полный список доступных HttpStatusCode <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.httpstatuscode">здесь</a>. Вы также можете указать свой собственный код статуса, используя структуру <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>.</p>
<h2 id="тело-и-тип-содержимого">Тело и тип содержимого</h2>
<p>Sisk поддерживает родные объекты содержимого .NET для отправки тела в ответах. Вы можете использовать класс <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.stringcontent">StringContent</a> для отправки JSON-ответа, например:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>Сервер всегда попытается рассчитать <code>Content-Length</code> из того, что вы определили в содержимом, если вы явно не определили его в заголовке. Если сервер не может неявно получить заголовок Content-Length из содержимого ответа, ответ будет отправлен с Chunked-Encoding.</p>
<p>Вы также можете передавать ответ, отправляя <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.streamcontent">StreamContent</a> или используя метод <a href="/api/Sisk.Core.Http.HttpRequest.GetResponseStream">GetResponseStream</a>.</p>
<h2 id="заголовки-ответа">Заголовки ответа</h2>
<p>Вы можете добавлять, редактировать или удалять заголовки, которые отправляются в ответе. Пример ниже показывает, как отправить ответ с перенаправлением клиенту.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>Или с помощью Fluent Syntax:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Когда вы используете метод <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a> коллекции HttpHeaderCollection, вы добавляете заголовок к запросу, не изменяя уже отправленные. Метод <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a> заменяет заголовки с тем же именем на указанное значение. Индексатор HttpHeaderCollection внутренне вызывает метод Set для замены заголовков.</p>
<h2 id="отправка-куки">Отправка куки</h2>
<p>Sisk имеет методы, которые облегчают определение куки на клиенте. Куки, установленные этим методом, уже закодированы URL и соответствуют стандарту RFC-6265.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;);
</code></pre>
<p>Или с помощью Fluent Syntax:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Имеются другие <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">более полные версии</a> того же метода.</p>
<h2 id="частичные-ответы">Частичные ответы</h2>
<p>Вы можете установить тип кодирования передачи на частичный для отправки больших ответов.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>При использовании chunked-encoding заголовок Content-Length автоматически опускается.</p>
<h2 id="поток-ответа">Поток ответа</h2>
<p>Потоки ответа - это управляемый способ, который позволяет отправлять ответы в сегментированном виде. Это более низкоуровневая операция, чем использование объектов HttpResponse, поскольку они требуют от вас отправки заголовков и содержимого вручную, а затем закрытия соединения.</p>
<p>Этот пример открывает поток только для чтения для файла, копирует поток в выходной поток ответа и не загружает весь файл в память. Это может быть полезно для обслуживания средних или больших файлов.</p>
<pre><code class="lang-cs">// получает выходной поток ответа
using var fileStream = File.OpenRead(&quot;my-big-file.zip&quot;);
var responseStream = request.GetResponseStream();

// устанавливает кодирование ответа для использования chunked-encoding
// также не следует отправлять заголовок content-length при использовании
// chunked encoding
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// копирует поток файла в выходной поток ответа
fileStream.CopyTo(responseStream.ResponseStream);

// закрывает поток
return responseStream.Close();
</code></pre>
<h2 id="сжатие-gzip-deflate-и-brotli">Сжатие GZip, Deflate и Brotli</h2>
<p>Вы можете отправлять ответы со сжатым содержимым в Sisk с помощью сжатия HTTP-содержимого. Во-первых, инкапсулируйте ваш объект <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent">HttpContent</a> внутри одного из компрессоров ниже, чтобы отправить сжатый ответ клиенту.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
 string myHtml = &quot;...&quot;;
    
 return new HttpResponse () {
 Content = new GZipContent(new HtmlContent(myHtml)),
 // или Content = new BrotliContent(new HtmlContent(myHtml)),
 // или Content = new DeflateContent(new HtmlContent(myHtml)),
 };
});
</code></pre>
<p>Вы также можете использовать эти сжатые содержимое с потоками.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
 // не применяйте &quot;using&quot; здесь. HttpServer отклонит ваше содержимое
 // после отправки ответа.
 var archive = File.OpenRead(&quot;/path/to/big-file.zip&quot;);
    
 return new HttpResponse () {
 Content = new GZipContent(archive)
 }
});
</code></pre>
<p>Заголовки Content-Encoding устанавливаются автоматически при использовании этих содержимостей.</p>
<h2 id="автоматическое-сжатие">Автоматическое сжатие</h2>
<p>Возможно автоматически сжимать HTTP-ответы с помощью свойства <a href="/api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression">EnableAutomaticResponseCompression</a>. Это свойство автоматически инкапсулирует содержимое ответа от маршрутизатора в сжимаемое содержимое, которое принимается запросом, при условии, что ответ не унаследован от <a href="/api/Sisk.Core.Http.CompressedContent">CompressedContent</a>.</p>
<p>Только одно сжимаемое содержимое выбирается для запроса, выбранное в соответствии с заголовком Accept-Encoding, который следует порядку:</p>
<ul>
<li><a href="/api/Sisk.Core.Http.BrotliContent">BrotliContent</a> (br)</li>
<li><a href="/api/Sisk.Core.Http.GZipContent">GZipContent</a> (gzip)</li>
<li><a href="/api/Sisk.Core.Http.DeflateContent">DeflateContent</a> (deflate)</li>
</ul>
<p>Если запрос указывает, что он принимает любой из этих методов сжатия, ответ будет автоматически сжат.</p>
<h2 id="неявные-типы-ответов">Неявные типы ответов</h2>
<p>Вы можете использовать другие типы возвращаемых значений, кроме HttpResponse, но необходимо настроить маршрутизатор, чтобы он обрабатывал каждый тип объекта.</p>
<p>Концепция состоит в том, чтобы всегда возвращать ссылочный тип и преобразовывать его в допустимый объект HttpResponse. Маршруты, которые возвращают HttpResponse, не подвергаются никаким преобразованиям.</p>
<p>Типы значений (структуры) не могут быть использованы в качестве типа возвращаемого значения, потому что они не совместимы с <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a>, поэтому они должны быть обернуты в ValueResult, чтобы иметь возможность использоваться в обработчиках.</p>
<p>Рассмотрим следующий пример из модуля маршрутизатора, не использующего HttpResponse в качестве типа возвращаемого значения:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
 public List&lt;User&gt; Users = new List&lt;User&gt;();

 [RouteGet]
 public IEnumerable&lt;User&gt; Index(HttpRequest request)
 {
 return Users.ToArray();
 }

 [RouteGet(&quot;&lt;id&gt;&quot;)]
 public User View(HttpRequest request)
 {
 int id = request.RouteParameters[&quot;id&quot;].GetInteger();
 User dUser = Users.First(u =&gt; u.Id == id);

 return dUser;
 }

 [RoutePost]
 public ValueResult&lt;bool&gt; Create(HttpRequest request)
 {
 User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
 Users.Add(fromBody);
        
 return true;
 }
}
</code></pre>
<p>При этом теперь необходимо определить в маршрутизаторе, как он будет обрабатывать каждый тип объекта. Объекты всегда являются первым аргументом обработчика, а тип вывода должен быть допустимым объектом HttpResponse. Также выходные объекты маршрута никогда не должны быть null.</p>
<p>Для типов ValueResult не обязательно указывать, что входной объект является ValueResult, и только T, поскольку ValueResult является объектом, отраженным от его исходного компонента.</p>
<p>Ассоциация типов не сравнивает то, что было зарегистрировано, с типом объекта, возвращаемого из обратного вызова маршрутизатора. Вместо этого она проверяет, является ли тип результата маршрутизатора присваиваемым зарегистрированному типу.</p>
<p>Регистрация обработчика типа Object будет резервным для всех ранее не проверенных типов. Порядок вставки обработчиков значений также имеет значение, поэтому регистрация обработчика Object проигнорирует все другие обработчики, специфичные для типов. Всегда регистрируйте обработчики значений сначала, чтобы обеспечить порядок.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;ApiResult&gt;(apiResult =&gt;
{
 return new HttpResponse() {
 Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest,
 Content = apiResult.GetHttpContent(),
 Headers = apiResult.GetHeaders()
 };
});
r.RegisterValueHandler&lt;bool&gt;(bvalue =&gt;
{
 return new HttpResponse() {
 Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest
 };
});
r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(enumerableValue =&gt;
{
 return new HttpResponse(string.Join(&quot;\n&quot;, enumerableValue));
});

// регистрация обработчика значений объекта должна быть последней
// обработчиком значений, который будет использоваться в качестве резервного
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
 return new HttpResponse() {
 Status = HttpStatusCode.OK,
 Content = JsonContent.Create(fallback)
 };
});
</code></pre>
<h2 id="примечание-о-перечислимых-объектах-и-массивах">Примечание о перечислимых объектах и массивах</h2>
<p>Неявные объекты ответа, реализующие <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.ienumerable?view=net-8.0">IEnumerable</a>, читаются в память с помощью метода <code>ToArray()</code> перед преобразованием с помощью определенного обработчика значений. Чтобы это произошло, объект <code>IEnumerable</code> преобразуется в массив объектов, и преобразователь ответа всегда получит <code>Object[]</code> вместо исходного типа.</p>
<p>Рассмотрим следующий сценарий:</p>
<pre><code class="lang-csharp">using var host = HttpServer.CreateBuilder(12300)
 .UseRouter(r =&gt;
 {
 r.RegisterValueHandler&lt;IEnumerable&lt;string&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Массив строк:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Массив объектов:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.MapGet(&quot;/&quot;, request =&gt;
 {
 return (IEnumerable&lt;string&gt;)[&quot;hello&quot;, &quot;world&quot;];
 });
 })
 .Build();
</code></pre>
<p>В приведенном выше примере преобразователь <code>IEnumerable&lt;string&gt;</code> <strong>никогда не будет вызван</strong>, потому что входной объект всегда будет массивом <code>Object[]</code> и не может быть преобразован в <code>IEnumerable&lt;string&gt;</code>. Однако преобразователь ниже, который получает <code>IEnumerable&lt;object&gt;</code>, получит свой вход, поскольку его значение совместимо.</p>
<p>Если вам нужно фактически обрабатывать тип объекта, который будет перечислен, вам нужно использовать отражение, чтобы получить тип элемента коллекции. Все перечислимые объекты (списки, массивы и коллекции) преобразуются в массив объектов преобразователем HTTP-ответа.</p>
<p>Значения, реализующие <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0">IAsyncEnumerable</a>, обрабатываются автоматически сервером, если включено свойство <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable">ConvertIAsyncEnumerableIntoEnumerable</a>, подобно тому, что происходит с <code>IEnumerable</code>. Асинхронная перечисляемая последовательность преобразуется в блокирующий перечислитель, а затем преобразуется в синхронный массив объектов.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>