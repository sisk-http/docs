<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Обработка запросов | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Обработка запросов | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/request-handlers.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>
                    <div class="actionbar-actions">
                        <div id="language-wrapper">
                            <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                                <i class="bi bi-globe"></i>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                        <img src="/assets/flag/usa.png">
                                        English
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                        <img src="/assets/flag/russia.png">
                                        Русский
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                        <img src="/assets/flag/brazil.png">
                                        Português
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                        <img src="/assets/flag/spain.png">
                                        Español
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                        <img src="/assets/flag/germany.png">
                                        Deutsch
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                        <img src="/assets/flag/china.png">
                                        中文 (简体)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                        <img src="/assets/flag/japan.png">
                                        日本語
                                    </a>
                                </li>
                            </ul>
                        </div>

                        <div id="copy-article-wrapper">
                            <a class="btn border-0" id="copy-article-btn" title="Copy article">
                                <i class="bi bi-copy"></i>
                            </a>
                            <div class="copy-dropdown" id="copy-dropdown">
                                <button type="button" id="copy-link-btn">
                                    <i class="bi bi-link-45deg"></i>
                                    Copy link
                                </button>
                                <button type="button" id="copy-markdown-btn">
                                    <i class="bi bi-markdown"></i>
                                    Copy as Markdown
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <article data-uid="">
<h1 id="обработка-запросов">Обработка запросов</h1>

<p>Обработчики запросов, также известные как &quot;посредники&quot;, являются функциями, которые выполняются до или после выполнения запроса на маршрутизаторе. Они могут быть определены для каждого маршрута или для всего маршрутизатора.</p>
<p>Существует два типа обработчиков запросов:</p>
<ul>
<li><strong>BeforeResponse</strong>: определяет, что обработчик запроса будет выполнен до вызова действия маршрутизатора.</li>
<li><strong>AfterResponse</strong>: определяет, что обработчик запроса будет выполнен после вызова действия маршрутизатора. Отправка ответа HTTP в этом контексте перезапишет ответ действия маршрутизатора.</li>
</ul>
<p>Оба обработчика запросов могут переопределить фактическую функцию ответа маршрутизатора. Кроме того, обработчики запросов могут быть полезны для проверки запроса, такой как аутентификация, содержимое или любая другая информация, такая как хранение информации, журналов или других шагов, которые можно выполнить до или после ответа.</p>
<p><img src="/assets/img/requesthandlers1.png" alt=""></p>
<p>Таким образом, обработчик запроса может прервать все это выполнение и вернуть ответ до завершения цикла, отбрасывая все остальное в процессе.</p>
<p>Пример: предположим, что обработчик запроса аутентификации пользователя не аутентифицирует его. Это предотвратит продолжение жизненного цикла запроса и зависнет. Если это происходит в обработчике запроса на второй позиции, третий и последующие не будут оценены.</p>
<p><img src="/assets/img/requesthandlers2.png" alt=""></p>
<h2 id="создание-обработчика-запроса">Создание обработчика запроса</h2>
<p>Чтобы создать обработчик запроса, мы можем создать класс, который наследует интерфейс <a href="/api/Sisk.Core.Routing.IRequestHandler">IRequestHandler</a>, в следующем формате:</p>
<div class="script-header">
    <span>
        Middleware/AuthenticateUserRequestHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;

    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            // Возвращение null указывает на то, что цикл запроса может быть продолжен
            return null;
        }
        else
        {
            // Возвращение объекта HttpResponse указывает на то, что этот ответ перезапишет соседние ответы.
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>В приведенном выше примере мы указали, что если заголовок <code>Authorization</code> присутствует в запросе, он должен продолжаться, и следующий обработчик запроса или callback маршрутизатора должен быть вызван, в зависимости от того, что происходит дальше. Если обработчик запроса выполняется после ответа по свойству <a href="/api/Sisk.Core.Routing.IRequestHandler.ExecutionMode">ExecutionMode</a> и возвращает не-null значение, он перезапишет ответ маршрутизатора.</p>
<p>Когда обработчик запроса возвращает <code>null</code>, это указывает на то, что запрос должен продолжаться, и следующий объект должен быть вызван, или цикл должен завершиться ответом маршрутизатора.</p>
<h2 id="связывание-обработчика-запроса-с-одним-маршрутом">Связывание обработчика запроса с одним маршрутом</h2>
<p>Вы можете определить один или несколько обработчиков запросов для маршрута.</p>
<div class="script-header">
    <span>
        Router.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/&quot;, IndexPage, &quot;&quot;, new IRequestHandler[]
{
    new AuthenticateUserRequestHandler(),     // до запроса обработчик
    new ValidateJsonContentRequestHandler(),  // до запроса обработчик
    //                                        -- метод IndexPage будет выполнен здесь
    new WriteToLogRequestHandler()            // после запроса обработчик
});
</code></pre>
<p>Или создавая объект <a href="/api/Sisk.Core.Routing.Route">Route</a>:</p>
<div class="script-header">
    <span>
        Router.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, &quot;/&quot;, &quot;&quot;, IndexPage, null);
indexRoute.RequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
mainRouter.SetRoute(indexRoute);
</code></pre>
<h2 id="связывание-обработчика-запроса-с-маршрутизатором">Связывание обработчика запроса с маршрутизатором</h2>
<p>Вы можете определить глобальный обработчик запроса, который будет выполняться для всех маршрутов на маршрутизаторе.</p>
<div class="script-header">
    <span>
        Router.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
</code></pre>
<h2 id="связывание-обработчика-запроса-с-атрибутом">Связывание обработчика запроса с атрибутом</h2>
<p>Вы можете определить обработчик запроса на методе атрибута вместе с атрибутом маршрута.</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        return new HttpResponse() {
            Content = new StringContent(&quot;Hello world!&quot;)
        };
    }
}
</code></pre>
<p>Обратите внимание, что необходимо передать желаемый тип обработчика запроса, а не экземпляр объекта. Таким образом, обработчик запроса будет создан парсером маршрутизатора. Вы можете передать аргументы в конструктор класса с помощью свойства <a href="/api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments">ConstructorArguments</a>.</p>
<p>Пример:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RequestHandler&lt;AuthenticateUserRequestHandler&gt;(&quot;arg1&quot;, 123, ...)]
public HttpResponse Index(HttpRequest request)
{
    return res = new HttpResponse() {
        Content = new StringContent(&quot;Hello world!&quot;)
    };
}
</code></pre>
<p>Вы также можете создать собственный атрибут, который реализует RequestHandler:</p>
<div class="script-header">
    <span>
        Middleware/Attributes/AuthenticateAttribute.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class AuthenticateAttribute : RequestHandlerAttribute
{
    public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { &quot;arg1&quot;, 123, ... })
    {
        ;
    }
}
</code></pre>
<p>И использовать его как:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[Authenticate]
static HttpResponse Index(HttpRequest request)
{
    return res = new HttpResponse() {
        Content = new StringContent(&quot;Hello world!&quot;)
    };
}
</code></pre>
<h2 id="пропуск-глобального-обработчика-запроса">Пропуск глобального обработчика запроса</h2>
<p>После определения глобального обработчика запроса на маршруте вы можете игнорировать этот обработчик запроса на конкретных маршрутах.</p>
<div class="script-header">
    <span>
        Router.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">var myRequestHandler = new AuthenticateUserRequestHandler();
mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    myRequestHandler
};

mainRouter.SetRoute(new Route(RouteMethod.Get, &quot;/&quot;, &quot;My route&quot;, IndexPage, null)
{
    BypassGlobalRequestHandlers = new IRequestHandler[]
    {
        myRequestHandler,                    // ок: тот же экземпляр, что и в глобальных обработчиках запросов
        new AuthenticateUserRequestHandler() // неправильно: не пропустит глобальный обработчик запроса
    }
});
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Если вы пропускаете обработчик запроса, вы должны использовать тот же ссылочный экземпляр, который был создан ранее, чтобы пропустить. Создание другого экземпляра обработчика запроса не пропустит глобальный обработчик запроса, поскольку его ссылка изменится. Помните, что необходимо использовать тот же ссылочный экземпляр обработчика запроса, который используется в обоих GlobalRequestHandlers и BypassGlobalRequestHandlers.</p>
</div>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/request-handlers.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext", "ApiGenerationContext", "OpenApiExporter", "BodyExampleResult",
                            "ParameterExampleResult", "OpenApiContact", "OpenApiLicense", "HttpContent",
                            "ApiDocumentation", "CrossOriginResourceSharingHeaders", "McpProvider",
                            "JsonSchema", "McpToolContext", "HttpListenerAbstractEngine", "HttpListener",
                            "CadenteHttpServerEngine", "CertificateHelper"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort", "HttpServerEngineContextEventLoopMechanism"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
                
                (function() {
                    const copyBtn = document.getElementById('copy-article-btn');
                    const copyDropdown = document.getElementById('copy-dropdown');
                    const copyLinkBtn = document.getElementById('copy-link-btn');
                    const copyMarkdownBtn = document.getElementById('copy-markdown-btn');
                    
                    if (!copyBtn) return;
                    
                    copyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        copyDropdown.classList.toggle('show');
                    });
                    
                    document.addEventListener('click', function(e) {
                        if (!copyDropdown.contains(e.target) && e.target !== copyBtn) {
                            copyDropdown.classList.remove('show');
                        }
                    });
                    
                    function getArticleContent() {
                        const article = document.querySelector('article');
                        if (!article) return null;
                        
                        const clone = article.cloneNode(true);
                        clone.querySelectorAll('.line-numbers, .code-action').forEach(el => el.remove());
                        
                        return clone;
                    }
                    
                    copyLinkBtn.addEventListener('click', function() {
                        navigator.clipboard.writeText(window.location.href);
                        copyDropdown.classList.remove('show');
                    });
                    
                    copyMarkdownBtn.addEventListener('click', async function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        if (typeof TurndownService === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/turndown/dist/turndown.js';
                            script.onload = function() {
                                convertAndCopy(article);
                            };
                            document.head.appendChild(script);
                        } else {
                            convertAndCopy(article);
                        }
                        
                        copyDropdown.classList.remove('show');
                    });
                    
                    function convertAndCopy(article) {
                        const turndown = new TurndownService({
                            headingStyle: 'atx',
                            codeBlockStyle: 'fenced'
                        });
                        
                        turndown.addRule('codeBlocks', {
                            filter: ['pre'],
                            replacement: function(content, node) {
                                const code = node.querySelector('code');
                                const langClass = code?.className.match(/lang-(\w+)/);
                                const lang = langClass ? langClass[1] : '';
                                const text = code?.textContent || content;
                                return '\n\n```' + lang + '\n' + text.trim() + '\n```\n\n';
                            }
                        });
                        
                        const markdown = turndown.turndown(article.innerHTML);
                        navigator.clipboard.writeText(markdown);
                    }
                })();
            </script>
        </footer>
    </body>
</html>