<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Обработка запросов | Sisk Framework </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Обработка запросов | Sisk Framework ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/request-handlers.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                document.querySelectorAll("pre").forEach(pre => {
                    const lineCount = pre.innerText.split('\n').length;
                    const lis = [];
                    
                    for(var i = 1; i < lineCount; i++)
                        lis.push(el("li", i))
                    
                    pre.appendChild(el("ul", ...lis));
                });
            });
        </script>
        
        <!-- Cloudflare Web Analytics -->
        <script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "e1483f9ff9e246f4bd69e45a87ef6923"}'></script>
        <!-- End Cloudflare Web Analytics -->

        <script>

            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>

    </head>


    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk Framework">
                        Sisk Framework
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="обработка-запросов">Обработка запросов</h1>

<p>Обработчики запросов, также известные как &quot;中间件&quot;, - это функции, которые выполняются до или после того, как запрос будет обработан маршрутизатором. Их можно определить для конкретного маршрута или для всего маршрутизатора.</p>
<p>Существуют два типа обработчиков запросов:</p>
<ul>
<li><strong>BeforeResponse</strong>: указывает, что обработчик запроса будет выполнен до вызова действия маршрутизатора.</li>
<li><strong>AfterResponse</strong>: указывает, что обработчик запроса будет выполнен после вызова действия маршрутизатора. Отправка HTTP-ответа в этом контексте перезапишет ответ действия маршрутизатора.</li>
</ul>
<p>Оба обработчика запросов могут перезаписать фактический ответ функции обратного вызова маршрутизатора. Кстати, обработчики запросов могут быть полезны для валидации запроса, например, аутентификации, содержимого или любой другой информации, такой как хранение информации, логирование или другие действия, которые можно выполнить до или после ответа.</p>
<p><img src="/assets/img/requesthandlers1.png" alt=""></p>
<p>Таким образом, обработчик запроса может прервать все эти действия и вернуть ответ, прежде чем завершить цикл, отбросив все остальное.</p>
<p>Пример: предположим, что обработчик запроса для аутентификации пользователя не аутентифицирует его. Это помешает продолжению жизненного цикла запроса и зависнет. Если это происходит в обработчике запроса на позиции два, то третий и последующие не будут оценены.</p>
<p><img src="/assets/img/requesthandlers2.png" alt=""></p>
<h2 id="создание-обработчика-запроса">Создание обработчика запроса</h2>
<p>Чтобы создать обработчик запроса, можно создать класс, наследующий интерфейс <a href="/api/Sisk.Core.Routing.IRequestHandler">IRequestHandler</a>, в следующем формате:</p>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;

    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            // Возвращение null указывает на то, что цикл запроса может быть продолжен
            return null;
        }
        else
        {
            // Возвращение объекта HttpResponse указывает на то, что этот ответ перезапишет соседние ответы.
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>В приведенном выше примере указано, что если запрос содержит заголовок <code>Authorization</code>, он должен продолжить выполнение, и будет вызван следующий обработчик запроса или обратный вызов маршрутизатора, whichever comes next. Если обработчик запроса выполняется после ответа с помощью их свойства <a href="/api/Sisk.Core.Routing.IRequestHandler.ExecutionMode">ExecutionMode</a> и возвращает не null значение, он перезапишет ответ маршрутизатора.</p>
<p>Каждый раз, когда обработчик запроса возвращает <code>null</code>, это указывает на то, что запрос должен быть продолжен, и должен быть вызван следующий объект или цикл должен завершиться ответом маршрутизатора.</p>
<h2 id="связывание-обработчика-запроса-с-отдельным-маршрутом">Связывание обработчика запроса с отдельным маршрутом</h2>
<p>Можно определить один или несколько обработчиков запросов для маршрута.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/&quot;, IndexPage, &quot;&quot;, new IRequestHandler[]
{
    new AuthenticateUserRequestHandler(),     // before request handler
    new ValidateJsonContentRequestHandler(),  // before request handler
    //                                        -- method IndexPage будет выполнен здесь
    new WriteToLogRequestHandler()            // after request handler
});
</code></pre>
<p>Или создание объекта <a href="/api/Sisk.Core.Routing.Route">Route</a>:</p>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, &quot;/&quot;, &quot;&quot;, IndexPage, null);
indexRoute.RequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
mainRouter.SetRoute(indexRoute);
</code></pre>
<h2 id="связывание-обработчика-запроса-с-маршрутизатором">Связывание обработчика запроса с маршрутизатором</h2>
<p>Можно определить глобальный обработчик запроса, который будет выполняться на всех маршрутах маршрутизатора.</p>
<pre><code class="lang-cs">mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
</code></pre>
<h2 id="связывание-обработчика-запроса-с-атрибутом">Связывание обработчика запроса с атрибутом</h2>
<p>Можно определить обработчик запроса на методе атрибута вместе с атрибутом маршрута.</p>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        return new HttpResponse()
            .WithContent(new StringContent(&quot;Hello world!&quot;));
    }
}
</code></pre>
<p>Обратите внимание, что необходимо передать тип желаемого обработчика запроса, а не экземпляр объекта. Таким образом, обработчик запроса будет создан парсером маршрутизатора. Вы можете передавать аргументы в конструктор класса с помощью свойства <a href="/api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments">ConstructorArguments</a>.</p>
<p>Пример:</p>
<pre><code class="lang-cs">[RequestHandler&lt;AuthenticateUserRequestHandler&gt;(&quot;arg1&quot;, 123, ...)]
static HttpResponse Index(HttpRequest request)
{
    HttpResponse res = new HttpResponse();
    res.Content = new StringContent(&quot;Hello world!&quot;);
    return res;
}
</code></pre>
<p>Также можно создать свой собственный атрибут, который реализует RequestHandler:</p>
<pre><code class="lang-cs">public class AuthenticateAttribute : RequestHandlerAttribute
{
    public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { &quot;arg1&quot;, 123, ... })
    {
        ;
    }
}
</code></pre>
<p>И использовать его так:</p>
<pre><code class="lang-cs">[Authenticate]
static HttpResponse Index(HttpRequest request)
{
    HttpResponse res = new HttpResponse();
    res.Content = new StringContent(&quot;Hello world!&quot;);
    return res;
}
</code></pre>
<h2 id="игнорирование-глобального-обработчика-запроса">Игнорирование глобального обработчика запроса</h2>
<p>После определения глобального обработчика запроса на маршруте можно игнорировать этот обработчик запроса на конкретных маршрутах.</p>
<pre><code class="lang-cs">var myRequestHandler = new AuthenticateUserRequestHandler();
mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    myRequestHandler
};

mainRouter.SetRoute(new Route(RouteMethod.Get, &quot;/&quot;, &quot;My route&quot;, IndexPage, null)
{
    BypassGlobalRequestHandlers = new IRequestHandler[]
    {
        myRequestHandler,                    // ok: the same instance of what is in the global request handlers
        new AuthenticateUserRequestHandler() // wrong: will not skip the global request handler
    }
});
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Если вы игнорируете обработчик запроса, вам необходимо использовать тот же ссылаемый объект, который был установлен ранее, чтобы пропустить его. Создание нового экземпляра обработчика запроса не позволит пропустить глобальный обработчик запроса, так как его ссылка изменится. Не забудьте использовать ту же ссылку на обработчик запроса, которая используется как в GlobalRequestHandlers, так и в BypassGlobalRequestHandlers.</p>
</div>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/ru/fundamentals/request-handlers.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>