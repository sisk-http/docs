<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Eventos Enviados por el Servidor | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Eventos Enviados por el Servidor | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/es/features/server-sent-events.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>
            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português Brasileiro
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Spanish
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="eventos-enviados-por-el-servidor">Eventos Enviados por el Servidor</h1>

<p>Sisk admite el envío de mensajes a través de Eventos Enviados por el Servidor de forma predeterminada. Puedes crear conexiones desechables y persistentes, obtener las conexiones durante la ejecución y utilizarlas.</p>
<p>Esta función tiene algunas limitaciones impuestas por los navegadores, como el envío solo de mensajes de texto y no poder cerrar permanentemente una conexión. Una conexión cerrada por el servidor tendrá un cliente que intentará reconectar cada 5 segundos (3 para algunos navegadores).</p>
<p>Estas conexiones son útiles para enviar eventos desde el servidor al cliente sin que el cliente tenga que solicitar la información cada vez.</p>
<h2 id="crear-una-conexión-sse">Crear una conexión SSE</h2>
<p>Una conexión SSE funciona como una solicitud HTTP regular, pero en lugar de enviar una respuesta y cerrar la conexión inmediatamente, la conexión se mantiene abierta para enviar mensajes.</p>
<p>Al llamar al método <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource()</a>, la solicitud se pone en un estado de espera mientras se crea la instancia SSE.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource();

    sse.Send(&quot;Hola, mundo!&quot;);

    return sse.Close();
});
</code></pre>
<p>En el código anterior, creamos una conexión SSE y enviamos un mensaje &quot;Hola, mundo&quot;, luego cerramos la conexión SSE desde el lado del servidor.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Cuando se cierra una conexión desde el lado del servidor, por defecto el cliente intentará conectarse de nuevo en ese extremo y la conexión se reiniciará, ejecutando el método de nuevo, indefinidamente.</p>
<p>Es común enviar un mensaje de terminación desde el servidor cada vez que la conexión se cierra desde el lado del servidor para evitar que el cliente intente reconectar de nuevo.</p>
</div>
<h2 id="agregar-encabezados">Agregar encabezados</h2>
<p>Si necesitas enviar encabezados, puedes utilizar el método <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader">HttpRequestEventSource.AppendHeader</a> antes de enviar cualquier mensaje.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource();
    sse.AppendHeader(&quot;Header-Key&quot;, &quot;Header-value&quot;);

    sse.Send(&quot;Hola!&quot;);

    return sse.Close();
});
</code></pre>
<p>Tenga en cuenta que es necesario enviar los encabezados antes de enviar cualquier mensaje.</p>
<h2 id="conexiones-de-espera-por-fallo">Conexiones de espera por fallo</h2>
<p>Las conexiones normalmente se terminan cuando el servidor ya no puede enviar mensajes debido a una posible desconexión del cliente. Con esto, la conexión se termina automáticamente y la instancia de la clase se descarta.</p>
<p>Incluso con una reconexión, la instancia de la clase no funcionará, ya que está vinculada a la conexión anterior. En algunas situaciones, es posible que necesites esta conexión más adelante y no quieras administrarla a través del método de devolución de llamada de la ruta.</p>
<p>Para esto, podemos identificar las conexiones SSE con un identificador y obtenerlas utilizando este identificador más adelante, incluso fuera del método de devolución de llamada de la ruta. Además, marcamos la conexión con <a href="/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail">WaitForFail</a> para no terminar la ruta y la conexión automáticamente.</p>
<p>Una conexión SSE en KeepAlive esperará a que se produzca un error de envío (causado por una desconexión) para reanudar la ejecución del método. También es posible establecer un tiempo de espera para esto. Después del tiempo, si no se ha enviado ningún mensaje, la conexión se termina y la ejecución se reanuda.</p>
<pre><code class="lang-cs">r += new Route(RouteMethod.Get, &quot;/&quot;, (req) =&gt;
{
    var sse = req.GetEventSource(&quot;my-index-connection&quot;);

    sse.WaitForFail(TimeSpan.FromSeconds(15)); // esperar 15 segundos sin ningún mensaje antes de terminar la conexión

    return sse.Close();
});
</code></pre>
<p>El método anterior creará la conexión, la administrará y esperará a que se produzca una desconexión o un error.</p>
<pre><code class="lang-cs">HttpRequestEventSource? evs = server.EventSources.GetByIdentifier(&quot;my-index-connection&quot;);
if (evs != null)
{
    // la conexión todavía está viva
    evs.Send(&quot;Hola de nuevo!&quot;);
}
</code></pre>
<p>Y el fragmento de código anterior intentará buscar la conexión recién creada, y si existe, enviará un mensaje a ella.</p>
<p>Todas las conexiones de servidor activas que estén identificadas estarán disponibles en la colección <a href="/api/Sisk.Core.Http.HttpServer.EventSources">HttpServer.EventSources</a>. Esta colección solo almacena conexiones activas y identificadas. Las conexiones cerradas se eliminan de la colección.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Es importante tener en cuenta que el mantenimiento de la conexión tiene un límite establecido por componentes que pueden estar conectados a Sisk de manera no controlable, como un proxy web, un kernel HTTP o un controlador de red, y que cierran las conexiones inactivas después de un cierto período de tiempo.</p>
<p>Por lo tanto, es importante mantener la conexión abierta enviando mensajes periódicos o extendiendo el tiempo máximo antes de que la conexión se cierre. Lea la siguiente sección para comprender mejor el envío de mensajes periódicos.</p>
</div>
<h2 id="configurar-la-política-de-ping-de-las-conexiones">Configurar la política de ping de las conexiones</h2>
<p>La política de ping es una forma automatizada de enviar mensajes periódicos al cliente. Esta función permite al servidor entender cuándo el cliente se ha desconectado de la conexión sin tener que mantener la conexión abierta indefinidamente.</p>
<pre><code class="lang-cs">[RouteGet(&quot;/sse&quot;)]
public HttpResponse Events(HttpRequest request)
{
    var sse = request.GetEventSource();
    sse.WithPing(ping =&gt;
    {
        ping.DataMessage = &quot;ping-message&quot;;
        ping.Interval = TimeSpan.FromSeconds(5);
        ping.Start();
    });

    sse.KeepAlive();
    return sse.Close();
}
</code></pre>
<p>En el código anterior, cada 5 segundos, se enviará un nuevo mensaje de ping al cliente. Esto mantendrá la conexión TCP abierta y evitará que se cierre debido a la inactividad. Además, cuando un mensaje no se pueda enviar, la conexión se cerrará automáticamente, liberando los recursos utilizados por la conexión.</p>
<h2 id="consultar-conexiones">Consultar conexiones</h2>
<p>Puedes buscar conexiones activas utilizando un predicado en el identificador de la conexión, para poder difundir, por ejemplo.</p>
<pre><code class="lang-cs">HttpRequestEventSource[] evs = server.EventSources.Find(es =&gt; es.StartsWith(&quot;my-connection-&quot;));
foreach (HttpRequestEventSource e in evs)
{
    e.Send(&quot;Difundiendo a todas las fuentes de eventos que comienzan con 'my-connection-'&quot;);
}
</code></pre>
<p>También puedes utilizar el método <a href="/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All">All</a> para obtener todas las conexiones SSE activas.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/es/features/server-sent-events.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>