<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Inyecci&#243;n de dependencias | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Inyecci&#243;n de dependencias | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/es/features/instancing.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>
            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português Brasileiro
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Spanish
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="inyección-de-dependencias">Inyección de dependencias</h1>

<p>Es común dedicar miembros e instancias que duran toda la vida de una solicitud, como una conexión a una base de datos, un usuario autenticado o un token de sesión. Una de las posibilidades es a través de <a href="/api/Sisk.Core.Http.HttpContext">HttpContext.RequestBag</a>, que crea un diccionario que dura toda la vida de una solicitud.</p>
<p>Este diccionario se puede acceder desde <a href="/docs/fundamentals/request-handlers">manejadores de solicitudes</a> y definir variables a lo largo de esa solicitud. Por ejemplo, un manejador de solicitudes que autentica a un usuario establece este usuario dentro de <code>HttpContext.RequestBag</code>, y dentro de la lógica de la solicitud, este usuario se puede recuperar con <code>HttpContext.RequestBag.Get&lt;User&gt;()</code>.</p>
<p>Aquí hay un ejemplo:</p>
<div class="script-header">
    <span>
        RequestHandlers/AuthenticateUser.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">public class AuthenticateUser : IRequestHandler
{
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;
    
    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        User authenticatedUser = AuthenticateUser(request);
        context.RequestBag.Set(authenticatedUser);
        return null; // avanzar a la siguiente solicitud de manejo o lógica de solicitud
    }
}
</code></pre>
<div class="script-header">
    <span>
        Controllers/HelloController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">[RouteGet(&quot;/hello&quot;)]
[RequestHandler&lt;AuthenticateUser&gt;]
public static HttpResponse SayHello(HttpRequest request)
{
    var authenticatedUser = request.Bag.Get&lt;User&gt;();
    return new HttpResponse()
    {
        Content = new StringContent($&quot;Hola {authenticatedUser.Name}!&quot;)
    };
}
</code></pre>
<p>Este es un ejemplo preliminar de esta operación. La instancia de <code>User</code> se creó dentro del manejador de solicitudes dedicado a la autenticación, y todas las rutas que utilizan este manejador de solicitudes tendrán la garantía de que habrá un <code>User</code> en su instancia de <code>HttpContext.RequestBag</code>.</p>
<p>Es posible definir lógica para obtener instancias cuando no se han definido previamente en <code>RequestBag</code> a través de métodos como <a href="/api/Sisk.Core.Entity.TypedValueDictionary.GetOrAdd">GetOrAdd</a> o <a href="/api/Sisk.Core.Entity.TypedValueDictionary.GetOrAddAsync">GetOrAddAsync</a>.</p>
<p>Desde la versión 1.3, se introdujo la propiedad estática <a href="/api/Sisk.Core.Http.HttpContext.Current">HttpContext.Current</a>, que permite acceder al <code>HttpContext</code> actualmente en ejecución del contexto de la solicitud. Esto permite exponer miembros del <code>HttpContext</code> fuera de la solicitud actual y definir instancias en objetos de rutas.</p>
<p>El ejemplo siguiente define un controlador que tiene miembros comúnmente accedidos por el contexto de una solicitud.</p>
<div class="script-header">
    <span>
        Controllers/Controller.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">public abstract class Controller : RouterModule
{
    public DbContext Database
    {
        get
        {
            // crear un DbContext o obtener el existente
            return HttpContext.Current.RequestBag.GetOrAdd(() =&gt; new DbContext());
        }
    }

    // la siguiente línea lanzará una excepción si la propiedad se accede cuando el Usuario no
    // está definido en la bolsa de solicitudes
    public User AuthenticatedUser { get =&gt; HttpContext.Current.RequestBag.Get&lt;User&gt;(); }

    // También se admite la exposición de la instancia de HttpRequest
    public HttpRequest Request { get =&gt; HttpContext.Current.Request; }
}
</code></pre>
<p>Y define tipos que heredan del controlador:</p>
<div class="script-header">
    <span>
        Controllers/PostsController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">[RoutePrefix(&quot;/api/posts&quot;)]
public class PostsController : Controller
{
    [RouteGet]
    public IEnumerable&lt;Blog&gt; ListPosts()
    {
        return Database.Posts
            .Where(post =&gt; post.AuthorId == AuthenticatedUser.Id)
            .ToList();
    }

    [RouteGet(&quot;&lt;id&gt;&quot;)]
    public Post GetPost()
    {
        int blogId = Request.RouteParameters[&quot;id&quot;].GetInteger();

        Post? post = Database.Posts
            .FirstOrDefault(post =&gt; post.Id == blogId &amp;&amp; post.AuthorId == AuthenticatedUser.Id);

        return post ?? new HttpResponse(404);
    }
}
</code></pre>
<p>Para el ejemplo anterior, necesitarás configurar un <a href="/docs/fundamentals/responses.html#implicit-response-types">manejador de valores</a> en tu enrutador para que los objetos devueltos por el enrutador se transformen en un <a href="/api/Sisk.Core.Http.HttpResponse">HttpResponse</a> válido.</p>
<p>Tenga en cuenta que los métodos no tienen un argumento <code>HttpRequest request</code> como está presente en otros métodos. Esto se debe a que, desde la versión 1.3, el enrutador admite dos tipos de delegados para respuestas de enrutamiento: <a href="/api/Sisk.Core.Routing.RouteAction">RouteAction</a>, que es el delegado predeterminado que recibe un argumento <code>HttpRequest</code>, y <a href="/api/Sisk.Core.Routing.ParameterlessRouteAction">ParameterlessRouteAction</a>. El objeto <code>HttpRequest</code> aún se puede acceder desde ambos delegados a través de la propiedad <a href="/api/Sisk.Core.Http.HttpContext.Request">Request</a> del <code>HttpContext</code> estático en el subproceso.</p>
<p>En el ejemplo anterior, definimos un objeto desechable, el <code>DbContext</code>, y necesitamos asegurarnos de que todas las instancias creadas en un <code>DbContext</code> se desechen cuando la sesión HTTP finalice. Para ello, podemos utilizar dos formas de lograrlo. Una es crear un <a href="/docs/fundamentals/request-handlers">manejador de solicitudes</a> que se ejecute después de la acción del enrutador, y la otra forma es a través de un <a href="/docs/advanced/http-server-handlers">manejador de servidor personalizado</a>.</p>
<p>Para el primer método, podemos crear el manejador de solicitudes directamente en el método <a href="/api/Sisk.Core.Routing.RouterModule.OnSetup">OnSetup</a> heredado de <code>RouterModule</code>:</p>
<div class="script-header">
    <span>
        Controllers/PostsController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">public abstract class Controller : RouterModule
{
    ...

    protected override void OnSetup(Router parentRouter)
    {
        base.OnSetup(parentRouter);

        HasRequestHandler(RequestHandler.Create(
            execute: (req, ctx) =&gt;
            {
                // obtener un DbContext definido en el contexto del manejador de solicitudes y
                // desecharlo
                ctx.RequestBag.GetOrDefault&lt;DbContext&gt;()?.Dispose();
                return null;
            },
            executionMode: RequestHandlerExecutionMode.AfterResponse));
    }
}
</code></pre>
<div class="TIP">
<h5>Tip</h5>
<p>Desde Sisk versión 1.4, la propiedad <a href="/api/Sisk.Core.Http.HttpServerConfiguration.DisposeDisposableContextValues">HttpServerConfiguration.DisposeDisposableContextValues</a> se introdujo y se habilitó de forma predeterminada, lo que define si el servidor HTTP debe desechar todos los valores <code>IDisposable</code> en la bolsa de contexto cuando se cierra una sesión HTTP.</p>
</div>
<p>El método anterior garantizará que el <code>DbContext</code> se deseché cuando la sesión HTTP se finalice. Puedes hacer esto para más miembros que necesitan desecharse al final de una respuesta.</p>
<p>Para el segundo método, puedes crear un <a href="/docs/advanced/http-server-handlers">manejador de servidor personalizado</a> que desechará el <code>DbContext</code> cuando la sesión HTTP se finalice.</p>
<div class="script-header">
    <span>
        Server/Handlers/ObjectDisposerHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">public class ObjectDisposerHandler : HttpServerHandler
{
    protected override void OnHttpRequestClose(HttpServerExecutionResult result)
    {
        result.Context.RequestBag.GetOrDefault&lt;DbContext&gt;()?.Dispose();
    }
}
</code></pre>
<p>Y usarlo en tu constructor de aplicaciones:</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">using var host = HttpServer.CreateBuilder()
    .UseHandler&lt;ObjectDisposerHandler&gt;()
    .Build();
</code></pre>
<p>Esta es una forma de manejar la limpieza de código y mantener las dependencias de una solicitud separadas por el tipo de módulo que se utilizará, reduciendo la cantidad de código duplicado dentro de cada acción de un enrutador. Es una práctica similar a la que se utiliza la inyección de dependencias en frameworks como ASP.NET.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/es/features/instancing.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>