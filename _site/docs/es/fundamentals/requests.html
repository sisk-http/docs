<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Solicitudes | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Solicitudes | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/es/fundamentals/requests.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>
                    <div class="actionbar-actions">
                        <div id="language-wrapper">
                            <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                                <i class="bi bi-globe"></i>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                        <img src="/assets/flag/usa.png">
                                        English
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                        <img src="/assets/flag/russia.png">
                                        Русский
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                        <img src="/assets/flag/brazil.png">
                                        Português
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                        <img src="/assets/flag/spain.png">
                                        Español
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                        <img src="/assets/flag/germany.png">
                                        Deutsch
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                        <img src="/assets/flag/china.png">
                                        中文 (简体)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                        <img src="/assets/flag/japan.png">
                                        日本語
                                    </a>
                                </li>
                            </ul>
                        </div>

                        <div id="copy-article-wrapper">
                            <a class="btn border-0" id="copy-article-btn" title="Copy article">
                                <i class="bi bi-copy"></i>
                            </a>
                            <div class="copy-dropdown" id="copy-dropdown">
                                <button type="button" id="copy-text-btn">
                                    <i class="bi bi-file-text"></i>
                                    Copy as text
                                </button>
                                <button type="button" id="copy-markdown-btn">
                                    <i class="bi bi-markdown"></i>
                                    Copy as Markdown
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <article data-uid="">
<h1 id="solicitudes">Solicitudes</h1>

<p>Las solicitudes son estructuras que representan un mensaje de solicitud HTTP. El objeto <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> contiene funciones útiles para manejar mensajes HTTP en toda su aplicación.</p>
<p>Una solicitud HTTP se forma por el método, ruta, versión, encabezados y cuerpo.</p>
<p>En este documento, le enseñaremos cómo obtener cada uno de estos elementos.</p>
<h2 id="obtener-el-método-de-la-solicitud">Obtener el método de la solicitud</h2>
<p>Para obtener el método de la solicitud recibida, puede utilizar la propiedad Method:</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    HttpMethod requestMethod = request.Method;
    ...
}
</code></pre>
<p>Esta propiedad devuelve el método de la solicitud representado por un objeto <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.httpmethod">HttpMethod</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>A diferencia de los métodos de ruta, esta propiedad no sirve el elemento <a href="/api/Sisk.Core.Routing.RouteMethod">RouteMethod.Any</a>. En su lugar, devuelve el método de solicitud real.</p>
</div>
<h2 id="obtener-componentes-de-la-url-de-la-solicitud">Obtener componentes de la URL de la solicitud</h2>
<p>Puede obtener varios componentes de una URL a través de ciertas propiedades de una solicitud. Para este ejemplo, consideremos la URL:</p>
<pre><code>http://localhost:5000/user/login?email=foo@bar.com
</code></pre>
<table>
<thead>
<tr>
<th>Nombre del componente</th>
<th>Descripción</th>
<th>Valor del componente</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Path">Path</a></td>
<td>Obtiene la ruta de la solicitud.</td>
<td><code>/user/login</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullPath">FullPath</a></td>
<td>Obtiene la ruta de la solicitud y la cadena de consulta.</td>
<td><code>/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullUrl">FullUrl</a></td>
<td>Obtiene la cadena de solicitud de URL completa.</td>
<td><code>http://localhost:5000/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Host">Host</a></td>
<td>Obtiene el host de la solicitud.</td>
<td><code>localhost</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Authority">Authority</a></td>
<td>Obtiene el host y el puerto de la solicitud.</td>
<td><code>localhost:5000</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.QueryString">QueryString</a></td>
<td>Obtiene la consulta de la solicitud.</td>
<td><code>?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a></td>
<td>Obtiene la consulta de la solicitud en una colección de valores con nombre.</td>
<td><code>{StringValueCollection object}</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.IsSecure">IsSecure</a></td>
<td>Determina si la solicitud utiliza SSL (true) o no (false).</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p>También puede optar por utilizar la propiedad <a href="/api/Sisk.Core.Http.HttpRequest.Uri">HttpRequest.Uri</a>, que incluye todo lo anterior en un solo objeto.</p>
<h2 id="obtener-el-cuerpo-de-la-solicitud">Obtener el cuerpo de la solicitud</h2>
<p>Algunas solicitudes incluyen un cuerpo, como formularios, archivos o transacciones de API. Puede obtener el cuerpo de una solicitud desde la propiedad:</p>
<pre><code class="lang-cs">// obtiene el cuerpo de la solicitud como una cadena, utilizando la codificación de la solicitud como codificador
string body = request.Body;

// o lo obtiene en una matriz de bytes
byte[] bodyBytes = request.RawBody;

// o también puede transmitirlo.
Stream requestStream = request.GetRequestStream();
</code></pre>
<p>También es posible determinar si hay un cuerpo en la solicitud y si está cargado con las propiedades <a href="/api/Sisk.Core.Http.HttpRequest.HasContents">HasContents</a>, que determina si la solicitud tiene contenido y <a href="/api/Sisk.Core.Http.HttpRequest.IsContentAvailable">IsContentAvailable</a> que indica que el servidor HTTP recibió completamente el contenido del punto remoto.</p>
<p>No es posible leer el contenido de la solicitud a través de <code>GetRequestStream</code> más de una vez. Si lee con este método, los valores en <code>RawBody</code> y <code>Body</code> no estarán disponibles. No es necesario desechar el flujo de solicitud en el contexto de la solicitud, ya que se desecha al final de la sesión HTTP en la que se crea. También puede utilizar la propiedad <a href="/api/Sisk.Core.Http.HttpRequest.RequestEncoding">HttpRequest.RequestEncoding</a> para obtener la mejor codificación para decodificar la solicitud manualmente.</p>
<p>El servidor tiene límites para leer el contenido de la solicitud, que se aplica tanto a <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.Body</a> como a <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.RawBody</a>. Estas propiedades copian el flujo de entrada completo en un búfer local del mismo tamaño que <a href="/api/Sisk.Core.Http.HttpRequest.ContentLength">HttpRequest.ContentLength</a>.</p>
<p>Una respuesta con estado 413 Contenido demasiado grande se devuelve al cliente si el contenido enviado es mayor que <a href="/api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength">HttpServerConfiguration.MaximumContentLength</a> definido en la configuración del usuario. Además, si no hay un límite configurado o si es demasiado grande, el servidor lanzará una <a href="https://learn.microsoft.com/en-us/dotnet/api/system.outofmemoryexception?view=net-8.0">OutOfMemoryException</a> cuando el contenido enviado por el cliente supere <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32.maxvalue">Int32.MaxValue</a> (2 GB) y si el contenido se intenta acceder a través de una de las propiedades mencionadas anteriormente. Todavía puede tratar con el contenido a través de transmisión.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Aunque Sisk lo permite, siempre es una buena idea seguir la semántica HTTP para crear su aplicación y no obtener o servir contenido en métodos que no lo permiten. Lea sobre <a href="https://httpwg.org/spec/rfc9110.html">RFC 9110 &quot;Semántica HTTP&quot;</a>.</p>
</div>
<h2 id="obtener-el-contexto-de-la-solicitud">Obtener el contexto de la solicitud</h2>
<p>El contexto HTTP es un objeto exclusivo de Sisk que almacena información del servidor HTTP, ruta, enrutador y controlador de solicitudes. Puede utilizarlo para organizarse en un entorno donde estos objetos son difíciles de organizar.</p>
<p>Puede obtener el contexto actual de <a href="/api/Sisk.Core.Http.HttpContext">HttpContext</a> utilizando el método estático <code>HttpContext.GetCurrentContext()</code>. Este método devuelve el contexto de la solicitud que se está procesando actualmente en el subproceso actual.</p>
<pre><code class="lang-cs">HttpContext context = HttpContext.GetCurrentContext();
</code></pre>
<h3 id="modo-de-registro">Modo de registro</h3>
<p>La propiedad <a href="/api/Sisk.Core.Http.HttpContext.LogMode">HttpContext.LogMode</a> le permite controlar el comportamiento de registro para la solicitud actual. Puede habilitar o deshabilitar el registro para solicitudes específicas, anulando la configuración del servidor predeterminada.</p>
<pre><code class="lang-cs">// deshabilitar el registro para esta solicitud
context.LogMode = LogOutputMode.None;
</code></pre>
<h3 id="bolsa-de-solicitudes">Bolsa de solicitudes</h3>
<p>El objeto <a href="/api/Sisk.Core.Http.HttpContext.RequestBag">RequestBag</a> contiene información almacenada que se pasa de un controlador de solicitudes a otro punto y se puede consumir en el destino final. Este objeto también se puede utilizar por controladores de solicitudes que se ejecutan después de la devolución de llamada de la ruta.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Esta propiedad también es accesible a través de la propiedad <a href="/api/Sisk.Core.Http.HttpRequest.Bag">HttpRequest.Bag</a>.</p>
</div>
<div class="script-header">
    <span>
        Middleware/AuthenticateUserRequestHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public string Identifier { get; init; } = Guid.NewGuid().ToString();
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;
    
    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            context.RequestBag.Add(&quot;AuthenticatedUser&quot;, new User(&quot;Bob&quot;));
            return null;
        }
        else
        {
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>El controlador de solicitudes anterior definirá <code>AuthenticatedUser</code> en la bolsa de solicitudes y se puede consumir más adelante en la devolución de llamada final:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        User authUser = request.Context.RequestBag[&quot;AuthenticatedUser&quot;];
        
        return new HttpResponse() {
            Content = new StringContent($&quot;Hello, {authUser.Name}!&quot;)
        };
    }
}
</code></pre>
<p>También puede utilizar los métodos de ayuda <code>Bag.Set()</code> y <code>Bag.Get()</code> para obtener o establecer objetos por sus tipos singleton.</p>
<p>La clase <code>TypedValueDictionary</code> también proporciona métodos <code>GetValue</code> y <code>SetValue</code> para un control más preciso.</p>
<div class="script-header">
    <span>
        Middleware/Authenticate.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class Authenticate : RequestHandler
{
    public override HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        request.Bag.Set&lt;User&gt;(authUser);
    }
}
</code></pre>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">[RouteGet(&quot;/&quot;)]
[RequestHandler&lt;Authenticate&gt;]
public static HttpResponse GetUser(HttpRequest request)
{
    var user = request.Bag.Get&lt;User&gt;();
    ...
}
</code></pre>
<h2 id="obtener-datos-de-formulario">Obtener datos de formulario</h2>
<p>Puede obtener los valores de los datos de un formulario en una <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.specialized.namevaluecollection">NameValueCollection</a> con el ejemplo siguiente:</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/auth&quot;)]
public HttpResponse Index(HttpRequest request)
{
    var form = request.GetFormContent();

    string? username = form[&quot;username&quot;];
    string? password = form[&quot;password&quot;];

    if (AttempLogin(username, password))
    {
        ...
    }
}
</code></pre>
<h2 id="obtener-datos-de-formulario-multipart">Obtener datos de formulario multipart</h2>
<p>La solicitud HTTP de Sisk le permite obtener contenidos multipart, como archivos, campos de formulario o contenido binario.</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/upload-contents&quot;)]
public HttpResponse Index(HttpRequest request)
{
    // el siguiente método lee la entrada de solicitud completa en una
    // matriz de objetos Multipart
    var multipartFormDataObjects = request.GetMultipartFormContent();
    
    foreach (MultipartObject uploadedObject in multipartFormDataObjects)
    {
        // El nombre del archivo proporcionado por los datos del formulario multipart.
        // Se devuelve null si el objeto no es un archivo.
        Console.WriteLine(&quot;Nombre del archivo       : &quot; + uploadedObject.Filename);

        // El nombre del campo del objeto de datos del formulario multipart.
        Console.WriteLine(&quot;Nombre del campo      : &quot; + uploadedObject.Name);

        // La longitud del contenido del objeto de datos del formulario multipart.
        Console.WriteLine(&quot;Longitud del contenido  : &quot; + uploadedObject.ContentLength);

        // Determina el formato de archivo común en función del encabezado del archivo para cada
        // tipo de contenido conocido. Si el contenido no es un formato de archivo común reconocido,
        // este método a continuación devolverá MultipartObjectCommonFormat.Unknown
        Console.WriteLine(&quot;Formato común   : &quot; + uploadedObject.GetCommonFileFormat());
    }
}
</code></pre>
<p>Puede leer más sobre los objetos de formulario multipart de Sisk y sus métodos, propiedades y funcionalidades.</p>
<h2 id="detectar-la-desconexión-del-cliente">Detectar la desconexión del cliente</h2>
<p>Desde la versión v1.15 de Sisk, el marco proporciona un CancellationToken que se lanza cuando la conexión entre el cliente y el servidor se cierra prematuramente antes de recibir la respuesta. Este token puede ser útil para detectar cuándo el cliente ya no desea la respuesta y cancelar operaciones de larga duración.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/connect&quot;, async (HttpRequest req) =&gt;
{
    // obtiene el token de desconexión de la solicitud
    var dc = req.DisconnectToken;

    await LongOperationAsync(dc);

    return new HttpResponse();
});
</code></pre>
<p>Este token no es compatible con todos los motores HTTP, y cada uno requiere una implementación.</p>
<h2 id="soporte-para-eventos-enviados-por-el-servidor">Soporte para eventos enviados por el servidor</h2>
<p>Sisk admite <a href="https://developer.mozilla.org/en-US/docs/es/Web/API/Server-sent_events">eventos enviados por el servidor</a>, que permite enviar fragmentos como un flujo y mantener la conexión entre el servidor y el cliente viva.</p>
<p>Llamando al método <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource</a> se pondrá la solicitud de HTTP en su estado de escucha. A partir de esto, el contexto de esta solicitud de HTTP no esperará una respuesta de HttpResponse, ya que se superpondrá con los paquetes enviados por eventos del servidor.</p>
<p>Después de enviar todos los paquetes, la devolución de llamada debe devolver el método <a href="/api/Sisk.Core.Http.HttpRequestEventSource.Close">Close</a>, que enviará la respuesta final al servidor e indicará que la transmisión ha terminado.</p>
<p>No es posible predecir qué será la longitud total de todos los paquetes que se enviarán, por lo que no es posible determinar el final de la conexión con el encabezado <code>Content-Length</code>.</p>
<p>Por defecto, la mayoría de los navegadores no admiten el envío de encabezados HTTP o métodos diferentes al GET. Por lo tanto, tenga cuidado al utilizar controladores de solicitudes con solicitudes de evento de origen que requieren encabezados específicos en la solicitud, ya que es probable que no los tengan.</p>
<p>Además, la mayoría de los navegadores reinician las transmisiones si el método <a href="https://developer.mozilla.org/en-US/docs/es/Web/API/EventSource/close">EventSource.close</a> no se llama en el lado del cliente después de recibir todos los paquetes, lo que causa un procesamiento adicional infinito en el lado del servidor. Para evitar este tipo de problema, es común enviar un paquete final que indique que el evento de origen ha terminado de enviar todos los paquetes.</p>
<p>El ejemplo siguiente muestra cómo el navegador puede comunicarse con el servidor que admite eventos enviados por el servidor.</p>
<div class="script-header">
    <span>
        sse-example.html
    </span>
    <span>
        HTML
    </span>
</div>
<pre><code class="lang-html">&lt;html&gt;
    &lt;body&gt;
        &lt;b&gt;Frutas:&lt;/b&gt;
        &lt;ul&gt;&lt;/ul&gt;
    &lt;/body&gt;
    &lt;script&gt;
        const evtSource = new EventSource('http://localhost:5555/event-source');
        const eventList = document.querySelector('ul');
        
        evtSource.onmessage = (e) =&gt; {
            const newElement = document.createElement(&quot;li&quot;);

            newElement.textContent = `mensaje: ${e.data}`;
            eventList.appendChild(newElement);

            if (e.data == &quot;Tomate&quot;) {
                evtSource.close();
            }
        }
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>Y envíe progresivamente los mensajes al cliente:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/event-source&quot;)]
    public async Task&lt;HttpResponse&gt; ServerEventsResponse(HttpRequest request)
    {
        var sse = await request.GetEventSourceAsync ();
        
        string[] frutas = new[] { &quot;Manzana&quot;, &quot;Plátano&quot;, &quot;Sandía&quot;, &quot;Tomate&quot; };
        
        foreach (string fruta in frutas)
        {
            await serverEvents.SendAsync(fruta);
            await Task.Delay(1500);
        }

        return serverEvents.Close();
    }
}
</code></pre>
<p>Al ejecutar este código, esperamos un resultado similar a este:</p>
<img src="/assets/img/server side events demo.gif">
<h2 id="resolver-direcciones-ip-y-hosts-proxy">Resolver direcciones IP y hosts proxy</h2>
<p>Sisk se puede utilizar con proxies, y por lo tanto, las direcciones IP pueden reemplazarse por el punto final del proxy en la transacción desde un cliente hasta el proxy.</p>
<p>Puede definir sus propios resolutores en Sisk con <a href="/docs/es/advanced/forwarding-resolvers">resolutores de reenvío</a>.</p>
<h2 id="codificación-de-encabezados">Codificación de encabezados</h2>
<p>La codificación de encabezados puede ser un problema para algunas implementaciones. En Windows, los encabezados UTF-8 no son compatibles, por lo que se utiliza ASCII. Sisk tiene un convertidor de codificación incorporado, que puede ser útil para decodificar encabezados codificados incorrectamente.</p>
<p>Esta operación es costosa y está deshabilitada de forma predeterminada, pero se puede habilitar bajo la bandera <a href="/specification/spec/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings">NormalizeHeadersEncodings</a>.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/es/fundamentals/requests.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext", "ApiGenerationContext", "OpenApiExporter", "BodyExampleResult",
                            "ParameterExampleResult", "OpenApiContact", "OpenApiLicense", "HttpContent",
                            "ApiDocumentation", "CrossOriginResourceSharingHeaders", "McpProvider",
                            "JsonSchema", "McpToolContext", "HttpListenerAbstractEngine", "HttpListener",
                            "CadenteHttpServerEngine", "CertificateHelper"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort", "HttpServerEngineContextEventLoopMechanism"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
                
                (function() {
                    const copyBtn = document.getElementById('copy-article-btn');
                    const copyDropdown = document.getElementById('copy-dropdown');
                    const copyTextBtn = document.getElementById('copy-text-btn');
                    const copyMarkdownBtn = document.getElementById('copy-markdown-btn');
                    
                    if (!copyBtn) return;
                    
                    copyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        copyDropdown.classList.toggle('show');
                    });
                    
                    document.addEventListener('click', function(e) {
                        if (!copyDropdown.contains(e.target) && e.target !== copyBtn) {
                            copyDropdown.classList.remove('show');
                        }
                    });
                    
                    function getArticleContent() {
                        const article = document.querySelector('article');
                        if (!article) return null;
                        
                        const clone = article.cloneNode(true);
                        clone.querySelectorAll('.line-numbers, .code-action').forEach(el => el.remove());
                        
                        return clone;
                    }
                    
                    copyTextBtn.addEventListener('click', function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        navigator.clipboard.writeText(article.innerText.trim());
                        copyDropdown.classList.remove('show');
                    });
                    
                    copyMarkdownBtn.addEventListener('click', async function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        if (typeof TurndownService === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/turndown/dist/turndown.js';
                            script.onload = function() {
                                convertAndCopy(article);
                            };
                            document.head.appendChild(script);
                        } else {
                            convertAndCopy(article);
                        }
                        
                        copyDropdown.classList.remove('show');
                    });
                    
                    function convertAndCopy(article) {
                        const turndown = new TurndownService({
                            headingStyle: 'atx',
                            codeBlockStyle: 'fenced'
                        });
                        
                        turndown.addRule('codeBlocks', {
                            filter: ['pre'],
                            replacement: function(content, node) {
                                const code = node.querySelector('code');
                                const langClass = code?.className.match(/lang-(\w+)/);
                                const lang = langClass ? langClass[1] : '';
                                const text = code?.textContent || content;
                                return '\n\n```' + lang + '\n' + text.trim() + '\n```\n\n';
                            }
                        });
                        
                        const markdown = turndown.turndown(article.innerHTML);
                        navigator.clipboard.writeText(markdown);
                    }
                })();
            </script>
        </footer>
    </body>
</html>