<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Respuestas | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Respuestas | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/es/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="respuestas">Respuestas</h1>

<p>Las respuestas representan objetos que son respuestas HTTP a solicitudes HTTP. Son enviadas por el servidor al cliente como una indicación de la solicitud de un recurso, página, documento, archivo u otro objeto.</p>
<p>Una respuesta HTTP se compone de estado, encabezados y contenido.</p>
<p>En este documento, te enseñaremos a arquitecturar respuestas HTTP con Sisk.</p>
<h2 id="establecer-un-estado-http">Establecer un estado HTTP</h2>
<p>La lista de estados HTTP es la misma desde HTTP/1.0, y Sisk los admite todos.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; //202
</code></pre>
<p>O con sintaxis fluida:</p>
<pre><code class="lang-cs">new HttpResponse()
 .WithStatus(200) // o
 .WithStatus(HttpStatusCode.Ok) // o
 .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Puedes ver la lista completa de HttpStatusCode disponibles <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.httpstatuscode">aquí</a>. También puedes proporcionar tu propio código de estado utilizando la estructura <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>.</p>
<h2 id="cuerpo-y-tipo-de-contenido">Cuerpo y tipo de contenido</h2>
<p>Sisk admite objetos de contenido .NET nativos para enviar el cuerpo en las respuestas. Puedes utilizar la clase <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.stringcontent">StringContent</a> para enviar una respuesta JSON, por ejemplo:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>El servidor siempre intentará calcular el <code>Content-Length</code> a partir de lo que has definido en el contenido si no lo has definido explícitamente en un encabezado. Si el servidor no puede obtener implícitamente el encabezado Content-Length del contenido de la respuesta, la respuesta se enviará con Chunked-Encoding.</p>
<p>También puedes transmitir la respuesta enviando un <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.streamcontent">StreamContent</a> o utilizando el método <a href="/api/Sisk.Core.Http.HttpRequest.GetResponseStream">GetResponseStream</a>.</p>
<h2 id="encabezados-de-respuesta">Encabezados de respuesta</h2>
<p>Puedes agregar, editar o eliminar encabezados que estás enviando en la respuesta. El ejemplo siguiente muestra cómo enviar una respuesta de redirección al cliente.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>O con sintaxis fluida:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Cuando utilices el método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a> de HttpHeaderCollection, estás agregando un encabezado a la solicitud sin alterar los que ya se han enviado. El método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a> reemplaza los encabezados con el mismo nombre con el valor indicado. El indexador de HttpHeaderCollection llama internamente al método Set para reemplazar los encabezados.</p>
<h2 id="enviar-cookies">Enviar cookies</h2>
<p>Sisk tiene métodos que facilitan la definición de cookies en el cliente. Las cookies establecidas por este método ya están codificadas en URL y se ajustan al estándar RFC-6265.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;);
</code></pre>
<p>O con sintaxis fluida:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Hay otras <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">versiones más completas</a> del mismo método.</p>
<h2 id="respuestas-fragmentadas">Respuestas fragmentadas</h2>
<p>Puedes establecer la codificación de transferencia en fragmentada para enviar respuestas grandes.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>Cuando utilices codificación fragmentada, el encabezado Content-Length se omite automáticamente.</p>
<h2 id="flujo-de-respuesta">Flujo de respuesta</h2>
<p>Los flujos de respuesta son una forma administrada que te permiten enviar respuestas de manera segmentada. Es una operación de nivel inferior que utilizar objetos HttpResponse, ya que requieren que envíes los encabezados y el contenido manualmente, y luego cierres la conexión.</p>
<p>Este ejemplo abre un flujo de lectura solo para el archivo, copia el flujo en el flujo de salida de la respuesta y no carga todo el archivo en la memoria. Esto puede ser útil para servir archivos medianos o grandes.</p>
<pre><code class="lang-cs">// obtiene el flujo de salida de la respuesta
using var fileStream = File.OpenRead(&quot;my-big-file.zip&quot;);
var responseStream = request.GetResponseStream();

// establece la codificación de la respuesta para utilizar codificación fragmentada
// también no deberías enviar el encabezado content-length cuando utilices
// codificación fragmentada
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// copia el flujo del archivo en el flujo de salida de la respuesta
fileStream.CopyTo(responseStream.ResponseStream);

// cierra el flujo
return responseStream.Close();
</code></pre>
<h2 id="compresión-gzip-deflate-y-brotli">Compresión GZip, Deflate y Brotli</h2>
<p>Puedes enviar respuestas con contenido comprimido en Sisk con contenidos HTTP comprimidos. Primero, encapsula tu objeto <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent">HttpContent</a> dentro de uno de los compresores siguientes para enviar la respuesta comprimida al cliente.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
 string myHtml = &quot;...&quot;;
    
 return new HttpResponse () {
 Content = new GZipContent(new HtmlContent(myHtml)),
 // o Content = new BrotliContent(new HtmlContent(myHtml)),
 // o Content = new DeflateContent(new HtmlContent(myHtml)),
 };
});
</code></pre>
<p>También puedes utilizar estos contenidos comprimidos con flujos.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
 // no apliques &quot;using&quot; aquí. el HttpServer descartará tu contenido
 // después de enviar la respuesta.
 var archive = File.OpenRead(&quot;/path/to/big-file.zip&quot;);
    
 return new HttpResponse () {
 Content = new GZipContent(archive)
 }
});
</code></pre>
<p>Los encabezados Content-Encoding se establecen automáticamente cuando se utilizan estos contenidos.</p>
<h2 id="compresión-automática">Compresión automática</h2>
<p>Es posible comprimir automáticamente las respuestas HTTP con la propiedad <a href="/api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression">EnableAutomaticResponseCompression</a>. Esta propiedad encapsula automáticamente el contenido de la respuesta del enrutador en un contenido compressible que es aceptado por la solicitud, siempre y cuando la respuesta no sea heredada de un <a href="/api/Sisk.Core.Http.CompressedContent">CompressedContent</a>.</p>
<p>Solo se elige un contenido compressible para una solicitud, elegido según el encabezado Accept-Encoding, que sigue el orden:</p>
<ul>
<li><a href="/api/Sisk.Core.Http.BrotliContent">BrotliContent</a> (br)</li>
<li><a href="/api/Sisk.Core.Http.GZipContent">GZipContent</a> (gzip)</li>
<li><a href="/api/Sisk.Core.Http.DeflateContent">DeflateContent</a> (deflate)</li>
</ul>
<p>Si la solicitud especifica que acepta cualquiera de estos métodos de compresión, la respuesta se comprimirá automáticamente.</p>
<h2 id="tipos-de-respuesta-implícitos">Tipos de respuesta implícitos</h2>
<p>Puedes utilizar otros tipos de retorno además de HttpResponse, pero es necesario configurar el enrutador para que sepa cómo manejará cada tipo de objeto.</p>
<p>El concepto es siempre devolver un tipo de referencia y convertirlo en un objeto HttpResponse válido. Las rutas que devuelven HttpResponse no se someten a conversión.</p>
<p>Los tipos de valor (estructuras) no se pueden utilizar como tipo de retorno porque no son compatibles con el <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a>, por lo que deben estar envueltos en un ValueResult para poder ser utilizados en controladores.</p>
<p>Considera el siguiente ejemplo de un módulo de enrutador que no utiliza HttpResponse en el tipo de retorno:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
 public List&lt;User&gt; Users = new List&lt;User&gt;();

 [RouteGet]
 public IEnumerable&lt;User&gt; Index(HttpRequest request)
 {
 return Users.ToArray();
 }

 [RouteGet(&quot;&lt;id&gt;&quot;)]
 public User View(HttpRequest request)
 {
 int id = request.RouteParameters[&quot;id&quot;].GetInteger();
 User dUser = Users.First(u =&gt; u.Id == id);

 return dUser;
 }

 [RoutePost]
 public ValueResult&lt;bool&gt; Create(HttpRequest request)
 {
 User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
 Users.Add(fromBody);
        
 return true;
 }
}
</code></pre>
<p>Con esto, ahora es necesario definir en el enrutador cómo manejará cada tipo de objeto. Los objetos siempre son el primer argumento del controlador y el tipo de salida debe ser un HttpResponse válido. Además, los objetos de salida de una ruta nunca deben ser nulos.</p>
<p>Para tipos ValueResult no es necesario indicar que el objeto de entrada es un ValueResult y solo T, ya que ValueResult es un objeto reflejado de su componente original.</p>
<p>La asociación de tipos no compara lo que se registró con el tipo del objeto devuelto del controlador de enrutador. En su lugar, verifica si el tipo del resultado del enrutador es asignable al tipo registrado.</p>
<p>Registrar un controlador de tipo Object actuará como una reserva para todos los tipos no validados previamente. El orden de inserción de los controladores de valor también importa, por lo que registrar un controlador de Object ignorará todos los controladores específicos de tipo. Siempre registre controladores de valor específicos primero para asegurarse del orden.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;ApiResult&gt;(apiResult =&gt;
{
 return new HttpResponse() {
 Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest,
 Content = apiResult.GetHttpContent(),
 Headers = apiResult.GetHeaders()
 };
});
r.RegisterValueHandler&lt;bool&gt;(bvalue =&gt;
{
 return new HttpResponse() {
 Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest
 };
});
r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(enumerableValue =&gt;
{
 return new HttpResponse(string.Join(&quot;\n&quot;, enumerableValue));
});

// registrar un controlador de valor de objeto debe ser el último
// controlador de valor que se utilizará como una reserva
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
 return new HttpResponse() {
 Status = HttpStatusCode.OK,
 Content = JsonContent.Create(fallback)
 };
});
</code></pre>
<h2 id="nota-sobre-objetos-enumerables-y-matrices">Nota sobre objetos enumerables y matrices</h2>
<p>Los objetos de respuesta implícitos que implementan <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.ienumerable?view=net-8.0">IEnumerable</a> se leen en la memoria a través del método <code>ToArray()</code> antes de ser convertidos a través de un controlador de valor definido. Para que esto ocurra, el objeto <code>IEnumerable</code> se convierte en una matriz de objetos, y el convertidor de respuesta siempre recibirá un <code>Object[]</code> en lugar del tipo original.</p>
<p>Considera el siguiente escenario:</p>
<pre><code class="lang-csharp">using var host = HttpServer.CreateBuilder(12300)
 .UseRouter(r =&gt;
 {
 r.RegisterValueHandler&lt;IEnumerable&lt;string&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Matriz de cadenas:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Matriz de objetos:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.MapGet(&quot;/&quot;, request =&gt;
 {
 return (IEnumerable&lt;string&gt;)[&quot;hola&quot;, &quot;mundo&quot;];
 });
 })
 .Build();
</code></pre>
<p>En el ejemplo anterior, el convertidor <code>IEnumerable&lt;string&gt;</code> <strong>nunca se llamará</strong>, porque el objeto de entrada siempre será un <code>Object[]</code> y no es convertible a un <code>IEnumerable&lt;string&gt;</code>. Sin embargo, el convertidor siguiente que recibe un <code>IEnumerable&lt;object&gt;</code> recibirá su entrada, ya que su valor es compatible.</p>
<p>Si necesitas manejar realmente el tipo de objeto que se enumerará, necesitarás utilizar reflexión para obtener el tipo del elemento de la colección. Todos los objetos enumerables (listas, matrices y colecciones) se convierten en una matriz de objetos por el convertidor de respuesta HTTP.</p>
<p>Los valores que implementan <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0">IAsyncEnumerable</a> se manejan automáticamente por el servidor si la propiedad <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable">ConvertIAsyncEnumerableIntoEnumerable</a> está habilitada, de manera similar a lo que sucede con <code>IEnumerable</code>. Una enumeración asincrónica se convierte en un enumerador bloqueante y luego se convierte en una matriz de objetos sincrónica.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/es/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>