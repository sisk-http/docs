<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Logging | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Logging | Sisk ">


        <link rel="icon" href="../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../public/docfx.min.css">
        <link rel="stylesheet" href="../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/features/logging.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../index.html">
                        <img id="logo" class="svg" src="../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>
                    <div class="actionbar-actions">
                        <div id="language-wrapper">
                            <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                                <i class="bi bi-globe"></i>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                        <img src="/assets/flag/usa.png">
                                        English
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                        <img src="/assets/flag/russia.png">
                                        Русский
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                        <img src="/assets/flag/brazil.png">
                                        Português
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                        <img src="/assets/flag/spain.png">
                                        Español
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                        <img src="/assets/flag/germany.png">
                                        Deutsch
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                        <img src="/assets/flag/china.png">
                                        中文 (简体)
                                    </a>
                                </li>
                                <li>
                                    <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                        <img src="/assets/flag/japan.png">
                                        日本語
                                    </a>
                                </li>
                            </ul>
                        </div>

                        <div id="copy-article-wrapper">
                            <a class="btn border-0" id="copy-article-btn" title="Copy article">
                                <i class="bi bi-copy"></i>
                            </a>
                            <div class="copy-dropdown" id="copy-dropdown">
                                <button type="button" id="copy-link-btn">
                                    <i class="bi bi-link-45deg"></i>
                                    Copy link
                                </button>
                                <button type="button" id="copy-markdown-btn">
                                    <i class="bi bi-markdown"></i>
                                    Copy as Markdown
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <article data-uid="">
<h1 id="logging">Logging</h1>

<p>You can configure Sisk to write access and error logs automatically. It is possible to define log rotation, extensions and frequency.</p>
<p>The <a href="/api/Sisk.Core.Http.LogStream">LogStream</a> class provides an asynchronous way of writing logs and keeping them in an awaitable write queue. The <code>LogStream</code> class implements <code>IAsyncDisposable</code>, ensuring that all pending logs are written before the stream is closed.</p>
<p>In this article we will show you how to configure logging for your application.</p>
<h2 id="file-based-access-logs">File based access logs</h2>
<p>Logs to files open the file, write the line text, and then close the file for every line written. This procedure was adopted to maintain write responsiveness in the logs.</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class Program
{
    static async Task Main(string[] args)
    {
        using var app = HttpServer.CreateBuilder()
            .UseConfiguration(config =&gt; {
                config.AccessLogsStream = new LogStream(&quot;logs/access.log&quot;);
            })
            .Build();
        
        ...
        
        await app.StartAsync();
    }
}
</code></pre>
<p>The above code will write all incoming requests to the <code>logs/access.log</code> file. Note that, the file is created automatically if it does not exist, however the folder before it does not. It's not necessary to create the <code>logs/</code> directory as the LogStream class automatically creates it.</p>
<h2 id="stream-based-logging">Stream based logging</h2>
<p>You can write log files to TextWriter objects instances, such as <code>Console.Out</code>, by passing an TextWriter object in the constructor:</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">using var app = HttpServer.CreateBuilder()
    .UseConfiguration(config =&gt; {
        config.AccessLogsStream = new LogStream(Console.Out);
    })
    .Build();
</code></pre>
<p>For every message written in the stream-based log, the <code>TextWriter.Flush()</code> method is called.</p>
<h2 id="access-log-formatting">Access log formatting</h2>
<p>You can customize the access log format by predefined variables. Consider the following line:</p>
<pre><code class="lang-cs">config.AccessLogsFormat = &quot;%dd/%dmm/%dy %tH:%ti:%ts %tz %ls %ri %rs://%ra%rz%rq [%sc %sd] %lin -&gt; %lou in %lmsms [%{user-agent}]&quot;;
</code></pre>
<p>It will write an message like:</p>
<pre><code>29/mar./2023 15:21:47 -0300 Executed ::1 http://localhost:5555/ [200 OK] 689B -&gt; 707B in 84ms [Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/111.0.0.0 Safari/537.36]
</code></pre>
<p>You can format your log file by the format described by the table:</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>What it represents</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>%dd</td>
<td>Day of the month (formatted as two digits)</td>
<td>05</td>
</tr>
<tr>
<td>%dmmm</td>
<td>Full name of the month</td>
<td>July</td>
</tr>
<tr>
<td>%dmm</td>
<td>Abbreviated name of the month (three letters)</td>
<td>Jul</td>
</tr>
<tr>
<td>%dm</td>
<td>Month number (formatted as two digits)</td>
<td>07</td>
</tr>
<tr>
<td>%dy</td>
<td>Year (formatted as four digits)</td>
<td>2023</td>
</tr>
<tr>
<td>%th</td>
<td>Hour in 12-hour format</td>
<td>03</td>
</tr>
<tr>
<td>%tH</td>
<td>Hour in 24-hour format (HH)</td>
<td>15</td>
</tr>
<tr>
<td>%ti</td>
<td>Minutes (formatted as two digits)</td>
<td>30</td>
</tr>
<tr>
<td>%ts</td>
<td>Seconds (formatted as two digits)</td>
<td>45</td>
</tr>
<tr>
<td>%tm</td>
<td>Milliseconds (formatted as three digits)</td>
<td>123</td>
</tr>
<tr>
<td>%tz</td>
<td>Time zone offset (total hours in UTC)</td>
<td>+03:00</td>
</tr>
<tr>
<td>%ri</td>
<td>Client's remote IP address</td>
<td>192.168.1.100</td>
</tr>
<tr>
<td>%rm</td>
<td>HTTP method (uppercase)</td>
<td>GET</td>
</tr>
<tr>
<td>%rs</td>
<td>URI scheme (http/https)</td>
<td>https</td>
</tr>
<tr>
<td>%ra</td>
<td>URI authority (domain)</td>
<td>example.com</td>
</tr>
<tr>
<td>%rh</td>
<td>Host of the request</td>
<td><a href="http://www.example.com">www.example.com</a></td>
</tr>
<tr>
<td>%rp</td>
<td>Port of the request</td>
<td>443</td>
</tr>
<tr>
<td>%rz</td>
<td>Path of the request</td>
<td>/path/to/resource</td>
</tr>
<tr>
<td>%rq</td>
<td>Query string</td>
<td>?key=value&amp;another=123</td>
</tr>
<tr>
<td>%sc</td>
<td>HTTP response status code</td>
<td>200</td>
</tr>
<tr>
<td>%sd</td>
<td>HTTP response status description</td>
<td>OK</td>
</tr>
<tr>
<td>%lin</td>
<td>Human-readable size of the request</td>
<td>1.2 KB</td>
</tr>
<tr>
<td>%linr</td>
<td>Raw size of the request (bytes)</td>
<td>1234</td>
</tr>
<tr>
<td>%lou</td>
<td>Human-readable size of the response</td>
<td>2.5 KB</td>
</tr>
<tr>
<td>%lour</td>
<td>Raw size of the response (bytes)</td>
<td>2560</td>
</tr>
<tr>
<td>%lms</td>
<td>Elapsed time in milliseconds</td>
<td>120</td>
</tr>
<tr>
<td>%ls</td>
<td>Execution status</td>
<td>Executed</td>
</tr>
<tr>
<td>%{header-name}</td>
<td>Represents the <code>header-name</code> header of the request.</td>
<td><code>Mozilla/5.0 (platform; rv:gecko [...]</code></td>
</tr>
<tr>
<td>%{:header-name}</td>
<td>Represents the <code>header-name</code> header of the response.</td>
<td><code>application/json</code></td>
</tr>
</tbody>
</table>
<p>You can also use <code>HttpServerConfiguration.DefaultAccessLogFormat</code> to use the default access log format.</p>
<h2 id="rotating-logs">Rotating logs</h2>
<p>You can configure the HTTP server to rotate the log files to a compressed .gz file when they reach a certain size. The size is checked periodically by the limiar you define.</p>
<pre><code class="lang-cs">LogStream errorLog = new LogStream(&quot;logs/error.log&quot;)
    .ConfigureRotatingPolicy(
        maximumSize: 64 * SizeHelper.UnitMb,
        dueTime: TimeSpan.FromHours(6));
</code></pre>
<p>The above code will check every six hours if the LogStream's file has reached it's 64MB limit. If so, the file is compressed to an .gz file and it then <code>access.log</code> is cleaned.</p>
<p>During this process, writing to the file is locked until the file is compressed and cleaned. All lines that enter to be written in this period will be in a queue waiting for the end of compression.</p>
<p>This function only works with file-based LogStreams.</p>
<h2 id="error-logging">Error logging</h2>
<p>When a server is not throwing errors to the debugger, it forwards the errors to log writing when there are any. You can configure error writing with:</p>
<pre><code class="lang-cs">config.ThrowExceptions = false;
config.ErrorsLogsStream = new LogStream(&quot;error.log&quot;);
</code></pre>
<p>This property will only write something to the log if the error is not captured by the callback or the <a href="/api/Sisk.Core.Routing.Router.CallbackErrorHandler">Router.CallbackErrorHandler</a> property.</p>
<p>The error written by the server always writes the date and time, the request headers (not the body), the error trace, and the inner exception trace, if theres any.</p>
<h2 id="other-logging-instances">Other logging instances</h2>
<p>Your application can have zero or multiple LogStreams, there is no limit on how many log channels it can have. Therefore, it is possible to direct your application's log to a file other than the default AccessLog or ErrorLog.</p>
<pre><code class="lang-cs">LogStream appMessages = new LogStream(&quot;messages.log&quot;);
appMessages.WriteLine(&quot;Application started at {0}&quot;, DateTime.Now);
</code></pre>
<h2 id="extending-logstream">Extending LogStream</h2>
<p>You can extend the <code>LogStream</code> class to write custom formats, compatible with the current Sisk log engine. The example below allows to write colorful messages into the Console through Spectre.Console library:</p>
<div class="script-header">
    <span>
        CustomLogStream.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class CustomLogStream : LogStream
{
    protected override void WriteLineInternal(string line)
    {
        base.WriteLineInternal($&quot;[{DateTime.Now:g}] {line}&quot;);
    }
}
</code></pre>
<p>Another way to automatically write custom logs for each request/response is to create an <a href="/api/Sisk.Core.Http.Handlers.HttpServerHandler">HttpServerHandler</a>. The example below is a little more complete. It writes the body of the request and response in JSON to the Console. It can be useful for debugging requests in general. This example makes use of ContextBag and HttpServerHandler.</p>
<div class="script-header">
    <span>
        Program.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class Program
{
    static async Task Main(string[] args)
    {
        var app = HttpServer.CreateBuilder(host =&gt;
        {
            host.UseListeningPort(5555);
            host.UseHandler&lt;JsonMessageHandler&gt;();
        });

        app.Router += new Route(RouteMethod.Any, &quot;/json&quot;, request =&gt;
        {
            return new HttpResponse()
                .WithContent(JsonContent.Create(new
                {
                    method = request.Method.Method,
                    path = request.Path,
                    specialMessage = &quot;Hello, world!!&quot;
                }));
        });

        await app.StartAsync();
    }
}
</code></pre>
<div class="script-header">
    <span>
        JsonMessageHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">class JsonMessageHandler : HttpServerHandler
{
    protected override void OnHttpRequestOpen(HttpRequest request)
    {
        if (request.Method != HttpMethod.Get &amp;&amp; request.Headers[&quot;Content-Type&quot;]?.Contains(&quot;json&quot;, StringComparison.InvariantCultureIgnoreCase) == true)
        {
            // At this point, the connection is open and the client has sent the header specifying
            // that the content is JSON.The line below reads the content and leaves it stored in the request.
            //
            // If the content is not read in the request action, the GC is likely to collect the content
            // after sending the response to the client, so the content may not be available after the response is closed.
            //
            _ = request.RawBody;

            // add hint in the context to tell that this request has an json body on it
            request.Bag.Add(&quot;IsJsonRequest&quot;, true);
        }
    }

    protected override async void OnHttpRequestClose(HttpServerExecutionResult result)
    {
        string? requestJson = null,
                responseJson = null,
                responseMessage;

        if (result.Request.Bag.ContainsKey(&quot;IsJsonRequest&quot;))
        {
            // reformats the JSON using the CypherPotato.LightJson library
            var content = result.Request.Body;
            requestJson = JsonValue.Deserialize(content, new JsonOptions() { WriteIndented = true }).ToString();
        }
        
        if (result.Response is { } response)
        {
            var content = response.Content;
            responseMessage = $&quot;{(int)response.Status} {HttpStatusInformation.GetStatusCodeDescription(response.Status)}&quot;;
            
            if (content is HttpContent httpContent &amp;&amp;
                // check if the response is JSON
                httpContent.Headers.ContentType?.MediaType?.Contains(&quot;json&quot;, StringComparison.InvariantCultureIgnoreCase) == true)
            {
                string json = await httpContent.ReadAsStringAsync();
                responseJson = JsonValue.Deserialize(json, new JsonOptions() { WriteIndented = true }).ToString();
            }
        }
        else
        {
            // gets the internal server handling status
            responseMessage = result.Status.ToString();
        }
        
        StringBuilder outputMessage = new StringBuilder();

        if (requestJson != null)
        {
            outputMessage.AppendLine(&quot;-----&quot;);
            outputMessage.AppendLine($&quot;&gt;&gt;&gt; {result.Request.Method} {result.Request.Path}&quot;);

            if (requestJson is not null)
                outputMessage.AppendLine(requestJson);
        }

        outputMessage.AppendLine($&quot;&lt;&lt;&lt; {responseMessage}&quot;);

        if (responseJson is not null)
            outputMessage.AppendLine(responseJson);

        outputMessage.AppendLine(&quot;-----&quot;);

        await Console.Out.WriteLineAsync(outputMessage.ToString());
    }
}
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/features/logging.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext", "ApiGenerationContext", "OpenApiExporter", "BodyExampleResult",
                            "ParameterExampleResult", "OpenApiContact", "OpenApiLicense", "HttpContent",
                            "ApiDocumentation", "CrossOriginResourceSharingHeaders", "McpProvider",
                            "JsonSchema", "McpToolContext", "HttpListenerAbstractEngine", "HttpListener",
                            "CadenteHttpServerEngine", "CertificateHelper"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort", "HttpServerEngineContextEventLoopMechanism"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
                
                (function() {
                    const copyBtn = document.getElementById('copy-article-btn');
                    const copyDropdown = document.getElementById('copy-dropdown');
                    const copyLinkBtn = document.getElementById('copy-link-btn');
                    const copyMarkdownBtn = document.getElementById('copy-markdown-btn');
                    
                    if (!copyBtn) return;
                    
                    copyBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        copyDropdown.classList.toggle('show');
                    });
                    
                    document.addEventListener('click', function(e) {
                        if (!copyDropdown.contains(e.target) && e.target !== copyBtn) {
                            copyDropdown.classList.remove('show');
                        }
                    });
                    
                    function getArticleContent() {
                        const article = document.querySelector('article');
                        if (!article) return null;
                        
                        const clone = article.cloneNode(true);
                        clone.querySelectorAll('.line-numbers, .code-action').forEach(el => el.remove());
                        
                        return clone;
                    }
                    
                    copyLinkBtn.addEventListener('click', function() {
                        navigator.clipboard.writeText(window.location.href);
                        copyDropdown.classList.remove('show');
                    });
                    
                    copyMarkdownBtn.addEventListener('click', async function() {
                        const article = getArticleContent();
                        if (!article) return;
                        
                        if (typeof TurndownService === 'undefined') {
                            const script = document.createElement('script');
                            script.src = 'https://unpkg.com/turndown/dist/turndown.js';
                            script.onload = function() {
                                convertAndCopy(article);
                            };
                            document.head.appendChild(script);
                        } else {
                            convertAndCopy(article);
                        }
                        
                        copyDropdown.classList.remove('show');
                    });
                    
                    function convertAndCopy(article) {
                        const turndown = new TurndownService({
                            headingStyle: 'atx',
                            codeBlockStyle: 'fenced'
                        });
                        
                        turndown.addRule('codeBlocks', {
                            filter: ['pre'],
                            replacement: function(content, node) {
                                const code = node.querySelector('code');
                                const langClass = code?.className.match(/lang-(\w+)/);
                                const lang = langClass ? langClass[1] : '';
                                const text = code?.textContent || content;
                                return '\n\n```' + lang + '\n' + text.trim() + '\n```\n\n';
                            }
                        });
                        
                        const markdown = turndown.turndown(article.innerHTML);
                        navigator.clipboard.writeText(markdown);
                    }
                })();
            </script>
        </footer>
    </body>
</html>