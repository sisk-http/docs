<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title> | Sisk Framework </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content=" | Sisk Framework ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        <script>
            document.addEventListener('DOMContentLoaded', () => {
                document.querySelectorAll("pre").forEach(pre => {
                    const lineCount = pre.innerText.split('\n').length;
                    const lis = [];
                    
                    for(var i = 1; i < lineCount; i++)
                        lis.push(el("li", i))
                    
                    pre.appendChild(el("ul", ...lis));
                });
            });
        </script>
        
        <!-- Cloudflare Web Analytics -->
        <script defer="" src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "e1483f9ff9e246f4bd69e45a87ef6923"}'></script>
        <!-- End Cloudflare Web Analytics -->

        <script>

            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>

    </head>


    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk Framework">
                        Sisk Framework
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">

<p>Respostas representam objetos que são respostas HTTP para solicitações HTTP. Elas são enviadas pelo servidor para o cliente como uma indicação da solicitação de um recurso, página, documento, arquivo ou outro objeto.</p>
<p>Uma resposta HTTP é formada por status, cabeçalhos e conteúdo.</p>
<p>Neste documento, ensinaremos como arquitetar respostas HTTP com o Sisk.</p>
<h2 id="definindo-um-status-http">Definindo um status HTTP</h2>
<p>A lista de status HTTP é a mesma desde HTTP/1.0, e o Sisk suporta todos eles.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; // 202
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse()
    .WithStatus(200) // ou
    .WithStatus(HttpStatusCode.Ok) // ou
    .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Você pode ver a lista completa de códigos de status HttpStatusCode disponíveis <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.httpstatuscode">aqui</a>. Você também pode fornecer seu próprio código de status usando a estrutura <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>.</p>
<h2 id="corpo-e-tipo-de-conteúdo">Corpo e tipo de conteúdo</h2>
<p>O Sisk suporta objetos de conteúdo .NET nativos para enviar o corpo em respostas. Você pode usar a classe <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.stringcontent">StringContent</a> para enviar uma resposta JSON, por exemplo:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>O servidor sempre tentará calcular o <code>Content-Length</code> com base no que você definiu no conteúdo, se você não tiver definido explicitamente em um cabeçalho. Se o servidor não conseguir obter implicitamente o cabeçalho Content-Length do conteúdo da resposta, a resposta será enviada com Chunked-Encoding.</p>
<p>Você também pode transmitir a resposta enviando um <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.streamcontent">StreamContent</a> ou usando o método GetResponseStream.</p>
<h2 id="cabeçalhos-de-resposta">Cabeçalhos de resposta</h2>
<p>Você pode adicionar, editar ou remover cabeçalhos que está enviando na resposta. O exemplo abaixo mostra como enviar uma resposta de redirecionamento para o cliente.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse(301)
    .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Quando você usa o método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a> de HttpHeaderCollection, você está adicionando um cabeçalho à solicitação sem alterar os que já foram enviados. O método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a> substitui os cabeçalhos com o mesmo nome pelo valor instruído. O índice de HttpHeaderCollection chama internamente o método Set para substituir os cabeçalhos.</p>
<h2 id="envio-de-cookies">Envio de cookies</h2>
<p>O Sisk possui métodos que facilitam a definição de cookies no cliente. Cookies definidos por este método já estão codificados em URL e atendem ao padrão RFC-6265.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;);
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse(301)
    .WithCookie(&quot;cookie-name&quot;, &quot;cookie-value&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Existem outras <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">versões mais completas</a> do mesmo método.</p>
<h2 id="respostas-chunked">Respostas chunked</h2>
<p>Você pode definir a codificação de transferência como chunked para enviar respostas grandes.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>Ao usar chunked-encoding, o cabeçalho Content-Length é omitido automaticamente.</p>
<h2 id="stream-de-resposta">Stream de resposta</h2>
<p>Os streams de resposta são uma maneira gerenciada que permite enviar respostas de forma segmentada. É uma operação de nível inferior do que usar objetos HttpResponse, pois exige que você envie os cabeçalhos e o conteúdo manualmente e, em seguida, feche a conexão.</p>
<p>Este exemplo abre um stream de leitura para o arquivo, copia o stream para o stream de saída da resposta e não carrega o arquivo inteiro na memória. Isso pode ser útil para servir arquivos médios ou grandes.</p>
<pre><code class="lang-cs">// abre o stream de resposta para o arquivo
using var fileStream = File.OpenRead(&quot;my-big-file.zip&quot;);
var responseStream = request.GetResponseStream();

// define a codificação de resposta para usar chunked-encoding
// também você não deve enviar o cabeçalho Content-Length quando usar
// chunked encoding
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// copia o stream do arquivo para o stream de saída da resposta
fileStream.CopyTo(responseStream.ResponseStream);

// fecha o stream
return responseStream.Close();
</code></pre>
<h2 id="compressão-gzip-deflate-e-brotli">Compressão GZip, Deflate e Brotli</h2>
<p>Você pode enviar respostas com conteúdo compactado no Sisk com compressão de conteúdo HTTP. Primeiro, encapsule seu objeto <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent">HttpContent</a> dentro de um dos compactadores abaixo para enviar a resposta compactada ao cliente.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
    string myHtml = &quot;...&quot;;
    
    return new HttpResponse () {
        Content = new GZipContent(new HtmlContent(myHtml)),
        // ou Content = new BrotliContent(new HtmlContent(myHtml)),
        // ou Content = new DeflateContent(new HtmlContent(myHtml)),
    };
});
</code></pre>
<p>Você também pode usar esses conteúdos compactados com streams.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
    // não aplique &quot;using&quot; aqui. o HttpServer descartará seu conteúdo
    // após enviar a resposta.
    var archive = File.OpenRead(&quot;/path/to/big-file.zip&quot;);
    
    return new HttpResponse () {
        Content = new GZipContent(archive)
    }
});
</code></pre>
<p>Os cabeçalhos Content-Encoding são definidos automaticamente ao usar esses conteúdos.</p>
<h2 id="tipos-de-resposta-implícitos">Tipos de resposta implícitos</h2>
<p>Desde a versão 0.15, você pode usar outros tipos de retorno além de HttpResponse, mas é necessário configurar o roteador como ele irá lidar com cada tipo de objeto.</p>
<p>O conceito é sempre retornar um tipo de referência e transformá-lo em um objeto HttpResponse válido. Rotas que retornam HttpResponse não passam por nenhuma conversão.</p>
<p>Tipos de valor (estruturas) não podem ser usados como tipo de retorno porque não são compatíveis com o <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a>, portanto, devem ser envoltos em um ValueResult para poderem ser usados em manipuladores.</p>
<p>Considere o seguinte exemplo de um módulo de roteador que não usa HttpResponse no tipo de retorno:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
    public List&lt;User&gt; Users = new List&lt;User&gt;();

    [RouteGet]
    public IEnumerable&lt;User&gt; Index(HttpRequest request)
    {
        return Users.ToArray();
    }

    [RouteGet(&quot;&lt;id&gt;&quot;)]
    public User View(HttpRequest request)
    {
        int id = request.Query[&quot;id&quot;].GetInteger();
        User dUser = Users.First(u =&gt; u.Id == id);

        return dUser;
    }

    [RoutePost]
    public ValueResult&lt;bool&gt; Create(HttpRequest request)
    {
        User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
        Users.Add(fromBody);

        return true;
    }
}
</code></pre>
<p>Com isso, agora é necessário definir no roteador como ele irá lidar com cada tipo de objeto. Os objetos são sempre o primeiro argumento do manipulador e o tipo de saída deve ser um HttpResponse válido. Além disso, os objetos de saída de uma rota nunca devem ser nulos.</p>
<p>Para tipos ValueResult não é necessário indicar que o objeto de entrada é um ValueResult e apenas T, pois ValueResult é um objeto refletido do seu componente original.</p>
<p>A associação de tipos não compara o que foi registrado com o tipo do objeto retornado pelo callback do roteador. Em vez disso, verifica se o tipo do resultado do roteador é atribuível ao tipo registrado.</p>
<p>Registrar um manipulador de tipo Object será usado como fallback para todos os tipos de objeto previamente não validados. A ordem de inserção dos manipuladores de valor também importa, então registrar um manipulador Object último garantirá que ele ignore todos os outros manipuladores específicos de tipo. Sempre registre manipuladores de valor específicos primeiro para garantir a ordem.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;bool&gt;(bolVal =&gt;
{
    HttpResponse res = new HttpResponse();
    res.Status = (bool)bolVal ? HttpStatusCode.OK : HttpStatusCode.BadRequest;
    return res;
});

r.RegisterValueHandler&lt;IEnumerable&gt;(enumerableValue =&gt;
{
    return new HttpResponse();
    // faça algo com enumerableValue aqui
});

// registrar um manipulador de valor de object deve ser o último
// manipulador de valor que será usado como fallback
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
    HttpResponse res = new HttpResponse();
    res.Status = HttpStatusCode.OK;
    res.Content = JsonContent.Create(fallback);
    return res;
});
</code></pre>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>