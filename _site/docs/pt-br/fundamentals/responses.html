<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Respostas | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Respostas | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/responses.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="respostas">Respostas</h1>

<p>Respostas representam objetos que são respostas HTTP para solicitações HTTP. Elas são enviadas pelo servidor ao cliente como uma indicação da solicitação de um recurso, página, documento, arquivo ou outro objeto.</p>
<p>Uma resposta HTTP é formada por status, cabeçalhos e conteúdo.</p>
<p>Neste documento, ensinaremos como arquitetar respostas HTTP com Sisk.</p>
<h2 id="definindo-um-status-http">Definindo um status HTTP</h2>
<p>A lista de status HTTP é a mesma desde o HTTP/1.0, e Sisk suporta todos eles.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = System.Net.HttpStatusCode.Accepted; //202
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse()
 .WithStatus(200) // ou
 .WithStatus(HttpStatusCode.Ok) // ou
 .WithStatus(HttpStatusInformation.Ok);
</code></pre>
<p>Você pode ver a lista completa de HttpStatusCode disponíveis <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.httpstatuscode">aqui</a>. Você também pode fornecer seu próprio código de status usando a estrutura <a href="/api/Sisk.Core.Http.HttpStatusInformation">HttpStatusInformation</a>.</p>
<h2 id="corpo-e-tipo-de-conteúdo">Corpo e tipo de conteúdo</h2>
<p>Sisk suporta objetos de conteúdo .NET nativos para enviar corpos em respostas. Você pode usar a classe <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.stringcontent">StringContent</a> para enviar uma resposta JSON, por exemplo:</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Content = new StringContent(myJson, Encoding.UTF8, &quot;application/json&quot;);
</code></pre>
<p>O servidor sempre tentará calcular o <code>Content-Length</code> do que você definiu no conteúdo se você não o definiu explicitamente em um cabeçalho. Se o servidor não puder obter implicitamente o cabeçalho Content-Length do conteúdo da resposta, a resposta será enviada com Chunked-Encoding.</p>
<p>Você também pode transmitir a resposta enviando um <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.streamcontent">StreamContent</a> ou usando o método <a href="/api/Sisk.Core.Http.HttpRequest.GetResponseStream">GetResponseStream</a>.</p>
<h2 id="cabeçalhos-de-resposta">Cabeçalhos de resposta</h2>
<p>Você pode adicionar, editar ou remover cabeçalhos que está enviando na resposta. O exemplo abaixo mostra como enviar uma resposta de redirecionamento para o cliente.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.Status = HttpStatusCode.Moved;
res.Headers.Add(HttpKnownHeaderNames.Location, &quot;/login&quot;);
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithHeader(&quot;Location&quot;, &quot;/login&quot;);
</code></pre>
<p>Quando você usa o método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Add">Add</a> de HttpHeaderCollection, você está adicionando um cabeçalho à solicitação sem alterar os que já foram enviados. O método <a href="/api/Sisk.Core.Entity.HttpHeaderCollection.Set">Set</a> substitui os cabeçalhos com o mesmo nome pelo valor instruído. O indexador de HttpHeaderCollection chama internamente o método Set para substituir os cabeçalhos.</p>
<h2 id="enviando-cookies">Enviando cookies</h2>
<p>Sisk tem métodos que facilitam a definição de cookies no cliente. Cookies definidos por este método já estão codificados em URL e atendem ao padrão RFC-6265.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SetCookie(&quot;nome-do-cookie&quot;, &quot;valor-do-cookie&quot;);
</code></pre>
<p>Ou com Sintaxe Fluente:</p>
<pre><code class="lang-cs">new HttpResponse(301)
 .WithCookie(&quot;nome-do-cookie&quot;, &quot;valor-do-cookie&quot;, expiresAt: DateTime.Now.Add(TimeSpan.FromDays(7)));
</code></pre>
<p>Existem outras <a href="/api/Sisk.Core.Http.CookieHelper.SetCookie">versões mais completas</a> do mesmo método.</p>
<h2 id="respostas-chunked">Respostas chunked</h2>
<p>Você pode definir a codificação de transferência como chunked para enviar respostas grandes.</p>
<pre><code class="lang-cs">HttpResponse res = new HttpResponse();
res.SendChunked = true;
</code></pre>
<p>Quando usar chunked-encoding, o cabeçalho Content-Length é automaticamente omitido.</p>
<h2 id="fluxo-de-resposta">Fluxo de resposta</h2>
<p>Os fluxos de resposta são uma maneira gerenciada que permite enviar respostas de forma segmentada. É uma operação de nível mais baixo do que usar objetos HttpResponse, pois exigem que você envie os cabeçalhos e o conteúdo manualmente e, em seguida, feche a conexão.</p>
<p>Este exemplo abre um fluxo de leitura somente para o arquivo, copia o fluxo para o fluxo de saída da resposta e não carrega o arquivo inteiro na memória. Isso pode ser útil para servir arquivos médios ou grandes.</p>
<pre><code class="lang-cs">// obtém o fluxo de saída da resposta
using var fileStream = File.OpenRead(&quot;meu-arquivo-grande.zip&quot;);
var responseStream = request.GetResponseStream();

// define a codificação de resposta para usar chunked-encoding
// também você não deve enviar o cabeçalho content-length quando usar
// chunked encoding
responseStream.SendChunked = true;
responseStream.SetStatus(200);
responseStream.SetHeader(HttpKnownHeaderNames.ContentType, contentType);

// copia o fluxo do arquivo para o fluxo de saída da resposta
fileStream.CopyTo(responseStream.ResponseStream);

// fecha o fluxo
return responseStream.Close();
</code></pre>
<h2 id="compressão-gzip-deflate-e-brotli">Compressão GZip, Deflate e Brotli</h2>
<p>Você pode enviar respostas com conteúdo comprimido em Sisk com conteúdos HTTP comprimidos. Primeiramente, encapsule seu objeto <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent">HttpContent</a> dentro de um dos compressores abaixo para enviar a resposta comprimida ao cliente.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/hello.html&quot;, request =&gt; {
 string meuHtml = &quot;...&quot;;
    
 return new HttpResponse () {
 Content = new GZipContent(new HtmlContent(meuHtml)),
 // ou Content = new BrotliContent(new HtmlContent(meuHtml)),
 // ou Content = new DeflateContent(new HtmlContent(meuHtml)),
 };
});
</code></pre>
<p>Você também pode usar esses conteúdos comprimidos com fluxos.</p>
<pre><code class="lang-cs">router.MapGet(&quot;/archive.zip&quot;, request =&gt; {
    
 // não aplique &quot;using&quot; aqui. o HttpServer irá descartar seu conteúdo
 // após enviar a resposta.
 var arquivo = File.OpenRead(&quot;/caminho/para/arquivo-grande.zip&quot;);
    
 return new HttpResponse () {
 Content = new GZipContent(arquivo)
 }
});
</code></pre>
<p>Os cabeçalhos Content-Encoding são automaticamente definidos quando usados esses conteúdos.</p>
<h2 id="compressão-automática">Compressão automática</h2>
<p>É possível comprimir automaticamente respostas HTTP com a propriedade <a href="/api/Sisk.Core.Http.HttpServerConfiguration.EnableAutomaticResponseCompression">EnableAutomaticResponseCompression</a>. Essa propriedade encapsula automaticamente o conteúdo da resposta do roteador em um conteúdo comprimido que é aceito pela solicitação, desde que a resposta não seja herdada de um <a href="/api/Sisk.Core.Http.CompressedContent">CompressedContent</a>.</p>
<p>Apenas um conteúdo comprimido é escolhido para uma solicitação, escolhido de acordo com o cabeçalho Accept-Encoding, que segue a ordem:</p>
<ul>
<li><a href="/api/Sisk.Core.Http.BrotliContent">BrotliContent</a> (br)</li>
<li><a href="/api/Sisk.Core.Http.GZipContent">GZipContent</a> (gzip)</li>
<li><a href="/api/Sisk.Core.Http.DeflateContent">DeflateContent</a> (deflate)</li>
</ul>
<p>Se a solicitação especificar que aceita qualquer um desses métodos de compressão, a resposta será automaticamente comprimida.</p>
<h2 id="tipos-de-resposta-implícitos">Tipos de resposta implícitos</h2>
<p>Você pode usar outros tipos de retorno além de HttpResponse, mas é necessário configurar o roteador para lidar com cada tipo de objeto.</p>
<p>O conceito é sempre retornar um tipo de referência e transformá-lo em um objeto HttpResponse válido. Rotas que retornam HttpResponse não passam por nenhuma conversão.</p>
<p>Tipos de valor (estruturas) não podem ser usados como tipo de retorno porque não são compatíveis com o <a href="/api/Sisk.Core.Routing.RouterCallback">RouterCallback</a>, portanto, devem ser encapsulados em um ValueResult para poderem ser usados em manipuladores.</p>
<p>Considere o exemplo a seguir de um módulo de roteador que não usa HttpResponse no tipo de retorno:</p>
<pre><code class="lang-cs">[RoutePrefix(&quot;/users&quot;)]
public class UsersController : RouterModule
{
 public List&lt;User&gt; Users = new List&lt;User&gt;();

 [RouteGet]
 public IEnumerable&lt;User&gt; Index(HttpRequest request)
 {
 return Users.ToArray();
 }

 [RouteGet(&quot;&lt;id&gt;&quot;)]
 public User View(HttpRequest request)
 {
 int id = request.RouteParameters[&quot;id&quot;].GetInteger();
 User dUser = Users.First(u =&gt; u.Id == id);

 return dUser;
 }

 [RoutePost]
 public ValueResult&lt;bool&gt; Create(HttpRequest request)
 {
 User fromBody = JsonSerializer.Deserialize&lt;User&gt;(request.Body)!;
 Users.Add(fromBody);
        
 return true;
 }
}
</code></pre>
<p>Com isso, agora é necessário definir no roteador como ele lidará com cada tipo de objeto. Objetos são sempre o primeiro argumento do manipulador e o tipo de saída deve ser um HttpResponse válido. Além disso, os objetos de saída de uma rota nunca devem ser nulos.</p>
<p>Para tipos ValueResult, não é necessário indicar que o objeto de entrada é um ValueResult e apenas T, pois ValueResult é um objeto refletido de seu componente original.</p>
<p>A associação de tipos não compara o que foi registrado com o tipo do objeto retornado do callback do roteador. Em vez disso, verifica se o tipo do resultado do roteador é atribuível ao tipo registrado.</p>
<p>Registrar um manipulador do tipo Object será um fallback para todos os tipos não validados anteriormente. A ordem de inserção dos manipuladores de valor também importa, portanto, registrar um manipulador de objeto primeiro ignorará todos os outros manipuladores específicos de tipo. Sempre registre manipuladores de valor específicos primeiro para garantir a ordem.</p>
<pre><code class="lang-cs">Router r = new Router();
r.SetObject(new UsersController());

r.RegisterValueHandler&lt;ApiResult&gt;(apiResult =&gt;
{
 return new HttpResponse() {
 Status = apiResult.Success ? HttpStatusCode.OK : HttpStatusCode.BadRequest,
 Content = apiResult.GetHttpContent(),
 Headers = apiResult.GetHeaders()
 };
});
r.RegisterValueHandler&lt;bool&gt;(bvalue =&gt;
{
 return new HttpResponse() {
 Status = bvalue ? HttpStatusCode.OK : HttpStatusCode.BadRequest
 };
});
r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(enumerableValue =&gt;
{
 return new HttpResponse(string.Join(&quot;\n&quot;, enumerableValue));
});

// registrando um manipulador de valor de objeto deve ser o último
// manipulador de valor que será usado como fallback
r.RegisterValueHandler&lt;object&gt;(fallback =&gt;
{
 return new HttpResponse() {
 Status = HttpStatusCode.OK,
 Content = JsonContent.Create(fallback)
 };
});
</code></pre>
<h2 id="nota-sobre-objetos-enumeráveis-e-arrays">Nota sobre objetos enumeráveis e arrays</h2>
<p>Objetos de resposta implícitos que implementam <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.ienumerable?view=net-8.0">IEnumerable</a> são lidos na memória através do método <code>ToArray()</code> antes de serem convertidos através de um manipulador de valor definido. Para que isso ocorra, o objeto <code>IEnumerable</code> é convertido em uma matriz de objetos, e o conversor de resposta sempre receberá um <code>Object[]</code> em vez do tipo original.</p>
<p>Considere o cenário a seguir:</p>
<pre><code class="lang-csharp">using var host = HttpServer.CreateBuilder(12300)
 .UseRouter(r =&gt;
 {
 r.RegisterValueHandler&lt;IEnumerable&lt;string&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Matriz de string:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.RegisterValueHandler&lt;IEnumerable&lt;object&gt;&gt;(stringEnumerable =&gt;
 {
 return new HttpResponse(&quot;Matriz de objeto:\n&quot; + string.Join(&quot;\n&quot;, stringEnumerable));
 });
 r.MapGet(&quot;/&quot;, request =&gt;
 {
 return (IEnumerable&lt;string&gt;)[&quot;hello&quot;, &quot;world&quot;];
 });
 })
 .Build();
</code></pre>
<p>No exemplo acima, o conversor <code>IEnumerable&lt;string&gt;</code> <strong>nunca será chamado</strong>, porque o objeto de entrada sempre será um <code>Object[]</code> e não é conversível para um <code>IEnumerable&lt;string&gt;</code>. No entanto, o conversor abaixo que recebe um <code>IEnumerable&lt;object&gt;</code> receberá sua entrada, pois seu valor é compatível.</p>
<p>Se você precisar lidar com o tipo de objeto que será enumerado, você precisará usar reflexão para obter o tipo do elemento da coleção. Todos os objetos enumeráveis (listas, arrays e coleções) são convertidos em uma matriz de objetos pelo conversor de resposta HTTP.</p>
<p>Valores que implementam <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic.iasyncenumerable-1?view=net-8.0">IAsyncEnumerable</a> são tratados automaticamente pelo servidor se a propriedade <a href="/api/Sisk.Core.Http.HttpServerConfiguration.ConvertIAsyncEnumerableIntoEnumerable">ConvertIAsyncEnumerableIntoEnumerable</a> estiver habilitada, semelhante ao que acontece com <code>IEnumerable</code>. Uma enumeração assíncrona é convertida em um enumerador bloqueador e, em seguida, convertida em uma matriz de objetos síncronos.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/responses.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>