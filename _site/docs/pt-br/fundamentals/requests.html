<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Requisi&#231;&#245;es | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Requisi&#231;&#245;es | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/requests.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es|de|jp)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Español
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/de/')">
                                    <img src="/assets/flag/germany.png">
                                    Deutsch
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    中文 (简体)
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/jp/')">
                                    <img src="/assets/flag/japan.png">
                                    日本語
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="requisições">Requisições</h1>

<p>Requisições são estruturas que representam uma mensagem de requisição HTTP. O objeto <a href="/api/Sisk.Core.Http.HttpRequest">HttpRequest</a> contém funções úteis para manipular mensagens HTTP em toda a sua aplicação.</p>
<p>Uma requisição HTTP é formada pelo método, caminho, versão, cabeçalhos e corpo.</p>
<p>Neste documento, vamos ensinar como obter cada um desses elementos.</p>
<h2 id="obtendo-o-método-da-requisição">Obtendo o método da requisição</h2>
<p>Para obter o método da requisição recebida, você pode usar a propriedade Method:</p>
<pre><code class="lang-cs">static HttpResponse Index(HttpRequest request)
{
    HttpMethod requestMethod = request.Method;
    ...
}
</code></pre>
<p>Essa propriedade retorna o método da requisição representado por um objeto <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.net.http.httpmethod">HttpMethod</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Ao contrário dos métodos de rota, essa propriedade não atende ao item <a href="/api/Sisk.Core.Routing.RouteMethod">RouteMethod.Any</a>. Em vez disso, ela retorna o método de requisição real.</p>
</div>
<h2 id="obtendo-componentes-da-url-da-requisição">Obtendo componentes da URL da requisição</h2>
<p>Você pode obter vários componentes de uma URL por meio de certas propriedades de uma requisição. Para este exemplo, vamos considerar a URL:</p>
<pre><code>http://localhost:5000/user/login?email=foo@bar.com
</code></pre>
<table>
<thead>
<tr>
<th>Nome do componente</th>
<th>Descrição</th>
<th>Valor do componente</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Path">Path</a></td>
<td>Obtém o caminho da requisição.</td>
<td><code>/user/login</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullPath">FullPath</a></td>
<td>Obtém o caminho da requisição e a string de consulta.</td>
<td><code>/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.FullUrl">FullUrl</a></td>
<td>Obtém a string de requisição URL completa.</td>
<td><code>http://localhost:5000/user/login?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Host">Host</a></td>
<td>Obtém o host da requisição.</td>
<td><code>localhost</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Authority">Authority</a></td>
<td>Obtém o host e a porta da requisição.</td>
<td><code>localhost:5000</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.QueryString">QueryString</a></td>
<td>Obtém a consulta da requisição.</td>
<td><code>?email=foo@bar.com</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.Query">Query</a></td>
<td>Obtém a consulta da requisição em uma coleção de valores nomeados.</td>
<td><code>{StringValueCollection object}</code></td>
</tr>
<tr>
<td><a href="/api/Sisk.Core.Http.HttpRequest.IsSecure">IsSecure</a></td>
<td>Determina se a requisição está usando SSL (true) ou não (false).</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
<p>Você também pode optar por usar a propriedade <a href="/api/Sisk.Core.Http.HttpRequest.Uri">HttpRequest.Uri</a>, que inclui tudo acima em um objeto.</p>
<h2 id="obtendo-o-corpo-da-requisição">Obtendo o corpo da requisição</h2>
<p>Algumas requisições incluem corpo, como formulários, arquivos ou transações de API. Você pode obter o corpo de uma requisição da propriedade:</p>
<pre><code class="lang-cs">// obtém o corpo da requisição como uma string, usando o codificador de requisição
string body = request.Body;

// ou obtém em um array de bytes
byte[] bodyBytes = request.RawBody;

// ou pode transmiti-lo.
Stream requestStream = request.GetRequestStream();
</code></pre>
<p>Também é possível determinar se há um corpo na requisição e se ele está carregado com as propriedades <a href="/api/Sisk.Core.Http.HttpRequest.HasContents">HasContents</a>, que determina se a requisição tem conteúdo e <a href="/api/Sisk.Core.Http.HttpRequest.IsContentAvailable">IsContentAvailable</a> que indica que o servidor HTTP recebeu totalmente o conteúdo do ponto remoto.</p>
<p>Não é possível ler o conteúdo da requisição por <code>GetRequestStream</code> mais de uma vez. Se você ler com este método, os valores em <code>RawBody</code> e <code>Body</code> também não estarão disponíveis. Não é necessário descartar o fluxo de requisição no contexto da requisição, pois ele é descartado no final da sessão HTTP em que é criado. Além disso, você pode usar a propriedade <a href="/api/Sisk.Core.Http.HttpRequest.RequestEncoding">HttpRequest.RequestEncoding</a> para obter o melhor codificador para decodificar a requisição manualmente.</p>
<p>O servidor tem limites para ler o conteúdo da requisição, que se aplica a ambos <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.Body</a> e <a href="/api/Sisk.Core.Http.HttpRequest.Body">HttpRequest.RawBody</a>. Essas propriedades copiam o fluxo de entrada inteiro para um buffer local do mesmo tamanho de <a href="/api/Sisk.Core.Http.HttpRequest.ContentLength">HttpRequest.ContentLength</a>.</p>
<p>Uma resposta com status 413 Conteúdo Muito Grande é retornada ao cliente se o conteúdo enviado for maior que <a href="/api/Sisk.Core.Http.HttpServerConfiguration.MaximumContentLength">HttpServerConfiguration.MaximumContentLength</a> definido na configuração do usuário. Além disso, se não houver limite configurado ou se for muito grande, o servidor lançará uma <a href="https://learn.microsoft.com/en-us/dotnet/api/system.outofmemoryexception?view=net-8.0">OutOfMemoryException</a> quando o conteúdo enviado pelo cliente exceder <a href="https://learn.microsoft.com/en-us/dotnet/api/system.int32.maxvalue">Int32.MaxValue</a> (2 GB) e se o conteúdo for acessado por meio de uma das propriedades mencionadas acima. Você ainda pode lidar com o conteúdo por meio de transmissão.</p>
<div class="NOTE">
<h5>Note</h5>
<p>Embora o Sisk permita, é sempre uma boa ideia seguir a Semântica HTTP para criar sua aplicação e não obter ou servir conteúdo em métodos que não o permitam. Leia sobre <a href="https://httpwg.org/spec/rfc9110.html">RFC 9110 &quot;HTTP Semantics&quot;</a>.</p>
</div>
<h2 id="obtendo-o-contexto-da-requisição">Obtendo o contexto da requisição</h2>
<p>O Contexto HTTP é um objeto exclusivo do Sisk que armazena informações do servidor HTTP, rota, roteador e manipulador de requisição. Você pode usá-lo para se organizar em um ambiente onde esses objetos são difíceis de organizar.</p>
<p>Você pode obter o contexto de execução atual <a href="/api/Sisk.Core.Http.HttpContext">HttpContext</a> usando o método estático <code>HttpContext.GetCurrentContext()</code>. Este método retorna o contexto da requisição que está sendo processada na thread atual.</p>
<pre><code class="lang-cs">HttpContext context = HttpContext.GetCurrentContext();
</code></pre>
<h3 id="modo-de-registro">Modo de registro</h3>
<p>A propriedade <a href="/api/Sisk.Core.Http.HttpContext.LogMode">HttpContext.LogMode</a> permite controlar o comportamento de registro para a requisição atual. Você pode habilitar ou desabilitar o registro para requisições específicas, substituindo a configuração padrão do servidor.</p>
<pre><code class="lang-cs">// Desabilita o registro para esta requisição
context.LogMode = LogOutputMode.None;
</code></pre>
<h3 id="bolsa-de-requisição">Bolsa de requisição</h3>
<p>O objeto <a href="/api/Sisk.Core.Http.HttpContext.RequestBag">RequestBag</a> contém informações armazenadas que são passadas de um manipulador de requisição para outro ponto e podem ser consumidas no destino final. Este objeto também pode ser usado por manipuladores de requisição que são executados após o callback da rota.</p>
<div class="TIP">
<h5>Tip</h5>
<p>Essa propriedade também é acessível pela propriedade <a href="/api/Sisk.Core.Http.HttpRequest.Bag">HttpRequest.Bag</a>.</p>
</div>
<div class="script-header">
    <span>
        Middleware/AuthenticateUserRequestHandler.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public string Identifier { get; init; } = Guid.NewGuid().ToString();
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;
    
    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            context.RequestBag.Add(&quot;AuthenticatedUser&quot;, new User(&quot;Bob&quot;));
            return null;
        }
        else
        {
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>O manipulador de requisição acima definirá <code>AuthenticatedUser</code> na bolsa de requisição e pode ser consumido posteriormente no callback final:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        User authUser = request.Context.RequestBag[&quot;AuthenticatedUser&quot;];
        
        return new HttpResponse() {
            Content = new StringContent($&quot;Hello, {authUser.Name}!&quot;)
        };
    }
}
</code></pre>
<p>Você também pode usar os métodos de ajuda <code>Bag.Set()</code> e <code>Bag.Get()</code> para obter ou definir objetos por seus tipos singleton.</p>
<p>A classe <code>TypedValueDictionary</code> também fornece métodos <code>GetValue</code> e <code>SetValue</code> para um controle mais preciso.</p>
<div class="script-header">
    <span>
        Middleware/Authenticate.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class Authenticate : RequestHandler
{
    public override HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        request.Bag.Set&lt;User&gt;(authUser);
    }
}
</code></pre>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-csharp">[RouteGet(&quot;/&quot;)]
[RequestHandler&lt;Authenticate&gt;]
public static HttpResponse GetUser(HttpRequest request)
{
    var user = request.Bag.Get&lt;User&gt;();
    ...
}
</code></pre>
<h2 id="obtendo-dados-de-formulário">Obtendo dados de formulário</h2>
<p>Você pode obter os valores de dados de formulário em uma <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.specialized.namevaluecollection">NameValueCollection</a> com o exemplo abaixo:</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/auth&quot;)]
public HttpResponse Index(HttpRequest request)
{
    var form = request.GetFormContent();

    string? username = form[&quot;username&quot;];
    string? password = form[&quot;password&quot;];

    if (AttempLogin(username, password))
    {
        ...
    }
}
</code></pre>
<h2 id="obtendo-dados-de-formulário-multipart">Obtendo dados de formulário multipart</h2>
<p>A requisição HTTP do Sisk permite obter conteúdos multipart, como arquivos, campos de formulário ou qualquer conteúdo binário.</p>
<div class="script-header">
    <span>
        Controller/Auth.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">[RoutePost(&quot;/upload-contents&quot;)]
public HttpResponse Index(HttpRequest request)
{
    // o método a seguir lê a entrada de requisição inteira em um
    // array de MultipartObjects
    var multipartFormDataObjects = request.GetMultipartFormContent();
    
    foreach (MultipartObject uploadedObject in multipartFormDataObjects)
    {
        // O nome do arquivo fornecido pelo Multipart form data.
        // Nulo é retornado se o objeto não for um arquivo.
        Console.WriteLine(&quot;Nome do arquivo       : &quot; + uploadedObject.Filename);

        // O nome do campo do formulário de dados multipart.
        Console.WriteLine(&quot;Nome do campo      : &quot; + uploadedObject.Name);

        // O comprimento do conteúdo de dados multipart.
        Console.WriteLine(&quot;Comprimento do conteúdo  : &quot; + uploadedObject.ContentLength);

        // Determina o formato do arquivo com base no cabeçalho do arquivo para cada
        // tipo de conteúdo conhecido. Se o conteúdo não for um formato de arquivo comum
        // reconhecido, o método abaixo retornará MultipartObjectCommonFormat.Unknown
        Console.WriteLine(&quot;Formato comum   : &quot; + uploadedObject.GetCommonFileFormat());
    }
}
</code></pre>
<p>Você pode ler mais sobre objetos de formulário multipart do Sisk <a href="/api/Sisk.Core.Entity.MultipartObject">Multipart form objects</a> e seus métodos, propriedades e funcionalidades.</p>
<h2 id="detectando-desconexão-do-cliente">Detectando desconexão do cliente</h2>
<p>Desde a versão v1.15 do Sisk, o framework fornece um CancellationToken que é lançado quando a conexão entre o cliente e o servidor é fechada prematuramente antes de receber a resposta. Esse token pode ser útil para detectar quando o cliente não deseja mais a resposta e cancelar operações de longa execução.</p>
<pre><code class="lang-csharp">router.MapGet(&quot;/connect&quot;, async (HttpRequest req) =&gt;
{
    // obtém o token de desconexão da requisição
    var dc = req.DisconnectToken;

    await LongOperationAsync(dc);

    return new HttpResponse();
});
</code></pre>
<p>Esse token não é compatível com todos os motores HTTP, e cada um requer uma implementação.</p>
<h2 id="suporte-a-eventos-enviados-pelo-servidor">Suporte a eventos enviados pelo servidor</h2>
<p>O Sisk suporta <a href="https://developer.mozilla.org/en-US/docs/pt-br/Web/API/Server-sent_events">Eventos enviados pelo servidor</a>, que permite enviar pedaços como um fluxo e manter a conexão entre o servidor e o cliente viva.</p>
<p>Chamar o método <a href="/api/Sisk.Core.Http.HttpRequest.GetEventSource">HttpRequest.GetEventSource</a> colocará a HttpRequest em seu estado de ouvinte. A partir disso, o contexto desta requisição HTTP não esperará uma HttpResponse, pois ela sobreporá os pacotes enviados por eventos do servidor.</p>
<p>Depois de enviar todos os pacotes, o callback deve retornar o método <a href="/api/Sisk.Core.Http.HttpRequestEventSource.Close">Close</a>, que enviará a resposta final ao servidor e indicará que o streaming foi concluído.</p>
<p>Não é possível prever o comprimento total de todos os pacotes que serão enviados, portanto, não é possível determinar o fim da conexão com o cabeçalho <code>Content-Length</code>.</p>
<p>Por padrão da maioria dos navegadores, eventos do servidor não suportam o envio de cabeçalhos HTTP ou métodos diferentes do método GET. Portanto, tenha cuidado ao usar manipuladores de requisição com solicitações de evento de origem que exigem cabeçalhos específicos na requisição, pois eles provavelmente não os terão.</p>
<p>Além disso, a maioria dos navegadores reinicia os fluxos se o método <a href="https://developer.mozilla.org/en-US/docs/pt-br/Web/API/EventSource/close">EventSource.close</a> não for chamado no lado do cliente após receber todos os pacotes, causando processamento adicional infinito no lado do servidor. Para evitar esse tipo de problema, é comum enviar um pacote final que indica que a origem do evento concluiu o envio de todos os pacotes.</p>
<p>O exemplo abaixo mostra como o navegador pode se comunicar com o servidor que suporta Eventos enviados pelo servidor.</p>
<div class="script-header">
    <span>
        sse-example.html
    </span>
    <span>
        HTML
    </span>
</div>
<pre><code class="lang-html">&lt;html&gt;
    &lt;body&gt;
        &lt;b&gt;Frutas:&lt;/b&gt;
        &lt;ul&gt;&lt;/ul&gt;
    &lt;/body&gt;
    &lt;script&gt;
        const evtSource = new EventSource('http://localhost:5555/event-source');
        const eventList = document.querySelector('ul');
        
        evtSource.onmessage = (e) =&gt; {
            const newElement = document.createElement(&quot;li&quot;);

            newElement.textContent = `mensagem: ${e.data}`;
            eventList.appendChild(newElement);

            if (e.data == &quot;Tomate&quot;) {
                evtSource.close();
            }
        }
    &lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>E envie progressivamente as mensagens para o cliente:</p>
<div class="script-header">
    <span>
        Controller/MyController.cs
    </span>
    <span>
        C#
    </span>
</div>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/event-source&quot;)]
    public async Task&lt;HttpResponse&gt; ServerEventsResponse(HttpRequest request)
    {
        var sse = await request.GetEventSourceAsync ();
        
        string[] frutas = new[] { &quot;Maçã&quot;, &quot;Banana&quot;, &quot;Melancia&quot;, &quot;Tomate&quot; };
        
        foreach (string fruta in frutas)
        {
            await serverEvents.SendAsync(fruta);
            await Task.Delay(1500);
        }

        return serverEvents.Close();
    }
}
</code></pre>
<p>Ao executar esse código, esperamos um resultado semelhante a este:</p>
<img src="/assets/img/server side events demo.gif">
<h2 id="resolvendo-ips-e-hosts-proxy">Resolvendo IPs e hosts proxy</h2>
<p>O Sisk pode ser usado com proxies, e, portanto, os endereços IP podem ser substituídos pelo endpoint do proxy na transação de um cliente para o proxy.</p>
<p>Você pode definir seus próprios resolvidores no Sisk com <a href="/docs/pt-br/advanced/forwarding-resolvers">resolvidores de encaminhamento</a>.</p>
<h2 id="codificação-de-cabeçalhos">Codificação de cabeçalhos</h2>
<p>A codificação de cabeçalhos pode ser um problema para algumas implementações. No Windows, cabeçalhos UTF-8 não são suportados, então ASCII é usado. O Sisk tem um conversor de codificação incorporado, que pode ser útil para decodificar cabeçalhos codificados incorretamente.</p>
<p>Essa operação é custosa e está desabilitada por padrão, mas pode ser habilitada sob a flag <a href="/specification/spec/Sisk.Core.Http.HttpServerFlags.NormalizeHeadersEncodings">NormalizeHeadersEncodings</a>.</p>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/requests.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
                
                function splitText(text, words) {
                    if (!Array.isArray(words)) return [];
                    const escapedWords = words.map(word =>
                        word.replace(/([.*+?^${}()|[\]\\])/g, '\\$1').replace(/\s/g, '\\$&'));
                        
                    escapedWords.sort((a, b) => b.length - a.length || b.localeCompare(a, 'en-US', { sensitivity: 'base' }));
                    const pattern = new RegExp(`\\b(${escapedWords.join('|')})\\b`, 'gi');
                    const splitResult = text.split(pattern);
                    const cleanedResult = splitResult.filter(segment => segment !== '');
                    return cleanedResult;
                }
                
                function runPostHljsFunctions() {
                    if (!document.querySelector("pre>code")) {
                        return;
                    }
                    if (!document.querySelector(".hljs")) {
                        setTimeout(runPostHljsFunctions, 100);
                        return;
                    }
                    
                    function highlightMissingCodeTokens(pre) {
                        const tokenClasses = [
                            "HttpResponse", "HttpRequest", "File", "Task",
                            "Router", "Route", "StringContent", "StreamContent",
                            "JsonContent", "RegexRoute", "HtmlContent", "CancellationTokenSource",
                            "HttpContext", "Stream", "MultipartObject", "Thread", "Task", "Encoding",
                            "HttpKnownHeaderNames", "HttpMethod", "List", "JsonSerializer",
                            "LogStream", "HttpServer", "RotatingLogPolicy", "StringBuilder",
                            "Console", "HttpRequestEventSource", "HttpWebSocket", "X509Certificate2",
                            "AppDomain", "Path", "Directory", "HttpServerConfiguration", "ListeningHost",
                            "ByteArrayContent", "ForwardingResolver", "IPAddress", "IPEndPoint",
                            "HttpServerExecutionResult", "ArgumentNullException", "JsonSerializerOptions",
                            "DbContext"
                        ];
                        const tokenValues = [
                            "RouteMethod", "Guid", "RequestHandlerExecutionMode", "HttpStatusCode",
                            "HttpStatusInformation", "DateTime", "TimeSpan", "RouterMethod",
                            "ListeningPort"
                        ];
                        const tokenInterfaces = [
                            "IRequestHandler", "IEnumerable", "ICollection", "IList"
                        ];
                        
                        function runStyles(node) {
                            if (node.nodeType === 3) {
                                applyStyles(node);
                                
                            } else if (node.nodeType === 1) {
                                
                                const prohibitedClasses = ["hljs-comment", "hljs-string"];
                                
                                if (! prohibitedClasses.some(cls => node.classList.contains(cls))) {
                                    for(const child of node.childNodes) {
                                        runStyles(child);
                                    }
                                }
                            }
                        }
                        
                        function applyStyles(textNode) {
                            const text = textNode.textContent;
                            const fragment = [];
                            
                            for (const token of splitText(text, [...tokenClasses, ...tokenValues, ...tokenInterfaces])) {
                                if (tokenClasses.includes(token)) {
                                    fragment.push(el("span.hljs-meta", token));
                                    
                                } else if (tokenValues.includes(token)) {
                                    fragment.push(el("span.hljs-meta-value", token));
                                    
                                } else if (tokenInterfaces.includes(token)) {
                                    fragment.push(el("span.hljs-meta-interface", token));
                                    
                                } else {
                                    fragment.push(token);
                                }
                            }
                            
                            textNode.replaceWith(el.fragment(...fragment));
                        }
                        
                        const code = pre.querySelector("code");
                        if (code && (code.classList.contains("lang-csharp") || code.classList.contains("lang-cs"))) {
                            runStyles(code);
                        }
                    }
                    
                    function addLineNumbers(pre) {
                        const code = pre.querySelector("code");
                        if (!code) return;
                        
                        var lines = (code.textContent.match(/\n/g) || []).length;
                        
                        if (lines <= 1) {
                            return;
                        }
                        
                        const lineElements = [];
                        for (let i = 1; i <= lines; i++) {
                            lineElements.push(el("span.hljs-line-number", i + "\n"));
                        }
                        
                        code.prepend(el("div.line-numbers", ...lineElements));
                        code.classList.add("has-line-numbers");
                    }
                                        
                    document.querySelectorAll("pre").forEach(pre => {
                        highlightMissingCodeTokens(pre);
                        addLineNumbers(pre);
                    });
                }
                
                runPostHljsFunctions();
            </script>
        </footer>
    </body>
</html>