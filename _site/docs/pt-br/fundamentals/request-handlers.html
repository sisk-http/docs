<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Processamento de Requisi&#231;&#245;es | Sisk </title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="title" content="Processamento de Requisi&#231;&#245;es | Sisk ">


        <link rel="icon" href="../../../assets/img/favicon.ico">
        <link rel="stylesheet" href="../../../public/docfx.min.css">
        <link rel="stylesheet" href="../../../public/main.css">

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
        <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">

        <meta name="docfx:navrel" content="../../../toc.html">
        <meta name="docfx:tocrel" content="../toc.html">

        <meta name="docfx:rel" content="../../../">


        <meta name="docfx:docurl" content="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/request-handlers.md/#L1">
        <meta name="loc:inThisArticle" content="In this article">
        <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
        <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
        <meta name="loc:tocFilter" content="Filter by title">
        <meta name="loc:nextArticle" content="Next">
        <meta name="loc:prevArticle" content="Previous">
        <meta name="loc:themeLight" content="Light">
        <meta name="loc:themeDark" content="Dark">
        <meta name="loc:themeAuto" content="Auto">
        <meta name="loc:changeTheme" content="Change theme">
        <meta name="loc:copy" content="Copy">
        <meta name="loc:downloadPdf" content="Download PDF">
        
        <script type="module" src="./../../../public/docfx.min.js"></script>
        <script>
            const theme = localStorage.getItem('theme') || 'auto';
            document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
        </script>
        
        <script src="https://unpkg.com/@cypherpotato/el/dist/el.min.js"></script>
        
        <!-- GoatCounter -->
        <script data-goatcounter="https://siskframework.goatcounter.com/count" async="" src="//gc.zgo.at/count.js"></script>
        <!-- End GoatCounter -->
        
        <script>
            
            function switchLanguage(lang) {
                const docPart = window.location.pathname.match(/\/docs\/((pt\-br|ru|cn|es)\/)?(.*)/)[3];
                const newPath = lang + docPart;
                window.location.href = window.location.origin + newPath;
            }
        
        </script>
        
    </head>
    
    
    <body class="tex2jax_ignore" data-layout="" data-yaml-mime="">
        <header class="bg-body border-bottom">
            <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
                <div class="container-xxl flex-nowrap">
                    <a class="navbar-brand" href="../../../index.html">
                        <img id="logo" class="svg" src="../../../assets/img/Icon.png" alt="Sisk">
                        Sisk
                    </a>
                    <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
                        <i class="bi bi-three-dots"></i>
                    </button>
                    <div class="collapse navbar-collapse" id="navpanel">
                        <div id="navbar">
                            <form class="search" role="search" id="search">
                                <i class="bi bi-search"></i>
                                <input class="form-control" id="search-query" type="search" disabled="" placeholder="Search" autocomplete="off" aria-label="Search">
                            </form>
                        </div>
                    </div>
                </div>
            </nav>
        </header>

        <main class="container-xxl">
            <div class="toc-offcanvas">
                <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
                    <div class="offcanvas-header">
                        <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
                    </div>
                    <div class="offcanvas-body">
                        <nav class="toc" id="toc"></nav>
                    </div>
                </div>
            </div>

            <div class="content">
                <div class="actionbar">
                    <button class="btn btn-lg border-0 d-md-none" style="margin-top: -.65em; margin-left: -.8em" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
                        <i class="bi bi-list"></i>
                    </button>

                    <nav id="breadcrumb"></nav>

                    <div id="language-wrapper">
                        <a class="btn border-0 dropdown-toggle show" data-bs-toggle="dropdown" aria-expanded="true" title="Change theme">
                            <i class="bi bi-globe"></i>
                        </a>
                        <ul class="dropdown-menu dropdown-menu-end language-dropdown">
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/')">
                                    <img src="/assets/flag/usa.png">
                                    English
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/ru/')">
                                    <img src="/assets/flag/russia.png">
                                    Русский
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/cn/')">
                                    <img src="/assets/flag/china.png">
                                    汉语
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/pt-br/')">
                                    <img src="/assets/flag/brazil.png">
                                    Português Brasileiro
                                </a>
                            </li>
                            <li>
                                <a class="dropdown-item" href="javascript:switchLanguage('/docs/es/')">
                                    <img src="/assets/flag/spain.png">
                                    Spanish
                                </a>
                            </li>
                        </ul>
                    </div>
                </div>

                <article data-uid="">
<h1 id="processamento-de-requisições">Processamento de Requisições</h1>

<p>Os manipuladores de requisições, também conhecidos como &quot;middlewares&quot;, são funções que são executadas antes ou depois de uma requisição ser processada pelo roteador. Eles podem ser definidos por rota ou por roteador.</p>
<p>Existem dois tipos de manipuladores de requisições:</p>
<ul>
<li><strong>BeforeResponse</strong>: define que o manipulador de requisição será executado antes de chamar a ação do roteador.</li>
<li><strong>AfterResponse</strong>: define que o manipulador de requisição será executado após chamar a ação do roteador. O envio de uma resposta HTTP neste contexto sobrescreverá a resposta da ação do roteador.</li>
</ul>
<p>Ambos os manipuladores de requisições podem sobrescrever a resposta da função de callback do roteador. Aliás, manipuladores de requisições podem ser úteis para validar uma requisição, como autenticação, conteúdo ou qualquer outra informação, como armazenar informações, logs ou outras etapas que podem ser realizadas antes ou depois de uma resposta.</p>
<p><img src="/assets/img/requesthandlers1.png" alt=""></p>
<p>Desta forma, um manipulador de requisição pode interromper toda essa execução e retornar uma resposta antes de terminar o ciclo, descartando tudo mais no processo.</p>
<p>Exemplo: suponha que um manipulador de requisição de autenticação de usuário não o autentique. Ele impedirá que o ciclo de vida da requisição seja continuado e ficará pendente. Se isso acontecer no manipulador de requisição na posição dois, o terceiro e os seguintes não serão avaliados.</p>
<p><img src="/assets/img/requesthandlers2.png" alt=""></p>
<h2 id="criando-um-manipulador-de-requisição">Criando um manipulador de requisição</h2>
<p>Para criar um manipulador de requisição, podemos criar uma classe que herda a interface <a href="/api/Sisk.Core.Routing.IRequestHandler">IRequestHandler</a>, no seguinte formato:</p>
<pre><code class="lang-cs">public class AuthenticateUserRequestHandler : IRequestHandler
{
    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;

    public HttpResponse? Execute(HttpRequest request, HttpContext context)
    {
        if (request.Headers.Authorization != null)
        {
            // Retornando null indica que o ciclo de requisição pode ser continuado
            return null;
        }
        else
        {
            // Retornando um objeto HttpResponse indica que esta resposta sobrescreverá respostas adjacentes.
            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
        }
    }
}
</code></pre>
<p>No exemplo acima, indicamos que se o cabeçalho <code>Authorization</code> estiver presente na requisição, ele deve continuar e o próximo manipulador de requisição ou a callback do roteador deve ser chamada, seja qual for a próxima. Se um manipulador de requisição é executado após a resposta por sua propriedade <a href="/api/Sisk.Core.Routing.IRequestHandler.ExecutionMode">ExecutionMode</a> e retornar um valor não nulo, ele sobrescreverá a resposta do roteador.</p>
<p>Sempre que um manipulador de requisição retorna <code>null</code>, indica que a requisição deve continuar e o próximo objeto deve ser chamado ou o ciclo deve terminar com a resposta do roteador.</p>
<h2 id="associando-um-manipulador-de-requisição-a-uma-única-rota">Associando um manipulador de requisição a uma única rota</h2>
<p>Você pode definir um ou mais manipuladores de requisição para uma rota.</p>
<pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, &quot;/&quot;, IndexPage, &quot;&quot;, new IRequestHandler[]
{
    new AuthenticateUserRequestHandler(),     // manipulador de requisição antes
    new ValidateJsonContentRequestHandler(),  // manipulador de requisição antes
    //                -- método IndexPage será executado aqui
    new WriteToLogRequestHandler()            // manipulador de requisição depois
});
</code></pre>
<p>Ou criando um objeto <a href="/api/Sisk.Core.Routing.Route">Route</a>:</p>
<pre><code class="lang-cs">Route indexRoute = new Route(RouteMethod.Get, &quot;/&quot;, &quot;&quot;, IndexPage, null);
indexRoute.RequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
mainRouter.SetRoute(indexRoute);
</code></pre>
<h2 id="associando-um-manipulador-de-requisição-a-um-roteador">Associando um manipulador de requisição a um roteador</h2>
<p>Você pode definir um manipulador de requisição global que será executado em todas as rotas de um roteador.</p>
<pre><code class="lang-cs">mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    new AuthenticateUserRequestHandler()
};
</code></pre>
<h2 id="associando-um-manipulador-de-requisição-a-um-atributo">Associando um manipulador de requisição a um atributo</h2>
<p>Você pode definir um manipulador de requisição em um atributo de método junto com um atributo de rota.</p>
<pre><code class="lang-cs">public class MyController
{
    [RouteGet(&quot;/&quot;)]
    [RequestHandler&lt;AuthenticateUserRequestHandler&gt;]
    static HttpResponse Index(HttpRequest request)
    {
        return new HttpResponse()
            .WithContent(new StringContent(&quot;Hello world!&quot;));
    }
}
</code></pre>
<p>Observe que é necessário passar o tipo de manipulador de requisição desejado e não uma instância de objeto. Dessa forma, o manipulador de requisição será instanciado pelo parser do roteador. Você pode passar argumentos no construtor com a propriedade <a href="/api/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments">ConstructorArguments</a>.</p>
<p>Exemplo:</p>
<pre><code class="lang-cs">[RequestHandler&lt;AuthenticateUserRequestHandler&gt;(&quot;arg1&quot;, 123, ...)]
static HttpResponse Index(HttpRequest request)
{
    HttpResponse res = new HttpResponse();
    res.Content = new StringContent(&quot;Hello world!&quot;);
    return res;
}
</code></pre>
<p>Você também pode criar seu próprio atributo que implementa RequestHandler:</p>
<pre><code class="lang-cs">public class AuthenticateAttribute : RequestHandlerAttribute
{
    public AuthenticateAttribute() : base(typeof(AuthenticateUserRequestHandler), ConstructorArguments = new object?[] { &quot;arg1&quot;, 123, ... })
    {
        ;
    }
}
</code></pre>
<p>E usá-lo como:</p>
<pre><code class="lang-cs">[Authenticate]
static HttpResponse Index(HttpRequest request)
{
    HttpResponse res = new HttpResponse();
    res.Content = new StringContent(&quot;Hello world!&quot;);
    return res;
}
</code></pre>
<h2 id="ignorando-um-manipulador-de-requisição-global">Ignorando um manipulador de requisição global</h2>
<p>Depois de definir um manipulador de requisição global em uma rota, você pode ignorá-lo em rotas específicas.</p>
<pre><code class="lang-cs">var myRequestHandler = new AuthenticateUserRequestHandler();
mainRouter.GlobalRequestHandlers = new IRequestHandler[]
{
    myRequestHandler
};

mainRouter.SetRoute(new Route(RouteMethod.Get, &quot;/&quot;, &quot;My route&quot;, IndexPage, null)
{
    BypassGlobalRequestHandlers = new IRequestHandler[]
    {
        myRequestHandler,                    // ok: a mesma instância do que está nos manipuladores de requisição globais
        new AuthenticateUserRequestHandler() // errado: não ignorará o manipulador de requisição global
    }
});
</code></pre>
<div class="NOTE">
<h5>Note</h5>
<p>Se você estiver ignorando um manipulador de requisição, deve usar a mesma referência do que você instanciou antes para ignorá-lo. Criar outra instância de manipulador de requisição não ignorará o manipulador de requisição global, pois a referência será alterada. Lembre-se de usar a mesma referência de manipulador de requisição usada tanto em GlobalRequestHandlers quanto em BypassGlobalRequestHandlers.</p>
</div>

</article>

                <div class="contribution d-print-none">
                    <a href="https://github.com/sisk-http/docs/blob/master/docs/pt-br/fundamentals/request-handlers.md/#L1" class="edit-link">Edit this page</a>
                </div>

                <div class="next-article d-print-none border-top" id="nextArticle"></div>

            </div>

            <div class="affix">
                <nav id="affix"></nav>
            </div>
        </main>

        <div class="container-xxl search-results" id="search-results"></div>

        <footer class="border-top text-secondary">
            <div class="container-xxl">
                <div class="flex-fill">
                    <span>Made with <a href="https://dotnet.github.io/docfx">docfx</a></span>
                </div>
            </div>
            <script>
                if (window.location.pathname.startsWith('/docs/')) {
                    document.getElementById('language-wrapper').style.display = 'block';
                }
            </script>
        </footer>
    </body>
</html>