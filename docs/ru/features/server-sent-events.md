# Серверные события

Sisk поддерживает отправку сообщений через Серверные события из коробки. Вы можете создавать одноразовые и постоянные соединения, получать соединения во время выполнения и использовать их.

Эта функция имеет некоторые ограничения, наложенные браузерами, такие как отправка только текстовых сообщений и невозможность постоянного закрытия соединения. Серверное закрытое соединение будет иметь клиент, который периодически попытается переподключиться каждые 5 секунд (3 для некоторых браузеров).

Эти соединения полезны для отправки событий от сервера к клиенту без необходимости запроса информации каждый раз.

## Создание соединения SSE

Соединение SSE работает как обычный HTTP-запрос, но вместо отправки ответа и немедленного закрытия соединения, соединение остается открытым для отправки сообщений.

Вызывая метод [HttpRequest.GetEventSource()](/api/Sisk.Core.Http.HttpRequest.GetEventSource), запрос помещается в состояние ожидания, пока экземпляр SSE не будет создан.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource();

    sse.Send("Привет, мир!");

    return sse.Close();
});
```

В вышеприведенном коде мы создаем соединение SSE и отправляем сообщение "Привет, мир", затем мы закрываем соединение SSE с серверной стороны.

> [!NOTE]
> Когда соединение закрывается с серверной стороны, по умолчанию клиент попытается подключиться снова и соединение будет перезапущено, выполняя метод снова, бесконечно.
>
> Обычно передается сообщение о завершении от сервера всякий раз, когда соединение закрывается с серверной стороны, чтобы предотвратить попытки клиента переподключиться снова.

## Добавление заголовков

Если вам нужно отправить заголовки, вы можете использовать метод [HttpRequestEventSource.AppendHeader](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader) перед отправкой любых сообщений.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource();
    sse.AppendHeader("Header-Key", "Header-value");

    sse.Send("Привет!");

    return sse.Close();
});
```

Обратите внимание, что необходимо отправить заголовки перед отправкой любых сообщений.

## Соединения Wait-For-Fail

Соединения обычно завершаются, когда сервер больше не может отправлять сообщения из-за возможного отключения клиента. С этим соединение автоматически завершается и экземпляр класса удаляется.

Даже с переподключением экземпляр класса не будет работать, поскольку он связан с предыдущим соединением. В некоторых ситуациях вам может понадобиться это соединение позже, и вы не хотите управлять им через метод обратного вызова маршрута.

Для этого мы можем идентифицировать соединения SSE с помощью идентификатора и получить их позже, даже вне обратного вызова маршрута. Кроме того, мы помечаем соединение как [WaitForFail](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail), чтобы не завершать маршрут и не завершать соединение автоматически.

Соединение SSE в режиме KeepAlive будет ожидать ошибки отправки (вызванной отключением) для возобновления выполнения метода. Также можно задать таймаут для этого. После истечения времени, если не было отправлено ни одного сообщения, соединение завершается и выполнение возобновляется.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource("my-index-connection");

    sse.WaitForFail(TimeSpan.FromSeconds(15)); // ожидать 15 секунд без каких-либо сообщений перед завершением соединения

    return sse.Close();
});
```

Вышеприведенный метод создаст соединение, обработает его и будет ожидать отключения или ошибки.

```cs
HttpRequestEventSource? evs = server.EventSources.GetByIdentifier("my-index-connection");
if (evs != null)
{
    // соединение仍然 существует
    evs.Send("Привет снова!");
}
```

И вышеприведенный фрагмент кода попытается найти только что созданное соединение, и если оно существует, оно отправит сообщение ему.

Все активные серверные соединения, которые идентифицированы, будут доступны в коллекции [HttpServer.EventSources](/api/Sisk.Core.Http.HttpServer.EventSources). Эта коллекция хранит только активные и идентифицированные соединения. Закрытые соединения удаляются из коллекции.

> [!NOTE]
> Важно отметить, что KeepAlive имеет ограничение, установленное компонентами, которые могут быть подключены к Sisk неуправляемым образом, такими как веб-прокси, HTTP-ядро или сетевой драйвер, и они закрывают неактивные соединения после определенного периода времени.
>
> Следовательно, важно поддерживать соединение открытым, отправляя периодические пинги или продлевая максимальное время до закрытия соединения. Прочитайте следующий раздел, чтобы лучше понять отправку периодических пингов.

## Настройка политики пингов соединений

Политика пингов - это автоматизированный способ отправки периодических сообщений клиенту. Эта функция позволяет серверу понять, когда клиент отключился от соединения, не имея необходимости поддерживать соединение открытым бесконечно.

```cs
[RouteGet("/sse")]
public HttpResponse Events(HttpRequest request)
{
    var sse = request.GetEventSource();
    sse.WithPing(ping =>
    {
        ping.DataMessage = "ping-message";
        ping.Interval = TimeSpan.FromSeconds(5);
        ping.Start();
    });

    sse.KeepAlive();
    return sse.Close();
}
```

В вышеприведенном коде каждые 5 секунд будет отправлено новое сообщение пинга клиенту. Это будет поддерживать TCP-соединение открытым и предотвратить его закрытие из-за неактивности. Кроме того, когда сообщение не может быть отправлено, соединение автоматически закрывается, освобождая ресурсы, используемые соединением.

## Запрос соединений

Вы можете искать активные соединения, используя предикат на идентификаторе соединения, чтобы, например, транслировать сообщения.

```cs
HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith("my-connection-"));
foreach (HttpRequestEventSource e in evs)
{
    e.Send("Транслирую всем источникам событий, которые начинаются с 'my-connection-'");
}
```

Вы также можете использовать метод [All](/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All), чтобы получить все активные соединения SSE.