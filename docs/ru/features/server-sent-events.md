# Server Sent Events

Sisk поддерживает отправку сообщений через Server Sent Events из коробки. Вы можете создавать одноразовые и постоянные подключения, получать подключения во время выполнения и использовать их.

Эта функция имеет некоторые ограничения, налагаемые браузерами, такие как отправка только текстовых сообщений и невозможность навсегда закрыть подключение. Закрытое с серверной стороны подключение будет иметь клиент, периодически пытающийся reconnect каждые 5 секунд (3 для некоторых браузеров).

Эти подключения полезны для отправки событий с сервера клиенту без необходимости запроса информации клиентом каждый раз.

## Создание подключения SSE

Подключение SSE работает как обычный HTTP-запрос, но вместо отправки ответа и немедленного закрытия подключения, подключение остается открытым для отправки сообщений.

Вызывая метод [HttpRequest.GetEventSource()](/api/Sisk.Core.Http.HttpRequest.GetEventSource), запрос помещается в состояние ожидания, пока создается экземпляр SSE.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
 using var sse = req.GetEventSource();

 sse.Send("Hello, world!");

 return sse.Close();
});
```

В приведенном выше коде мы создаем подключение SSE и отправляем сообщение "Hello, world", затем закрываем подключение SSE с серверной стороны.

> [!NOTE]
> При закрытии подключения с серверной стороны, по умолчанию клиент будет пытаться подключиться снова и подключение будет перезапущено, выполняя метод снова, навсегда.
>
> Обычно отправляют сообщение о завершении с сервера, когда подключение закрывается с сервера, чтобы предотвратить попытки клиента reconnect снова.

## Добавление заголовков

Если вам нужно отправить заголовки, вы можете использовать метод [HttpRequestEventSource.AppendHeader](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader) перед отправкой любых сообщений.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
 using var sse = req.GetEventSource();
 sse.AppendHeader("Header-Key", "Header-value");

 sse.Send("Hello!");

 return sse.Close();
});
```

Обратите внимание, что необходимо отправить заголовки перед отправкой любых сообщений.

## Подключения Wait-For-Fail

Подключения обычно завершаются, когда сервер больше не может отправлять сообщения из-за возможного отключения клиента. При этом подключение автоматически завершается и экземпляр класса удаляется.

Даже при reconnect, экземпляр класса не будет работать, поскольку он связан с предыдущим подключением. В некоторых ситуациях вам может понадобиться это подключение позже и вы не хотите управлять им через метод callback маршрута.

Для этого мы можем идентифицировать подключения SSE с помощью идентификатора и получить их позже, даже вне callback маршрута. Кроме того, мы помечаем подключение с помощью [WaitForFail](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail), чтобы не завершать маршрут и не завершать подключение автоматически.

Подключение SSE в KeepAlive будет ждать ошибки отправки (вызванной отключением) для возобновления выполнения метода. Также можно установить Timeout для этого. После истечения времени, если не было отправлено никаких сообщений, подключение завершается и выполнение возобновляется.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
 using var sse = req.GetEventSource("my-index-connection");

 sse.WaitForFail(TimeSpan.FromSeconds(15)); // ждать 15 секунд без каких-либо сообщений перед завершением подключения

 return sse.Close();
});
```

Приведенный выше метод создаст подключение, обработает его и будет ждать отключения или ошибки.

```cs
HttpRequestEventSource? evs = server.EventSources.GetByIdentifier("my-index-connection");
if (evs != null)
{
 // подключение все еще живо
 evs.Send("Hello again!");
}
```

А приведенный выше фрагмент кода попытается найти вновь созданное подключение и если оно существует, отправит ему сообщение.

Все активные подключения сервера, которые идентифицированы, будут доступны в коллекции [HttpServer.EventSources](/api/Sisk.Core.Http.HttpServer.EventSources). Эта коллекция хранит только активные и идентифицированные подключения. Закрытые подключения удаляются из коллекции.

> [!NOTE]
> Важно отметить, что keep alive имеет ограничение, установленное компонентами, которые могут быть подключены к Sisk неконтролируемым образом, такими как веб-прокси, HTTP-ядро или сетевой драйвер, и они закрывают неактивные подключения после определенного периода времени.
>
> Поэтому важно поддерживать подключение открытым, отправляя периодические пинги или продлевая максимальное время до закрытия подключения. Читайте следующий раздел, чтобы лучше понять отправку периодических пингов.

## Настройка политики пингов подключения

Политика пингов - это автоматизированный способ отправки периодических сообщений клиенту. Эта функция позволяет серверу понимать, когда клиент отключился от этого подключения, не держа подключение открытым бесконечно.

```cs
[RouteGet("/sse")]
public HttpResponse Events(HttpRequest request)
{
 using var sse = request.GetEventSource();
 sse.WithPing(ping =>
 {
 ping.DataMessage = "ping-message";
 ping.Interval = TimeSpan.FromSeconds(5);
 ping.Start();
 });
    
 sse.KeepAlive();
 return sse.Close();
}
```

В приведенном выше коде, каждые 5 секунд, будет отправлено новое сообщение пинга клиенту. Это будет поддерживать подключение TCP в активном состоянии и предотвращать его закрытие из-за неактивности. Кроме того, когда отправка сообщения fails, подключение автоматически закрывается, освобождая ресурсы, используемые подключением.

## Запрос подключений

Вы можете искать активные подключения, используя предикат по идентификатору подключения, чтобы иметь возможность广播, например.

```cs
HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith("my-connection-"));
foreach (HttpRequestEventSource e in evs)
{
 e.Send("Broadcasting to all event sources that starts with 'my-connection-'");
}
```

Вы также можете использовать метод [All](/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All), чтобы получить все активные подключения SSE.