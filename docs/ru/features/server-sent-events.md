# Серверные события

Sisk поддерживает отправку сообщений через Server Sent Events из коробки. Вы можете создавать одноразовые и постоянные соединения, получать соединения во время выполнения и использовать их.

Эта функция имеет некоторые ограничения, налагаемые браузерами, такие как отправка только текстовых сообщений и невозможность постоянного закрытия соединения. Закрытие соединения серверной стороной приведет к периодическим попыткам клиента переподключиться каждые 5 секунд (3 для некоторых браузеров).

Эти соединения полезны для отправки событий с сервера на клиент без необходимости запроса информации клиентом каждый раз.

## Создание соединения SSE

Соединение SSE работает как обычный HTTP-запрос, но вместо отправки ответа и немедленного закрытия соединения соединение остается открытым для отправки сообщений.

Вызов метода [HttpRequest.GetEventSource()](/api/Sisk.Core.Http.HttpRequest.GetEventSource), запрос помещается в состояние ожидания, пока создается экземпляр SSE.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource();

    sse.Send("Hello, world!");

    return sse.Close();
});
```

В приведенном выше коде мы создаем соединение SSE и отправляем сообщение "Hello, world", затем закрываем соединение SSE со стороны сервера.

> [!NOTE]
> При закрытии соединения серверной стороной по умолчанию клиент попытается снова подключиться, и соединение будет перезапущено, выполняя метод снова, вечно.
>
> Обычно с сервера отправляется сообщение о завершении, когда соединение закрывается, чтобы предотвратить повторное подключение клиента.

## Добавление заголовков

Если вам нужно отправить заголовки, вы можете использовать метод [HttpRequestEventSource.AppendHeader](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.AppendHeader) перед отправкой каких-либо сообщений.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource();
    sse.AppendHeader("Header-Key", "Header-value");

    sse.Send("Hello!");

    return sse.Close();
});
```

Обратите внимание, что необходимо отправить заголовки перед отправкой каких-либо сообщений.

## Соединения Wait-For-Fail

Соединения обычно прерываются, когда сервер больше не может отправлять сообщения из-за возможного разрыва соединения с клиентом. В этом случае соединение автоматически прерывается, и экземпляр класса удаляется.

Даже при повторном подключении экземпляр класса не будет работать, так как он связан с предыдущим соединением. В некоторых ситуациях вам может потребоваться это соединение позже, и вы не хотите управлять им через метод обратного вызова маршрута.

Для этого мы можем идентифицировать соединения SSE с помощью идентификатора и получать их позже, даже вне метода обратного вызова маршрута. Кроме того, мы отмечаем соединение с помощью [WaitForFail](/api/Sisk.Core.Http.Streams.HttpRequestEventSource.WaitForFail), чтобы не прерывать маршрут и не прерывать соединение автоматически.

Соединение SSE в KeepAlive будет ожидать ошибки отправки (вызванной разрывом соединения), чтобы возобновить выполнение метода. Также можно установить Timeout для этого. После истечения времени, если не было отправлено сообщение, соединение прерывается, и выполнение возобновляется.

```cs
r += new Route(RouteMethod.Get, "/", (req) =>
{
    var sse = req.GetEventSource("my-index-connection");

    sse.WaitForFail(TimeSpan.FromSeconds(15)); // ожидать 15 секунд без отправки сообщения, прежде чем прервать соединение

    return sse.Close();
});
```

В приведенном выше методе будет создано соединение, обработано и ожидание разрыва соединения или ошибки.

```cs
HttpRequestEventSource? evs = server.EventSources.GetByIdentifier("my-index-connection");
if (evs != null)
{
    // соединение все еще активное
    evs.Send("Hello again!");
}
```

И фрагмент кода выше попытается найти недавно созданное соединение, и если оно существует, отправит сообщение на него.

Все активные серверные соединения, которые идентифицированы, будут доступны в коллекции [HttpServer.EventSources](/api/Sisk.Core.Http.HttpServer.EventSources). Эта коллекция хранит только активные и идентифицированные соединения. Закрытые соединения удаляются из коллекции.

> [!NOTE]
> Важно отметить, что Keep Alive имеет ограничение, установленное компонентами, которые могут быть подключены к Sisk неконтролируемым образом, например, веб-прокси, ядро HTTP или драйвер сети, и они закрывают неиспользуемые соединения после определенного периода времени.
>
> Поэтому важно поддерживать соединение открытым, отправляя периодические пинги или увеличивая максимальное время, прежде чем соединение будет закрыто. Прочитайте следующую секцию, чтобы лучше понять отправку периодических пингов.

## Настройка политики пингов соединений

Политика пингов - это автоматизированный способ отправки периодических сообщений вашему клиенту. Эта функция позволяет серверу понимать, когда клиент отключился от этого соединения, не принуждая его постоянно держать соединение открытым.

```cs
[RouteGet("/sse")]
public HttpResponse Events(HttpRequest request)
{
    var sse = request.GetEventSource();
    sse.WithPing(ping =>
    {
        ping.DataMessage = "ping-message";
        ping.Interval = TimeSpan.FromSeconds(5);
        ping.Start();
    });

    sse.KeepAlive();
    return sse.Close();
}
```

В приведенном выше коде каждые 5 секунд будет отправляться новое сообщение пинга клиенту. Это поддержит TCP-соединение и предотвратит его закрытие из-за неактивности. Также при неудачной отправке сообщения соединение автоматически закрывается, освобождая ресурсы, используемые соединением.

## Поиск соединений

Вы можете искать активные соединения с помощью предиката на идентификаторе соединения, чтобы иметь возможность, например, отправлять рассылку.

```cs
HttpRequestEventSource[] evs = server.EventSources.Find(es => es.StartsWith("my-connection-"));
foreach (HttpRequestEventSource e in evs)
{
    e.Send("Рассылка всем событиям, начинающимся с 'my-connection-'");
}
```

Вы также можете использовать метод [All](/api/Sisk.Core.Http.Streams.HttpEventSourceCollection.All) для получения всех активных соединений SSE.